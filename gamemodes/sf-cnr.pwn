/*
 *
 *      	San Fierro: Cops and Robbers
 *
 *      		Created all by Lorenc_
 *
 *
 *      Thanks to: y_less/zeex/Frosha/Incognito/SA-MP team
 *
 *  Codes:
 *      8hska7082bmahu -> Money Farming Checks
 *      plugins mysql crashdetect sscanf streamer socket Whirlpool regex gvar FileManager profiler FCNPC
*/

#pragma compat 1
#pragma dynamic 7200000
#define DEBUG_MODE

/* ** SA-MP Includes ** */
#include 							< a_samp >
#include                            < a_http >

/* ** YSI ** */
#include 							< foreach >
#include                            < YSI\y_va >

/* ** Redefinitions ** */
#undef  MAX_PLAYERS
#define MAX_PLAYERS                 ( 128 )

/* ** Sundry Includes ** */
#include                            < a_mysql >
#include 							< zcmd >
#include 							< sscanf2 >
#include 							< streamer >
#include 							< sf-cnr >
#include                            < regex >
#include                            < gvar >
#include                            < lookupffs >
#include 							< FloodControl >
#include 							< RouteConnector >
#include 							< sampac >
#include 							< color >
#include 							< mailer >
#include 							< a_weapondata >
#include 							< MathParser >
#include 							< attachments >
//#include 							< a_analytics >
native WP_Hash						( buffer[ ], len, const str[ ] );
native IsValidVehicle				( vehicleid );
native gpci 						( playerid, serial[ ], len );

/* ** IG CONFIG ** */
#define 							CNR_SERVER
#include 							< a_ig >

#if !defined AC_INCLUDED
	#include 						< anticheat\global >
	#include 						< anticheat\player >

	#include 						< anticheat\weapon >
	//#include 						< anticheat\spectate >
	#include 						< anticheat\airbrake >
	#include 						< anticheat\proaim >
	#include 						< anticheat\autocbug >
	#include 						< anticheat\flying >
	#include 						< anticheat\remotejack > // Works fine

	#include 						< anticheat\hooks >

	#include 						< anticheat\hitpoints >  // Good

	#define AC_INCLUDED
#endif

/* ** Useful macros ** */
#define function%1(%2)              forward%1(%2); public%1(%2)
#define DQCMD:%1(%2) 				forward discord_%1(%2); public discord_%1(%2)
#define RandomEx(%0,%1)  			(random((%1) - (%0)) + (%0))
#define HOLDING(%0)             	((newkeys & (%0)) == (%0))
#define PRESSED(%0)					(((newkeys & (%0)) == (%0)) && ((oldkeys & (%0)) != (%0)))
#define IsPlayerSpawned(%1)    		(p_Spawned{%1})
#define IsPlayerJailed(%1)          (p_Jailed{%1})
#define IsPlayerTazed(%1)          	(p_Tazed{%1})
#define IsPlayerDetained(%1)        (p_Detained{%1})
#define IsPlayerCuffed(%1)          (p_Cuffed{%1})
#define IsPlayerTied(%1)          	(p_Tied{%1})
#define IsPlayerKidnapped(%1)       (p_Kidnapped{%1})
#define IsPlayerBlowingCock(%0)   	(p_GivingBlowjob{%0})
#define IsPlayerGettingBlowed(%0) 	(p_GettingBlowjob{%0})
#define IsPlayerAdminOnDuty(%0)     (p_AdminOnDuty{%0})
#define IsPlayerInPaintBall(%0)		(p_inPaintBall{%0})
#define IsPlayerMining(%0)			(p_isMining{%0})
#define IsPlayerUsingRadio(%0)		(p_UsingRadio{%0})
#define IsPlayerLoadingObjects(%0)	(p_pausedToLoad{%0})
#define IsPlayerOnSlotMachine(%0)	(p_usingSlotMachine[%0]!=-1)
#define IsPlayerOnRoulette(%0)		(p_RouletteTable[%0]!=-1)
#define IsPlayerRobbing(%0)			IsPlayerAttachedObjectSlotUsed(%0,0)
#define IsPlayerAdminJailed(%0) 	(p_AdminJailed{%0}&&p_JailTime[%0])
#define IsPlayerInMethlab(%0)		(GetPVarInt(%0,"inMethLab")==1&&GetPlayerInterior(%0)==VW_METH)
#define IsPlayerInShamal(%0)		(GetPlayerInterior(%0)==VW_SHAMAL)
#define IsValidApartment(%0)		(0 <= %0 < sizeof(g_apartmentData))
#define GetPlayerCash(%1)           p_Cash[%1]
#define GetPlayerXP(%1)             p_XP[%1]
#define hasTickcountPassed(%1,%2)   ((GetTickCount()-%1)>(%2))
#define strmatch(%1,%2) 			(!strcmp(%1,%2,true))
#define Beep(%1)              		PlayerPlaySound(%1, 1137, 0.0, 0.0, 5.0)
#define fRandomEx(%1,%2)			(floatrandom(%2-%1)+%1)
#define StopSound(%1)       		PlayerPlaySound(%1,1186,0.0,0.0,0.0)
#define Ach_Unlock(%0,%1) 			(%0 >= %1 ?("{6EF83C}"):("{FFFFFF}"))
#define UpdatePlayerTime(%0)		SetPlayerTime(%0,floatround(g_WorldClockSeconds/60),g_WorldClockSeconds-floatround((g_WorldClockSeconds/60)*60))
#define erase(%0)                   (%0[0]='\0')
#define GetPlayerTotalCash(%0)  	(p_BankMoney[%0] + p_Cash[%0]) // Bank Money and Money
#define KEY_AIM                     (128)
#define thread               		function
#define IsPlayerAFK(%0)				((GetTickCount()-p_AFKTime[%0])>=2595)
#define GetPlayerMethLabVehicle(%0)	(GetPlayerVirtualWorld(%0)-VW_METH)
#define IsPlayerLorenc(%0) 			(p_AccountID[%0]==1)
#define Achievement:: 				ach_
#define UpdateWoodStockObject()		(format(szNormalString,32,"%d Logs Ready",g_LogsInStock),SetDynamicObjectMaterialText(g_LogCountObject,0,szNormalString,130,"Arial",0,1,-1,0,1))
#define replacePercentageSymbol(%0)	strreplacechar(szString,'%','#')
#define IsPlayerInEntrance(%0,%1) 	(p_LastEnteredEntrance[%0]==(%1))
#define ReturnPlayerIP(%0) 			(p_PlayerIP[(%0)])
#define ReturnPlayerName(%0) 		(p_PlayerName[(%0)])
#define IsPlayerInEvent(%0)			(GetPlayerVirtualWorld(playerid)==69)
#define IsPlayerInPlayerGang(%0,%1)	(p_Class[%0] == p_Class[%1] && p_Class[%0] == CLASS_CIVILIAN && p_GangID[%0] == p_GangID[%1] && p_GangID[%0] != INVALID_GANG_ID)
#define INVALID_TIMER_ID			(-1)
#define IsPlayerUnderCover(%0)		((p_AccountID[%0] == 577142 || p_AccountID[%0] == 536230 || p_AccountID[%0] == 668504) && p_PlayerLogged{%0}) // StefiTV852, Shepard23, JamesComey
#define IsPlayerNpcEx(%0)			(IsPlayerNPC(%0) || strmatch(p_PlayerIP[%0], "127.0.0.1"))
#define IsRedRouletteNumber(%0) 	(%0 == 1 || %0 == 3 || %0 == 5 || %0 == 7 || %0 == 9 || %0 == 12 || %0 == 14 || %0 == 16 || %0 == 18 || %0 == 19 || %0 == 21 || %0 == 23 || %0 == 25 || %0 == 27 || %0 == 30 || %0 == 32 || %0 == 34 || %0 == 36)
#define positionToString(%0) 		(%0==1?("st"):(%0==2?("nd"):(%0==3?("rd"):("th"))))
#define ITER_NONE 					-1

/* Dynamic Macros */
#define GetTaxRate()				(GetGVarFloat("taxrate"))
#define IsDoubleXP()				(GetGVarInt("doublexp")!=0)
#define IsProxiesBanned()			(GetGVarInt("proxyban")!=0)

#define UpdateBusinessTitle(%0) \
	 mysql_function_query(dbHandle,sprintf("SELECT f.`NAME` FROM `USERS` f LEFT JOIN `BUSINESSES` m ON m.`OWNER_ID`=f.`ID` WHERE m.`ID`=%d",%0),true,"OnUpdateBusinessTitle","i",%0)
#define UpdateGarageTitle(%0) \
	mysql_function_query(dbHandle,sprintf("SELECT f.`NAME` FROM `USERS` f LEFT JOIN `GARAGES` m ON m.`OWNER`=f.`ID` WHERE m.`ID`=%d",(%0)),true,"OnUpdateGarageTitle","i",(%0))
#define UpdateGarageData(%0) \
	mysql_function_query(dbHandle,sprintf("UPDATE `GARAGES` SET OWNER=%d,PRICE=%d,INTERIOR=%d WHERE ID=%d",g_garageData[(%0)][E_OWNER_ID],g_garageData[(%0)][E_PRICE],g_garageData[(%0)][E_INTERIOR_ID],(%0)),true,"","")

/* Beast Functions */
new bool: False = false, szNormalString[ 144 ];
#define SendClientMessageToAllFormatted(%1,%2,%3) \
	do{format(szNormalString,sizeof(szNormalString),(%2),%3),SendClientMessageToAll((%1),szNormalString);}while(False)
#define SendClientMessageToRCON(%1,%2,%3) \
	do{foreach(new fI : Player){if (IsPlayerAdmin(fI))format(szNormalString,sizeof(szNormalString),(%2),%3),SendClientMessage(fI,(%1),szNormalString);}}while(False)
#define SendClientMessageToCops(%1,%2,%3) \
	do{foreach(new fI : Player){if (p_Class[fI]==CLASS_POLICE)format(szNormalString,sizeof(szNormalString),(%2),%3),SendClientMessage(fI,(%1),szNormalString);}}while(False)
#define SendClientMessageToFireman(%1,%2,%3) \
	do{foreach(new fI : Player){if (p_Class[fI]==CLASS_FIREMAN)format(szNormalString,sizeof(szNormalString),(%2),%3),SendClientMessage(fI,(%1),szNormalString);}}while(False)
#define SendClientMessageToVips(%1,%2,%3) \
	do{foreach(new fI : Player){if (p_VIPLevel[fI]>=VIP_REGULAR)format(szNormalString,sizeof(szNormalString),(%2),%3),SendClientMessage(fI,(%1),szNormalString);}}while(False)
#define SendClientMessageToAmbulance(%1,%2,%3) \
	do{foreach(new fI : Player){if (p_Class[fI]==CLASS_MEDIC)format(szNormalString,sizeof(szNormalString),(%2),%3),SendClientMessage(fI,(%1),szNormalString);}}while(False)
#define SendClientMessageToPaintball(%0,%1,%2,%3) \
	do{foreach(new fI : Player){if (p_inPaintBall{fI}&&p_PaintBallArena{fI}==(%0))format(szNormalString,sizeof(szNormalString),(%2),%3),SendClientMessage(fI,(%1),szNormalString);}}while(False)
#define DCC_SendChannelMessageFormatted(%0,%1,%2) \
	do{format(szNormalString,sizeof(szNormalString),(%1),%2),DCC_SendChannelMessage(%0,szNormalString);}while(False)

#define mysql_single_query(%0) mysql_function_query(dbHandle,(%0),true,"","")
#define SetPlayerPosEx(%0,%1,%2,%3,%4) SetPlayerPos(%0,%1,%2,%3),SetPlayerInterior(%0,%4)
#define CreateBillboard(%0,%1,%2,%3,%4) SetDynamicObjectMaterialText(CreateDynamicObject(7246,%1,%2,%3,0,0,%4),0,(%0),120,"Arial",24,0,-1,-16777216,1)

/* ** Configuration ** */
#define FILE_BUILD                	"v11.5.12"
#define SERVER_NAME                 "San Fierro Cops And Robbers (0.3.7)"
#define SERVER_WEBSITE              "www.irresistiblegaming.com"
#define SERVER_IP                   "192.169.82.202:7777"

#define ADMIN_COMMAND_REJECT        "You don't have an appropriate administration level to use this command."
#define ADMIN_COMMAND_TIME 			4

//#define MAX_WEAPONS                 54
#define MAX_MACHINES 				35 // Placed top because of textdraws
#define MAX_ROULETTE_TABLES 		12
#define MAX_CLASS_BAN_WARNS			3
#define MAX_CAR_MODS                15
#define MAX_BURGLARY_SLOTS          8
#define MAX_WANTED_LVL 				2048
#define MAX_TIME_TIED 				180
#define MAX_EXTRA_SLOTS 			5
#define sscanf_u					"u"

#define EXCHANGE_XPCASH             10 // Per 1 XP for cash.

#define VW_METH 					110
#define VW_SHAMAL 					220

#define VIP_REGULAR 				( 1 )
#define VIP_BRONZE 					( 2 )
#define VIP_GOLD 					( 3 )
#define VIP_PLATINUM 				( 4 )
#define VIP_DIAMOND 				( 5 )

const
	Float: default_X 				= -2242.152,
	Float: default_Y 				= 759.0619,
	Float: default_Z 				= 30.0,
	Float: default_Angle 			= 0.0
;

/* ** Cities ** */
#define ENABLE_CITY_LV 				true
#define ENABLE_CITY_LS 				true

#define MAX_CITIES 					3

#define CITY_SF 					0
#define CITY_LV						1
#define CITY_LS						2
#define CITY_DESERTS 				3
#define CITY_COUNTRY				4

/* ** Colours ** */
#define COL_GREEN               	"{6EF83C}"
#define COL_LGREEN               	"{91FA6B}"
#define COL_RED                 	"{F81414}"
#define COL_BLUE		           	"{00C0FF}"
#define COL_LRED                	"{FFA1A1}"
#define COL_GOLD                	"{FFDC2E}"
#define COL_PLATINUM                "{E0E0E0}"
#define COL_DIAMOND                	"{4EE2EC}"
#define COL_GREY                    "{C0C0C0}"
#define COL_PINK                    "{FF0770}"
#define COL_WHITE                   "{FFFFFF}"
#define COL_ORANGE                  "{FF7500}"
#define COL_GANG                    "{009999}"
#define COL_YELLOW                  "{FFFF00}"
#define COL_BLACK					"{333333}"
#define COLOR_GANGZONE              0x00000080
#define COLOR_RDMZONES 				0x00CC0010
#define COLOR_GREEN             	0x00CC00FF
#define COLOR_RED               	0xFF0000FF
#define COLOR_BLUE                  0x00C0FFFF
#define COLOR_YELLOW            	0xFFFF00FF
#define COLOR_ORANGE            	0xEE9911FF
#define COLOR_POLICE              	0x3E7EFF70
#define COLOR_MAYOR              	0x99000070
#define COLOR_GREY                  0xC0C0C0FF
#define COLOR_WHITE                 0xFFFFFFFF
#define COLOR_PINK                  0xFF0770FF
#define COLOR_GOLD                  0xFFDC2EFF
#define COLOR_DEFAULT               0xFFFFFF70
#define COLOR_WANTED2               0xFFEC41E2
#define COLOR_WANTED6               0xFF9233FF
#define COLOR_WANTED12              0xF83245FF
#define COLOR_FBI                   0x0035FF70
#define COLOR_ARMY                  0x954BFF70
#define COLOR_CIA                   0x19197000
#define COLOR_FIREMAN               0xA8343470
#define COLOR_MEDIC                 0x00CC0070
#define COLOR_CONNECT				0x22BB22AA
#define COLOR_DISCONNECT			0xC0C0C0AA
#define COLOR_TIMEOUT				0x990099AA
#define COLOR_KICK					0xFFCC00AA

/* ** Dialogs ** */
#define DIALOG_REGISTER             0 			+ 1000
#define DIALOG_LOGIN	            1 			+ 1000
#define DIALOG_JOB	            	2 			+ 1000
#define DIALOG_BOMB_SHOP            3           + 1000
#define DIALOG_NULL                 4           + 1000
#define DIALOG_BANNED               5           + 1000
#define DIALOG_BANK_MENU            6           + 1000
#define DIALOG_BANK_WITHDRAW        7           + 1000
#define DIALOG_BANK_DEPOSIT         8           + 1000
#define DIALOG_BANK_INFO            9           + 1000
#define DIALOG_SHOP_MENU            10          + 1000
#define DIALOG_HOUSES               11          + 1000
#define DIALOG_CITY_HALL 	       	12          + 1000
#define DIALOG_HOSPITAL             13          + 1000
#define DIALOG_HOUSE_CONFIG         14          + 1000
#define DIALOG_HOUSE_TITLE          15          + 1000
#define DIALOG_HOUSE_INTERIORS      16          + 1000
#define DIALOG_IC_MARKET            17          + 1000
#define DIALOG_VEHICLE_SPAWN        18          + 1000
#define DIALOG_ARENAS               19          + 1000
#define DIALOG_BOUGHT_VEH        	20          + 1000
#define DIALOG_PERKS                21          + 1000
#define DIALOG_PERKS_P              22          + 1000
#define DIALOG_VIP              	23          + 1000
#define DIALOG_PERKS_V              24          + 1000
#define DIALOG_DONATED           	25          + 1000
#define DIALOG_VEHICLE_LOCATE       26          + 1000
#define DIALOG_GANG_COLOR           27          + 1000
#define DIALOG_GANG_COLOR_INPUT     28          + 1000
#define DIALOG_RADIO                29          + 1000
#define DIALOG_XPMARKET             30          + 1000
#define DIALOG_PAINTBALL            31          + 1000
#define DIALOG_GPS                  32          + 1000
#define DIALOG_VIP_LOCKER           33          + 1000
#define DIALOG_AMMU                 34          + 1000
#define DIALOG_GARAGE_INTERIORS     35          + 1000
#define DIALOG_GARAGE_INT_CONFIRM	36          + 1000
#define DIALOG_GANG_LIST         	37          + 1000
#define DIALOG_LUMBERJACK           38          + 1000
#define DIALOG_FIGHTSTYLE           39          + 1000
#define DIALOG_TOYS_MAIN            40          + 1000
#define DIALOG_TOYS     			41          + 1000
#define DIALOG_TOYS_BONE 			42          + 1000
#define DIALOG_VIP_WEP              43          + 1000
#define DIALOG_VIP_WEP_SELECT       44          + 1000
#define DIALOG_GANG_LIST_RESPONSE 	45          + 1000
#define DIALOG_CMDS                 46          + 1000
#define DIALOG_CMDS_REDIRECT        47          + 1000
#define DIALOG_STATS                48          + 1000
#define DIALOG_STATS_REDIRECT       49          + 1000
#define DIALOG_VEHDEALER            50          + 1000
#define DIALOG_CP_MENU            	51          + 1000
#define DIALOG_AMMU_BUY             52          + 1000
#define DIALOG_APARTMENTS         	53          + 1000
#define DIALOG_APARTMENTS_BUY     	54          + 1000
#define DIALOG_FLAT_CONFIG          55          + 1000
#define DIALOG_FLAT_CONTROL         56          + 1000
#define DIALOG_FLAT_TITLE	        57          + 1000
#define DIALOG_BUSINESS_TERMINAL	58          + 1000
#define DIALOG_WEAPON_DEAL          59          + 1000
#define DIALOG_WEAPON_DEAL_BUY      60          + 1000
#define DIALOG_HOUSE_PW             61          + 1000
#define DIALOG_HOUSE_SET_PW         62          + 1000
#define DIALOG_HOUSE_WEAPONS        63          + 1000
#define DIALOG_HOUSE_WEAPONS_ADD    64          + 1000
#define DIALOG_BUSINESS_BUY         65          + 1000
#define DIALOG_FURNITURE            66          + 1000
#define DIALOG_FURNITURE_LIST 		67          + 1000
#define DIALOG_FURNITURE_OPTION     68          + 1000
#define DIALOG_FURNITURE_ROTATION   69          + 1000
#define DIALOG_FURNITURE_MAN_SEL    70          + 1000
#define DIALOG_ONLINE_JOB           71          + 1000
#define DIALOG_ONLINE_JOB_R         72          + 1000
#define DIALOG_FURNITURE_CATEGORY   73          + 1000
#define DIALOG_FLAT_FURNITURE 		74         	+ 1000
#define DIALOG_TRUNCATE_FURNITURE	75 			+ 1000
#define DIALOG_VEHDEALER_BUY		76 			+ 1000
#define DIALOG_VEHDEALER_OPTIONS	77 			+ 1000
#define DIALOG_HELP 				78 			+ 1000
#define DIALOG_HELP_CATEGORY		79 			+ 1000
#define DIALOG_HELP_THREAD			80 			+ 1000
#define DIALOG_HELP_BACK			81 			+ 1000
#define DIALOG_RADIO_CUSTOM			82 			+ 1000
#define DIALOG_GPS_CITY 			83 			+ 1000
#define DIALOG_SPAWN_CITY			84 			+ 1000
#define DIALOG_GATE					85  		+ 1000
#define DIALOG_GATE_EDIT 			86 			+ 1000
#define DIALOG_GATE_OWNER 			87 			+ 1000
#define DIALOG_GATE_OWNER_EDIT		88 			+ 1000
#define DIALOG_PAINTBALL_EDIT 		89 			+ 1000
#define DIALOG_PAINTBALL_EDIT_VAL 	90 			+ 1000
#define DIALOG_PAINTBALL_ARENAS 	91 			+ 1000
#define DIALOG_PAINTBALL_WEP 		92 			+ 1000
#define DIALOG_PAINTBALL_PW 		93 			+ 1000
#define DIALOG_DONATED_PLATBRONZE 	94 			+ 1000
#define DIALOG_SHOP_AMOUNT 			95 			+ 1000
#define DIALOG_PAINTBALL_REFILL 	96 			+ 1000
#define DIALOG_HOUSE_INT_CONFIRM	98 			+ 1000
#define DIALOG_TOYS_ITEMS			99 			+ 1000
#define DIALOG_TOYS_EDIT 			100 		+ 1000
#define DIALOG_TOYS_BONE_EDIT 		101 		+ 1000
#define DIALOG_TOYS_BUY 			102 		+ 1000
#define DIALOG_TOYS_ITEMS_BUY 		103 		+ 1000
#define DIALOG_UNBAN_CLASS 			104 		+ 1000
#define DIALOG_GANG_BANK_WITHDRAW   105			+ 1000
#define DIALOG_GANG_BANK_DEPOSIT    106			+ 1000
#define DIALOG_GANG_BANK_INFO       107			+ 1000
#define DIALOG_YOU_SURE_APART  		108			+ 1000
#define DIALOG_YOU_SURE_VIP 		109			+ 1000
#define DIALOG_CHANGENAME			110 		+ 1000
#define DIALOG_GANG_LIST_OPTIONS	111 		+ 1000
#define DIALOG_GANG_LIST_MEMBERS 	112 		+ 1000
#define DIALOG_COMPONENTS_CATEGORY 	113 		+ 1000
#define DIALOG_COMPONENTS			114 		+ 1000
#define DIALOG_COMPONENT_EDIT 		115 		+ 1000
#define DIALOG_COMPONENT_EDIT_MENU	116			+ 1000
#define DIALOG_COMPONENT_MENU		117			+ 1000
#define DIALOG_DONATED_DIAGOLD 		118			+ 1000
#define DIALOG_LATEST_DONOR			119			+ 1000
#define DIALOG_FINISHED_DONATING	120			+ 1000
#define DIALOG_MODIFY_HITSOUND 		121			+ 1000
#define DIALOG_VIP_NOTE				122 		+ 1000
#define DIALOG_REGISTER_QUIT 		123 		+ 1000
#define DIALOG_LOGIN_QUIT			124			+ 1000
#define DIALOG_WEAPON_LOCKER		125			+ 1000
#define DIALOG_WEAPON_LOCKER_BUY	126			+ 1000
#define DIALOG_FEEDBACK				127			+ 1000
#define DIALOG_IC_MARKET_2 			128			+ 1000
#define DIALOG_BUSINESS_CAR			129 		+ 1000
#define DIALOG_BUSINESS_HELI		130 		+ 1000
#define DIALOG_ACC_GUARD 			131			+ 1000
#define DIALOG_ACC_GUARD_EMAIL		132 		+ 1000
#define DIALOG_ACC_GUARD_MODE 		133			+ 1000
#define DIALOG_ACC_GUARD_CONFIRM	134			+ 1000
#define DIALOG_ACC_GUARD_DEL_CANCEL	135			+ 1000
#define DIALOG_RACE 				136			+ 1000
#define DIALOG_RACE_MODE 			137			+ 1000
#define DIALOG_RACE_FEE 			138			+ 1000
#define DIALOG_RACE_POS 			139			+ 1000
#define DIALOG_RACE_DISTANCE 		140			+ 1000
#define DIALOG_RACE_KICK 			141			+ 1000
#define DIALOG_RACE_DEST 			142			+ 1000
#define DIALOG_RACE_PRESELECT 		143			+ 1000
#define DIALOG_RACE_CUSTOM_DEST 	144			+ 1000
#define DIALOG_BUSINESS_SELL		145			+ 1000
#define DIALOG_BUSINESS_NAME 		146 		+ 1000
#define DIALOG_BUSINESS_ADD_MEMBER	147			+ 1000
#define DIALOG_BUSINESS_MEMBERS		148			+ 1000
#define DIALOG_BUSINESS_WITHDRAW	149 		+ 1000
#define DIALOG_BUSINESS_UPGRADES	150			+ 1000
#define DIALOG_BUSINESSES 			151 		+ 1000

/* ** Progress Bars ** */
#define PROGRESS_CRACKING 			0
#define PROGRESS_BRUTEFORCE 		1
#define PROGRESS_ROBTRUCK 			2
#define PROGRESS_MINING				3
#define PROGRESS_ROBBING			4
#define PROGRESS_SAFEPICK 			5
#define PROGRESS_CHEMICAL 			6
#define PROGRESS_GRAB_METH 			7

/* ** Jobs ** */
#define MAX_JOB_NAME 				( 16 )

#define JOB_RAPIST                  ( 0 )
#define JOB_KIDNAPPER               ( 1 )
#define JOB_TERRORIST               ( 2 )
#define JOB_HITMAN                  ( 3 )
#define JOB_PROSTITUTE          	( 4 )
#define JOB_WEAPON_DEALER           ( 5 )
#define JOB_DRUG_DEALER           	( 6 )
#define JOB_DIRTY_MECHANIC         	( 7 )
#define JOB_BURGLAR              	( 8 )

/* ** Class ID's ** */
#define CLASS_CIVILIAN              ( 0 )
#define CLASS_POLICE              	( 1 )
#define CLASS_FIREMAN               ( 2 )
#define CLASS_MEDIC              	( 3 )

/* ** Checkpoints ** */
#define ALL_CHECKPOINTS             ( 43 )

#define CP_BOMB_SHOP                ( 0 )
#define CP_BANK_MENU                ( 1 )
#define CP_247_MENU                	( 2 )
#define CP_CHANGE_JOB               ( 3 )
#define CP_HOSPITAL                 ( 4 )
#define CP_BANK_MENU_LS          	( 5 )
#define CP_PAINTBALL                ( 6 )
#define CP_AMMUNATION_0            	( 7 )
#define CP_LUMBERJACK				( 8 )
#define CP_FIGHTSTYLE               ( 9 )
#define CP_VEHDEALER                ( 10 )
#define CP_AMMUNATION_1       		( 11 )
#define CP_AMMUNATION_2       		( 12 )
#define CP_COUNTRY_BANK_MENU 		( 13 )
#define CP_BOMB_SHOP_LV	 			( 14 )
#define CP_HOSPITAL_LV 				( 15 )
#define CP_FIGHTSTYLE_LV 			( 16 )
#define CP_VEHDEALER_2 				( 17 )
#define CP_BOMB_SHOP_LS 			( 18 )
#define CP_HOSPITAL1_LS 			( 19 )
#define CP_HOSPITAL2_LS 			( 20 )
#define CP_FIGHTSTYLE_LS 			( 21 )
#define CP_VEHDEALER_3				( 22 )
#define CP_PAWNSHOP 				( 23 )
#define CP_HOSPITAL_FC 				( 24 )
#define CP_REFILL_AMMO				( 25 )
#define CP_REFILL_AMMO_LS			( 26 )
#define CP_REFILL_AMMO_LV			( 27 )
#define CP_DROP_OFF_COP           	( 28 )
#define CP_DROP_OFF_FC				( 29 )
#define CP_DROP_OFF_DILLIMORE		( 30 )
#define CP_DROP_OFF_DIABLO			( 31 )
#define CP_DROP_OFF_QUBRADOS		( 32 )
#define CP_DROP_OFF_COP_LS 			( 33 )
#define CP_DROP_OFF_FBI_LS 			( 34 )
#define CP_DROP_OFF_FBI_LV 			( 35 )
#define CP_DROP_OFF_COP_LV 			( 36 )
#define CP_DROP_OFF_FBI             ( 37 )
#define CP_DROP_OFF_HELI         	( 38 )
#define CP_BIZ_TERMINAL_COKE		( 39 )
#define CP_BIZ_TERMINAL_METH 		( 40 )
#define CP_BIZ_TERMINAL_WEED 		( 41 )
#define CP_BIZ_TERMINAL_WEAP 		( 42 )

/* ** Discord ** */
//#include <discord-connector>
#define ENABLE_DISCORD 				false

#define DISCORD_GENERAL 			"191078670360641536"
#define DISCORD_ADMINISTRATION 		"191078670360641536"
#define DISCORD_SPAM 				"364725535256870913"

#define DISCORD_ROLE_EXEC 			"191727949404176384"
#define DISCORD_ROLE_HEAD 			"191134988354191360"
#define DISCORD_ROLE_LEAD			"191080382689443841"
#define DISCORD_ROLE_VIP			"191180697547833344"
#define DISCORD_ROLE_VOICE			"364678874681966592"

new stock
	DCC_Guild: discordGuild,
	DCC_Channel: discordGeneralChan,
	DCC_Channel: discordAdminChan,
	DCC_Channel: discordSpamChan,

	DCC_Role: discordRoleExecutive,
	DCC_Role: discordRoleHead,
	DCC_Role: discordRoleLead,
	DCC_Role: discordRoleVIP,
	DCC_Role: discordRoleVoice
;

/* ** Random Messages ** */
stock const
	g_randomMessages[ 51 ] [ 137 ] =
	{
		{ "{8ADE47}Stephanie:"COL_WHITE" You can buy ropes at Supa Save or a 24/7 store to tie people up!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" Save us on your favourites so you don't miss out on the action!" },
        { "{8ADE47}Stephanie:"COL_WHITE" You can catch updates on our website - "#SERVER_WEBSITE"!" },
        { "{8ADE47}Stephanie:"COL_WHITE" Interested in getting V.I.P? Type "COL_GREY"/vip"COL_WHITE" for more details!" },
        { "{8ADE47}Stephanie:"COL_WHITE" Consider helping the community by donating! You will receive Irresistible Coins to redeem V.I.P!" },
        { "{8ADE47}Stephanie:"COL_WHITE" Just donated? Check your e-mail for a transaction ID and redeem your coins easily with /donated!" },
        { "{8ADE47}Stephanie:"COL_WHITE" Do not share your password with anyone, or even use it in a friends server!" },
        { "{8ADE47}Stephanie:"COL_WHITE" Trouble getting to places? Use "COL_GREY"/gps{FFFFFF} inside a vehicle!" },
        { "{8ADE47}Stephanie:"COL_WHITE" Donors receive a Irresistible Coins in return of their generous donation, used to redeem V.I.P!" },
        { "{8ADE47}Stephanie:"COL_WHITE" Rob stores and earn score, the more XP you have, the more benefits you gain!" },
        { "{8ADE47}Stephanie:"COL_WHITE" Houses are buyable, you can buy one and set your spawning location inside that house!" },
        { "{8ADE47}Stephanie:"COL_WHITE" Remember to check the "COL_GREY"/rules{FFFFFF}! Disobeying the rules can lead to punishment!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" Seen a cheater? Use "COL_GREY"/report {FFFFFF}to tell an admin." },
		{ "{8ADE47}Stephanie:"COL_WHITE" To change your class, type "COL_GREY"/changeclass{FFFFFF}." },
		{ "{8ADE47}Stephanie:"COL_WHITE" Detaining a suspect as a cop pays more than arresting by itself, and killing." },
		{ "{8ADE47}Stephanie:"COL_WHITE" Being annoyed by some member via PM? "COL_GREY"/dnd{FFFFFF} to block them!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" See "COL_GREY"/animlist {FFFFFF}for animations." },
		{ "{8ADE47}Stephanie:"COL_WHITE" Type "COL_GREY"/help {FFFFFF}for information on the server!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" Need a set of commands to view? Use "COL_GREY"/cmds{FFFFFF}!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" To give money to a player, use "COL_GREY"/sendmoney{FFFFFF} or "COL_GREY"/sm{FFFFFF} for short." },
		{ "{8ADE47}Stephanie:"COL_WHITE" Get V.I.P with Irresistible Coins! Consider donating by visiting our site to get more!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" To explode the bank vault, or the jail cells; plant C4 by the two cells then explode!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" Tired of a player? You can place a contract on their head with "COL_GREY"/placehit{FFFFFF}!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" Need a label on your head with an informative message? You can use "COL_GREY"/label{FFFFFF}!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" The golden bar at the bottom right of your screen is the amount of XP you have!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" Follow us on twitter! "COL_GREY"@IrresistibleDev{FFFFFF}!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" Holding "COL_GREY"LEFT ALT{FFFFFF} and "COL_GREY"SPACE{FFFFFF} stops the current radio you're playing." },
		{ "{8ADE47}Stephanie:"COL_WHITE" You can change your current job at the "COL_GREY"City Hall{FFFFFF}!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" You can change your spawning city at the "COL_GREY"City Hall{FFFFFF}!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" You can buy fancy toys at a "COL_GREY"Pawnshop{FFFFFF}!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" Never share your password, not even with the server owner!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" You can access our Discord server at {7289da}sfcnr.com/discord" },
		{ "{8ADE47}Stephanie:"COL_WHITE" Locate ChuffSec's security truck with "COL_GREY"/chuffloc{FFFFFF} and rob his security truck for cash!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" Buy a "COL_GREY"Money Case{FFFFFF} to double up your robbery loot from Supa Save or a 24/7 store! " },
		{ "{8ADE47}Stephanie:"COL_WHITE" Grab a truck, connect it to a trailer then begin to "COL_GREY"/work{FFFFFF}! It's rewarding!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" Looking for something to do? Work on your "COL_GREY"/achievements"COL_WHITE"!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" Check your global SF-CNR rank with "COL_GREY"/rank"COL_WHITE"!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" Consider mining some ores near Jizzy's or at the Quarry! It's some fine pay!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" See how many Irresistible Coins you generated with "COL_GREY"/irresistiblecoins"COL_WHITE"." },
		{ "{8ADE47}Stephanie:"COL_WHITE" Split your robbing profits with your gang members using "COL_GREY"/gang splitprofit"COL_WHITE"." },
		{ "{8ADE47}Stephanie:"COL_WHITE" Toggle your total coins generated bar with "COL_GREY"/cp"COL_WHITE"." },
		{ "{8ADE47}Stephanie:"COL_WHITE" Be assigned to a rank by playing the game frequently, making use of all features!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" View the current robbing, arresting and killing streak that you are on with "COL_GREY"/streaks"COL_WHITE"!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" Check out what your favourite weapon is with "COL_GREY"/weaponstats"COL_WHITE"!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" The secret monthly top donor can claim a prize at the end of the month!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" Got any feedback for the server? Use "COL_GREY"/feedback"COL_WHITE"!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" Attach an email to your account using "COL_GREY"/email"COL_WHITE" for strong security features!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" Want to form a criminal enterprise? Create a gang and invite your friends with "COL_GREY"/gang create"COL_WHITE"!" },
		{ "SLOT_MACHINES" },
		{ "{8ADE47}Stephanie:"COL_WHITE" Play roulette at a Casino and win up to 35x on the money you place on a single number!" },
		{ "{8ADE47}Stephanie:"COL_WHITE" Race your friends in a street race or outrun race by using "COL_GREY"/race"COL_WHITE"!" }
	},
	killedWords[ ] [ ] =
	{
		{ "murked" }, { "killed" }, { "ended" }, { "slain" }, { "massacred" }, { "destroyed" }, { "screwed" }
	}
;

/* ** Textdraw Data ** */
new
	Text:  g_ClassBoxTD        		= Text: INVALID_TEXT_DRAW,
	Text:  g_ClassBoxTD1        	= Text: INVALID_TEXT_DRAW,
	Text:  g_ObjectLoadTD         	= Text: INVALID_TEXT_DRAW,
	Text:  p_ClassTitleTD      		[ MAX_PLAYERS ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  p_ClassInfoTD       		[ MAX_PLAYERS ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  p_JailTimeTD     		[ MAX_PLAYERS ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  p_TrackPlayerTD     		[ MAX_PLAYERS ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  g_WebsiteTD        		= Text: INVALID_TEXT_DRAW,
	Text:  g_MotdTD               	= Text: INVALID_TEXT_DRAW,
	Text:  g_MovieModeTD            [ 6 ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  p_GPSInformation        	[ MAX_PLAYERS ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  g_WorldDayTD       		= Text: INVALID_TEXT_DRAW,
	Text:  p_FireDistance1        	[ MAX_PLAYERS ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  p_FireDistance2         	[ MAX_PLAYERS ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  g_AchievementTD          [ 4 ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  p_AchievementTD          [ MAX_PLAYERS ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  g_AnimationTD            = Text: INVALID_TEXT_DRAW,
	Text:  g_AdminLogTD         	= Text: INVALID_TEXT_DRAW,
	Text:  g_ProgressBoxTD        	= Text: INVALID_TEXT_DRAW,
	Text:  p_ProgressBoxOutsideTD	[ MAX_PLAYERS ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  p_ProgressBoxTD        	[ MAX_PLAYERS ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  p_ProgressTitleTD      	[ MAX_PLAYERS ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  g_VehiclePreviewBoxTD 	= Text: INVALID_TEXT_DRAW,
	Text:  g_VehiclePreviewTxtTD	= Text: INVALID_TEXT_DRAW,
	Text:  p_VehiclePreviewCloseTD	= Text: INVALID_TEXT_DRAW,
	Text:  g_DoubleXPTD				= Text: INVALID_TEXT_DRAW,
	Text:  p_HelpBoxTD 				[ MAX_PLAYERS ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  p_TruckingTD 			[ MAX_PLAYERS ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  g_currentXPTD 			= Text: INVALID_TEXT_DRAW,
	Text:  g_CurrentRankTD 			= Text: INVALID_TEXT_DRAW,
	Text:  g_CurrentCoinsTD 		= Text: INVALID_TEXT_DRAW,
	Text:  g_SlotMachineOneTD		[ MAX_MACHINES ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  g_SlotMachineTwoTD		[ MAX_MACHINES ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  p_SlotMachineFigureTD 	[ MAX_MACHINES ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  g_SlotMachineThreeTD		[ MAX_MACHINES ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  g_SlotMachineBoxTD		[ 2 ] = { Text: INVALID_TEXT_DRAW, ... },
	Text:  g_TopDonorTD				= Text: INVALID_TEXT_DRAW,
	Text:  g_NotManyPlayersTD		= Text: INVALID_TEXT_DRAW,
	Text: g_rouletteNumberBG		[ MAX_ROULETTE_TABLES ],
	Text: g_rouletteNumberTD		[ MAX_ROULETTE_TABLES ],

	// Player Textdraws
	PlayerText: p_LocationTD		[ MAX_PLAYERS ] = { PlayerText: INVALID_TEXT_DRAW, ... },
	PlayerText: p_ExperienceTD   	[ MAX_PLAYERS ] = { PlayerText: INVALID_TEXT_DRAW, ... },
	PlayerText: p_ExperienceAwardTD	[ MAX_PLAYERS ] = { PlayerText: INVALID_TEXT_DRAW, ... },
	PlayerText: p_WantedLevelTD		[ MAX_PLAYERS ] = { PlayerText: INVALID_TEXT_DRAW, ... },
	PlayerText: p_CoinsTD        	[ MAX_PLAYERS ] = { PlayerText: INVALID_TEXT_DRAW, ... },
	PlayerText: p_PlayerRankTD 		[ MAX_PLAYERS ] = { PlayerText: INVALID_TEXT_DRAW, ... },
	PlayerText: p_PlayerRankTextTD 	[ MAX_PLAYERS ] = { PlayerText: INVALID_TEXT_DRAW, ... },
	PlayerText: p_RobberyAmountTD 	[ MAX_PLAYERS ] = { PlayerText: INVALID_TEXT_DRAW, ... },
	PlayerText: p_RobberyRiskTD 	[ MAX_PLAYERS ] = { PlayerText: INVALID_TEXT_DRAW, ... },
	PlayerText: p_DamageTD          [ MAX_PLAYERS ] = { PlayerText: INVALID_TEXT_DRAW, ... },


	PlayerText: p_VehiclePreviewTD 	[ 7 ] = { PlayerText: INVALID_TEXT_DRAW, ... }
;

/* ** Player Spawns ** */
enum E_RANDOM_SPAWNS
{
	Float:RANDOM_SPAWN_X,
	Float:RANDOM_SPAWN_Y,
	Float:RANDOM_SPAWN_Z,
	Float:RANDOM_SPAWN_A,
	RANDOM_SPAWN_INTERIOR,
	RANDOM_SPAWN_WORLD
};

stock const
	g_SanFierroSpawns[ ] [ E_RANDOM_SPAWNS ] =
	{
		{ -2097.5737, 715.2664, 69.5625, 277.9042, 	0, 0 },
		{ -1757.4670, 961.8670, 24.8828, 181.7833,  0, 0 },
		{ -1953.8724, 300.1801, 41.0471, 133.1765, 	0, 0 },
		{ -2020.3107, -96.6103, 35.1641, 331.9525,  0, 0 },
		{ -2343.3860, -138.315, 35.3203, 3.2265,   	0, 0 },
		{ -2519.0496, -30.7666, 25.6172, 319.5007,  0, 0 },
		{ -2759.6978, 375.4238, 4.5230,  270.5632,  0, 0 },
		{ -2474.5874, 1264.014, 28.7647, 275.3246, 	0, 0 },
		{ -1501.3506, 914.5378, 7.1875,  90.5807,   0, 0 },
		{ -2238.6428, 113.4054, 35.3203, 243.0862,  0, 0 },
		{ -1983.5684, 129.8655, 27.6875, 74.4550, 	0, 0 },
		{ -2626.2156, 1398.626, 7.1016,  204.5252,  0, 0 },
		{ -2626.2156, 1398.626, 7.1016,  204.5252,  0, 0 },
		{ -2587.4861, 212.0579, 9.0733,  9.073300,  0, 0 }
	},

	g_LasVenturasSpawns[ ] [ E_RANDOM_SPAWNS ] =
	{
		{ 2170.4834, 1714.3723, 11.0469, 137.5881, 	0, 0 },
		{ 2000.1403, 1564.7941, 15.3672, 236.5212,  0, 0 },
		{ 2417.5991, 1136.6140, 10.8125, 225.6512,  0, 0 },
		{ 2484.6160, 1528.7273, 10.8954, 323.0129, 	0, 0 },
		{ 2464.4070, 2033.2441, 11.0625, 47.88940,  0, 0 },
		{ 2451.2332, 2347.0044, 12.1635, 112.7286,  0, 0 },
		{ 1480.3296, 2250.1125, 11.0291, 279.2149, 	0, 0 },
		{ 2143.3252, 2840.4441, 10.8203, 139.9116, 	0, 0 }
	},

	g_LosSantosSpawns[ ] [ E_RANDOM_SPAWNS ] =
	{
		{ 810.63520, -1340.0682, 13.5386, 37.33070, 0, 0 },
		{ 1124.6071, -1427.5155, 15.7969, 350.9336, 0, 0 },
		{ 585.81520, -1247.9160, 17.9521, 335.6035, 0, 0 },
		{ 2025.2626, -1423.2682, 16.9922, 135.4516, 0, 0 },
		{ 2509.2468, -1679.2029, 13.5469, 50.24740, 0, 0 },
		{ 1457.1467, -1011.7307, 26.8438, 51.79910, 0, 0 },
		{ 2017.8206, -1279.4851, 23.9820, 47.38920, 0, 0 },
		{ 1935.7644, -1794.6068, 13.5469, 295.5515, 0, 0 },
		{ 1371.4569, -1090.6387, 24.5459, 92.84640, 0, 0 },
		{ 2298.4055, -1500.3264, 25.3047, 199.6940, 0, 0 }
	},

	g_FiremanSpawns[ MAX_CITIES ] [ E_RANDOM_SPAWNS ] =
	{
		{ -2026.3287, 67.1439, 28.6916, 270.0000, 	0, 0 },
		{ 1744.56240, 2079.43, 10.8203, 172.1325, 	0, 0 },
		{ 1757.44350, -1456.7, 13.5469, 282.4133, 	0, 0 }
	},

	g_MedicSpawns[ MAX_CITIES ] [ E_RANDOM_SPAWNS ] =
	{
		{ -2658.0764, 634.333, 14.4531, 180.0000, 	0, 0 },
		{ 1615.62490, 1840.19, 10.9696, 0.000000, 	0, 0 },
		{ 1178.04170, -1323.6, 14.1005, 285.5701, 	0, 0 }
	},

	g_ArmySpawns[ MAX_CITIES ] [ E_RANDOM_SPAWNS ] =
	{
		{ -1401.8173, 493.496, 18.2294, 0.000000, 	0, 0 },
		{ 199.572200, 1920.97, 17.6406, 180.0000, 	0, 0 },
		{ 1229.35670, -2611.4, 19.7344, 264.2092, 	0, 0 }
	},

	g_CIASpawns[ MAX_CITIES ] [ E_RANDOM_SPAWNS ] =
	{
		{ -2455.4487, 503.92360, 30.078, 270.000, 	0, 0 },
		{ 940.813400, 1733.6327, 8.8516, 270.000, 	0, 0 },
		{ 1518.82930, -1452.430, 14.203, 0.00000, 	0, 0 }
	},

	g_PoliceSpawns[ MAX_CITIES ] [ E_RANDOM_SPAWNS ] =
	{
		{ -1606.3693, 674.1749, -5.2422, 0.0000, 	0, 0 },
		{ 2295.62960, 2468.796, 10.8203, 90.000, 	0, 0 },
		{ 1528.58340, -1677.49, 5.89060, 270.00, 	0, 0 }
	}

	/*g_MayorSpawns[ MAX_CITIES ] [ E_RANDOM_SPAWNS ] =
	{
		{ 354.7187, 172.4094, 1025.7964, 180.000, 	3, 1 },
		{ 354.7187, 172.4094, 1025.7964, 180.000, 	3, 2 },
		{ 354.7187, 172.4094, 1025.7964, 180.000, 	3, 5 }
	}*/
;

/* ** House System ** */
#define MAX_HOUSES                  ( 2000 )
#define MAX_HOUSE_WEAPONS           ( 7 ) // Don't change...
#define HOUSE_MAPICON_RADIUS 		( 25.0 )

// Furniture Categories
#define FC_DOORS        0
#define FC_TABLECHAIR   1
#define FC_FITNESS      2
#define FC_KITCHENBATH  3
#define FC_ELECTRONIC   4
#define FC_BEDROOM      5
#define FC_LOUNGE       6
#define FC_FLOWERS      7
#define FC_MISC         8
#define FC_WEAPONS		9
#define FC_HOLIDAYS 	10
#define FC_FOODRINK 	11

enum E_HOUSE_DATA
{
	E_OWNER[ 24 ],    	E_HOUSE_NAME[ 30 ],  	bool: E_CREATED,
	Float: E_EX,      	Float: E_EY,           	Float: E_EZ,
	Float: E_TX,     	Float: E_TY,          	Float: E_TZ,
	E_COST,        		E_INTERIOR_ID,          E_CHECKPOINT[ 2 ],
	E_WORLD, 			Text3D: E_LABEL [ 2 ], 	E_PASSWORD[ 5 ],
	bool: E_CRACKED, 	bool: E_BEING_CRACKED,  E_CRACKED_TS,
	E_CRACKED_WAIT,		E_MAP_ICON
};

new
	g_houseData                     [ MAX_HOUSES ] [ E_HOUSE_DATA ]
;

enum E_HINTERIOR_DATA
{
	E_NAME[ 19 ], 		Float: E_EX, 				Float: E_EY,
	Float: E_EZ, 		E_INTERIOR_ID, 				E_COST,
	bool: E_VIP,		Float: E_PREVIEW_POS[ 3 ],	Float: E_PREVIEW_LOOKAT[ 3 ]
};

enum E_FURINTURE_DATA
{
	E_CATEGORY,			E_NAME[ 21 ],       E_MODEL,
	E_COST
};

#define H_DEFAULT_X  	266.4996
#define H_DEFAULT_Y  	304.9577
#define H_DEFAULT_Z  	999.1484

new
	g_houseInteriors[ ] [ E_HINTERIOR_DATA ] =
  	{
      	{ "Cattus Interior",   	H_DEFAULT_X, H_DEFAULT_Y, H_DEFAULT_Z, 	2,  0,	false, { 266.60010, 302.42820, 999.14840 }, { 271.44260, 306.64240, 999.15580 } },
   		{ "Assum Interior",   	243.71980, 304.963500, 999.14840, 	1,  10000,	false, { 249.61870, 300.89080, 999.14840 }, { 244.85410, 305.49680, 999.14840 } },
      	{ "Fossor Interior", 	2218.4036, -1076.2621, 1050.4844,	1,	15000,	false, { 2202.6704, -1078.198, 1050.4844 }, { 2211.8030, -1074.362, 1050.4844 } },
      	{ "Angusto Interior", 	260.98790, 1284.29470, 1080.2578,	4,	20000,	false, { 253.80180, 1294.2167, 1080.2578 }, { 258.55260, 1288.3639, 1080.2578 } },
      	{ "Organum Interior", 	309.37170, 311.674700, 1003.3047,	4,  25000,	false, { 310.13720, 310.80550, 1003.3047 }, { 300.02930, 300.86170, 1003.5391 } },
      	{ "Bulbus Interior", 	-68.84510, 1351.19570, 1080.2109,	6,	25000,	false, { -71.41990, 1366.0359, 1080.2185 }, { -64.59070, 1360.7052, 1080.2185 } },
      	{ "Vindemia Interior", 	295.08510, 1472.25520, 1080.2578,	15,	25000,	false, { 290.14430, 1488.8372, 1080.2578 }, { 294.96960, 1483.6603, 1080.2578 } },
      	{ "Aurora Interior", 	-2170.344, 639.502500, 1052.3750,	1,	30000,	false, { -2168.073, 646.40000, 1057.5938 }, { -2158.598, 638.13010, 1057.5861 } },
      	{ "Fragor Interior",   	318.58580, 1114.47920, 1083.8828,	5,	35000,	false, { 326.31450, 1117.5468, 1083.8828 }, { 317.28550, 1122.6113, 1083.8828 } },
      	{ "Mundus Interior", 	24.012500, 1340.15890, 1084.3750,	10,	40000,	false, { 19.801100, 1340.7814, 1084.3750 }, { 34.253800, 1342.9272, 1084.3750 } },
      	{ "Artus Interior", 	2237.5259, -1081.6458, 1049.0234,	2,	40000,	false, { 2236.2290, -1081.065, 1049.0234 }, { 2244.2285, -1069.357, 1049.0234 } },
      	{ "Caelum Interior", 	2233.6931, -1115.2620, 1050.8828,	5,	40000,	false, { 2235.1128, -1114.911, 1050.8828 }, { 2229.8982, -1105.175, 1050.8903 } },
      	{ "Rotta Interior",		2495.9663, -1692.0857, 1014.7422,	3,	50000,	false, { 2491.1794, -1694.953, 1014.7461 }, { 2497.4587, -1704.258, 1014.7422 } },
      	{ "Ascensor Interior", 	2317.8369, -1026.7662, 1050.2178,	9,	50000,	false, { 2320.9111, -1025.776, 1050.2109 }, { 2319.0242, -1014.091, 1050.2109 } },
      	{ "Colonel Interior",	2807.5693, -1174.7520, 1025.5703,	8,	60000,	false, { 2812.0911, -1173.043, 1025.5703 }, { 2806.0210, -1165.486, 1025.5703 } },
      	{ "Godfather Interior", 140.28170, 1365.92150, 1083.8594,	5,	65000,	false, { 135.53440, 1366.6400, 1083.8615 }, { 143.49590, 1375.7461, 1083.8668 } },
      	{ "Recens Interior",	2270.4192, -1210.5172, 1047.5625,	10,	70000,	false, { 2248.2854, -1207.207, 1049.0234 }, { 2261.0574, -1213.011, 1049.0234 } },
      	{ "Novus Interior",		2365.2341, -1135.5957, 1050.8826,	8,	72000,	false, { 2375.3567, -1121.340, 1050.8750 }, { 2367.7095, -1130.863, 1050.8826 } },
      	{ "Securuse Interior",	2324.3826, -1149.5442, 1050.7101,	12,	80000,	false, { 2317.5684, -1136.016, 1054.3047 }, { 2333.1262, -1147.694, 1050.7031 } },
      	{ "Lorem Interior", 	234.13900, 1063.72110, 1084.2123,	6,	82500,	false, { 235.83530, 1070.2394, 1084.1903 }, { 226.63560, 1073.0388, 1086.2266 } },
      	{ "Domus Interior", 	225.73480, 1021.44500, 1084.0177,	7,	120000,	false, { 224.76680, 1022.3558, 1084.0150 }, { 241.65380, 1037.2081, 1084.0118 } },
      	{ "Madd Doggs Mansion", 1260.6455, -785.46530, 1091.9063,	5,	1337,	true , { 1262.1033, -772.6712, 1091.9063 }, { 1282.7361, -783.5193, 1089.9375 } },
      	{ "Butcher Interior", 	964.93310, 2160.13210, 1011.0303, 	1,	1337,	true , { 933.67050, 2118.9556, 1012.8329 }, { 947.38930, 2163.8730, 1011.0234 } },
      	{ "Bar Interior", 		501.93780, -67.563000, 998.75780, 	11, 1337,	true , { 511.80380, -68.01930, 999.25000 }, { 490.78870, -78.92080, 998.75780 } },
      	{ "Casino Interior", 	1133.1831, -15.833100, 1000.6797, 	12, 1337,	true , { 1114.8433, -12.31790, 1003.0643 }, { 1136.3059, 2.6477000, 1000.6797 } }
  	},
  	g_furnitureCategory[ ] [ ] =
	{
	    { "Doors" }, { "Tables and Chairs" }, { "Fitness" }, { "Kitchen and Bathroom" }, { "Electronics" }, { "Bedroom" },
	    { "Lounge" }, { "Flowers and Plants" }, { "Miscellaneous" }, { "Weapons" }, { "Holiday" }, { "Food/Drink" }
	},
	g_houseFurniture[ ] [ E_FURINTURE_DATA ] =
	{
		// Doors
	    { FC_DOORS, 		"Red Door", 			1504, 175 },
	    { FC_DOORS, 		"Blue Door", 			1505, 175 },
	    { FC_DOORS, 		"White Door", 			1506, 175 },
	    { FC_DOORS, 		"Yellow Door", 			1507, 175 },
	    // Tables and Chairs
  	  	{ FC_TABLECHAIR, 	"Wooden Open Table", 	1817, 50 },
	    { FC_TABLECHAIR,    "Dining Chair",         2079, 60 },
	    { FC_TABLECHAIR,    "Office Chair",         1806, 62 },
	    { FC_TABLECHAIR, 	"Wooden Circle Table", 	1815, 75 },
		{ FC_TABLECHAIR, 	"Cluckin' Table Sml",	2763, 80 },
		{ FC_TABLECHAIR, 	"Cluckin' Table", 		2762, 125 },
		{ FC_TABLECHAIR,    "Dining Table",         2115, 135 },
		{ FC_TABLECHAIR,    "Circle Dining Chair",  2125, 135 },
		{ FC_TABLECHAIR,    "Circle Dining Table",  2030, 150 },
		{ FC_TABLECHAIR,    "Swivel Chair",      	1663, 180 },
		{ FC_TABLECHAIR, 	"Rocking Chair", 		11734, 200 },
		{ FC_TABLECHAIR, 	"Gamer Chair", 			19999, 320 },
		{ FC_TABLECHAIR, 	"Poker Table", 			19474, 500 },
		{ FC_TABLECHAIR, 	"Lab Table",			3383, 900 },
		// Fitness
	    { FC_FITNESS, 		"Mattress #1", 			2815, 50 },
	    { FC_FITNESS, 		"Mattress #2", 			2817, 50 },
	    { FC_FITNESS, 		"Mattress #3", 			2833, 50 },
	    { FC_FITNESS, 		"Mattress #4", 			2836, 50 },
	    { FC_FITNESS, 		"Mattress #5", 			2847, 50 },
	    { FC_FITNESS, 		"Cycle", 				2630, 950 },
	    { FC_FITNESS, 		"Treadmill", 			2627, 1250 },
	    { FC_FITNESS, 		"Weight Lifting", 		2628, 1550 },
	    // Kitchen and Bathroom
		{ FC_KITCHENBATH, 	"Soap", 				19874, 15 },
		{ FC_KITCHENBATH, 	"Toilet Paper", 		19873, 20 },
		{ FC_KITCHENBATH, 	"Towel holder", 		11707, 300 },
	    { FC_KITCHENBATH,	"Double Metal Cabin", 	2007, 400 },
	    { FC_KITCHENBATH,	"Metal Shelf x4", 		2063, 400 },
	    { FC_KITCHENBATH,	"Metal Table", 			941, 500 },
	    { FC_KITCHENBATH,	"Metal Counter", 		937, 600 },
	    { FC_KITCHENBATH,	"Metal Bench-top", 		936, 685 },
	    { FC_KITCHENBATH,	"Toilet",  				2514, 700 },
	    { FC_KITCHENBATH,	"Bathroom Sink", 		2523, 900 },
	    { FC_KITCHENBATH,   "Wooden Double Draw", 	2139, 910 },
	    { FC_KITCHENBATH,   "Wooden Low-unit",      2138, 925 },
	    { FC_KITCHENBATH,	"Washing Machine", 		1208, 925 },
	    { FC_KITCHENBATH,   "Laundry Unit",         2303, 980 },
	    { FC_KITCHENBATH,	"White Bath Tub",		2519, 1000 },
	    { FC_KITCHENBATH,   "Corner Wooden Bench",	2305, 1100 },
	    { FC_KITCHENBATH,   "Wooden Bench w/ Sink", 2136, 1185 },
	    { FC_KITCHENBATH,   "Stable Counter",       2339, 1200 },
	    { FC_KITCHENBATH,	"Bath Tub", 			2526, 1200 },
	    { FC_KITCHENBATH,	"Shower System",		14481, 1290 },
	    { FC_KITCHENBATH,   "Stable Shelf",       	2141, 1300 },
	    { FC_KITCHENBATH,   "Stable Sink",          2132, 1500 },
		{ FC_KITCHENBATH, 	"Love Spa", 			11732, 2000 },
	    { FC_KITCHENBATH,   "Cooker and Oven",      2135, 2200 },
	    { FC_KITCHENBATH,	"Deep Fryer", 			2413, 2300 },
		// Electronics
		{ FC_ELECTRONIC, 	"Blender", 				19830, 120 },
	    { FC_ELECTRONIC,	"Mini Stereo Speaker", 	2233, 450 },
		{ FC_ELECTRONIC, 	"Coffee Machine", 		11743, 500 },
	    { FC_ELECTRONIC,	"Red Guitar",          	19317, 650 },
	    { FC_ELECTRONIC,	"White Guitar",        	19318, 675 },
	    { FC_ELECTRONIC,	"Bass speaker", 		2229, 675 },
	    { FC_ELECTRONIC,	"Black Guitar",       	19319, 700 },
	    { FC_ELECTRONIC,	"8 Bit TV", 			1748, 700 },
	    { FC_ELECTRONIC,	"VCR Player", 			1719, 900 },
	    { FC_ELECTRONIC, 	"Small TV with VCR",	2595, 1100 },
		{ FC_ELECTRONIC, 	"Laptop", 				19893, 1250 },
	    { FC_ELECTRONIC,	"TV Small", 			1518, 1575 },
	    { FC_ELECTRONIC, 	"Swank TV",				1792, 1600 },
	    { FC_ELECTRONIC,	"TV with Wall Hook", 	2596, 1790 },
	    { FC_ELECTRONIC,    "TV With Stance",       1717, 2000 },
	    { FC_ELECTRONIC, 	"Doozy TV with Stance",	2224, 2050 },
	    { FC_ELECTRONIC,	"Stereo System", 		2100, 2175 },
	    { FC_ELECTRONIC,	"Wide-screen TV", 		1786, 2500 },
		{ FC_ELECTRONIC, 	"Huge LCD", 			19786, 3000 },
	    { FC_ELECTRONIC,	"Small TV Unit", 		2297, 3700 },
	    { FC_ELECTRONIC,    "TV Unit",              2296, 4000 },
	    { FC_ELECTRONIC,    "PC with Desk",     	2181, 4200 },
		// Bedroom
	    { FC_BEDROOM,		"Wooden Stance", 		1743, 650 },
	    { FC_BEDROOM,		"Wooden Counter", 		1416, 750 },
	    { FC_BEDROOM,		"Wooden Drawer", 		1417, 800 },
	    { FC_BEDROOM,		"Hobo bed", 			1745, 800 },
	    { FC_BEDROOM,		"Luxurious bed", 		2298, 1300 },
	    { FC_BEDROOM,		"Super Luxurious bed", 	2563, 1750 },
		{ FC_BEDROOM, 		"Lavish Red Bed", 		11720, 2000 },
		{ FC_BEDROOM, 		"Love Bed", 			11731, 4200 },
		// Lounge
	    { FC_LOUNGE,		"Wooden Couch", 		1755, 275 },
	    { FC_LOUNGE,		"Couch", 				1754, 350 },
	    { FC_LOUNGE,		"Leather Couch",		1702, 500 },
	    { FC_LOUNGE,		"Single Couch", 		1704, 850 },
	    { FC_LOUNGE, 		"Luxury Mattress", 		1828, 900 },
	    { FC_LOUNGE,		"Bookshelf", 			1742, 1000 },
	    { FC_LOUNGE,		"Leather Couch",		1723, 1650 },
	    { FC_LOUNGE,		"TV Stand",				2313, 1700 },
		{ FC_LOUNGE, 		"Fireplace", 			11724, 4800 },
		{ FC_LOUNGE, 		"Chandelier",			19806, 5200 },
		// Flowers and plants
	    { FC_FLOWERS,		"Flower Plant 3", 		2001, 30 },
	    { FC_FLOWERS,		"Flower Plant 4", 		2253, 35 },
	    { FC_FLOWERS, 		"Clear Flower Vase",	2247, 35 },
	    { FC_FLOWERS,		"Painted Flower Vase", 	2251, 40 },
	    { FC_FLOWERS,		"Plant Vase", 			2245, 50 },
	    { FC_FLOWERS,		"Flower Wall-Mount", 	3810, 120 },
	    { FC_FLOWERS,		"Weed Plant", 			19473, 2250 },
		// Miscellaneous
		{ FC_MISC, 			"Chainsaw Dildo", 		19086, 69 },
		{ FC_MISC,			"Massive Die",			1851, 80 },
	    { FC_MISC,			"Deer Head Mount",   	1736, 120 },
	    { FC_MISC,			"Striped Surfboard",   	2404, 140 },
	    { FC_MISC,			"Beach Surfboard",     	2406, 150 },
	    { FC_MISC,			"Flamed Torch",       	3461, 175 },
		{ FC_MISC, 			"Rocking Unicorn", 		11733, 180 },
		{ FC_MISC, 			"Do Not Cross Tape",	19834, 250 },
		{ FC_MISC, 			"Grill",				19831, 300 },
	    { FC_MISC,			"Boxing Bag",         	1985, 300 },
		{ FC_MISC, 			"Car Engine", 			19917, 500 },
		{ FC_MISC, 			"Drum Kit",				19609, 800 },
		{ FC_MISC, 			"Mechanic Computer", 	19903, 1000 },
	    { FC_MISC,			"Pool Table",         	2964, 1250 },
		{ FC_MISC, 			"Cow",					19833, 1337 },
	    { FC_MISC,			"Deer", 				19315, 1337 },
	    { FC_MISC,			"Money Safe", 			2332, 2000 },
		{ FC_MISC, 			"Mechanic Shelves",		19899, 2000 },
	    { FC_MISC,			"Dance Floor", 			19128, 3250 },
	    { FC_MISC,			"Craps Table", 			1824, 4000 },
	    { FC_MISC, 			"Boxing Arena",			14781, 15000 },
	    // Weapons
		{ FC_WEAPONS, 		"Brass Knuckles", 		331, 25 },
		{ FC_WEAPONS,		"Pool Cue",				338, 40 },
		{ FC_WEAPONS, 		"Parachute", 			371, 60 },
		{ FC_WEAPONS, 		"Purple Dildo", 		321, 69 },
		{ FC_WEAPONS, 		"Sledge Hammer", 		19631, 90 },
		{ FC_WEAPONS, 		"Landmine", 			19602, 100 },
		{ FC_WEAPONS, 		"Ammo Box", 			19832, 120 },
		{ FC_WEAPONS, 		"Antique Sword", 		19590, 250 },
		{ FC_WEAPONS, 		"Mac 10", 				352, 250 },
		{ FC_WEAPONS, 		"Tec 9", 				372, 290 },
		{ FC_WEAPONS, 		"Rifle", 				357, 300 },
		{ FC_WEAPONS, 		"Desert Eagle", 		348, 500 },
		{ FC_WEAPONS, 		"Shotgun", 				349, 600 },
		{ FC_WEAPONS, 		"Sawn-off Shotgun", 	350, 800 },
		{ FC_WEAPONS, 		"Sniper", 				358, 800 },
		{ FC_WEAPONS, 		"Spas 12", 				351, 900 },
		{ FC_WEAPONS, 		"M4", 					356, 900 },
		{ FC_WEAPONS, 		"Minigun", 				362, 1337 },
		{ FC_WEAPONS, 		"Heatseeker", 			360, 1337 },
		{ FC_WEAPONS, 		"RPG", 					359, 1337 },
		// Holiday
		{ FC_HOLIDAYS, 		"Xmas Box 1", 			19054, 100 },
		{ FC_HOLIDAYS, 		"Xmas Box 2", 			19055, 100 },
		{ FC_HOLIDAYS, 		"Xmas Box 3", 			19056, 100 },
		{ FC_HOLIDAYS, 		"Xmas Box 4", 			19057, 100 },
		{ FC_HOLIDAYS, 		"Xmas Box 5", 			19058, 100 },
		{ FC_HOLIDAYS, 		"Witch Pot",			19527, 200 },
		{ FC_HOLIDAYS, 		"Devil Face",			11704, 666 },
		{ FC_HOLIDAYS, 		"Xmas Tree", 			19076, 777 },
		// Food/Drink
		{ FC_FOODRINK, 		"Pizza Box", 			19571, 10 },
		{ FC_FOODRINK, 		"Coffee Mug", 			19835, 15 },
		{ FC_FOODRINK, 		"Pizza", 				19580, 30 },
		{ FC_FOODRINK, 		"Ordinary Brandy", 		19821, 45 },
		{ FC_FOODRINK, 		"Fine Scotch", 			19823, 90 },
		{ FC_FOODRINK, 		"Beer Keg", 			19812, 150 },
		{ FC_FOODRINK, 		"Vintage Whiskey", 		19824, 155 },
		{ FC_FOODRINK, 		"Premium Brandy", 		19820, 190 },
		{ FC_FOODRINK, 		"Premium Wine", 		19822, 220 }
	},
	szg_houseInteriors				[ 24 * sizeof( g_houseInteriors ) ],
	g_HouseWeapons					[ MAX_HOUSES ] [ MAX_HOUSE_WEAPONS ],
	g_HouseWeaponAmmo				[ MAX_HOUSES ] [ MAX_HOUSE_WEAPONS ],
	g_HouseFurnitureCount			[ MAX_HOUSES ]
;

/* ** Bribe Data ** */
#define MAX_BRIBES                  ( 200 )
#define MAX_BRIBE_WAIT              ( 300000 )

enum E_BRIBE_DATA
{
	bool: E_DISABLED, 	E_PICKUP[ 2 ],			Text3D: E_LABEL,
	Float: E_X, 		Float: E_Y, 			Float: E_Z,
	E_TIMESTAMP
};

new
	g_bribeData						[ MAX_BRIBES ] [ E_BRIBE_DATA ],

	// Iterator
	Iterator:BribeCount< MAX_BRIBES >
;

/* ** Gate System ** */
#define MAX_GATES 					( 300 )

enum E_GATE_DATA
{
	E_OBJECT,			E_PASS[ 8 ], 			Float: E_SPEED,
	Float: E_RANGE,		E_MODEL, 				bool: E_MOVING,
	E_OWNER,			E_NAME[ 24 ],			E_TIME,

	Float: E_X,			Float: E_Y,				Float: E_Z,
	Float: E_RX,		Float: E_RY,			Float: E_RZ,

	Float: E_MOVE_X,	Float: E_MOVE_Y,		Float: E_MOVE_Z,
	Float: E_MOVE_RX,	Float: E_MOVE_RY,		Float: E_MOVE_RZ,

	E_CLOSE_TIMER
};

new
	g_gateData 					[ MAX_GATES ] [ E_GATE_DATA ],

	// Iterator
	Iterator:gates<MAX_GATES>
;

/* ** Robbery Data **/
#define MAX_ROBBERIES 				( 200 )
#define MAX_ROBBERY_WAIT            ( 300 )
#define MAX_DRILL_STRENGTH 			( 150 )

#define STATE_NONE 					( 0 )
#define STATE_ROBBED 				( 1 )
#define STATE_PICKED 				( 2 )

enum E_ROBBERY_SYSTEM
{
	E_NAME[ 32 ],       E_ROB_VALUE, 	 		E_WORLD,
	E_ROB_TIME, 		bool: E_ROBBED,     	E_STATE,

	E_SAFE,				E_SAFE_DOOR,			E_SAFE_MONEY,
	E_SAFE_LOOT,		E_ROBTIMER,				bool: E_OPEN,

	E_C4,				bool: E_C4_SLOT,
	E_DRILL,			E_DRILL_PLACER,			E_DRILL_EFFECT,

	Float: E_DOOR_X, 	Float: E_DOOR_Y, 		Float: E_DOOR_Z,
	Float: E_DOOR_ROT, 	Float: E_VELOCITY,

	Float: E_MULTIPLIER
};

enum
{
	ROBBERY_TYPE_DRILL,
	ROBBERY_TYPE_C4,
	ROBBERY_TYPE_LABOR
};

new
	g_robberyData					[ MAX_ROBBERIES ] [ E_ROBBERY_SYSTEM ],
	p_drillStrength					[ MAX_PLAYERS ],

	Iterator:RobberyCount<MAX_ROBBERIES>
;

/* ** Vehicle Data ** */
#define MAX_BUYABLE_VEHICLES        ( 20 + MAX_EXTRA_SLOTS )

enum E_CAR_DATA
{
	E_VEHICLE_ID,       bool: E_CREATED,        	bool: E_LOCKED,
	Float: E_X,         Float: E_Y,             	Float: E_Z,
	Float: E_ANGLE,     E_OWNER_ID,            		E_PRICE,
	E_COLOR[ 2 ],       E_MODEL,                    E_PLATE[ 32 ],
	E_PAINTJOB,			E_SQL_ID,					E_GARAGE
};

new
	g_vehicleData                	[ MAX_PLAYERS ] [ MAX_BUYABLE_VEHICLES ] [ E_CAR_DATA ],
	bool: g_buyableVehicle        	[ MAX_VEHICLES char ],
	g_vehicleModifications          [ MAX_PLAYERS ] [ MAX_BUYABLE_VEHICLES ] [ MAX_CAR_MODS ]
;

/** ** Vehicle Modification Data ** */
#define ENABLE_COMPONENTS_SYSTEM	true

#if ENABLE_COMPONENTS_SYSTEM == true
#define MAX_PIMPS 					( 10 )
#define MAX_COMPONENT_NAME			( 32 )

#define CATEGORY_SPOILERS 			( 0 )
#define CATEGORY_HOOD 				( 1 )
#define CATEGORY_BAGS				( 2 )
#define CATEGORY_LAMPS				( 3 )
#define CATEGORY_WHEELS				( 4 )
#define CATEGORY_BULLBAR			( 5 )
#define CATEGORY_FRONT_BUMPER		( 6 )
#define CATEGORY_REAR_BUMPER		( 7 )
#define CATEGORY_VENTS				( 8 )
#define CATEGORY_NEON				( 9 )
#define CATEGORY_MECHANIC_ITEMS 	( 10 )
#define CATEGORY_MILITARY_ITEMS 	( 11 )
#define CATEGORY_MISCELLANEOUS		( 12 )

enum E_CAR_MODS
{
	E_CATEGORY,						E_LIMIT,						E_MODEL_ID,
	E_NAME[ MAX_COMPONENT_NAME ], 	E_PRICE
};

enum E_PIMP_DATA
{
	bool: E_CREATED[ MAX_PIMPS ],	E_OBJECT[ MAX_PIMPS ],			E_MODEL[ MAX_PIMPS ],
	Float: E_X[ MAX_PIMPS ],		Float: E_Y[ MAX_PIMPS ],		Float: E_Z[ MAX_PIMPS ],
	Float: E_RX[ MAX_PIMPS ],		Float: E_RY[ MAX_PIMPS ],		Float: E_RZ[ MAX_PIMPS ],
	E_SQL_ID[ MAX_PIMPS ],			bool: E_DISABLED[ MAX_PIMPS ]
};

new
	g_vehicleComponentsCategories[ ] [ MAX_COMPONENT_NAME ] = {
		"Spoilers", "Hood", "Bags", "Lamps", "Wheels", "Bullbar", "Front Bumper", "Rear Bumper", "Vents", "Neon", "Mechanic Items", "Military Items", "Miscellaneous"
	},
	g_vehicleComponentsData[ ] [ E_CAR_MODS ] =
	{
		// Spoilers
		{ CATEGORY_SPOILERS, 0, 1023, "Fury", 8000 },
		{ CATEGORY_SPOILERS, 0, 1001, "Win", 9000 },
		{ CATEGORY_SPOILERS, 0, 1000, "Pro", 10000 },
		{ CATEGORY_SPOILERS, 0, 1016, "Worx", 10000 },
		{ CATEGORY_SPOILERS, 0, 1058, "Alien - Stratum", 10000 },
		{ CATEGORY_SPOILERS, 0, 1014, "Champ", 11000 },
		{ CATEGORY_SPOILERS, 0, 1003, "Alpha", 12000 },
		{ CATEGORY_SPOILERS, 0, 1002, "Drag", 13000 },
		{ CATEGORY_SPOILERS, 0, 1015, "Race", 14000 },
		{ CATEGORY_SPOILERS, 0, 1060, "X-Flow - Stratum", 14000 },
		{ CATEGORY_SPOILERS, 0, 1049, "Alien - Flash", 14000 },
		{ CATEGORY_SPOILERS, 0, 1162, "Alien - Jester", 18000 },
		{ CATEGORY_SPOILERS, 0, 1164, "Alien - Uranus", 19000 },
		{ CATEGORY_SPOILERS, 0, 1147, "Alien - Elegy", 22000 },
		{ CATEGORY_SPOILERS, 0, 1050, "X-Flow - Flash", 23000 },
		{ CATEGORY_SPOILERS, 0, 1138, "Alien - Sultan", 25000 },
		{ CATEGORY_SPOILERS, 0, 1158, "X-Flow - Jester", 27000 },
		{ CATEGORY_SPOILERS, 0, 1163, "X-Flow - Uranus", 28000 },
		{ CATEGORY_SPOILERS, 0, 1146, "X-Flow - Elegy", 30000 },
		{ CATEGORY_SPOILERS, 0, 1139, "X-Flow - Sultan", 35000 },

		// Hood
		{ CATEGORY_HOOD, 0, 1011, "Race Scoop", 13000 },
		{ CATEGORY_HOOD, 0, 1004, "Champ Scoop", 15000 },
		{ CATEGORY_HOOD, 0, 1005, "Fury Scoop", 16000 },
		{ CATEGORY_HOOD, 0, 1012, "Worx Scoop", 23000 },

		// Bags
		{ CATEGORY_BAGS, 0, 11745, "Bag", 15000 },
		{ CATEGORY_BAGS, 0, 1279, "Tent Pack", 17000 },
		{ CATEGORY_BAGS, 0, 1550, "Money Bag", 35000 },
		{ CATEGORY_BAGS, 0, 1210, "Money Case", 25000 },
		{ CATEGORY_BAGS, 0, 1575, "Grey Drug Bag", 15000 },
		{ CATEGORY_BAGS, 0, 1576, "Orange Drug Bag", 15000 },
		{ CATEGORY_BAGS, 0, 1577, "Yellow Drug Bag", 15000 },
		{ CATEGORY_BAGS, 0, 1578, "Green Drug Bag", 15000 },
		{ CATEGORY_BAGS, 0, 1579, "Blue Drug Bag", 15000 },
		{ CATEGORY_BAGS, 0, 1580, "Red Drug Bag", 15000 },

		// Lamps
		{ CATEGORY_LAMPS, 0, 1013, "Round Fog", 15000 },
		{ CATEGORY_LAMPS, 0, 1024, "Square Fog", 25000 },

		// Wheels
		{ CATEGORY_WHEELS, 0, 1025, "Offroad", 25000 },
		{ CATEGORY_WHEELS, 0, 1080, "Switch", 25000 },
		{ CATEGORY_WHEELS, 0, 1077, "Classic", 30000 },
		{ CATEGORY_WHEELS, 0, 1073, "Shadow", 35000 },
		{ CATEGORY_WHEELS, 0, 1079, "Cutter", 35000 },
		{ CATEGORY_WHEELS, 0, 1085, "Atomic", 35000 },
		{ CATEGORY_WHEELS, 0, 1096, "Ahab", 35000 },
		{ CATEGORY_WHEELS, 0, 1078, "Twist", 40000 },
		{ CATEGORY_WHEELS, 0, 1081, "Grove", 40000 },
		{ CATEGORY_WHEELS, 0, 1084, "Trance", 45000 },
		{ CATEGORY_WHEELS, 0, 1075, "Rimshine", 45000 },
		{ CATEGORY_WHEELS, 0, 1074, "Mega", 45000 },
		{ CATEGORY_WHEELS, 0, 1076, "Wires", 50000 },
		{ CATEGORY_WHEELS, 0, 1098, "Access", 55000 },
		{ CATEGORY_WHEELS, 0, 1097, "Virtual", 65000 },
		{ CATEGORY_WHEELS, 0, 1082, "Import", 75000},
		{ CATEGORY_WHEELS, 0, 1327, "Large Wheel", 80000 },
		{ CATEGORY_WHEELS, 0, 1083, "Dollar", 100000 },

		// Bullbar
		{ CATEGORY_BULLBAR, 0, 1123, "Bullbar Chrome Bars", 30000 },
		{ CATEGORY_BULLBAR, 0, 1100, "Chrome Grill", 35000 },
		{ CATEGORY_BULLBAR, 0, 1125, "Bullbar Chrome Lights", 37000 },

		// Front Bumper
		{ CATEGORY_FRONT_BUMPER, 0, 1155, "Alien - Stratum", 15000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1160, "Alien - Jester", 20000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1166, "Alien - Uranus", 20000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1153, "Alien - Flash", 25000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1157, "X-Flow - Stratum", 25000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1171, "Alien - Elegy", 25000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1181, "Slamin - Blade", 25000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1185, "Slamin - Remington", 25000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1190, "Slamin - Tornado", 25000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1165, "X-Flow - Uranus", 30000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1169, "Alien - Sultan", 30000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1173, "X-Flow - Jester", 30000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1152, "X-Flow - Flash", 35000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1172, "X-Flow - Elegy", 35000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1170, "X-Flow - Sultan", 40000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1174, "Chrome - Broadway 1", 45000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1176, "Chrome - Broadway 2", 45000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1117, "Chrome - Slamvan", 50000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1182, "Chrome - Blade", 50000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1188, "Slamin - Savanna", 50000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1189, "Chrome - Savanna",50000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1191, "Chrome - Tornado", 50000 },
		{ CATEGORY_FRONT_BUMPER, 0, 1179, "Chrome - Remington", 55000 },

		// Rear Bumper
		{ CATEGORY_REAR_BUMPER, 0, 1154, "Alien - Stratum", 15000 },
		{ CATEGORY_REAR_BUMPER, 0, 1159, "Alien - Jester", 15000 },
		{ CATEGORY_REAR_BUMPER, 0, 1168, "Alien - Uranus", 15000 },
		{ CATEGORY_REAR_BUMPER, 0, 1175, "Slamin - Broadway", 15000 },
		{ CATEGORY_REAR_BUMPER, 0, 1150, "Alien - Flash", 18000 },
		{ CATEGORY_REAR_BUMPER, 0, 1149, "Alien - Elegy", 19000 },
		{ CATEGORY_REAR_BUMPER, 0, 1140, "X-Flow - Sultan", 20000 },
		{ CATEGORY_REAR_BUMPER, 0, 1178, "Slamin - Remington", 23000 },
		{ CATEGORY_REAR_BUMPER, 0, 1156, "X-Flow Straum", 25000 },
		{ CATEGORY_REAR_BUMPER, 0, 1161, "X-Flow - Jester", 25000 },
		{ CATEGORY_REAR_BUMPER, 0, 1183, "Slamin - Blade", 25000 },
		{ CATEGORY_REAR_BUMPER, 0, 1186, "Slamin - Savanna", 25000 },
		{ CATEGORY_REAR_BUMPER, 0, 1167, "X-Flow - Uranus", 25000 },
		{ CATEGORY_REAR_BUMPER, 0, 1193, "Slamin - Tornado", 25000 },
		{ CATEGORY_REAR_BUMPER, 0, 1151, "X-Flow - Flash", 28000 },
		{ CATEGORY_REAR_BUMPER, 0, 1148, "X-Flow - Elegy", 29000 },
		{ CATEGORY_REAR_BUMPER, 0, 1141, "Alien - Sultan", 30000 },
		{ CATEGORY_REAR_BUMPER, 0, 1177, "Slamin - Broadway", 35000 },
		{ CATEGORY_REAR_BUMPER, 0, 1180, "Chrome - Remington", 50000 },
		{ CATEGORY_REAR_BUMPER, 0, 1184, "Chrome - Blade", 50000 },
		{ CATEGORY_REAR_BUMPER, 0, 1187, "Chrome - Savanna", 50000 },
		{ CATEGORY_REAR_BUMPER, 0, 1192, "Chrome - Tornado", 50000 },

		// Vents
		{ CATEGORY_VENTS, 0, 1142, "Left Oval Vents", 4000 },
		{ CATEGORY_VENTS, 0, 1143, "Right Oval Vents", 4000 },
		{ CATEGORY_VENTS, 0, 1144, "Left Square Vents", 6000 },
		{ CATEGORY_VENTS, 0, 1145, "Right Square Vents", 6000 },
		{ CATEGORY_VENTS, 3, 914, "Large Air Vent", 250000 },

		// Neon
		{ CATEGORY_NEON, 0, 18647, "Red Neon", 200000 },
		{ CATEGORY_NEON, 0, 18648, "Blue Neon", 200000 },
		{ CATEGORY_NEON, 0, 18649, "Green Neon", 200000 },
		{ CATEGORY_NEON, 0, 18650, "Yellow Neon", 200000 },
		{ CATEGORY_NEON, 0, 18651, "Pink Neon", 200000 },
		{ CATEGORY_NEON, 0, 18652, "White Neon", 200000 },

		// Military Items
		{ CATEGORY_MILITARY_ITEMS, 0, 1654, "Dynamite", 8000 },
		{ CATEGORY_MILITARY_ITEMS, 0, 19590, "Sword", 14000 },
		{ CATEGORY_MILITARY_ITEMS, 0, 19832, "Ammo Box", 20000 },
		{ CATEGORY_MILITARY_ITEMS, 0, 2040, "Ammo box closed", 20000 },
		{ CATEGORY_MILITARY_ITEMS, 0, 2041, "Ammo box open", 20000 },
		{ CATEGORY_MILITARY_ITEMS, 1, 964, "Army crate", 40000 },
		{ CATEGORY_MILITARY_ITEMS, 0, 11738, "Medikit", 135000 },

		// Mechanic Items
		{ CATEGORY_MECHANIC_ITEMS, 0, 18644, "Screwdriver", 1500 },
		{ CATEGORY_MECHANIC_ITEMS, 0, 18633, "Wrench", 2500 },
		{ CATEGORY_MECHANIC_ITEMS, 0, 18635, "Hammer", 2500 },
		{ CATEGORY_MECHANIC_ITEMS, 0, 1650, "Gas Can", 5000 },
		{ CATEGORY_MECHANIC_ITEMS, 0, 19621, "Oil Can", 7500 },
		{ CATEGORY_MECHANIC_ITEMS, 0, 19816, "Oxygen Tank", 20000 },
		{ CATEGORY_MECHANIC_ITEMS, 0, 19921, "Toolbox", 23000 },
		{ CATEGORY_MECHANIC_ITEMS, 1, 19917, "Engine", 65000 },
		{ CATEGORY_MECHANIC_ITEMS, 1, 920, "Generator", 80000 },
		{ CATEGORY_MECHANIC_ITEMS, 0, 19631, "Sledge Hammer", 90000 },

		// Miscellaneous
		{ CATEGORY_MISCELLANEOUS, 0, 19309, "Taxi White", 2000 },
		{ CATEGORY_MISCELLANEOUS, 0, 19310, "Taxi Black", 4000 },
		{ CATEGORY_MISCELLANEOUS, 0, 18632, "Fishing Rod", 8000 },
		{ CATEGORY_MISCELLANEOUS, 0, 19624, "Suitcase", 15000 },
		{ CATEGORY_MISCELLANEOUS, 0, 19314, "Bullhorn", 15000 },
		{ CATEGORY_MISCELLANEOUS, 0, 18646, "Police Light", 25000 },
		{ CATEGORY_MISCELLANEOUS, 0, 19280, "Floodlight", 30000 },
		{ CATEGORY_MISCELLANEOUS, 0, 19419, "Police Light Strip", 45000 },
		{ CATEGORY_MISCELLANEOUS, 0, 19320, "Pumpkin", 45000 },
		{ CATEGORY_MISCELLANEOUS, 0, 19306, "Red Flag", 50000 },
		{ CATEGORY_MISCELLANEOUS, 0, 19307, "Blue Flag", 50000 },
		{ CATEGORY_MISCELLANEOUS, 0, 19086, "Chainsaw Dildo", 69696},
		{ CATEGORY_MISCELLANEOUS, 0, 11704, "Devil Mask", 75000 },
		{ CATEGORY_MISCELLANEOUS, 2, 2985, "Mounted Minigun", 80000 },
		{ CATEGORY_MISCELLANEOUS, 0, 19315, "Deer", 133769 },
		{ CATEGORY_MISCELLANEOUS, 0, 1609, "Turtle", 250000 },
		{ CATEGORY_MISCELLANEOUS, 1, 19601, "Snow Plough", 1500000 }
	},

	g_vehiclePimpData[ MAX_PLAYERS ] [ MAX_BUYABLE_VEHICLES ] [ E_PIMP_DATA ]
;
#endif

/* ** Road Blocks ** */
#define MAX_ROADBLOCKS              ( 20 )

enum E_ROADBLOCK_DATA
{
	bool: E_CREATED,    E_OBJECT_ID,                Text3D: E_LABEL
};

enum E_ROADBLOCK_OBJ_DATA
{
	E_NAME[ 17 ],		E_MODEL,					Float: E_OFFSET
}

new
	g_roadblockData                 [ MAX_ROADBLOCKS ] [ E_ROADBLOCK_DATA ],

	g_roadblockObjectData 			[ ] [ E_ROADBLOCK_OBJ_DATA ] =
	{
		{ "Small Roadblock",	1459,	0.2 },
		{ "Medium Roadblock",	978,	0.5 },
		{ "Big Roadblock",		981,	0.2 },
		{ "Detour Sign",		1425,	0.6 },
		{ "Will Be Sign",		3265,	0.9 },
		{ "Line Closed Sign",	3091,	0.5 }
	}
;

/* ** Spike Strips ** */
#define MAX_SPIKESTRIPS          	( 20 )

enum E_SPIKE_STRIP_DATA
{
	E_OBJECT_ID,     	Text3D: E_LABEL,			E_SPHERE
};

new
	g_spikestripData                [ MAX_SPIKESTRIPS ] [ E_SPIKE_STRIP_DATA ],
	Iterator:SpikeStrip< MAX_SPIKESTRIPS >
;

/* ** Gang System ** */
#define MAX_GANGS                   ( MAX_PLAYERS )
#define TURF_TAKEOVER_TIME          ( 60 )
#define TAKEOVER_NEEDED_PEOPLE		( 3 )
#define TURF_PAYOUT 				( 1250 )
#define INVALID_GANG_ID             ( -1 )
#define MAX_COLEADERS				( 3 )

enum E_ZONE_DATA
{
	Float: E_MIN_X,
	Float: E_MIN_Y,
	Float: E_MAX_X,
	Float: E_MAX_Y,
	E_GANG_OWNER,
	E_COLOR
};

enum e_gang_data
{
	E_SQL_ID,
	E_NAME[ 30 ],
	E_LEADER,
	E_COLOR,

	E_BANK,
	E_KILLS,
	E_DEATHS,
	E_SCORE,

	E_COLEADER[ MAX_COLEADERS ],
	bool: E_INVITE_ONLY,
	E_JOIN_MSG[ 96 ]
};

enum E_GANG_LEAVE_REASON
{
	GANG_LEAVE_QUIT,
	GANG_LEAVE_KICK,
	GANG_LEAVE_UNKNOWN
};

new
	g_gangzoneData[ ] [ E_ZONE_DATA ] =
	{
		#if ENABLE_CITY_LV == true
		// Las Venturas
		{ 2071.2890, 1201.171, 2217.773, 1368.16, INVALID_GANG_ID, COLOR_GANGZONE },
		{ 2071.2890, 1646.484, 2129.882, 1719.72, INVALID_GANG_ID, COLOR_GANGZONE },
		{ 1297.8515, 2100.585, 1394.531, 2197.26, INVALID_GANG_ID, COLOR_GANGZONE },
		{ 2293.9453, 2238.281, 2416.992, 2402.34, INVALID_GANG_ID, COLOR_GANGZONE },
		{ 1989.2578, 1508.789, 2012.695, 1573.24, INVALID_GANG_ID, COLOR_GANGZONE },
		{ 1376.9531, 2603.515, 1488.281, 2671.87, INVALID_GANG_ID, COLOR_GANGZONE },
		{ 2433.5937, 1863.281, 2494.140, 1962.89, INVALID_GANG_ID, COLOR_GANGZONE },
		{ 2437.5000, 1261.718, 2517.578, 1306.64, INVALID_GANG_ID, COLOR_GANGZONE },
		{ 1101.5625, 1205.078, 1177.734, 1361.32, INVALID_GANG_ID, COLOR_GANGZONE },
		{ 2798.8281, 1222.656, 2859.375, 1382.81, INVALID_GANG_ID, COLOR_GANGZONE },
		#endif

		#if ENABLE_CITY_LS == true
		{ 2433.593, -1730.468, 2546.875, -1632.812, INVALID_GANG_ID, COLOR_GANGZONE },
		{ 1867.187, -1265.625, 2062.500, -1140.625, INVALID_GANG_ID, COLOR_GANGZONE },
		{ 1066.406, -1570.312, 1183.593, -1414.062, INVALID_GANG_ID, COLOR_GANGZONE },
		{ 148.4375, -1902.343, 355.4687, -1777.343, INVALID_GANG_ID, COLOR_GANGZONE },
		{ 664.0625, -1320.312, 789.0625, -1230.468, INVALID_GANG_ID, COLOR_GANGZONE },
		{ 640.6250, -1582.031, 765.6250, -1421.875, INVALID_GANG_ID, COLOR_GANGZONE },
		{ 2218.750, -1480.468, 2269.531, -1398.437, INVALID_GANG_ID, COLOR_GANGZONE },
		{ 1832.031, -2164.062, 1957.031, -2066.406, INVALID_GANG_ID, COLOR_GANGZONE },
		{ 1941.406, -1746.093, 2074.218, -1531.250, INVALID_GANG_ID, COLOR_GANGZONE },
		{ 1675.781, -2003.906, 1843.750, -1871.093, INVALID_GANG_ID, COLOR_GANGZONE },
		#endif

		// San Fierro
	    { -2510.152, 576.531, -2392.935, 700.782, INVALID_GANG_ID, COLOR_GANGZONE },
	    { -1476.562, 1481.25, -1345.315, 1516.40, INVALID_GANG_ID, COLOR_GANGZONE },
		{ -2074.275, 578.905, -2010.937, 728.906, INVALID_GANG_ID, COLOR_GANGZONE },
		{ -1495.312, 834.375, -1420.312, 1017.18, INVALID_GANG_ID, COLOR_GANGZONE },
		{ -2756.252, 328.125, -2646.093, 431.251, INVALID_GANG_ID, COLOR_GANGZONE },
		{ -2392.965, 75.1234, -2285.156, 236.718, INVALID_GANG_ID, COLOR_GANGZONE },
		{ -1988.281, 859.375, -1906.250, 916.015, INVALID_GANG_ID, COLOR_GANGZONE },
		{ -1988.281, 87.8906, -1931.640, 216.796, INVALID_GANG_ID, COLOR_GANGZONE },
		{ -2528.320, 1529.29, -2285.156, 1584.96, INVALID_GANG_ID, COLOR_GANGZONE },
		{ -1947.265, 1095.70, -1888.671, 1167.96, INVALID_GANG_ID, COLOR_GANGZONE }
	},
	g_gangColors[ ] =
	{
		0x99FF00FF, 0x00CC00FF, 0x009999FF, 0x0033CCFF, 0x330099FF, 0x660099FF, 0xCC0099FF
	},

	g_gangzoneID					[ sizeof( g_gangzoneData ) ],
	g_gangzoneAttacker				[ sizeof( g_gangzoneData ) ] = { INVALID_GANG_ID, ... },
	g_gangzoneAttackCount           [ sizeof( g_gangzoneData ) ],
	g_gangzoneAttackTimeout			[ sizeof( g_gangzoneData ) ],
	Text: g_ZoneOwnerTD             [ sizeof( g_gangzoneData ) ] = { Text: INVALID_TEXT_DRAW, ... },

	g_gangData						[ MAX_GANGS ] [ e_gang_data ],
	p_GangID                        [ MAX_PLAYERS ],

	bool: p_gangInvited           	[ MAX_PLAYERS ] [ MAX_GANGS ],
	p_gangInviteTick                [ MAX_PLAYERS ],

	Iterator:gangs<MAX_GANGS>
;

public OnPlayerLeaveGang( playerid, gangid, reason );
public ZoneTimer( );

/* ** GPS System ** */
enum E_GPS_DATA
{
	bool: E_CREATED,    E_NAME[ 24 ],   Float: E_X,
	Float: E_Y,         Float: E_Z, 	E_CITY
};

new
	g_gpsData						[ 61 ] [ E_GPS_DATA ]
;

/* ** ATM System ** */
enum E_ATM_DATA
{
	bool: E_CREATED, 	E_CHECKPOINT, 		Float: E_HEALTH,
	E_OBJECT,			Text3D: E_LABEL, 	bool: E_DISABLED,
	E_PICKUP,			E_LOOT,				E_TIMESTAMP
};

new
	g_atmData						[ 46 ] [ E_ATM_DATA ]
;

/* ** Invalid Mod Array ** */
stock const
	g_aLegalModifications[ 49 ] [ 22 ] =
	{
	    { 400, 1024, 1021, 1020, 1019, 1018, 1013, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 401, 1145, 1144, 1143, 1142, 1020, 1019, 1017, 1013, 1007, 1006, 1005, 1004, 1003, 1001, 0000, 0000, 0000, 0000 },
	    { 404, 1021, 1020, 1019, 1017, 1016, 1013, 1007, 1002, 1000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 405, 1023, 1021, 1020, 1019, 1018, 1014, 1001, 1000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 410, 1024, 1023, 1021, 1020, 1019, 1017, 1013, 1007, 1003, 1001, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 415, 1023, 1019, 1018, 1017, 1007, 1003, 1001, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 418, 1021, 1020, 1016, 1006, 1002, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 420, 1021, 1019, 1005, 1004, 1003, 1001, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 421, 1023, 1021, 1020, 1019, 1018, 1016, 1014, 1000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 422, 1021, 1020, 1019, 1017, 1013, 1007, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 426, 1021, 1019, 1006, 1005, 1004, 1003, 1001, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 436, 1022, 1021, 1020, 1019, 1017, 1013, 1007, 1006, 1003, 1001, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 439, 1145, 1144, 1143, 1142, 1023, 1017, 1013, 1007, 1003, 1001, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 477, 1021, 1020, 1019, 1018, 1017, 1007, 1006, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 478, 1024, 1022, 1021, 1020, 1013, 1012, 1005, 1004, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 489, 1024, 1020, 1019, 1018, 1016, 1013, 1006, 1005, 1004, 1002, 1000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 491, 1145, 1144, 1143, 1142, 1023, 1021, 1020, 1019, 1018, 1017, 1014, 1007, 1003, 0000, 0000, 0000, 0000, 0000 },
	    { 492, 1016, 1006, 1005, 1004, 1000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 496, 1143, 1142, 1023, 1020, 1019, 1017, 1011, 1007, 1006, 1003, 1002, 1001, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 500, 1024, 1021, 1020, 1019, 1013, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 516, 1021, 1020, 1019, 1018, 1017, 1016, 1015, 1007, 1004, 1002, 1000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 517, 1145, 1144, 1143, 1142, 1023, 1020, 1019, 1018, 1017, 1016, 1007, 1003, 1002, 0000, 0000, 0000, 0000, 0000 },
	    { 518, 1145, 1144, 1143, 1142, 1023, 1020, 1018, 1017, 1013, 1007, 1006, 1005, 1003, 1001, 0000, 0000, 0000, 0000 },
	    { 527, 1021, 1020, 1018, 1017, 1015, 1014, 1007, 1001, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 529, 1023, 1020, 1019, 1018, 1017, 1012, 1011, 1007, 1006, 1003, 1001, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 534, 1185, 1180, 1179, 1178, 1127, 1126, 1125, 1124, 1123, 1122, 1106, 1101, 1100, 0000, 0000, 0000, 0000, 0000 },
	    { 535, 1121, 1120, 1119, 1118, 1117, 1116, 1115, 1114, 1113, 1110, 1109, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 536, 1184, 1183, 1182, 1181, 1128, 1108, 1107, 1105, 1104, 1103, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 540, 1145, 1144, 1143, 1142, 1024, 1023, 1020, 1019, 1018, 1017, 1007, 1006, 1004, 1001, 0000, 0000, 0000, 0000 },
	    { 542, 1145, 1144, 1021, 1020, 1019, 1018, 1015, 1014, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 546, 1145, 1144, 1143, 1142, 1024, 1023, 1019, 1018, 1017, 1007, 1006, 1004, 1002, 1001, 0000, 0000, 0000, 0000 },
	    { 547, 1143, 1142, 1021, 1020, 1019, 1018, 1016, 1003, 1000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 549, 1145, 1144, 1143, 1142, 1023, 1020, 1019, 1018, 1017, 1012, 1011, 1007, 1003, 1001, 0000, 0000, 0000, 0000 },
	    { 550, 1145, 1144, 1143, 1142, 1023, 1020, 1019, 1018, 1006, 1005, 1004, 1003, 1001, 0000, 0000, 0000, 0000, 0000 },
	    { 551, 1023, 1021, 1020, 1019, 1018, 1016, 1006, 1005, 1003, 1002, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 558, 1168, 1167, 1166, 1165, 1164, 1163, 1095, 1094, 1093, 1092, 1091, 1090, 1089, 1088, 0000, 0000, 0000, 0000 },
	    { 559, 1173, 1162, 1161, 1160, 1159, 1158, 1072, 1071, 1070, 1069, 1068, 1067, 1066, 1065, 0000, 0000, 0000, 0000 },
	    { 560, 1170, 1169, 1141, 1140, 1139, 1138, 1033, 1032, 1031, 1030, 1029, 1028, 1027, 1026, 0000, 0000, 0000, 0000 },
	    { 561, 1157, 1156, 1155, 1154, 1064, 1063, 1062, 1061, 1060, 1059, 1058, 1057, 1056, 1055, 1031, 1030, 1027, 1026 },
	    { 562, 1172, 1171, 1149, 1148, 1147, 1146, 1041, 1040, 1039, 1038, 1037, 1036, 1035, 1034, 0000, 0000, 0000, 0000 },
	    { 565, 1153, 1152, 1151, 1150, 1054, 1053, 1052, 1051, 1050, 1049, 1048, 1047, 1046, 1045, 0000, 0000, 0000, 0000 },
	    { 567, 1189, 1188, 1187, 1186, 1133, 1132, 1131, 1130, 1129, 1102, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 575, 1177, 1176, 1175, 1174, 1099, 1044, 1043, 1042, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 576, 1193, 1192, 1191, 1190, 1137, 1136, 1135, 1134, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 580, 1023, 1020, 1018, 1017, 1007, 1006, 1001, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
		{ 585, 1143, 1145, 1020, 1019, 1018, 1013, 1006, 1007, 1001, 1003, 1023, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 589, 1145, 1144, 1024, 1020, 1018, 1017, 1016, 1013, 1007, 1006, 1005, 1004, 1000, 0000, 0000, 0000, 0000, 0000 },
	    { 600, 1022, 1020, 1018, 1017, 1013, 1007, 1006, 1005, 1004, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000 },
	    { 603, 1145, 1144, 1143, 1142, 1024, 1023, 1020, 1019, 1018, 1017, 1007, 1006, 1001, 0000, 0000, 0000, 0000, 0000 }
	}
;

/* ** Fire System ** */
enum E_FIRE_DATA
{
	bool: E_CREATED,	E_OBJECT,		Float: E_HEALTH,
	E_HOUSE,            Text3D: E_LABEL
};

new
	g_fireData                      [ 10 ] [ E_FIRE_DATA ],
	bool: fire_toggled              = false
;

public OnPlayerTakeOutFire			( playerid, fireid );

/* ** Lumberjack ** */
#define MAX_TREES                   ( 16 )
enum E_TREE_DATA
{
	bool: E_CREATED,    E_OBJECT,       Float: E_HEALTH,
	Text3D: E_LABEL,    bool: E_CUT,    bool: E_CHOPPED,
	Float: E_X,         Float: E_Y,     Float: E_Z
};

new
	Float: g_treeExportLocations   	[ ] [ 3 ] =
	{
	    { -520.2759, -504.32880, 24.6917 },
		{ -377.7403, -1438.5587, 25.7266 },
		{ -62.98320, -1122.2581, 1.21400 },
		{ 89.445900, -311.85220, 1.57810 },
		{ 362.28260, 865.053800, 20.4063 },
		{ 2399.5352, 2798.89310, 10.8203 },
		{ -2002.906, -2409.2000, 30.6250 }
	},
	p_treeExportLocation            [ MAX_PLAYERS ] = { 0xFF, ... },
	g_treeData                      [ MAX_TREES ] [ E_TREE_DATA ],
 	g_LogCountObject 				= INVALID_OBJECT_ID
;

/* ** Mining ** */
#define MAX_ROCKS 					( 61 )
#define MAX_ORE_STORAGE				12

#define ORE_BAUXITE					0
#define ORE_IRON					1
#define ORE_COAL					2
#define ORE_GOLD					3
#define ORE_RUBY					4
#define ORE_DIAMOND					5
#define ORE_PLATINUM 				6
#define ORE_EMERALD					7
#define ORE_SAPHHIRE				8
#define ORE_AMETHYST				9

enum E_ROCK_DATA
{
	E_OBJECT,			E_MINING,		Text3D: E_LABEL,
	E_ORES,				E_COLOR,		E_ORE,
	E_MAX_ORES
};

new
	g_miningData					[ MAX_ROCKS ] [ E_ROCK_DATA ],
	p_MiningOre						[ MAX_PLAYERS char ],
	bool: p_isMining				[ MAX_PLAYERS char ],

	g_orePrices                		[ ] = { 675, 900, 600, 2750, 3000, 3500, 4000, 2200, 2300, 1200 },
	g_oreMiningTime					[ ] = { 250, 350, 200, 0850, 0900, 0950, 1000, 0800, 0820, 500 },
	g_oreQuanities					[ ] = { 8, 8, 8, 8, 5, 3, 3, 5, 5, 6 },

	// Iterator
	Iterator:miningrock<MAX_ROCKS>
;

/* ** Weed System ** */
#define MAX_WEED_STORAGE 			6
#define MAX_WEED                    ( 42 )
enum E_WEED_DATA
{
	bool: E_CREATED,    E_OBJECT,       bool: E_CUT,
	Float: E_X,         Float: E_Y,     Float: E_Z
};

new
	g_weedData                      [ MAX_WEED ] [ E_WEED_DATA ]
;

/* ** Enter/Exit System ** */
#define MAX_ENTERS                  ( 300 )
enum E_ENTER_DATA
{
	E_WORLD,					E_INTERIOR, 				bool: E_VIP,
	Float: E_EX,    			Float: E_EY, 				Float: E_EZ,
	Float: E_LX,    			Float: E_LY, 				Float: E_LZ,
	E_ENTER,            		E_EXIT,						bool: E_CUSTOM,
	Text3D:  E_ENTER_LABEL,		Text3D: E_EXIT_LABEL,		bool: E_SAVED,
	E_SQL_ID
};

new
	g_entranceData					[ MAX_ENTERS ] [ E_ENTER_DATA ],

	// Hardcoded
	//g_Ammunation 					= -1,
	g_SupaSave 						= -1,
	//g_Hospital					= -1,
	//g_PoliceDepartment 			= -1,
	g_VIPLounge[ 3 ] 				= { -1, ... },

	// Iterator
	Iterator:entrances<MAX_ENTERS>
;

/* ** Copten Codes ** */
enum E_TEN_CODES
{
	E_CODE[ 6 ], 		E_SUBJECT[ 50 ]
};

new
	g_coptenCodes[ ] [ E_TEN_CODES ] =
	{
		{ "10-10", "Fight in progress" }, 						{ "10-11", "Robbery" },
		{ "10-12", "Stand by" }, 								{ "10-13", "Weather - road report" },
		{ "10-14", "Prowler report" }, 							{ "10-15", "Traffic check" },
		{ "10-16", "Domestic disturbance" }, 					{ "10-17", "Meet complainant" },
		{ "10-18", "Quickly" },									{ "10-19", "Return to" },
		{ "10-20", "Location" }, 								{ "10-21", "By telephone, call" },
		{ "10-22", "Disregard" }, 								{ "10-23", "Arrived at scene" },
		{ "10-24", "Assignment completed" }, 					{ "10-25", "Report in person" },
		{ "10-26", "Detaining subject, expedite" },				{ "10-27", "Drivers license information" },
		{ "10-28", "Vehicle registration information" },		{ "10-29", "Check for wanted" },
		{ "10-30", "Unnecessary use of radio" }, 				{ "10-31", "Crime in progress" },
		{ "10-32", "Man with gun" }, 							{ "10-33", "Emergency" },
		{ "10-34", "Riot" },									{ "10-35", "Major crime alert" },
		{ "10-36", "Correct time" }, 							{ "10-37", "(Investigate) suspicious vehicle" },
		{ "10-38", "Stopping suspicious vehicle" }, 			{ "10-39", "Urgent - use light, siren" },
		{ "10-40", "Silent run - no light, siren" }, 			{ "10-41", "Beginning tour of duty" },
		{ "10-42", "Ending tour of duty" }, 					{ "10-43", "Information" },
		{ "10-44", "Permission to leave for" }, 				{ "10-45", "Kidnapping" },
		{ "10-46", "Assist motorist" }, 						{ "10-47", "Emergency road repairs at" },
		{ "10-48", "Traffic standard repair at" }, 				{ "10-49", "Traffic light out at" },
		{ "10-50", "Accident" }, 								{ "10-51", "Wrecker needed" },
		{ "10-52", "Ambulance needed" }, 						{ "10-53", "Road blocked at" },
		{ "10-54", "Livestock on highway" }, 					{ "10-55", "Suspected DUI" },
		{ "10-56", "Intoxicated pedestrian" }, 					{ "10-57", "Hit and run" },
		{ "10-58", "Direct traffic" }, 							{ "10-59", "Convoy or escort" },
		{ "10-60", "Squad in vicinity" }, 						{ "10-61", "Isolate self for message" },
		{ "10-62", "Reply to message" }, 						{ "10-63", "Prepare to make written copy" },
		{ "10-64", "Message for local delivery" }, 				{ "10-65", "Net message assignment" },
		{ "10-66", "Message cancellation" }, 					{ "10-67", "Clear for net message" },
		{ "10-68", "Dispatch information" }, 					{ "10-69", "Message received" },
		{ "10-70", "Fire" }, 									{ "10-71", "Advise nature of fire" },
		{ "10-72", "Report progress on fire" }, 				{ "10-73", "Smoke report" },
		{ "10-74", "Negative" }, 								{ "10-75", "In contact with" },
		{ "10-76", "Bribe" }, 									{ "10-77", "ETA" },
		{ "10-78", "Need assistance" }, 						{ "10-79", "Notify coroner" },
		{ "10-80", "Chase in progress" }, 						{ "10-81", "Drug Activity" },
		{ "10-82", "Reserve lodging" }, 						{ "10-83", "Suspect Hidden on Radar" },
		{ "10-84", "If meeting, advise ETA" }, 					{ "10-85", "Delayed due to" },
		{ "10-86", "Officer on duty" }, 						{ "10-87", "Pick up/distribute checks" },
		{ "10-88", "Present telephone number of" }, 			{ "10-89", "Bomb threat" },
		{ "10-90", "Bank alarm at" }, 							{ "10-91", "Pick up prisoner/subject" },
		{ "10-92", "Improperly parked vehicle" }, 				{ "10-93", "Blockade" },
		{ "10-94", "Drag racing" }, 							{ "10-95", "Prisoner/subject in custody" },
		{ "10-96", "Mental subject" }, 							{ "10-97", "Check signal" },
		{ "10-98", "Prison/jail break" }, 						{ "10-99", "Wanted/stolen indicated" },
		// Some bug, so I'll do this.
	    { "10-0", "Caution" }, 									{ "10-1", "Unable to copy" },
		{ "10-2", "Signal good" }, 								{ "10-3", "Stop transmitting" },
		{ "10-4", "Acknowledgment" }, 							{ "10-5", "Relay" },
		{ "10-6", "Busy, stand by unless urgent" },				{ "10-7", "Out of service" },
		{ "10-8", "In service" }, 								{ "10-9", "Repeat" }
	}
;

/* ** Toy System ** */
#define MAX_TOYS                ( sizeof( g_ToyData ) )

#define CATEGORY_WATCHES 		( 0 )
#define CATEGORY_BERETS 		( 1 )
#define CATEGORY_HATS 			( 2 )
#define CATEGORY_HEADPHONES 	( 3 )
#define CATEGORY_MASKS 			( 4 )
#define CATEGORY_MOTORCYCLE 	( 5 )
#define CATEGORY_GUITARS		( 6 )
#define CATEGORY_GLASSES 		( 7 )
#define CATEGORY_HANDHELD 		( 8 )
#define CATEGORY_WEAPONS 		( 9 )
#define CATEGORY_MISC 			( 10 )
#define CATEGORY_VIP 			( 11 )

enum E_ATTACHED_DATA
{
	E_ENABLED, 			E_MODELID, 		E_BONE,
	Float: E_OX,		Float: E_OY, 	Float: E_OZ,
	Float: E_RX, 		Float: E_RY, 	Float: E_RZ,
	Float: E_SX, 		Float: E_SY, 	Float: E_SZ,
	E_SQL_ID
};

enum E_TOY_DATA
{
	E_CATEGORY, 		E_ID,			E_NAME[ 24 ],
	E_MODEL, 			E_PRICE,		E_DEFAULT_BONE
};

new
	g_ToyCategory[ ] [ ] =
	{
		{ "Watches" },  { "Berets" }, { "Hats" }, { "Headphones" }, { "Masks" },
		{ "Motorcycle Helmets" }, { "Guitars" }, { "Glasses" }, { "Handheld" },
		{ "Weapons" }, { "Miscellaneous" }, { "V.I.P" }
	},
 	g_ToyData[ ] [ E_TOY_DATA ] =
	{
		// WATCHES
		{ CATEGORY_WATCHES, 0, 	"Rolex Datejust II", 		19039, 220000,	5 },
		{ CATEGORY_WATCHES, 1, 	"Rolex Datejust I", 		19042, 160000,	5 },
		{ CATEGORY_WATCHES, 2, 	"Rolex Explorer", 			19040, 140800,	5 },
		{ CATEGORY_WATCHES, 3, 	"Rolex Sky-Dweller", 	 	19041, 95000,	5 },
		{ CATEGORY_WATCHES, 4, 	"G-Shock Camo", 	 		19053, 25000,	5 },
		{ CATEGORY_WATCHES, 5, 	"G-Shock Navy Camo", 	 	19048, 20000,	5 },
		{ CATEGORY_WATCHES, 6, 	"G-Shock Pink Camo", 	 	19049, 17500,	5 },
		{ CATEGORY_WATCHES, 7, 	"G-Shock Orange Camo", 		19051, 17500,	5 },
		{ CATEGORY_WATCHES, 8, 	"G-Shock Purple", 	 		19047, 10000,	5 },
		{ CATEGORY_WATCHES, 9, 	"G-Shock Pink", 	 		19045, 10000,	5 },
		{ CATEGORY_WATCHES, 10, "Martino Watch", 			19046, 5000,	5 },

		// BERET
		{ CATEGORY_BERETS, 11, 	"Louis Camo", 				18924, 750,		2 },
		{ CATEGORY_BERETS, 12,	"Gucci Black", 				18921, 340,		2 },
		{ CATEGORY_BERETS, 13,	"Gucci Red", 				18922, 340,		2 },
		{ CATEGORY_BERETS, 14,	"Gucci Blue", 				18923, 340,		2 },

		// HATS
		{ CATEGORY_HATS, 126,	"Witch Hat",				19528, 6666,	2 },
		{ CATEGORY_HATS, 93,	"Santa Hat",				19064, 5000,	2 },
		{ CATEGORY_HATS, 93,	"Santa Hat",				19064, 5000,	2 },
		{ CATEGORY_HATS, 15,	"Chicago Hoodie", 			19067, 1300, 	2 },
		{ CATEGORY_HATS, 16,	"Snake Skin Hat", 			18973, 1000, 	2 },
		{ CATEGORY_HATS, 17,	"Tiger Print Hat", 			18970, 1000, 	2 },
		{ CATEGORY_HATS, 18,	"Skulled Hoodie", 			19069, 1000, 	2 },
		{ CATEGORY_HATS, 19,	"Boxing Helmet", 			18952, 900, 	2 },
		{ CATEGORY_HATS, 20,	"Knit Cap Grey", 			18954, 800, 	2 },
		{ CATEGORY_HATS, 21,	"Knit Cap Black", 			18953, 800, 	2 },
		{ CATEGORY_HATS, 22,	"Dukes Hat", 				18972, 800, 	2 },
		{ CATEGORY_HATS, 23,	"Cowboy Hat", 				18962, 800, 	2 },
		{ CATEGORY_HATS, 24,	"Trucker Cap", 				18961, 700, 	2 },
		{ CATEGORY_HATS, 25,	"Black Bowler", 			18944, 500, 	2 },
		{ CATEGORY_HATS, 26,	"White Bowler", 			19488, 500, 	2 },
		{ CATEGORY_HATS, 27,	"Blue Bowler", 				18945, 500, 	2 },
		{ CATEGORY_HATS, 28,	"Green Bowler", 			18946, 500, 	2 },
		{ CATEGORY_HATS, 29,	"Red Bowler", 				18950, 500, 	2 },
		{ CATEGORY_HATS, 30,	"Yellow Bowler", 			18951, 500, 	2 },
		{ CATEGORY_HATS, 31,	"Skater Cap", 				18968, 500, 	2 },
		{ CATEGORY_HATS, 32,	"Fishing Cap", 				18969, 500, 	2 },
		{ CATEGORY_HATS, 33,	"Black Top Hat", 			19352, 500, 	2 },
		{ CATEGORY_HATS, 34,	"White Top Hat", 			19487, 500, 	2 },
		{ CATEGORY_HATS, 35,	"Fireman Helmet", 			19330, 400, 	2 },
		{ CATEGORY_HATS, 36,	"Sheriff Hat", 				19099, 300, 	2 },
		{ CATEGORY_HATS, 37,	"Camo Cap", 				18926, 240, 	2 },
		{ CATEGORY_HATS, 38,	"Chicken Hat",				19137, 240,		2 },
		{ CATEGORY_HATS, 39,	"BurgerShot Hat", 			19094, 240, 	2 },
		{ CATEGORY_HATS, 40,	"Police Cap", 				18636, 240, 	2 },
		{ CATEGORY_HATS, 41,	"Gas Mask",					19472, 240,		2 },

		// HEADPHONES
		{ CATEGORY_HEADPHONES, 41,	"White Beats", 			19421, 550, 	2 },
		{ CATEGORY_HEADPHONES, 42,	"Black Beats", 			19422, 550, 	2 },
		{ CATEGORY_HEADPHONES, 43,	"Red Beats", 			19423, 550, 	2 },
		{ CATEGORY_HEADPHONES, 44,	"Blue Beats", 			19424, 550, 	2 },

		// MASKS
		{ CATEGORY_MASKS, 96, 	"Gucci Balaclava",			19801, 	10000,	2 },
		{ CATEGORY_MASKS, 45,	"Louis Mask Bright",		18916, 	6000,	2 },
		{ CATEGORY_MASKS, 46,	"Louis Mask Dark ", 		18920, 	5200,	2 },
		{ CATEGORY_MASKS, 47,	"Versace Mask",				18915, 	4500,	2 },
		{ CATEGORY_MASKS, 48,	"Gimp Mask",				19163, 	300,	2 },
		{ CATEGORY_MASKS, 49,	"Hockey Mask White",		19036, 	250,	2 },
		{ CATEGORY_MASKS, 50,	"Hockey Mask Red",			19037, 	250,	2 },
		{ CATEGORY_MASKS, 51,	"Hockey Mask Green",		19038, 	250,	2 },
		{ CATEGORY_MASKS, 52,	"Camo Mask",				18914, 	220,	2 },
		{ CATEGORY_MASKS, 53,	"Grove Mask",				18913, 	200,	2 },
		{ CATEGORY_MASKS, 54,	"Zorro Mask",				18974, 	100,	2 },

		// MOTORCYCLE HELMETS
		{ CATEGORY_MOTORCYCLE, 87, "Fire Flame Helmet",		18645, 	1000,	2 },
		{ CATEGORY_MOTORCYCLE, 88, "Blue Helmet",			18976, 	800,	2 },
		{ CATEGORY_MOTORCYCLE, 89, "Red Helmet",			18977, 	700,	2 },
		{ CATEGORY_MOTORCYCLE, 90, "White Helmet",			18978, 	700,	2 },
		{ CATEGORY_MOTORCYCLE, 91, "Pink Helmet",			18979, 	500,	2 },

		// GUITARS
		{ CATEGORY_GUITARS, 55,	"Warlock Guitar",			19319, 	1250,	1 },
		{ CATEGORY_GUITARS, 56,	"Flying Guitar",			19318, 	800,	1 },
		{ CATEGORY_GUITARS, 57,	"Bass Guitar",				19317, 	400,	1 },

		// GLASSES
		{ CATEGORY_GLASSES, 58,	"Oakley Ferrari", 			19006, 900, 	2 },
		{ CATEGORY_GLASSES, 59,	"Armani Aviator Classic", 	19022, 840, 	2 },
		{ CATEGORY_GLASSES, 61,	"Armani Aviator Blue" , 	19023, 840, 	2 },
		{ CATEGORY_GLASSES, 62,	"Armani Aviator Purple", 	19024, 840, 	2 },
		{ CATEGORY_GLASSES, 63,	"Armani Aviator Pink", 		19025, 840, 	2 },
		{ CATEGORY_GLASSES, 64,	"Armani Aviator Orange", 	19027, 840, 	2 },
		{ CATEGORY_GLASSES, 65,	"Armani Aviator Yellow", 	19028, 840, 	2 },
		{ CATEGORY_GLASSES, 65,	"Armani Aviator Green", 	19029, 840, 	2 },
		{ CATEGORY_GLASSES, 66,	"Gucci Techno Yellow" , 	19017, 650, 	2 },
		{ CATEGORY_GLASSES, 67,	"Gucci Techno Salmon" , 	19018, 650, 	2 },
		{ CATEGORY_GLASSES, 68,	"Gucci Techno Red" , 		19019, 650, 	2 },
		{ CATEGORY_GLASSES, 69,	"Gucci Techno Blue" , 		19020, 650, 	2 },
		{ CATEGORY_GLASSES, 70,	"Gucci Techno Green" , 		19021, 650, 	2 },
		{ CATEGORY_GLASSES, 71,	"Versace Vintage", 			19033, 520, 	2 },
		{ CATEGORY_GLASSES, 72,	"Versace Havana Wrap", 		19030, 490, 	2 },
		{ CATEGORY_GLASSES, 73,	"Oakley Whisker", 			19008, 400, 	2 },
		{ CATEGORY_GLASSES, 74,	"Oakley Wiretap", 			19009, 400, 	2 },
		{ CATEGORY_GLASSES, 75,	"Versace Brown Square", 	19031, 360, 	2 },
		{ CATEGORY_GLASSES, 76,	"Versace Marble Square", 	19035, 380, 	2 },
		{ CATEGORY_GLASSES, 77,	"Oakley Valve", 			19010, 300, 	2 },
		{ CATEGORY_GLASSES, 78,	"Oakley Crankshaft", 		19007, 260, 	2 },

		// HANDHELD
		{ CATEGORY_HANDHELD, 100, "Antique Sword", 			19590, 	15000, 	6 },
		{ CATEGORY_HANDHELD, 101, "Microphone", 			19610, 	900, 	6 },
		{ CATEGORY_HANDHELD, 102, "Police Radio", 			19942, 	750, 	6 },
		{ CATEGORY_HANDHELD, 103, "Left Boxing Glove", 		19555, 	250, 	6 },
		{ CATEGORY_HANDHELD, 104, "Right Boxing Glove", 	19556, 	250, 	5 },
		{ CATEGORY_HANDHELD, 105, "Briefcase", 				19624, 	100, 	6 },

		// WEAPONS
		{ CATEGORY_WEAPONS, 125, "RPG", 					359, 13337, 1 },
		{ CATEGORY_WEAPONS, 124, "Heatseeker", 				360, 13337, 1 },
		{ CATEGORY_WEAPONS, 123, "Minigun", 				362, 13337, 1 },
		{ CATEGORY_WEAPONS, 121, "Spas 12", 				351, 9000, 1 },
		{ CATEGORY_WEAPONS, 122, "M4", 						356, 9000, 1 },
		{ CATEGORY_WEAPONS, 119, "Sawn-off Shotgun", 		350, 8000, 1 },
		{ CATEGORY_WEAPONS, 120, "Sniper", 					358, 8000, 1 },
		{ CATEGORY_WEAPONS, 118, "Shotgun", 				349, 6000, 1 },
		{ CATEGORY_WEAPONS, 117, "Desert Eagle", 			348, 5000, 1 },
		{ CATEGORY_WEAPONS, 116, "Rifle", 					357, 3000, 1 },
		{ CATEGORY_WEAPONS, 115, "Tec 9", 					372, 2900, 1 },
		{ CATEGORY_WEAPONS, 114, "Mac 10", 					352, 2500, 1 },
		{ CATEGORY_WEAPONS, 109, "Purple Dildo", 			321, 690, 1 },
		{ CATEGORY_WEAPONS, 108, "Parachute", 				371, 600, 1 },
		{ CATEGORY_WEAPONS,	107, "Pool Cue",				338, 400, 1 },
		{ CATEGORY_WEAPONS, 106, "Brass Knuckles", 			331, 250, 1 },

		// MISC
		{ CATEGORY_MISC, 99, "Gold Bar", 					19941, 	38000,	1 },
		{ CATEGORY_MISC, 128, "Cowboy Boots",				11735, 	3000,	1 }, // LATEST
		{ CATEGORY_MISC, 127, "Pistol Holster",				19773, 	1000,	1 },
		{ CATEGORY_MISC, 79, "Police Light",   				19419, 	600,	1 },
		{ CATEGORY_MISC, 94, "Xmas Box 1",					19054,  500,	1 },
		{ CATEGORY_MISC, 95, "Xmas Box 2",					19056,  500,	1 },
		{ CATEGORY_MISC, 80, "Surf Board",					2406,  	250,	1 },
		{ CATEGORY_MISC, 97, "Skateboard",					19878, 	200, 	1 },
		{ CATEGORY_MISC, 81, "Glider",         				2512, 	150,	1 },
		{ CATEGORY_MISC, 82, "Plane",          				2510, 	120,	1 },
		{ CATEGORY_MISC, 98, "Hiker Backpack", 				19559, 	100, 	1 },
		{ CATEGORY_MISC, 83, "Rubbish Bin",   				1343, 	80,		1 },
		{ CATEGORY_MISC, 84, "Chainsaw Dildo",				19086, 	69,		5 },
		{ CATEGORY_MISC, 85, "Easter Egg",					19344, 	50,		2 },
		{ CATEGORY_MISC, 86, "Hippobin",					1371, 	50,		1 },
		{ CATEGORY_MISC, 92, "Pumpkin",						19320, 	10,		1 },

		// VIP
		{ CATEGORY_VIP, -1,	"Small Fire",     				18688,	0,		1 },
		{ CATEGORY_VIP, -1,	"Dynamite",      				1654,	0,		6 },
		{ CATEGORY_VIP, -1,	"Caution Barrel", 				1218,	0,		1 },
		{ CATEGORY_VIP, -1,	"Gas Tank",    					918,	0,		1 },
		{ CATEGORY_VIP, -1,	"Parrot",         				19079, 	0,	   15 },
		{ CATEGORY_VIP, -1,	"Money Stack", 					1212, 	0,		6 },
		{ CATEGORY_VIP, -1,	"Turtle", 						1609, 	0,		1 },
		{ CATEGORY_VIP, -1,	"S.W.A.T Helmet", 				19141, 	0,		2 },
		{ CATEGORY_VIP, -1,	"S.W.A.T Armour", 				19142, 	0,		1 },
		{ CATEGORY_VIP, -1, "Construction Vest",			19904, 	0,		1 },
		{ CATEGORY_VIP, -1, "Sledge Hammer", 				19631, 	0,		5 },
		{ CATEGORY_VIP, -1,	"Better Santa Hat",     		19065,	0,		2 }
	},
	p_AttachedObjectsData     	[ MAX_PLAYERS ] [ 3 ] [ E_ATTACHED_DATA ],
	p_ToySlotSelected			[ MAX_PLAYERS char ],
	p_ToyCategorySelected 		[ MAX_PLAYERS char ],
	p_ToyIDSelected 			[ MAX_PLAYERS char ],
	bool: p_ToyUnlocked     	[ MAX_PLAYERS ] [ MAX_TOYS char ]
;

/* ** C4 Data ** */
#define MAX_C4                      ( 10 )
enum E_C4_DATA
{
	bool: E_SET,		E_OBJECT, 		E_VEHICLE,
	Text3D: E_LABEL, 	E_WORLD, 		E_INTERIOR
};

new
	g_C4Data						[ MAX_PLAYERS ] [ MAX_C4 ] [ E_C4_DATA ],
   	p_C4Amount          			[ MAX_PLAYERS ]
;

/* ** Dynamic Vehicle Purchasing ** */
#define BV_TYPE_AIRPLANES			( 1 )
#define BV_TYPE_HELICOPTERS			( 2 )
#define BV_TYPE_BIKES				( 3 )
#define BV_TYPE_CONVERTIBLES		( 4 )
#define BV_TYPE_INDUSTRIAL 			( 5 )
#define BV_TYPE_LOWRIDERS			( 6 )
#define BV_TYPE_OFF_ROAD 			( 7 )
#define BV_TYPE_PUBLIC_SERVICE		( 8 )
#define BV_TYPE_SALOONS 			( 9 )
#define BV_TYPE_SPORTS				( 10 )
#define BV_TYPE_STATION_WAGONS		( 11 )
#define BV_TYPE_BOATS				( 12 )
#define BV_TYPE_UNIQUE				( 13 )

enum E_BV_DATA
{
	E_TYPE, 	E_MODEL, 	E_VIP, E_PRICE,	E_NAME[ 18 ]
};

new
	g_BVCategories[ ] [ 16 ] =
	{
		{ "Airplanes" },		{ "Helicopters" },		{ "Bikes" },
		{ "Convertibles" },		{ "Industrial" },		{ "Lowriders" },
		{ "Off Road" },			{ "Public Service" },	{ "Saloons" },
		{ "Sport Vehicles" },	{ "Station Wagons" },	{ "Boats" },
		{ "Unique Vehicles" }
	},
	g_BuyableVehicleData[ ] [ E_BV_DATA ] =
	{
		// Airplanes
		{ BV_TYPE_AIRPLANES, 		577, 0, 35000000, 	"AT400" },
		{ BV_TYPE_AIRPLANES, 		592, 0, 17500000, 	"Andromada" },
		{ BV_TYPE_AIRPLANES, 		519, 0, 10000000, 	"Shamal" },
		{ BV_TYPE_AIRPLANES, 		513, 0, 4500000, 	"Stuntplane" },
		{ BV_TYPE_AIRPLANES, 		511, 0, 3300000, 	"Beagle" },
		{ BV_TYPE_AIRPLANES, 		553, 1, 3300000, 	"Nevada" },
		{ BV_TYPE_AIRPLANES, 		593, 0, 3000000, 	"Dodo" },
		{ BV_TYPE_AIRPLANES, 		476, 1, 3000000, 	"Rustler" },
		{ BV_TYPE_AIRPLANES, 		460, 1, 2700000, 	"Skimmer" },
		{ BV_TYPE_AIRPLANES, 		512, 0, 2200000, 	"Cropduster" },

		// Helicopters
		{ BV_TYPE_HELICOPTERS, 		487, 0, 7500000, 	"Maverick" },
		{ BV_TYPE_HELICOPTERS, 		417, 0, 6000000, 	"Leviathan" },
		{ BV_TYPE_HELICOPTERS, 		497, 1, 5000000, 	"Police Maverick" },
		{ BV_TYPE_HELICOPTERS, 		488, 1, 3250000, 	"SAN News Maverick" },
		{ BV_TYPE_HELICOPTERS, 		563, 0, 3000000, 	"Raindance" },
		{ BV_TYPE_HELICOPTERS, 		469, 1, 3000000, 	"Sparrow" },
		{ BV_TYPE_HELICOPTERS, 		548, 1, 2700000, 	"Cargobob" },

		// Bikes
		{ BV_TYPE_BIKES, 			522, 0, 2500000, 	"NRG-500" },
		{ BV_TYPE_BIKES, 			510, 0, 2000000, 	"Mountain Bike" },
		{ BV_TYPE_BIKES, 			521, 0, 1500000, 	"FCR-900" },
		{ BV_TYPE_BIKES, 			481, 0, 1500000, 	"BMX" },
		{ BV_TYPE_BIKES,			461, 0, 1000000, 	"PCJ-600" },
		{ BV_TYPE_BIKES, 			509, 0, 800000, 	"Bike" },
		{ BV_TYPE_BIKES, 			581, 0, 750000, 	"BF-400" },
		{ BV_TYPE_BIKES, 			468, 0, 750000, 	"Sanchez" },
		{ BV_TYPE_BIKES, 			471, 0, 500000, 	"Quad" },
		{ BV_TYPE_BIKES, 			463, 0, 550000, 	"Freeway" },
		{ BV_TYPE_BIKES, 			586, 0, 400000, 	"Wayfarer" },
		{ BV_TYPE_BIKES, 			462, 0, 375000, 	"Faggio" },
		{ BV_TYPE_BIKES, 			448, 1, 50000, 		"Pizzaboy" },

		// Convertiblies
		{ BV_TYPE_CONVERTIBLES, 	480, 0, 1700000, 	"Comet" },
		{ BV_TYPE_CONVERTIBLES, 	439, 0, 750000, 	"Stallion" },
		{ BV_TYPE_CONVERTIBLES, 	533, 0, 650000, 	"Feltzer" },
		{ BV_TYPE_CONVERTIBLES, 	555, 0, 620000, 	"Windsor" },

		// Industrial
		{ BV_TYPE_INDUSTRIAL, 		498, 1, 2000000, 	"Boxville" },
		{ BV_TYPE_INDUSTRIAL, 		578, 1, 1250000, 	"DFT-30" },
		{ BV_TYPE_INDUSTRIAL, 		408, 1, 1000000, 	"Trashmaster" },
		{ BV_TYPE_INDUSTRIAL, 		554, 0, 500000, 	"Yosemite" },
		{ BV_TYPE_INDUSTRIAL, 		482, 0, 500000, 	"Burrito" },
		{ BV_TYPE_INDUSTRIAL, 		600, 0, 375000, 	"Picador" },
		{ BV_TYPE_INDUSTRIAL, 		552, 1, 300000, 	"Utility Van" },
		{ BV_TYPE_INDUSTRIAL, 		413, 0, 300000, 	"Pony" },
		{ BV_TYPE_INDUSTRIAL, 		582, 1, 250000, 	"Newsvan" },
		{ BV_TYPE_INDUSTRIAL, 		440, 0, 250000, 	"Rumpo" },
		{ BV_TYPE_INDUSTRIAL, 		422, 0, 220000, 	"Bobcat" },
		{ BV_TYPE_INDUSTRIAL, 		531, 0, 180000, 	"Tractor" },
		{ BV_TYPE_INDUSTRIAL,		414, 0, 180000, 	"Mule" },
		{ BV_TYPE_INDUSTRIAL, 		543, 0, 130000, 	"Sadler" },
		{ BV_TYPE_INDUSTRIAL,		478, 0, 100000, 	"Walton" },
		{ BV_TYPE_INDUSTRIAL, 		499, 0, 80000, 		"Benson" },
		{ BV_TYPE_INDUSTRIAL, 		456, 0, 60000, 		"Yankee" },

		// Lowriders
		{ BV_TYPE_LOWRIDERS, 		535, 0, 1500000, 	"Slamvan" },
		{ BV_TYPE_LOWRIDERS, 		567, 0, 1250000, 	"Savanna" },
		{ BV_TYPE_LOWRIDERS, 		536, 0, 800000, 	"Blade" },
		{ BV_TYPE_LOWRIDERS, 		412, 0, 800000, 	"Voodoo" },
		{ BV_TYPE_LOWRIDERS, 		575, 0, 750000, 	"Broadway" },
		{ BV_TYPE_LOWRIDERS, 		576, 0, 600000, 	"Tornado" },
		{ BV_TYPE_LOWRIDERS, 		534, 0, 430000, 	"Remington" },
		{ BV_TYPE_LOWRIDERS, 		566, 0, 300000, 	"Tahoma" },

		// Off road
		{ BV_TYPE_OFF_ROAD, 		444, 1, 3000000, 	"Monster" },
		{ BV_TYPE_OFF_ROAD, 		556, 1, 2500000, 	"Monster A" },
		{ BV_TYPE_OFF_ROAD, 		557, 1, 2500000, 	"Monster B" },
		{ BV_TYPE_OFF_ROAD, 		573, 1, 1800000, 	"Dune" },
		{ BV_TYPE_OFF_ROAD, 		579, 0, 1750000, 	"Huntley" },
		{ BV_TYPE_OFF_ROAD, 		470, 1, 1500000, 	"Patriot" },
		{ BV_TYPE_OFF_ROAD, 		495, 0, 1500000, 	"Sandking" },
		{ BV_TYPE_OFF_ROAD,			489, 0, 850000, 	"Rancher" },
		{ BV_TYPE_OFF_ROAD, 		400, 0, 710000, 	"Landstalker" },
		{ BV_TYPE_OFF_ROAD, 		568, 1, 650000, 	"Bandito" },
		{ BV_TYPE_OFF_ROAD, 		500, 0, 500000, 	"Mesa" },
		{ BV_TYPE_OFF_ROAD, 		424, 0, 450000, 	"BF Injection" },

		// Public Service
		{ BV_TYPE_PUBLIC_SERVICE,	601, 1, 3000000, 	"S.W.A.T." },
		{ BV_TYPE_PUBLIC_SERVICE, 	596, 1, 2500000, 	"Police Car (LSPD)" },
		{ BV_TYPE_PUBLIC_SERVICE, 	597, 1, 2500000, 	"Police Car (SFPD)" },
		{ BV_TYPE_PUBLIC_SERVICE, 	598, 1, 2500000, 	"Police Car (LVPD)" },
		{ BV_TYPE_PUBLIC_SERVICE, 	416, 1, 2500000, 	"Ambulance" },
		{ BV_TYPE_PUBLIC_SERVICE, 	407, 1, 2500000, 	"Firetruck"},
		{ BV_TYPE_PUBLIC_SERVICE, 	544, 1, 2500000, 	"Firetruck LA" },
		{ BV_TYPE_PUBLIC_SERVICE, 	437, 1, 2000000, 	"Coach" },
		{ BV_TYPE_PUBLIC_SERVICE, 	427, 1, 2000000, 	"Enforcer" },
		{ BV_TYPE_PUBLIC_SERVICE, 	599, 1, 1800000, 	"Police Ranger" },
		{ BV_TYPE_PUBLIC_SERVICE, 	438, 1, 1700000,	"Cabbie" },
		{ BV_TYPE_PUBLIC_SERVICE,	431, 1, 1600000,	"Bus" },
		{ BV_TYPE_PUBLIC_SERVICE,	528, 1, 1300000, 	"FBI Truck" },
		{ BV_TYPE_PUBLIC_SERVICE, 	523, 1, 1100000, 	"HPV1000" },
		{ BV_TYPE_PUBLIC_SERVICE, 	420, 1, 1000000, 	"Taxi" },
		{ BV_TYPE_PUBLIC_SERVICE, 	490, 1, 950000, 	"FBI Rancher" },

		// Saloons
		{ BV_TYPE_SALOONS, 			580, 0, 5000000, 	"Stafford" },
		{ BV_TYPE_SALOONS, 			560, 0, 2500000, 	"Sultan" },
		{ BV_TYPE_SALOONS, 			562, 0, 1800000, 	"Elegy" },
		{ BV_TYPE_SALOONS, 			421, 0, 1750000,	"Washington" },
		{ BV_TYPE_SALOONS, 			426, 0, 1500000, 	"Premier" },
		{ BV_TYPE_SALOONS, 			492, 0, 875000, 	"Greenwood" },
		{ BV_TYPE_SALOONS, 			558, 0, 750000, 	"Uranus" },
		{ BV_TYPE_SALOONS, 			504, 1, 750000, 	"Bloodring Banger" },
		{ BV_TYPE_SALOONS, 			405, 0, 725000, 	"Sentinel" },
		{ BV_TYPE_SALOONS, 			474, 0, 650000, 	"Hermes" },
		{ BV_TYPE_SALOONS, 			507, 0, 650000, 	"Elegant" },
		{ BV_TYPE_SALOONS, 			466, 0, 560000, 	"Glendale" },
		{ BV_TYPE_SALOONS, 			517, 0, 500000, 	"Majestic" },
		{ BV_TYPE_SALOONS, 			467, 0, 480000, 	"Oceanic" },
		{ BV_TYPE_SALOONS, 			585, 0, 480000, 	"Emperor" },
		{ BV_TYPE_SALOONS, 			516, 0, 475000, 	"Nebula" },
		{ BV_TYPE_SALOONS,			419, 0, 425000, 	"Esperanto" },
		{ BV_TYPE_SALOONS, 			550, 0, 420000, 	"Sunrise" },
		{ BV_TYPE_SALOONS, 			518, 0, 400000, 	"Buccaneer" },
		{ BV_TYPE_SALOONS, 			491, 0, 350000, 	"Virgo" },
		{ BV_TYPE_SALOONS, 			549, 0, 310000, 	"Tampa" },
		{ BV_TYPE_SALOONS, 			445, 0, 300000,		"Admiral" },
		{ BV_TYPE_SALOONS, 			401, 0, 250000, 	"Bravura" },
		{ BV_TYPE_SALOONS, 			551, 0, 230000, 	"Merit" },
		{ BV_TYPE_SALOONS, 			529, 0, 210000, 	"Willard" },
		{ BV_TYPE_SALOONS, 			542, 0, 200000, 	"Clover" },
		{ BV_TYPE_SALOONS, 			540, 0, 200000, 	"Vincent" },
		{ BV_TYPE_SALOONS, 			546, 0, 190000, 	"Intruder" },
		{ BV_TYPE_SALOONS, 			547, 0, 160000, 	"Primo" },
		{ BV_TYPE_SALOONS, 			526, 0, 160000, 	"Fortune" },
		{ BV_TYPE_SALOONS, 			410, 0, 150000, 	"Manana" },
		{ BV_TYPE_SALOONS, 			436, 0, 100000, 	"Previon" },
		{ BV_TYPE_SALOONS, 			527, 0, 75000, 		"Cadrona" },

		// Sports
		{ BV_TYPE_SPORTS, 			411, 0, 5000000, 	"Infernus" },
		{ BV_TYPE_SPORTS, 			451, 0, 4000000, 	"Turismo" },
		{ BV_TYPE_SPORTS, 			541, 0, 3250000, 	"Bullet" },
		{ BV_TYPE_SPORTS, 			415, 0, 2600000, 	"Cheetah" },
		{ BV_TYPE_SPORTS, 			494, 1, 2500000, 	"Hotring Racer A" },
		{ BV_TYPE_SPORTS, 			502, 1, 2500000, 	"Hotring Racer B" },
		{ BV_TYPE_SPORTS, 			503, 1, 2500000, 	"Hotring Racer C" },
		{ BV_TYPE_SPORTS, 			402, 0, 2250000, 	"Buffalo" },
		{ BV_TYPE_SPORTS, 			429, 0, 1750000, 	"Banshee" },
		{ BV_TYPE_SPORTS, 			565, 0, 1250000, 	"Flash" },
		{ BV_TYPE_SPORTS, 			477, 0, 1100000, 	"ZR-350" },
		{ BV_TYPE_SPORTS, 			506, 0, 1000000,	"Super GT" },
		{ BV_TYPE_SPORTS, 			559, 0, 1000000, 	"Jester" },
		{ BV_TYPE_SPORTS, 			602, 0, 1000000, 	"Alpha" },
		{ BV_TYPE_SPORTS, 			587, 0, 750000, 	"Euros" },
		{ BV_TYPE_SPORTS, 			475, 0, 675000, 	"Sabre" },
		{ BV_TYPE_SPORTS, 			603, 0, 630000, 	"Phoenix" },
		{ BV_TYPE_SPORTS, 			589, 0, 625000, 	"Club" },
		{ BV_TYPE_SPORTS, 			496, 0, 325000, 	"Blista Compact" },

		// Station Wagons
		{ BV_TYPE_STATION_WAGONS, 	479, 0, 610000, 	"Regina" },
		{ BV_TYPE_STATION_WAGONS, 	458, 0, 600000,		"Solair" },
		{ BV_TYPE_STATION_WAGONS, 	561, 0, 400000, 	"Stratum" },
		{ BV_TYPE_STATION_WAGONS, 	404, 0, 300000, 	"Perenniel" },
		{ BV_TYPE_STATION_WAGONS, 	418, 0, 320000, 	"Moonbeam" },

		// Boats
		{ BV_TYPE_BOATS, 			484, 0, 5000000, 	"Marquis" },
		{ BV_TYPE_BOATS, 			493, 0, 3500000, 	"Jetmax" },
		{ BV_TYPE_BOATS, 			430, 1, 3500000, 	"Predator" },
		{ BV_TYPE_BOATS, 			446, 0, 2500000, 	"Squallo" },
		{ BV_TYPE_BOATS, 			454, 0, 1750000, 	"Tropic" },
		{ BV_TYPE_BOATS, 			595, 1, 1600000, 	"Launch" },
		{ BV_TYPE_BOATS, 			452, 0, 1000000, 	"Speeder" },
		{ BV_TYPE_BOATS, 			472, 1, 900000, 	"Coastguard" },
		{ BV_TYPE_BOATS, 			473, 0, 600000, 	"Dinghy" },
		{ BV_TYPE_BOATS, 			453, 0, 250000, 	"Reefer" },

		// Unique
		{ BV_TYPE_UNIQUE, 			406, 1, 2900000, 	"Dumper" },
		{ BV_TYPE_UNIQUE,			532, 1, 2500000, 	"Combine Harvester" },
		{ BV_TYPE_UNIQUE, 			409, 0, 2000000, 	"Stretch" },
		{ BV_TYPE_UNIQUE, 			539, 1, 2000000, 	"Vortex" },
		{ BV_TYPE_UNIQUE, 			508, 1, 2000000, 	"Journey" },
		{ BV_TYPE_UNIQUE, 			443, 1, 1300000, 	"Packer" },
		{ BV_TYPE_UNIQUE, 			423, 1, 850000, 	"Mr Whoopee" },
		{ BV_TYPE_UNIQUE, 			588, 1, 850000, 	"Hotdog" },
		{ BV_TYPE_UNIQUE, 			428, 1, 800000, 	"Securicar" },
		{ BV_TYPE_UNIQUE, 			434, 0, 780000, 	"Hotknife" },
		{ BV_TYPE_UNIQUE, 			483, 0, 770000, 	"Camper" },
		{ BV_TYPE_UNIQUE, 			525, 1, 500000, 	"Towtruck" },
		{ BV_TYPE_UNIQUE, 			545, 0, 500000, 	"Hustler" },
		{ BV_TYPE_UNIQUE, 			457, 1, 325000, 	"Caddy" },
		{ BV_TYPE_UNIQUE, 			486, 1, 200000, 	"Dozer" },
		{ BV_TYPE_UNIQUE, 			571, 1, 150000, 	"Kart" },
		{ BV_TYPE_UNIQUE, 			442, 0, 140000, 	"Romero" },
		{ BV_TYPE_UNIQUE, 			572, 1, 100000, 	"Mower" }
	}
;

/* ** Dynamic Ammunation ** */
#define MENU_ASSAULT      			( 0 )
#define MENU_MELEE					( 1 )
#define MENU_SUB_SMGS				( 2 )
#define MENU_PISTOLS				( 3 )
#define MENU_RIFLES					( 4 )
#define MENU_SHOTGUNS				( 5 )
#define MENU_THROWN					( 6 )

enum E_WEAPONS_DATA
{
	E_MENU, 				E_NAME[ 32 ],           E_WEPID,
	E_AMMO,					E_PRICE
};

new
	g_AmmunitionCategory[ ] [ ] =
	{
		{ "Assault" },  { "Melee" }, { "Submachine Guns" }, { "Pistols" },
		{ "Rifles" }, { "Shotguns" }, { "Thrown" }
	},
	g_AmmunationWeapons[ ][ E_WEAPONS_DATA ] =
	{
		{ MENU_MELEE,		"Flowers", 			14,		1, 		75 },
		{ MENU_MELEE,		"Shovel", 			6,		1, 		100 },
		{ MENU_MELEE,		"Pool Cue", 		7,		1, 		125 },
		{ MENU_MELEE,		"Golf Club", 		2,		1, 		125 },
		{ MENU_MELEE,		"Baseball Bat", 	5,		1, 		180 },
		{ MENU_MELEE, 		"Brass Knuckles", 	1,		1, 		200 },
		{ MENU_MELEE,		"Parachute", 		46,		1, 		200 },
		{ MENU_MELEE, 		"Camera",			43, 	1,		250 },
		{ MENU_MELEE,		"Knife", 			4,		1, 		300 },
		{ MENU_MELEE,		"Katana", 			8,		1, 		600 },
		{ MENU_MELEE,		"Chainsaw", 		9,		1, 		750 },

		{ MENU_PISTOLS,		"9mm Pistol", 		22,		180, 	200 },
		{ MENU_PISTOLS,		"Silenced 9mm", 	23,		180, 	400 },
		{ MENU_PISTOLS,		"Desert Eagle", 	24,		100, 	1250 },

		{ MENU_SHOTGUNS,	"Shotgun", 			25,		75, 	600  },
		{ MENU_SHOTGUNS,	"Sawn-off Shotgun",	26,		100,	1200 },
		{ MENU_SHOTGUNS,	"Combat Shotgun", 	27,		100,	1800 },

		{ MENU_SUB_SMGS,	"MP5", 				29,		100,	500  },
		{ MENU_SUB_SMGS,	"Tec 9", 			32,		100,	600  },
		{ MENU_SUB_SMGS,	"Mac 10", 			28,		100,	700 },

		{ MENU_ASSAULT,		"AK47", 			30,		100,	800  },
		{ MENU_ASSAULT,		"M4", 				31,		100,	1000 },

		{ MENU_RIFLES,		"Rifle", 			33,		100, 	300  },
		{ MENU_RIFLES,		"Sniper", 			34,		75, 	1000 },

		{ MENU_THROWN, 		"Teargas",			17,		5,		500 },
		{ MENU_THROWN, 		"Grenade",			16,		1,		1200 },
		{ MENU_THROWN, 		"Molotov Cocktail",	18,		4,		1400 }
	},
 	p_AmmunationMenu               [ MAX_PLAYERS char ]
;

/* ** Apartment System ** */
#define MAX_AFLOORS                 ( 20 )

enum E_FLAT_DATA
{
	E_OWNER[ 24 ],    		E_NAME[ 30 ], 		E_LOCKED,
	bool: E_CREATED,		E_FURNITURE
};

new
	g_apartmentData                 [ 19 ] [ E_FLAT_DATA ], // A1 = 19 Floors
	g_ApartmentFurnitureCount		[ sizeof( g_apartmentData ) ],
	g_apartmentElevator             = INVALID_OBJECT_ID,
	g_apartmentElevatorGate         = INVALID_OBJECT_ID,
    g_apartmentElevatorLevel        = 0,
	g_apartmentElevatorDoor1		[ MAX_AFLOORS ]	= INVALID_OBJECT_ID,
	g_apartmentElevatorDoor2		[ MAX_AFLOORS ] = INVALID_OBJECT_ID
;

/* ** Methamphetamine ** */
#define CHEMICAL_CS 				0
#define CHEMICAL_MU					1
#define CHEMICAL_HLC				2

enum E_METH_PROCEEDURE
{
	E_CHEMICAL, 		E_NAME[ 98 ]
}

static const
	sz_mu_MethProduction[  ] [ 56 ] =
	{
		{ "This batch looks like it needs some muriatic. Add some." },
		{ "Continue the cooking process by adding some acid." },
		{ "Soda. Actually, acid. Yeah, that's it." },
		{ "It's cooking fine. However, it needs more acid." },
		{ "If you have any muriatic, pour it in." },
		{ "Chloride, or... Acid. Muriatic. Add that."},
		{ "Stone Cleaner, add that in." }
	},

	sz_cs_MethProduction[  ] [ 54 ] =
	{
		{ "It's getting blue, add some soda in though." },
		{ "Got any soda? Drop it in." },
		{ "This batch needs some club soda." },
		{ "Add hydrogen chloride. Actually, add soda!" },
		{ "Continue the process with some caustic soda." },
		{ "Cooking up real fine. Needs some caustic soda though." },
		{ "Get the temperature up by adding caustic soda." },
		{ "Caustic soda... Or muriatic. Actually, add soda." }
	},

	sz_hcl_MethProduction[  ] [ 46 ] =
	{
		{ "Add some of that chloride." },
		{ "It needs some bubbles, hydrogen should be it." },
		{ "This batch needs hydrogen." },
		{ "Continue the process by adding a gas tank." },
		{ "Add soda. Actually, add hydrogen." },
		{ "A gas, what could it be? Hydrogen?" },
		{ "Cooking right away, needs more gas though." }
	}
;

new
	p_MuriaticAcid					[ MAX_PLAYERS char ],
	p_CausticSoda 					[ MAX_PLAYERS char ],
	p_HydrogenChloride 				[ MAX_PLAYERS char ],
	p_Methamphetamine				[ MAX_PLAYERS char ]
;

/* ** Paintball System ** */
#define MAX_PAINTBALL_ARENAS 		( 6 )

enum E_PAINTBALL_DATA
{
	E_NAME[ 16 ],		E_HOST, 				E_PASSWORD[ 5 ],
	E_LIMIT,			E_WEAPONS[ 3 ],			E_PLAYERS,
	E_ARENA, 			Float: E_ARMOUR, 		Float: E_HEALTH,
	bool: E_ACTIVE,		bool: E_PASSWORDED, 	bool: E_REFILLER,
	E_CD_TIMER
};

enum E_PAINTBALL_ARENAS
{
	Float: E_X, 		Float: E_Y, 			Float: E_Z,
	E_INTERIOR, 		E_NAME[ 16 ]
};

new
	g_paintballArenaData			[ ] [ E_PAINTBALL_ARENAS ] =
	{
		{ 1412.639892, -1.787510, 1000.924377, 1 , 	"Warehouse 1" },
		{ 1302.519897, -1.787510, 1001.028259, 18, 	"Warehouse 2" },
		{ 1063.650400, 2134.9487, 10.82030000, 0 , 	"Warehouse 3" },
		{ -2659.28170, 1410.3884, 910.1703000, 3 , 	"Jizzy's" },
		{ 296.8772000, 174.79120, 1007.171900, 3 ,	"LV-PD" },
		//{ 1265.012900, -775.0262, 1091.906300, 5 ,	"Mad Doggs" },
		{ -1401.68950, 107.43800, 1032.273400, 1 , 	"Stadium 1" },
		{ 2193.399700, -1142.272, 1029.796900, 15, 	"Jefferson Motel" },
		{ -949.294600, 1887.0156, 5.000000000, 17, 	"Sherman Dam" },
		{ 1721.863800, -1655.338, 20.96800000, 18,  "Atrium" }
	},

	g_paintballData       			[ MAX_PAINTBALL_ARENAS ] [ E_PAINTBALL_DATA ],

	bool: p_LeftPaintball           [ MAX_PLAYERS char ],
 	p_PaintBallArena				[ MAX_PLAYERS char ],

	// Iterator
	Iterator:paintball<MAX_PAINTBALL_ARENAS>
;

/* ** Shop Data ** */
#define LIMIT_SCISSORS				16
#define LIMIT_PINS					16
#define LIMIT_ROPES					8
#define LIMIT_CS 					16 // Caustic Soda
#define LIMIT_HCL 					16 // Hydrogen Chloride
#define LIMIT_MU 					16 // Muriatic Acid
#define LIMIT_FOIL 					8
#define LIMIT_MELTER 				4
#define LIMIT_ONE 					1

enum E_SHOP_DATA
{
	bool: E_SAVABLE, 	E_NAME[ 24 ], 			E_USAGE[ 32 ],
	E_LIMIT, 			E_PRICE
};

new
	g_shopItemData[ ] [ E_SHOP_DATA ] =
	{
 		{ true , "Drain Cleaner", 		"Caustic Soda",				 	LIMIT_CS,		150  }, // 0
 		{ true , "Stone Cleaner",		"Muriatic Acid", 			 	LIMIT_MU,		250  }, // 1
 		{ true , "Gas Tank",			"Hydrogen Chloride", 		 	LIMIT_HCL,		300  }, // 2
 		{ false, "Chastity Belt", 		"Preventation of Aids", 	 	LIMIT_ONE,		500  }, // 3
 		{ false, "Secure Wallet", 		"Less Being Robbed Chance",  	LIMIT_ONE,		600  }, // 4
 		{ true , "Scissors", 			"/cuttie", 					 	LIMIT_SCISSORS,	750  }, // 5
 		{ true , "Bobby Pin", 			"/breakcuff",				 	LIMIT_PINS,		1200 }, // 6 [1000] -makecopgreatagain
 		{ false, "Money Case", 			"Doubles Robbing Amount", 	 	LIMIT_ONE,		1500 }, // 7 [1250]
 		{ true , "Rope", 				"/tie", 					 	LIMIT_ROPES,	1750 }, // 8 [1500]
 		{ true , "Aluminium Foil", 		"Deflects EMP",				 	LIMIT_FOIL,		1750 }, // 9
 		{ true , "Thermal Drill", 		"Halves Safe Cracking Time",  	LIMIT_ONE,		5000 }, // 10
 		{ true , "Metal Melter", 		"/breakout", 				 	LIMIT_MELTER,	7500 }  // 11
	}
;

/* ** Easter Eggs ** */
#define ENABLED_EASTER_EGG 			( true )

#if ENABLED_EASTER_EGG == true
	#define EASTEREGG_LABEL 			"[EASTER EGG]"
	#define EASTEREGG_NAME 				"Easter Egg"
	#define EASTEREGG_MODEL 			randarg( 19341, 19342, 19343, 19344, 19345 )
	#define MAX_EGGS 					( 4 )

	enum E_EASTEREGG_DATA
	{
		Float: E_X,     		Float: E_Y,			Float: E_Z,
		E_PICK_UP, 				Text3D: E_LABEL
	};

	new
		g_EasterEggs                    [ MAX_EGGS ] [ E_EASTEREGG_DATA ],
		bool: g_EasterHunt              = false,

		Iterator:eastereggs<MAX_EGGS>
	;
#endif

/* ** Secure Truck Mod ** */
#define ENABLED_SECURE_TRUCK		( true )
#define SECURE_TRUCK_DRIVER_NAME 	( "ChuffSec" )
#define SECURE_TRUCK_DISTANCE 		( 6.0 )
#define SECURE_TRUCK_RADIUS 		( 4.0 )
#define COLOR_SECURITY 				0xFF440500

#if ENABLED_SECURE_TRUCK == true
	enum E_SECURE_OFFSET {
		Float: E_X, 			Float: E_Y, 			Float: E_Z,
		bool: E_LEFT, 			bool: E_ENABLED, 		Float: E_HP
	};

	enum E_SECURE_VEHICLE {
		E_LOOT, 				bool: E_ROBBED,			bool: E_OPEN,
		bool: E_BEING_ROBBED,	E_MAP_ICON
	};

	new
		Float: g_secureTruckOffsets[ ] [ E_SECURE_OFFSET ] =
		{
			{ 0.6641840, -3.134811, -0.072469, false, true, 100.0 },
			{ 0.6666250, -3.096450, 1.2469670, false, true, 100.0 },
			{ -0.641235, -3.098449, 1.2477970, true , true, 100.0 },
			{ -0.637695, -3.136108, -0.079330, true , true, 100.0 }
		},
		g_secureTruckData 					[ E_SECURE_VEHICLE ],
		g_secureTruckDriver					= INVALID_PLAYER_ID,
		g_secureTruckVehicle 				= INVALID_VEHICLE_ID,
		Text3D: g_secureTruckVehicleLabel	[ sizeof( g_secureTruckOffsets ) ] = { Text3D: INVALID_3DTEXT_ID, ... }
	;
#endif

/* ** Admin Ban Codes ** */
enum E_BAN_CODE
{
	E_CODE[ 4 ], 		E_DATA[ 21 ]
};

new
	g_banCodes[ ] [ E_BAN_CODE ] =
	{
		{ "AH",  "Armor Hacking" },
		{ "HH",  "Health Hacking" },
		{ "VHH", "Vehicle Health Hacks" },
		{ "NR",  "No Reload" },
		{ "IA",  "Infinite Ammo" },
		{ "FH",  "Fly Hacks" },
		{ "BE",  "Ban Evasion" },
		{ "AB",  "Air Brake" },
		{ "TP",  "Teleport Hacks" },
		{ "WH",  "Weapon Hack" },
		{ "SH",  "Speed Hacks" },
		{ "UA",  "Unlimited Ammo" },
		{ "RF",  "Rapid Fire" },
		{ "AIM", "Aimbot" },
		{ "ADV", "Advertising" }
	}
;

/* ** Dirty Mechanic ** */
#define CONTAINER_LIMIT 			( 6 )

enum E_CONTAINER_DATA {
	E_OBJECT, 			E_DOOR[ 2 ],				E_CHECKPOINT,
	Text3D: E_LABEL,	Float: E_OPEN_ANGLE[ 2 ], 	Float: E_CLOSE_ANGLE[ 2 ],
	bool: E_CLOSED, 	Float: E_DOOR1_CORDS[ 3 ], 	Float: E_DOOR2_CORDS[ 3 ]
}

new
	g_containerData 				[ CONTAINER_LIMIT ] [ E_CONTAINER_DATA ],
	g_LastExportModel 				[ MAX_PLAYERS ],

	Iterator:containers<CONTAINER_LIMIT>
;

/* ** Jail System ** */
#define JAIL_SECONDS_MULTIPLIER		( 5 )
#define ALCATRAZ_TIME_PAUSE 		( 5 )
#define ALCATRAZ_TIME_WANTED 		( 600 )

enum E_JAIL_DATA
{
	E_CITY,				Float: E_EXPLODE1_POS[ 3 ],	Float: E_EXPLODE2_POS[ 3 ],
	Float: E_RADIUS,	E_TIMESTAMP,				bool: E_BOMBED
};

new
	g_jailData						[ MAX_CITIES ] [ E_JAIL_DATA ] =
	{
		{ CITY_SF, { 217.4585, 113.6866, 999.0156 }, { 225.4888, 113.1873, 999.0156 }, 5.0,  0, false },
		{ CITY_LV, { 194.3351, 179.008, 1003.0234 }, { 193.8611, 158.0657, 1003.024 }, 10.0, 0, false },
		{ CITY_LS, { 268.5573, 86.1785, 1001.0391 }, { 268.1720, 78.5381, 1001.0391 }, 5.0,	 0, false }
	},
	p_JailObjectLV					[ MAX_PLAYERS ] [ 3 ],
	p_JailObjectSF					[ MAX_PLAYERS ] [ 4 ],
	p_JailObjectLS					[ MAX_PLAYERS ] [ 3 ],
	p_AlcatrazObject 				[ MAX_PLAYERS ] = { INVALID_OBJECT_ID, ... },
	p_AlcatrazEscapeTS 				[ MAX_PLAYERS ],
	g_alcatrazTimestamp 			= 0
;

/* ** Bank Vault ** */
enum E_BANKDOOR_DATA
{
	E_CITY,						E_OBJECT,					bool: E_DISABLED,
	E_TIMESTAMP,				E_TIMESTAMP_CLOSE,			E_WORLD,
	Float: E_EXPLODE_POS[ 3 ],	Float: E_OPEN_POS[ 3 ],		Float: E_OPEN_ROT[ 3 ]
}

new
	g_bankvaultData					[ MAX_CITIES ] [ E_BANKDOOR_DATA ] =
	{
		{ CITY_SF, INVALID_OBJECT_ID, false, 0, 0, 23, { -1413.956, 859.16560, 984.71260 }, { -1412.56506, 859.2745360, 978.6328730 }, { -1000.000, -1000.00, -1000.0000 } },
		{ CITY_LV, INVALID_OBJECT_ID, false, 0, 0, 52, { 2116.3513, 1233.0250, 1017.1369 }, { 2113.391357, 1233.155273, 1016.122619 }, { 90.000000, 0.000000, -90.000000 } },
		{ CITY_LS, INVALID_OBJECT_ID, false, 0, 0, 56, { 2116.3513, 1233.0250, 1017.1369 }, { 2113.391357, 1233.155273, 1016.122619 }, { 90.000000, 0.000000, -90.000000 } }
	}
;

/* ** Player Settings ** */
#define MAX_SETTINGS 					( 11 )

#define SETTING_BAILOFFERS 				( 0 )
#define SETTING_EVENT_TP				( 1 )
#define SETTING_GANG_INVITES			( 2 )
#define SETTING_CHAT_PREFIXES			( 3 )
#define SETTING_RANSOMS					( 4 )
#define SETTING_AUTOSAVE				( 5 )
#define SETTING_CONNECTION_LOG 			( 6 )
#define SETTING_HITMARKER 				( 7 )
#define SETTING_VIPSKIN 				( 8 )
#define SETTING_COINS_BAR	 			( 9 )
#define SETTING_TOP_DONOR 				( 10 )

enum E_SETTING_DATA
{
	bool: E_DEFAULT_VAL,		E_NAME[ 16 ]
};

new
	g_PlayerSettings[ ] [ E_SETTING_DATA ] = {
		{ false, "Bail Offers" }, { false, "Event Teleports" }, { false, "Gang Invites" }, { false, "Chat Prefixes" }, { false, "Ransom Offers" },
		{ false, "Auto-Save" }, { true, "Connection Log" }, { true, "Hitmarker" }, { true, "V.I.P Skin" }, { false, "Total Coin Bar" }, { false, "Last Donor Text" }
	},
	bool: p_PlayerSettings[ MAX_PLAYERS ] [ MAX_SETTINGS char ]
;

/* ** Trucking System ** */
#define RISK_FACTOR_EASY 				( 0x10 )
#define RISK_FACTOR_HARD 				( 0x8 )

#define INVALID_TRUCKING_ROUTE 			( 0xFF )

enum E_TRUCKING_DATA
{
	E_NAME[ 32 ],				E_CITY,
	Float: E_X,					Float: E_Y,					Float: E_Z
};

enum E_TRAILER_DATA
{
	E_NAME[ 17 ], 				E_BONUS, 					E_RISK
};

new
	g_aTruckingLocations[ ] [ E_TRUCKING_DATA ] =
	{
		// SF
		{ "Supa",					CITY_SF, -2492.6143, 768.56420, 34.5737 },
		{ "SF Hospital",			CITY_SF, -2698.4365, 622.14070, 13.8549 },
		{ "Golf Club",				CITY_SF, -2729.0786, -311.8507, 6.44090 },
		{ "SF Airport Fueling",		CITY_SF, -1127.2633, -150.5504, 13.5457 },
		{ "Herb Farm", 				CITY_SF, -1085.3650, -1644.566, 75.7690 },
		{ "Farm", 					CITY_SF, -376.94220, -1429.182, 25.1285 },
		{ "FleischBerg Beer",		CITY_SF, -172.67190, -233.8773, 0.83140 },
		{ "Chemical Plant",			CITY_SF, -1025.5406, -666.9636, 31.4098 },
		{ "SF Mine",				CITY_SF, -2755.9512, 1256.9657, 11.1721 },
		{ "Gas Station",			CITY_SF, -2405.2808, 982.05940, 44.6987 },

		// LV
		{ "LV SMALL Town",			CITY_LV, -796.19470, 1491.5441, 21.3110 },
		{ "Small LV Farm", 			CITY_LV, -379.07180, 2217.4116, 41.4955 },
		{ "Abandoned Airport LV", 	CITY_LV, 386.869300, 2539.4175, 15.9411 },
		{ "LV Truck Depot", 		CITY_LV, 1439.58200, 989.50120, 10.2221 },
		{ "LV Airport", 			CITY_LV, 1328.65330, 1613.9368, 10.2221 },
		{ "LV Construction Site", 	CITY_LV, 2422.11400, 1922.9708, 5.41740 },
		{ "LV Construction Site", 	CITY_LV, 2618.30830, 833.75980, 4.71790 },
		{ "LV Casino", 				CITY_LV, 1945.29390, 1347.5150, 8.51120 },
		{ "LV Train Station", 		CITY_LV, 1433.38670, 2606.7341, 10.0737 },
		//{ "LV Golf Course", 		CITY_LV, 1467.91980, 2775.1060, 10.0737 },
		{ "LV Army base",			CITY_LV, 314.20850, 1901.61900, 18.3275 },

		// LS
		{ "LS Farm", 				CITY_LS, 1933.2828, 171.656600, 36.6801 },
		{ "LS Farm", 				CITY_LS, 2372.1514, -647.70950, 126.906 },
		{ "LS Arena", 				CITY_LS, 2687.5447, -1682.9163, 8.84300 },
		{ "LS Trucking Depot", 		CITY_LS, 2488.4692, -2089.7585, 12.9487 },
		{ "LS Military Depot", 		CITY_LS, 2760.9412, -2456.6716, 12.9522 },
		{ "LS Pier", 				CITY_LS, 369.90320, -2027.8804, 7.07380 },
		{ "LS Airport", 			CITY_LS, 1930.5016, -2396.6973, 14.2341 },
		{ "LS Town Hall", 			CITY_LS, 1306.2109, -2056.8953, 58.1423 },
		{ "LS Farm", 				CITY_LS, 1557.1737, 24.4480000, 24.8366 },
		{ "LS Depot", 				CITY_LS, 2538.0132, -2228.3872, 14.0296 },

		// Assorted
		{ "Desert town",			CITY_DESERTS, -1495.147, 2614.85550, 56.3716 },
		{ "Farm",					CITY_DESERTS, -1480.387, 1949.57060, 49.6636 },
		{ "Hard Desert Town",		CITY_DESERTS, -788.0822, 2415.39090, 157.722 },
		{ "Desert Town",			CITY_DESERTS, -824.9703, 2728.89160, 46.2619 },
		{ "Small Town",				CITY_DESERTS, -1648.912, 2475.92090, 87.6510 },
		{ "Ganja Farm",				CITY_DESERTS, -1116.771, -1115.2540, 128.952 },
		{ "Farm",					CITY_COUNTRY, -367.4244, -1048.4260, 60.0209 }
	},

	g_aTrailerData[ 3 ] [ 8 ] [ E_TRAILER_DATA ] =
	{
		{
			{ "Methylamine", 		5000, 	RISK_FACTOR_HARD },
			{ "Mustard Gas", 		4000, 	RISK_FACTOR_HARD },
			{ "Ethylamine", 		2000, 	RISK_FACTOR_HARD },
			{ "Safrole", 			1000, 	RISK_FACTOR_HARD },

			{ "Crude Oil", 			2000,	RISK_FACTOR_EASY },
			{ "Natural Gas", 		1500,	RISK_FACTOR_EASY },
			{ "Unleaded Gas", 		1250,	RISK_FACTOR_EASY },
			{ "Heating Oil", 		750,	RISK_FACTOR_EASY }
		},

		{
			{ "Pseudoephedrine", 	5000, 	RISK_FACTOR_HARD },
			{ "Coca Plant", 		4000, 	RISK_FACTOR_HARD },
			{ "Kush", 				2000, 	RISK_FACTOR_HARD },
			{ "Opium", 				1000, 	RISK_FACTOR_HARD },

			{ "Soybeans", 			2000, 	RISK_FACTOR_EASY },
			{ "Wheat", 				1500, 	RISK_FACTOR_EASY },
			{ "Cocoa", 				1250, 	RISK_FACTOR_EASY },
			{ "Coffee", 			750, 	RISK_FACTOR_EASY }
		},

		{
			{ "Gold Bullion", 		2000, 	RISK_FACTOR_EASY },
			{ "Silver Bullion", 	1500, 	RISK_FACTOR_EASY },
			{ "Platinum Bullion",	1250, 	RISK_FACTOR_EASY },
			{ "Precious Metals", 	750, 	RISK_FACTOR_EASY },

			{ "Cocaine", 			5000, 	RISK_FACTOR_HARD },
			{ "Methamphetamine", 	4000, 	RISK_FACTOR_HARD },
			{ "Heroin", 			2000, 	RISK_FACTOR_HARD },
			{ "Various Pills", 		1000, 	RISK_FACTOR_HARD }
		}
	},

	bool: p_hasTruckingJob			[ MAX_PLAYERS char ],
	p_TruckingTrailer 				[ MAX_PLAYERS char ],
	p_TruckingTrailerModel 			[ MAX_PLAYERS char ],
	Float: p_TruckingDistance 		[ MAX_PLAYERS ],
	p_TruckingTimeElapsed			[ MAX_PLAYERS ],
	p_TruckingRoute 				[ MAX_PLAYERS ] [ 2 char ],
	p_TruckingCheckPoint			[ MAX_PLAYERS ] = { 0xFFFF, ... },
	p_TruckingMapIcon 				[ MAX_PLAYERS ] = { 0xFFFF, ... },
	p_TruckingCancelTimer 			[ MAX_PLAYERS ] = { 0xFFFF, ... },
	p_TruckingPositionTimer 		[ MAX_PLAYERS ] = { 0xFFFF, ... },
	p_LastAttachedVehicle 			[ MAX_PLAYERS ] = { INVALID_VEHICLE_ID, ... }
;

/* ** Information System ** */
enum E_INFO_PICKUP_DATA
{
	Float: E_X,					Float: E_Y, 				Float: E_Z,
	E_PICKUP_ID,				E_TEXT[ 128 ]
};

new
	g_informationPickupsData 		[ ] [ E_INFO_PICKUP_DATA ] =
	{
		{ -2118.1787, -77.9626, 35.3203, 0xFFFF, "{FFFFFF}Over here, you are able to complete trucking missions by attaching a trailer to your truck then going to /work!" }, 		// Trucking
		{ -2025.9523, -136.965, 35.2906, 0xFFFF, "{FFFFFF}Ever felt like breaking bad? Enter an RV as a passenger and begin to produce meth! Make sure you have the materials!" }, 	// Meth
		{ -1497.1375, 914.6858, 7.18750, 0xFFFF, "{FFFFFF}All civilians should bank their money, for their own protection and to save some money from tax!" }, 						// Bank
		{ -2450.2261, 752.2170, 35.1719, 0xFFFF, "{FFFFFF}Buy materials that can help you complete missions such as meth production, or buy other neccessary items!" }, 			// Supa
		{ -1589.4668, 115.8173, 3.54950, 0xFFFF, "{FFFFFF}Dirty Mechanics can export vehicles and receive money based on the material that can be taken from a vehicle!" },	 		// Car Jacker
		{ -2767.3765, 1257.077, 11.7703, 0xFFFF, "{FFFFFF}You can mine ores and store your ores in dunes for exportation! Use the /ore command to see its usage!" },				// Mining
		{ 1954.71890, 1038.251, 992.859, 0xFFFF, "{FFFFFF}Test out your luck on the slot machines, maybe you might win the mega jackpot!" },										// Slots
		{ 1955.69070, 1005.167, 992.468, 0xFFFF, "{FFFFFF}Roulette can payout up to $3.5M! Single bets return 35x your money whereas outside bets can return 2x to 3x!" }			// Roulette
	}
;

/* ** Garage System ** */
#define MAX_GARAGES 					( 200 )

#define G_DEFAULT_X  	405.0301
#define G_DEFAULT_Y  	2508.6348
#define G_DEFAULT_Z  	16.7825

enum E_GARAGE_DATA
{
	E_OWNER_ID,					E_PRICE,					E_INTERIOR_ID,
	Float: E_X,         		Float: E_Y,             	Float: E_Z,
	Float: E_ANGLE,    			E_SQL_ID,					E_CHECKPOINT,
	Text3D: E_LABEL, 			E_WORLD
};

enum E_GARAGE_INT_DATA
{
	E_NAME[ 17 ],				E_INTERIOR,
	E_VEHICLE_CAPACITY,			E_PRICE,					Float: E_ANGLE,
	Float: E_X,					Float: E_Y, 				Float: E_Z,
	Float: E_PREVIEW_POS[ 3 ],	Float: E_PREVIEW_LOOKAT[ 3 ]
};

new
	g_garageInteriorData 			[ ] [ E_GARAGE_INT_DATA ] =
	{
		{ "Default Interior",	11, 3, 	0, 		 0.0, 		G_DEFAULT_X, G_DEFAULT_Y, G_DEFAULT_Z, { 419.2017, 2517.6489, 17.9550 }, { 401.4677, 2506.3042, 16.9824 } },
		{ "Medium Interior", 	22, 5, 	1500000, 180.0, 	150.8938, 2497.9995, 16.5999, { 140.8066, 2483.9426, 16.7998 }, { 159.9573, 2501.1057, 16.7998 } },
		{ "Luxury Interior", 	33, 10, 3000000, 270.0, 	380.1852, 2496.8149, 16.4343, { 375.7204, 2486.4741, 16.6344 }, { 427.4626, 2505.8796, 16.6344 } }
	},
	g_garageData 					[ MAX_GARAGES ] [ E_GARAGE_DATA ],
	szg_garageInteriors				[ 174 ],

	// Iterator
	Iterator:garages<MAX_GARAGES>
;

/* ** Anti RDM Zones *
#define MAX_RDM_ZONES 				( 18 )
#define MAX_RDM_GANGZONES 			( 14 )

enum E_RDM_ZONE
{
	E_CIRCLE,					E_GANGZONES[ MAX_RDM_GANGZONES ],
};

new
	g_antiDeathmatchZoneData 		[ MAX_RDM_ZONES ] [ E_RDM_ZONE ],

	// Iterator
	Iterator:rdmzone<MAX_RDM_ZONES>
;*/

/* ** Sprunk ** */
enum E_VENDING_MACHINE
{
	E_MODEL,
	E_INTERIOR,
	Float: E_X,
	Float: E_Y,
	Float: E_Z,
	Float: E_RX,
	Float: E_RY,
	Float: E_RZ,
	Float: E_FX,
	Float: E_FY
};

stock const
	g_VendingMachines[ ] [ E_VENDING_MACHINE ] =
	{
		{ 955, 0, -862.82, 1536.60, 21.98, 0.00, 0.00, 180.00, -862.84, 1537.60 },			{ 1775, 16, -35.72, -140.22, 1003.63, 0.00, 0.00, 180.00, -35.74, -139.22 },
		{ 956, 0, 2271.72, -76.46, 25.96, 0.00, 0.00, 0.00, 2271.72, -77.46 }, 				{ 955, 0, 1277.83, 372.51, 18.95, 0.00, 0.00, 64.00, 1278.73, 372.07 },
		{ 956, 0, 662.42, -552.16, 15.71, 0.00, 0.00, 180.00, 662.41, -551.16 }, 			{ 955, 0, 201.01, -107.61, 0.89, 0.00, 0.00, 270.00, 200.01, -107.63 },
		{ 955, 0, -253.74, 2597.95, 62.24, 0.00, 0.00, 90.00, -252.74, 2597.95 }, 			{ 956, 0, -253.74, 2599.75, 62.24, 0.00, 0.00, 90.00, -252.74, 2599.75 },
		{ 956, 0, -76.03, 1227.99, 19.12, 0.00, 0.00, 90.00, -75.03, 1227.99 }, 			{ 955, 0, -14.70, 1175.35, 18.95, 0.00, 0.00, 180.00, -14.72, 1176.35 },
		{ 1977, 7, 316.87, -140.35, 998.58, 0.00, 0.00, 270.00, 315.87, -140.36 }, 			{ 1775, 17, 373.82, -178.14, 1000.73, 0.00, 0.00, 0.00, 373.82, -179.14 },
		{ 1776, 17, 379.03, -178.88, 1000.73, 0.00, 0.00, 270.00, 378.03, -178.90 }, 		{ 1775, 17, 495.96, -24.32, 1000.73, 0.00, 0.00, 180.00, 495.95, -23.32 },
		{ 1776, 17, 500.56, -1.36, 1000.73, 0.00, 0.00, 0.00, 500.56, -2.36 }, 				{ 1775, 17, 501.82, -1.42, 1000.73, 0.00, 0.00, 0.00, 501.82, -2.42 },
		{ 956, 0, -1455.11, 2591.66, 55.23, 0.00, 0.00, 180.00, -1455.13, 2592.66 }, 		{ 955, 0, 2352.17, -1357.15, 23.77, 0.00, 0.00, 90.00, 2353.17, -1357.15 },
		{ 955, 0, 2325.97, -1645.13, 14.21, 0.00, 0.00, 0.00, 2325.97, -1646.13 }, 			{ 956, 0, 2139.51, -1161.48, 23.35, 0.00, 0.00, 87.00, 2140.51, -1161.53 },
		{ 956, 0, 2153.23, -1016.14, 62.23, 0.00, 0.00, 127.00, 2154.03, -1015.54 }, 		{ 955, 0, 1928.73, -1772.44, 12.94, 0.00, 0.00, 90.00, 1929.73, -1772.44 },
		{ 1776, 1, 2222.36, 1602.64, 1000.06, 0.00, 0.00, 90.00, 2223.36, 1602.64 }, 		{ 1775, 1, 2222.20, 1606.77, 1000.05, 0.00, 0.00, 90.00, 2223.20, 1606.77 },
		{ 1775, 1, 2155.90, 1606.77, 1000.05, 0.00, 0.00, 90.00, 2156.90, 1606.77 }, 		{ 1775, 1, 2209.90, 1607.19, 1000.05, 0.00, 0.00, 270.00, 2208.90, 1607.17 },
		{ 1776, 1, 2155.84, 1607.87, 1000.06, 0.00, 0.00, 90.00, 2156.84, 1607.87 }, 		{ 1776, 1, 2202.45, 1617.00, 1000.06, 0.00, 0.00, 180.00, 2202.43, 1618.00 },
		{ 1776, 1, 2209.24, 1621.21, 1000.06, 0.00, 0.00, 0.00, 2209.24, 1620.21 }, 		{ 1776, 3, 330.67, 178.50, 1020.07, 0.00, 0.00, 0.00, 330.67, 177.50 },
		{ 1776, 3, 331.92, 178.50, 1020.07, 0.00, 0.00, 0.00, 331.92, 177.50 }, 			{ 1776, 3, 350.90, 206.08, 1008.47, 0.00, 0.00, 90.00, 351.90, 206.08 },
		{ 1776, 3, 361.56, 158.61, 1008.47, 0.00, 0.00, 180.00, 361.54, 159.61 }, 			{ 1776, 3, 371.59, 178.45, 1020.07, 0.00, 0.00, 0.00, 371.59, 177.45 },
		{ 1776, 3, 374.89, 188.97, 1008.47, 0.00, 0.00, 0.00, 374.89, 187.97 }, 			{ 1775, 2, 2576.70, -1284.43, 1061.09, 0.00, 0.00, 270.00, 2575.70, -1284.44 },
		{ 1775, 15, 2225.20, -1153.42, 1025.90, 0.00, 0.00, 270.00, 2224.20, -1153.43 },	{ 955, 0, 1154.72, -1460.89, 15.15, 0.00, 0.00, 270.00, 1153.72, -1460.90 },
		{ 956, 0, 2480.85, -1959.27, 12.96, 0.00, 0.00, 180.00, 2480.84, -1958.27 },		{ 955, 0, 2060.11, -1897.64, 12.92, 0.00, 0.00, 0.00, 2060.11, -1898.64 },
		{ 955, 0, 1729.78, -1943.04, 12.94, 0.00, 0.00, 0.00, 1729.78, -1944.04 },			{ 956, 0, 1634.10, -2237.53, 12.89, 0.00, 0.00, 0.00, 1634.10, -2238.53 },
		{ 955, 0, 1789.21, -1369.26, 15.16, 0.00, 0.00, 270.00, 1788.21, -1369.28 },		{ 956, 0, -2229.18, 286.41, 34.70, 0.00, 0.00, 180.00, -2229.20, 287.41 },
		{ 955, 256, -1980.78, 142.66, 27.07, 0.00, 0.00, 270.00, -1981.78, 142.64 },		{ 955, 256, -2118.96, -423.64, 34.72, 0.00, 0.00, 255.00, -2119.93, -423.40 },
		{ 955, 256, -2118.61, -422.41, 34.72, 0.00, 0.00, 255.00, -2119.58, -422.17 },		{ 955, 256, -2097.27, -398.33, 34.72, 0.00, 0.00, 180.00, -2097.29, -397.33 },
		{ 955, 256, -2092.08, -490.05, 34.72, 0.00, 0.00, 0.00, -2092.08, -491.05 },		{ 955, 256, -2063.27, -490.05, 34.72, 0.00, 0.00, 0.00, -2063.27, -491.05 },
		{ 955, 256, -2005.64, -490.05, 34.72, 0.00, 0.00, 0.00, -2005.64, -491.05 },		{ 955, 256, -2034.46, -490.05, 34.72, 0.00, 0.00, 0.00, -2034.46, -491.05 },
		{ 955, 256, -2068.56, -398.33, 34.72, 0.00, 0.00, 180.00, -2068.58, -397.33 },		{ 955, 256, -2039.85, -398.33, 34.72, 0.00, 0.00, 180.00, -2039.86, -397.33 },
		{ 955, 256, -2011.14, -398.33, 34.72, 0.00, 0.00, 180.00, -2011.15, -397.33 },		{ 955, 2048, -1350.11, 492.28, 10.58, 0.00, 0.00, 90.00, -1349.11, 492.28 },
		{ 956, 2048, -1350.11, 493.85, 10.58, 0.00, 0.00, 90.00, -1349.11, 493.85 },		{ 955, 0, 2319.99, 2532.85, 10.21, 0.00, 0.00, 0.00, 2319.99, 2531.85 },
		{ 956, 0, 2845.72, 1295.04, 10.78, 0.00, 0.00, 0.00, 2845.72, 1294.04 },			{ 955, 0, 2503.14, 1243.69, 10.21, 0.00, 0.00, 180.00, 2503.12, 1244.69 },
		{ 956, 0, 2647.69, 1129.66, 10.21, 0.00, 0.00, 0.00, 2647.69, 1128.66 },			{ 1209, 0, -2420.21, 984.57, 44.29, 0.00, 0.00, 90.00, -2419.21, 984.57 },
		{ 1302, 0, -2420.17, 985.94, 44.29, 0.00, 0.00, 90.00, -2419.17, 985.94 },			{ 955, 0, 2085.77, 2071.35, 10.45, 0.00, 0.00, 90.00, 2086.77, 2071.35 },
		{ 956, 0, 1398.84, 2222.60, 10.42, 0.00, 0.00, 180.00, 1398.82, 2223.60 },			{ 956, 0, 1659.46, 1722.85, 10.21, 0.00, 0.00, 0.00, 1659.46, 1721.85 },
		{ 955, 0, 1520.14, 1055.26, 10.00, 0.00, 0.00, 270.00, 1519.14, 1055.24 },			{ 1775, 6, -19.03, -57.83, 1003.63, 0.00, 0.00, 180.00, -19.05, -56.83 },
		{ 1775, 18, -16.11, -91.64, 1003.63, 0.00, 0.00, 180.00, -16.13, -90.64 },			{ 1775, 16, -15.10, -140.22, 1003.63, 0.00, 0.00, 180.00, -15.11, -139.22 },
		{ 1775, 17, -32.44, -186.69, 1003.63, 0.00, 0.00, 180.00, -32.46, -185.69 },		{ 1775, 16, -35.72, -140.22, 1003.63, 0.00, 0.00, 180.00, -35.74, -139.22 },
		{ 1776, 6, -36.14, -57.87, 1003.63, 0.00, 0.00, 180.00, -36.16, -56.87 },			{ 1776, 18, -17.54, -91.71, 1003.63, 0.00, 0.00, 180.00, -17.56, -90.71 },
		{ 1776, 16, -16.53, -140.29, 1003.63, 0.00, 0.00, 180.00, -16.54, -139.29 },		{ 1776, 17, -33.87, -186.76, 1003.63, 0.00, 0.00, 180.00, -33.89, -185.76 },
		{ 1775, 6, -19.03, -57.83, 1003.63, 0.00, 0.00, 180.00, -19.05, -56.83 },			{ 1776, 6, -36.14, -57.87, 1003.63, 0.00, 0.00, 180.00, -36.16, -56.87 },
		{ 1775, 18, -16.11, -91.64, 1003.63, 0.00, 0.00, 180.00, -16.13, -90.64 },			{ 1776, 18, -17.54, -91.71, 1003.63, 0.00, 0.00, 180.00, -17.56, -90.71 },
		{ 1776, 16, -16.53, -140.29, 1003.63, 0.00, 0.00, 180.00, -16.54, -139.29 },		{ 1775, 16, -15.10, -140.22, 1003.63, 0.00, 0.00, 180.00, -15.11, -139.22 },
		{ 1776, 17, -33.87, -186.76, 1003.63, 0.00, 0.00, 180.00, -33.89, -185.76 },		{ 1775, 17, -32.44, -186.69, 1003.63, 0.00, 0.00, 180.00, -32.46, -185.69 }
	}
;

new
	g_VendingMachineObject 			[ sizeof( g_VendingMachines ) ] = { -1, ... },
	p_VendingUseTimer				[ MAX_PLAYERS ] = { -1, ... }
;

/* ** Rank System ** */
enum E_RANK_DATA
{
	Float: E_POINTS,			E_NAME[ 32 ], 					E_MODEL,
	E_COLOR,
};

stock const
	g_aPlayerRanks[ ] [ E_RANK_DATA ] =
	{
		{ 9497.2,	"Elite V", 		19780, COLOR_GOLD },
		{ 5301.7,	"Elite IV", 	19782, COLOR_GOLD },
		{ 2959.61, 	"Elite III", 	19781, COLOR_GOLD },
		{ 1652.17, 	"Elite II", 	19784, COLOR_GOLD },
		{ 922.303, 	"Elite I", 		19783, COLOR_GOLD },
		{ 514.865,	"Silver V", 	19780, COLOR_GREY },
		{ 287.417,	"Silver IV", 	19782, COLOR_GREY },
		{ 160.45, 	"Silver III", 	19781, COLOR_GREY },
		{ 89.56, 	"Silver II", 	19784, COLOR_GREY },
		{ 50.0, 	"Silver I", 	19783, COLOR_GREY },
		{ 0.0, 		"unranked",		19300, COLOR_GREY }
	}
;

/* ** Gambling ** */
#define MAX_SLOT_POOLS				( 2 )
#define POOL_ENTITIES				( 5 )

enum E_SLOT_MACHINE_DATA
{
	E_SPIN[ 3 ], 				E_ACTIVE,
	Float: E_X, 				Float: E_Y, 					Float: E_Z,
	Float: E_A, 				Float: E_SPIN_ROTATE[ 3 ], 		Float: E_RANDOM_ROTATE[ 3 ],
	E_TIMER, 					bool: E_ROLLING,				E_POOL_ID,
	E_ENTRY_FEE
};

enum E_CASINO_POOL_DATA
{
	E_SQL_ID,					E_TOTAL_WINNINGS,				E_TOTAL_GAMBLED,
	E_POOL,						E_OBJECT[ POOL_ENTITIES ],		Text3D: E_LABEL[ POOL_ENTITIES ]
};

new
	g_slotmachineData				[ MAX_MACHINES ] [ E_SLOT_MACHINE_DATA ],
	g_slotmachineColors				[ ] [ ] = {
		{ "ld_slot:bar2_o" }, { "ld_slot:r_69" }, { "ld_slot:bar1_o" }, { "ld_slot:bell" }, { "ld_slot:cherry" }, { "ld_slot:grapes" }, { "ld_slot:cherry" }, { "ld_slot:grapes" }, { "ld_slot:bell" }, { "ld_slot:r_69" },
		{ "ld_slot:bell" }, { "ld_slot:bar1_o" }, { "ld_slot:cherry" }, { "ld_slot:grapes" }, { "ld_slot:r_69" }, { "ld_slot:grapes" }, { "ld_slot:bell" }, { "ld_slot:cherry" }, { "ld_slot:bar2_o" }
	},
	g_slotmachineTypes				[ sizeof( g_slotmachineColors ) ] = { 0, 5, 1, 2, 3, 4, 3, 4, 2, 5, 2, 1, 3, 4, 5, 4, 2, 3, 0 },
	p_usingSlotMachine				[ MAX_PLAYERS ] = { -1, ... },

	// Casino pools
	g_casinoPoolData 				[ MAX_SLOT_POOLS ] [ E_CASINO_POOL_DATA ],

	// Iterator
	Iterator:SlotMachines<MAX_MACHINES>,
	Iterator:CasinoPool<MAX_SLOT_POOLS>
;

/* ** Hitmarker ** */
enum E_HITMARKER_SOUND
{
	E_NAME[ 10 ],					E_SOUND_ID
};

new
	g_HitmarkerSounds[ ] [ E_HITMARKER_SOUND ] =
	{
		{ "Bell Ding", 17802 }, 	{ "Soft Beep", 5205 }, 		{ "Low Blip", 1138 }, 	{ "Med Blip", 1137 },
		{ "High Blip", 1139 }, 		{ "Bling", 5201 }
	},
	p_HitmarkerSound 				[ MAX_PLAYERS char ]
;

/* ** Streak System ** */
#define MAX_STREAKS 				( 3 ) // Changing order will require change in UCP seasonal page.

#define STREAK_ROBBERY				0
#define STREAK_ARREST 				1
#define STREAK_KILL 				2

enum E_STREAK_DATA
{
	E_STREAK, 					E_BEST_STREAK
};

new
	g_streaksTypes[ MAX_STREAKS ] [ 8 ] = { "robbery", "arrest", "kill" },
	p_streakData[ MAX_PLAYERS ] [ MAX_STREAKS ] [ E_STREAK_DATA ]
;

/* ** Robbery NPCs ** */
#define ENABLED_NPC_ROBBERIES		( true )
#define MAX_ROBBERY_NPCS 			( MAX_ROBBERIES )
#define MAX_CIVILIANS				( 200 )

#if ENABLED_NPC_ROBBERIES == true
#include <FCNPC>

enum E_ROBBERY_NPC_DATA
{
	E_NPC_NAME[ 24 ], 			E_NPC_ID,						E_TIMEOUT,
	E_HOLDUP_TIMER,				bool: E_PROVOKED,				Float: E_RZ,
 	E_WORLD,					E_MAX_LOOT, 					E_LOOT,
 	Text3D: E_LABEL,			E_SHOOTING_TIMER,				Float: E_SHOOTING_OFFSET
};

enum E_CIVILIAN_DATA
{
	E_CLERK_ID,				E_NPC_NAME[ 24 ],
	E_WEAPON_ID,				E_ANIM_LIB[ 16 ], E_ANIM_NAME[ 16 ], E_NPC_ID,
	E_WORLD, E_INTERIOR, Float: E_RZ, bool: E_HOSTILE, bool: E_PROVOKED, E_TIMEOUT
};

new
	g_robberyNpcData[ MAX_ROBBERY_NPCS ] [ E_ROBBERY_NPC_DATA ],
	Iterator:RobberyNpc< MAX_ROBBERY_NPCS >,

	g_civilianNpcData[ MAX_CIVILIANS ] [ E_CIVILIAN_DATA ],
	Iterator:CivilianNpc< MAX_CIVILIANS >
;
#endif

/* ** Informed Robbery System ** */
#define MAX_INFORMED_ROBBERIES				( 25 )

enum E_INFORMED_ROBBERY_DATA
{
	E_MAP_ICON,					E_ALPHA
};

new
	g_informedRobberies[ MAX_INFORMED_ROBBERIES ] [ E_INFORMED_ROBBERY_DATA ],
	Iterator:InformedRobbery< MAX_INFORMED_ROBBERIES >
;

/* ** Ammunation Cops ** */
#define MAX_WEAPON_LOCKERS					( 7 )

new
	g_weaponLockerCheckpoint[ MAX_WEAPON_LOCKERS ],
	Iterator:WeaponLockers< MAX_WEAPON_LOCKERS >
;

/* ** Security System ** */
#define SECURITY_MODE_MILD					( 0 )
#define SECURITY_MODE_PARANOID				( 1 )
#define SECURITY_MODE_DISABLED				( 2 )

enum E_IRRESISTIBLE_GUARD
{
	E_ID,						E_EMAIL[ 64 ],					E_MODE,
	bool: E_VERIFIED,			E_LAST_DISABLED
};

new
	p_accountSecurityData		[ MAX_PLAYERS ] [ E_IRRESISTIBLE_GUARD ]
;

/* ** Roulette ** */
enum E_ROULETTE_OFFSET_DATA
{
	E_VALUE, Float: E_OFFSET, Float: E_ANGLE
};

new
	Float: g_rouletteOffsets[ ] [ E_ROULETTE_OFFSET_DATA ] = {

		{ 0, 0.6, 85.0 }, // 0

		// 1, 2, 3
		{ 1, 0.50, 110.0 }, { 2, 0.44, 85.0 }, { 3, 0.55, 55.0 },

		// 4, 5, 6
		{ 4, 0.31, 120.0 }, { 5, 0.3, 75.0 }, { 6, 0.43, 40.0 },

		// 7, 8, 9
		{ 7, 0.20, 147.0 }, { 8, 0.13, 55.0 }, { 9, 0.32, 18.0 },

		// 10, 11, 12
		{ 10, 0.17, 195.0 }, { 11, 0.08, -25.0 }, { 12, 0.32, -10.0 },

		// 13, 14, 15
		{ 13, 0.25, 230.0 }, { 14, 0.22, -70.0 }, { 15, 0.38, -33.0 },

		// 16, 17, 18
		{ 16, 0.39, 244.0 }, { 17, -0.35, 103.0 }, { 18, 0.48, -48.0 },

		// 19, 20, 21
		{ 19, 0.53, 251.0 }, { 20, 0.51, 278.0 }, { 21, 0.6, -58.0 },

		// 22, 23, 24
		{ 22, 0.68, 256.0 }, { 23, 0.66, 276.0 }, { 24, 0.73, 295.0 },

		// 25, 26, 27
		{ 25, 0.82, 259.0 }, { 26, 0.81, 275.0 }, { 27, 0.87, 292.0 },

		// 28, 29, 30
		{ 28, 0.97, 261.0 }, { 29, 0.96, 275.0 }, { 30, 1.01, 289.0 },

		// 31, 32, 33
		{ 31, 1.12, 264.0 }, { 32, 1.12, 274.0 }, { 33, 1.17, 286.0 },

		// 34, 35, 36
		{ 34, 1.28, 264.0 }, { 35, 1.27, 274.0 }, { 36, 1.31, 284.0 },

		// 3to1, 3to1, 3to1
		{ 3211, 1.43, 264.0 }, { 3212, 1.42, 273.0 }, { 3213, 1.45, 283.0 },

		// 1-18, even, 1st to 12
		{ 118, 0.73, 152.0 },{ 222, 0.65, 178.0 }, { 112, 0.46, 153.0 },

		// red, black, 2nd 12
		{ 88, 0.7, 202.0 }, { 44, 0.87, 222.0 }, { 212, 0.59, 227.0 },

		// odd, 19 to 36, 3rd 12
		{ 333, 1.09, 233.0 }, { 1936, 1.35, 241.0 },{ 312, 1.12, 249.0 }

	}
;

enum E_ROULETTE_DATA
{
	E_OBJECT, 					E_SPINNER_OBJECT, 				E_SPINNING_TIMER,
	bool: E_NO_MORE_BETS,

	Float: E_X, 				Float: E_Y, 					Float: E_Z,
	Float: E_ROTATION
};


new
	g_rouletteTableData			[ MAX_ROULETTE_TABLES ] [ E_ROULETTE_DATA ],
	Iterator:roulettetables<MAX_ROULETTE_TABLES>,

	g_rouletteChipColor			[ MAX_PLAYERS ],
	g_rouletteChip				[ MAX_PLAYERS ] [ sizeof( g_rouletteOffsets ) ],
	g_rouletteChipValue			[ MAX_PLAYERS ] [ sizeof( g_rouletteOffsets ) ],
	Text3D: g_rouletteChipLabel	[ MAX_PLAYERS ] [ sizeof( g_rouletteOffsets ) ],
	p_rouletteBetValue			[ MAX_PLAYERS ],

	p_RouletteMarkerTimer 		[ MAX_PLAYERS ] = { -1, ... },
	p_RouletteMarker 			[ MAX_PLAYERS ] = { -1, ... },
	p_RouletteTable 			[ MAX_PLAYERS ] = { -1, ... },
	p_RouletteMarkerColumn 		[ MAX_PLAYERS char ],
	bool: p_rouletteBetLocked 	[ MAX_PLAYERS char ]
;

/* ** Race System ** */
#define MAX_RACES 				( 32 )

#define RACE_STREET_RACE 		0
#define RACE_OUTRUN 			1
#define OUTRUN_DIST 			6.0

enum E_RACE_DATA
{
	E_LOBBY_HOST, 				E_MODE, 						E_ENTRY_FEE,
	E_POOL, 					E_RACE_FINISH_SET, 				Float: E_FINISH_POS[ 3 ],
	E_CD_TIMER,					E_FINISH_MAP_ICON, 				Float: E_POSITION_PRIZE[ 3 ],
	E_START_CHECKPOINT,  		E_FINISH_CHECKPOINT, 			E_FINISHED_COUNT,
	bool: E_STARTED, 			E_OUTRUN_SPHERE, 				E_OUTRUN_OBJECT,
	E_OUTRUN_LEAD, 				E_OUTRUN_TIMER, 				Float: E_OUTRUN_DISTANCE
};

enum E_RACE_DEST_DATA
{
	E_NAME[ 16 ],
	Float: E_X, 				Float: E_Y, 					Float: E_Z
};

new
	g_raceFinalDestinations[ ] [ E_RACE_DEST_DATA ] =
	{
		{ "LS Airport", 		1487.0245, -2493.751, 13.2720 },
		{ "LS Pier", 			369.61540, -2011.367, 7.39200 },
		{ "LS Grove Street", 	2487.9739, -1666.938, 13.0633 },
		{ "LV Airport", 		1477.6246, 1207.3376, 10.8203 },
		{ "LV Old Strip", 		2350.5371, 2143.6689, 10.6815 },
		{ "El Quebrados",		-885.4323, 1660.3818, 27.0871 },
		{ "SF Airport", 		-1117.212, 375.26310, 14.1484 },
		{ "Mount Chiliad", 		-2324.256, -1624.915, 483.883 },
		{ "SF Gant Bridge", 	-2681.314, 1763.9274, 68.4844 },
		{ "SF Dealership ",		-2422.670, -609.4055, 132.562 }
	},
	g_raceData[ MAX_RACES ] [ E_RACE_DATA ],
	Iterator:races<MAX_RACES>,
	p_raceLobbyId[ MAX_PLAYERS ] = { -1, ... },
	p_raceInvited[ MAX_PLAYERS ] [ MAX_RACES ]
;

/* ** VIP House Display ** */
#define MAX_BUSINESSES				( 150 )
#define MAX_DROPS 					( 5 )
#define MAX_BUSINESS_MEMBERS 		( 8 )
#define MAX_BIZ_VEH_MODELS 			( 18 )
#define MAX_BIZ_ACTORS			 	( 9 )

#define BUSINESS_WEED				( 0 )
#define BUSINESS_METH				( 1 )
#define BUSINESS_COKE 				( 2 )
#define BUSINESS_WEAPON 			( 3 )

#define MAX_WEED_AMOUNT				( 30 )
#define MAX_METH_AMOUNT 			( 20 )
#define MAX_COKE_AMOUNT 			( 10 )
#define MAX_WEAPON_AMOUNT 			( 10 )

#define IsBusinessAerialVehicle(%0,%1) (%1 == g_businessData[%0][E_HELI_MODEL_ID])

enum E_BUSINESS_DATA
{
	E_NAME[ 32 ],				E_COST,							E_WORLD,
	E_OWNER_ID,					E_INTERIOR_TYPE,				E_MEMBERS[ MAX_BUSINESS_MEMBERS ],

	E_SUPPLIES,					E_PRODUCT,						Text3D: E_PROD_LABEL,
	E_PROD_TIMESTAMP, 			E_BANK,

	E_CAR_MODEL_ID,				E_HELI_MODEL_ID,				E_EXTRA_MEMBERS,
	bool: E_CAR_NOS,			bool: E_CAR_RIMS,				E_UPGRADES,

	E_EXPORT_CP[ MAX_DROPS ],	E_EXPORT_ICON[ MAX_DROPS ],		E_EXPORT_INDEX[ MAX_DROPS ],
	E_EXPORT_VALUE,				E_EXPORT_CIRCLE[ MAX_DROPS ],	E_EXPORT_STARTED,
	E_EXPORT_CITY,				bool: E_EXPORTED[ MAX_DROPS ],	E_EXPORTED_AMOUNT,

	Float: E_X, 				Float: E_Y, 					Float: E_Z,
	E_ENTER_CP,					E_EXIT_CP,						E_VEHICLE_DECOR,
	Text3D: E_ENTER_LABEL, 		Text3D: E_EXIT_LABEL,
};

enum E_BUSINESS_INT_DATA
{
	E_NAME[ 8 ],

	Float: E_X, 				Float: E_Y, 				Float: E_Z,
	Float: E_PROD_X, 			Float: E_PROD_Y, 			Float: E_PROD_Z,

	E_COST_PRICE,				E_PRODUCTION_TIME, 			E_MAX_SUPPLIES,
	E_UPGRADE_COST
};

enum E_BUSINESS_VEHICLE_DATA
{
	E_ID, // used only for saving it in the database (change MAX_BIZ_VEH_MODEL on new entry)

	E_NAME[ 12 ],				E_MODEL,					E_BOOT_OPEN,

	E_OBJECT_MODEL,
	Float: E_O_X,				Float: E_O_Y,				Float: E_O_Z,
	Float: E_O_RX,				Float: E_O_RY,				Float: E_O_RZ,

	E_COST
};

new
	g_businessInteriorData 			[ 4 ] [ E_BUSINESS_INT_DATA ] =
	{
		{ "Weed",	 -1719.1877, -1377.3049, 5874.8721, -1734.094, -1374.4567, 5874.1475, 10000, 12, MAX_WEED_AMOUNT, 2500000 },
		{ "Meth",	 2040.54810, 1011.41470, 1513.2777, 2029.2456, 1003.55200, 1510.2416, 18000, 16, MAX_METH_AMOUNT, 4000000 },
		{ "Coke",  	 2566.50070, -1273.2887, 1143.7203, 2558.5261, -1290.6298, 1143.7242, 50000, 20, MAX_COKE_AMOUNT, 7500000 },
		{ "Weapons", -4314.9248, 195.699300, 1303.4542, -4306.674, 223.979000, 1303.6268, 125000, 48, MAX_WEAPON_AMOUNT, 16000000 }
	},
	g_businessCarModelData[ ] [ E_BUSINESS_VEHICLE_DATA ] =
	{
		{ -1, "Yosemite",	554, 0,  3800, 0.000000, -1.200000, 0.000000, 0.000000, 0.000000, 0.000000, 0 },
		{ 0,  "Buccaneer", 	518, 0,  1279, 0.000000, -2.250000, -0.07500, 21.60000, 0.000000, 0.000000, 500000 },
		{ 1,  "Dune", 		573, 0,     0, 0.000000, 0.0000000, 0.000000, 0.000000, 0.000000, 0.000000, 1000000 },
		{ 2,  "Sabre", 		475, 1,  1279, 0.000000, -2.175000, -0.07500, 24.30000, 0.000000, 0.000000, 2500000 },
		{ 3,  "Patriot", 	470, 1,  1279, 0.000000, -1.800000, 0.150000, 29.70000, 0.000000, 0.000000, 10000000 },
		{ 4,  "Buffalo", 	402, 1,  1279, 0.000000, -2.250000, 0.225000, 140.3999, 0.000000, 0.000000, 15000000 },
		{ 5,  "Elegy", 		562, 1,  1279, 0.000000, -1.875000, 0.075000, 21.60000, 0.000000, 0.000000, 18000000 },
		{ 6,  "Savanna", 	567, 1,  1279, 0.000000, -1.875000, 0.075000, 21.60000, 0.000000, 0.000000, 20000000 },
		{ 7,  "Sultan", 	560, 1,  1279, 0.000000, -1.875000, 0.150000, 29.70000, 0.000000, 0.000000, 25000000 },
		{ 8,  "Infernus", 	411, 0,     0, 0.000000, 0.0000000, 0.000000, 0.000000, 0.000000, 0.000000, 27500000 },
		{ 9,  "Turismo", 	451, 0, 18694, 0.000000, -2.475000, -1.95000, 0.000000, 0.000000, 180.0000, 30000000 },
		{ 10, "ChuffSec",	428, 0, 19601, -0.075000, 3.000001, -0.52499, -10.800000, 0.0000, 180.8998, 1337 }
	},
	g_businessAirModelData[ ] [ E_BUSINESS_VEHICLE_DATA ] =
	{
		{ -1, "Levetian", 	417, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0 },
		{ 11, "Raindance",	563, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 5000000 },
		{ 12, "Sparrow",	469, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 12500000 },
		{ 13, "Shamal", 	519, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 17500000 },
		{ 14, "Dodo", 		593, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 20000000 },
		{ 15, "Maverick", 	487, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 25000000 },
		{ 16, "Rustler", 	476, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 30000000 },
		{ 17, "Seasparrow",	447, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1337 }
	},
	Float: g_roadBusinessExportData[ 3 ] [ 20 ] [ 3 ] =
	{
		// sf
		{
			{ -1955.7727, -859.1984, 31.6437 }, { -1821.7363, -175.0119, 8.97350 }, { -2052.4871, -42.96680, 34.9414 }, { -2474.6616, -128.5411, 25.2988 },
			{ -2755.9614, -130.8518, 6.41240 }, { -2796.0234, 772.94480, 50.2686 }, { -2471.4382, 786.22140, 35.1719 }, { -2438.4072, 1038.4346, 50.1885 },
			{ -2513.1267, 1217.6478, 36.9885 }, { -2141.8496, 1217.6788, 47.1079 }, { -2049.0244, 1108.5524, 53.1531 }, { -1822.6821, 1302.3539, 59.2771 },
			{ -1629.2491, 886.42290, 8.97560 }, { -1808.1614, 781.52560, 30.2879 }, { -1758.9180, 515.09530, 28.1970 }, { -2191.0745, 1031.4736, 79.8809 },
			{ -2495.9778, 322.49280, 30.3050 }, { -2496.6187, 153.75120, 7.07910 }, { -2278.0718, 0.8677000, 34.9636 }, { -1931.6978, 268.7024, 40.6186 }
		},

		// lv
		{
			{ 2213.5220, 1968.3105, 10.4767 }, { 2636.1663, 1070.0991, 10.5039 }, { 2524.9036, 918.76700, 10.5057 }, { 2452.5000, 697.58150, 11.1406 },
			{ 2493.1589, 1211.8390, 10.5000 }, { 2810.7197, 2021.3927, 10.5000 }, { 2825.9368, 2602.4082, 10.5000 }, { 2113.6406, 2416.5217, 49.2031 },
			{ 1747.8733, 2240.5823, 10.5000 }, { 1062.3818, 2071.9485, 10.5000 }, { 1165.3585, 1998.6810, 10.5000 }, { 1091.2410, 1890.5908, 10.5000 },
			{ 1461.9596, 972.89570, 9.81850 }, { 1696.4849, 918.22110, 10.4934 }, { 1920.3811, 959.92890, 10.4965 }, { 2490.7720, 2397.3308, 3.89006 },
			{ 423.12482, 2547.1460, 16.2824 }, { -141.1849, 1239.3811, 19.4340 }, { -106.3463, 1373.7528, 10.2663 }, { -830.0345, 1461.5646, 14.3749 }
		},

		// ls
		{
			{ 2473.6917, -1692.1799, 13.0918 }, { 2299.9851, -1796.2080, 13.1327 }, { 2185.0979, -1669.2697, 14.1983 }, { 2087.7139, -1569.9736, 12.7890 },
			{ 2352.3740, -1159.1722, 27.2014 }, { 1027.1260, -1364.0104, 13.4350 }, { 369.96310, -2043.9053, 7.54070 }, { 1449.2119, -1842.7052, 13.4189 },
			{ 1859.6608, -1855.0867, 13.4456 }, { 1924.1621, -2124.3977, 13.4511 }, { 2107.5293, -2416.4065, 13.4130 }, { 2174.3906, -2265.9956, 13.2424 },
			{ 2780.3481, -2494.4780, 13.5250 }, { 2457.3801, -1969.2207, 13.3801 }, { 1826.3085, -1125.9072, 23.8518 }, { 973.43920, -1257.8624, 16.6373 },
			{ 1344.5089, -1752.9572, 13.0808 }, { 1315.9122, -918.28160, 37.7431 }, { 995.74950, -921.07030, 41.8990 }, { 659.64170, -1417.0704, 13.5658 }
		}
	},
	Float: g_airBusinessExportData[ 3 ] [ 20 ] [ 3 ] =
	{
		// SF
		{
			//-1860.0874,801.0096,117.2762
			{ -2031.557617, -32.978599, 56.509998 }, { -2150.111572, -251.47599, 47.49000 }, { -2550.367431, 64.2822030, 25.639999 }, { -2786.211425, 784.576416, 59.41999 },
			{ -2632.868896, 1417.777709, 24.76000 }, { -1542.633800, 924.657800, 6.611400 }, { -1466.235473, 920.849975, 29.129999 }, { -1538.288696, 86.039398, 17.319999 },
			{ -1854.864379, -153.065704, 21.64999 }, { -2522.358642, -654.40240, 147.8999 }, { -2676.479248, 250.410903, 14.350000 }, { -2476.141357, 785.419372, 35.16999 },
			{ -1421.171142, -559.867370, 14.14000 }, { -1944.489624, -1035.7249, 53.34000 }, { -1983.709960, 751.809082, 85.919998 }, { -1870.065917, 970.645812, 49.79999 },
			{ -1864.599975, 807.597290, 112.54000 }, { -1778.899047, 574.798583, 234.8899 }, { -2232.311035, 133.423599, 57.900001 }, { -1766.309082, 1018.421386, 97.7099 }
		},

		// LV
		{
			{ 1529.842651, 1028.566040, 10.819999 }, { 2586.644042, 1120.391113, 16.729999 }, { 2644.996826, 1771.328125, 18.799999 }, { 2778.071289, 2595.210449, 10.81999 },
			{ 2555.316650, 2312.920410, 10.819999 }, { 2484.965087, 2342.515625, 10.819999 }, { 2388.430664, 2813.810058, 10.819999 }, { 923.603027, 2164.776367, 10.819999 },
			{ 1742.377441, 2216.271240, 10.819999 }, { 1141.489501, 1961.233642, 10.819999 }, { 697.5897820, 1983.606567, 8.6300000 }, { 431.901306, 2544.465820, 21.600000 },
			{ 1449.718750, 2370.324462, 10.819999 }, { 2046.728759, 2233.209716, 10.819999 }, { 1714.863769, 1795.094116, 10.819999 }, { 2301.520751, 1734.541748, 10.81999 },
			{ 2436.147949, 716.4329830, 10.819999 }, { 1902.672119, 950.4011230, 10.819999 }, { -164.004104, 1227.733764, 19.739999 }, { -823.314025, 1454.987060, 13.93999 }
		},

		// LS
		{
			{ 2491.046875, -1669.197143, 13.329999 }, { 2418.060302, -1232.265502, 24.43000 }, { 1211.151855, -1097.152343, 25.459999 }, { 666.427124, -1289.167236, 13.460000 },
			{ 1289.633911, -787.4636230, 96.449996 }, { 656.0767820, -1865.779418, 5.460000 }, { 369.996093, -2029.1451410, 7.6700000 }, { 708.949829, -1430.432617, 13.529999 },
			{ 1005.249572, -1349.099853, 13.340000 }, { 1480.326782, -1895.195922, 22.27000 }, { 1119.803833, -2037.035400, 78.209999 }, { 1657.912231, -1705.729614, 20.47999 },
			{ 1923.681030, -1679.990112, 13.539999 }, { 1700.012207, -2146.625732, 13.53999 }, { 1700.012207, -2146.625732, 13.539999 }, { 2746.048583, -2445.280273, 13.64000 },
			{ 1908.276855, -1319.675048, 14.189999 }, { 1286.067504, 181.42990100, 20.27000 }, { 2314.976318, -4.973299000, 32.529998 }, { 665.014404, -614.880187, 16.3299999 }
		}
	},
	g_businessData					[ MAX_BUSINESSES ] [ E_BUSINESS_DATA ],
	g_businessActors				[ MAX_BUSINESSES ] [ MAX_BIZ_ACTORS ],
	g_isBusinessVehicle 			[ MAX_VEHICLES ] = { -1, ... },
	g_businessVehicle 				[ MAX_BUSINESSES ] = { INVALID_VEHICLE_ID, ... },
	bool: g_businessVehicleUnlocked [ MAX_BUSINESSES ] [ MAX_BIZ_VEH_MODELS char ],
	Iterator:business<MAX_BUSINESSES>
;

/* ** Blackjack ** */
#define MAX_BLACKJACK_TABLES 		( 32 )
#define MAX_BLACKJACK_CARDS 		( 5 )
#define MAX_BLACKJACK_PLAYERS 		( 3 )
#define BLACKJACK_DEALER_WAIT 		( 500 )
#define BLACKJACK_PLAYER_WAIT 		( 10 )

#define BLACKJACK_STATE_NONE 		( 0 )
#define BLACKJACK_STATE_TURN 		( 1 )
#define BLACKJACK_STATE_BUST 		( 2 )
#define BLACKJACK_STATE_STAND 		( 3 )
#define BLACKJACK_STATE_WIN 		( 4 )

enum E_BLACKJACK_DATA
{
    bool: E_GAME_STARTED,   E_CARDS_DRAWN,          E_GAME_TIMER,

    E_PAYOUT,

    E_OBJECT,               E_ACTOR,
    Float: E_X,             Float: E_Y,             Float: E_Z,
    Float: E_ROTATION
};

new
    g_blackjackData 				[ MAX_BLACKJACK_TABLES ] [ E_BLACKJACK_DATA ],
    Text: g_blackjackTurnTD			[ MAX_BLACKJACK_TABLES ] = { Text: INVALID_TEXT_DRAW, ... },
    Text: g_blackjackPlayerCards	[ MAX_BLACKJACK_TABLES ] [ MAX_BLACKJACK_CARDS ] [ MAX_BLACKJACK_PLAYERS ],
    Text: g_blackjackDealerCards	[ MAX_BLACKJACK_TABLES ] [ MAX_BLACKJACK_CARDS ],
    g_blackjackDealerCardIndex		[ MAX_BLACKJACK_TABLES ] [ MAX_BLACKJACK_CARDS ],
    g_blackjackPlayerCardIndex		[ MAX_BLACKJACK_TABLES ] [ MAX_BLACKJACK_CARDS ] [ MAX_BLACKJACK_PLAYERS ],
    g_blackjackPlayerState			[ MAX_BLACKJACK_TABLES ] [ MAX_BLACKJACK_PLAYERS ],
    g_blackjackSlotData				[ MAX_BLACKJACK_TABLES ] [ MAX_BLACKJACK_PLAYERS ],
    p_blackjackTable				[ MAX_PLAYERS ] = { -1, ... },
    Iterator:blackjacktables<MAX_BLACKJACK_TABLES>
;

/* ** Visage Apartments ** */

/* ** Player Data ** */
new
    bool: p_Spawned    				[ MAX_PLAYERS char ],
    bool: p_PlayerLogged    		[ MAX_PLAYERS char ],
    p_AccountID						[ MAX_PLAYERS ],
    p_AdminLevel       				[ MAX_PLAYERS ],
    bool: p_Detained          		[ MAX_PLAYERS char ],
    p_Class 						[ MAX_PLAYERS ],
    p_Job               			[ MAX_PLAYERS char ],
    p_VIPJob               			[ MAX_PLAYERS char ],
    bool: p_JobSet            		[ MAX_PLAYERS char ],
    bool: p_CitySet            		[ MAX_PLAYERS char ],
  	p_JailTime          			[ MAX_PLAYERS ],
  	p_AdminJailed					[ MAX_PLAYERS char ],
   	p_JailTimer       				[ MAX_PLAYERS ],
    bool: p_Jailed          	  	[ MAX_PLAYERS char ],
   	p_WantedLevel       			[ MAX_PLAYERS ],
    bool: p_Tazed           	  	[ MAX_PLAYERS char ],
  	p_LastVehicle       			[ MAX_PLAYERS ] = { INVALID_VEHICLE_ID, ... },
  	bool: p_Cuffed          	  	[ MAX_PLAYERS char ],
	p_CuffAbuseTimer    			[ MAX_PLAYERS ],
 	p_Cash              			[ MAX_PLAYERS ],
 	p_AntiRobSpam       			[ MAX_PLAYERS ],
 	p_AntiRapeSpam      			[ MAX_PLAYERS ],
  	bool: p_Tied            	  	[ MAX_PLAYERS char ],
 	p_Ropes             			[ MAX_PLAYERS ],
  	bool: p_Kidnapped       	  	[ MAX_PLAYERS char ],
  	bool: p_ToggledViewPM        	[ MAX_PLAYERS char ],
  	p_TicketTimestamp  				[ MAX_PLAYERS ],
   	p_TicketIssuer           		[ MAX_PLAYERS ] = { INVALID_PLAYER_ID, ... },
	p_CheckpointEnterTick   	    [ MAX_PLAYERS ],
	bool: p_pausedToLoad    	    [ MAX_PLAYERS char ],
	bool: p_CantUseReport           [ MAX_PLAYERS char ],
	p_pausedToLoadTimer     	    [ MAX_PLAYERS ],
	p_BankMoney               	 	[ MAX_PLAYERS ],
	p_OwnedHouses                   [ MAX_PLAYERS ],
	p_OwnedVehicles                 [ MAX_PLAYERS ],
	p_OwnedBusinesses				[ MAX_PLAYERS ],
	p_TrackingTimer             	[ MAX_PLAYERS ] = { INVALID_TIMER_ID, ... },
	p_ContractedAmount          	[ MAX_PLAYERS ],
	p_MetalMelter                   [ MAX_PLAYERS ],
	p_HouseSpawnLocation            [ MAX_PLAYERS ] = { -1, ... },
	p_Kills                         [ MAX_PLAYERS ],
	p_Deaths                        [ MAX_PLAYERS ],
	p_VIPLevel                     	[ MAX_PLAYERS ],
	p_XP                            [ MAX_PLAYERS ],
	p_CureDealer                    [ MAX_PLAYERS ] = { INVALID_PLAYER_ID, ... },
	p_CureTick                      [ MAX_PLAYERS ],
	p_HealDealer					[ MAX_PLAYERS ] = { INVALID_PLAYER_ID, ... },
	p_HealTick						[ MAX_PLAYERS ],
	bool: p_Spectating            	[ MAX_PLAYERS char ],
	bool: p_Muted                   [ MAX_PLAYERS char ],
	bool: p_InfectedHIV             [ MAX_PLAYERS char ],
	p_InHouse                       [ MAX_PLAYERS ],
	p_ExperienceHideTimer           [ MAX_PLAYERS ],
	p_AntiTextSpam                  [ MAX_PLAYERS ],
	p_DetainedBy                    [ MAX_PLAYERS ],
	bool: p_BlockedPM            	[ MAX_PLAYERS ] [ MAX_PLAYERS ],
	bool: p_inFBI                   [ MAX_PLAYERS char ],
	bool: p_inArmy                  [ MAX_PLAYERS char ],
	p_MutedTime                     [ MAX_PLAYERS ],
    p_AntiCommandSpam               [ MAX_PLAYERS ],
    p_PmResponder                  	[ MAX_PLAYERS ] = { INVALID_PLAYER_ID, ... },
    bool: justConnected        		[ MAX_PLAYERS char ],
	p_BailOfferer                   [ MAX_PLAYERS ] = { INVALID_PLAYER_ID, ... },
	p_DamageTDTimer                 [ MAX_PLAYERS ] = { -1, ... },
	Text3D: p_InfoLabel             [ MAX_PLAYERS ] = { Text3D: INVALID_3DTEXT_ID, ... },
	p_InfoLabelString               [ MAX_PLAYERS ] [ 32 ],
	bool: p_inMovieMode             [ MAX_PLAYERS char ],
	bool: p_inCIA                   [ MAX_PLAYERS char ],
	// bool: p_inMayor					[ MAX_PLAYERS char ],
	p_AntiEmpSpam                   [ MAX_PLAYERS ],
	bool: p_inPaintBall           	[ MAX_PLAYERS char ],
	p_Scissors                      [ MAX_PLAYERS ],
	bool: p_TaxTime              	[ MAX_PLAYERS char ],
	bool: p_GPSToggled            	[ MAX_PLAYERS char ],
	p_GPSTimer                      [ MAX_PLAYERS ] = { 0xFF, ... },
	p_GPSLocation               	[ MAX_PLAYERS ],
	p_GPSObject                   	[ MAX_PLAYERS ] = { INVALID_OBJECT_ID, ... },
	p_VIPArmourRedeem               [ MAX_PLAYERS ],
	p_VIPWeaponRedeem               [ MAX_PLAYERS ],
	p_VIPExpiretime                 [ MAX_PLAYERS ],
	p_LastSkin                      [ MAX_PLAYERS ],
	bool: p_MoneyBag                [ MAX_PLAYERS char ],
	p_CopBanned                     [ MAX_PLAYERS char ],
	p_AntiEMP                       [ MAX_PLAYERS ],
	p_FireDistanceTimer             [ MAX_PLAYERS ] = { 0xFF, ... },
	p_Warns                         [ MAX_PLAYERS ],
	p_Wood							[ MAX_PLAYERS ],
	p_LumberjackDeliver				[ MAX_PLAYERS ] = { 0xFFFF, ... },
	p_LumberjackReturn				[ MAX_PLAYERS ] = { 0xFFFF, ... },
	p_LumberjackTimeElapsed			[ MAX_PLAYERS ],
	bool: p_StartedLumberjack		[ MAX_PLAYERS char ],
	p_Uptime                        [ MAX_PLAYERS ],
	p_AchievementTimer              [ MAX_PLAYERS ] = { 0xFF, ... },
	bool: p_SecureWallet          	[ MAX_PLAYERS char ],
	p_WeedGrams                     [ MAX_PLAYERS ],
	p_WeedDealer                    [ MAX_PLAYERS ] = { INVALID_PLAYER_ID, ... },
	p_WeedTick                      [ MAX_PLAYERS ],
	p_WeedSellingGrams 				[ MAX_PLAYERS ],
	p_Arrests                       [ MAX_PLAYERS ],
	bool: p_AidsVaccine          	[ MAX_PLAYERS char ],
	bool: p_CantUseAsk              [ MAX_PLAYERS char ],
	bool: p_AdminLog                [ MAX_PLAYERS char ],
	LastDeath						[ MAX_PLAYERS ],
	DeathSpam						[ MAX_PLAYERS char ],
	bool: p_beingSpectated			[ MAX_PLAYERS ],
	p_whomSpectating				[ MAX_PLAYERS ],
	bool: p_InAnimation        		[ MAX_PLAYERS char ],
	p_AntiSaveStatsSpam				[ MAX_PLAYERS ],
	p_AntiMechFixSpam				[ MAX_PLAYERS ],
	p_AntiMechNosSpam				[ MAX_PLAYERS ],
	p_AntiMechEmpSpam				[ MAX_PLAYERS ],
	bool: p_GivingBlowjob         	[ MAX_PLAYERS char ],
	bool: p_GettingBlowjob         	[ MAX_PLAYERS char ],
	p_AntiBlowJobSpam               [ MAX_PLAYERS ],
	p_EntranceTickcount            	[ MAX_PLAYERS ],
    p_VIPWep1                       [ MAX_PLAYERS char ],
    p_VIPWep2                       [ MAX_PLAYERS char ],
    p_VIPWep3                       [ MAX_PLAYERS char ],
    p_VIPWep_Modify                	[ MAX_PLAYERS char ],
    p_BobbyPins                     [ MAX_PLAYERS ],
    p_IncorrectLogins               [ MAX_PLAYERS char ],
    p_Robberies                     [ MAX_PLAYERS ],
    p_ViewingStats                  [ MAX_PLAYERS ] = { INVALID_PLAYER_ID, ... },
    p_CarWarpTime					[ MAX_PLAYERS ],
    p_CarWarpVehicleID              [ MAX_PLAYERS ],
	p_AntiTextSpamCount				[ MAX_PLAYERS char ],
	Float: p_PlayerBuggerX			[ MAX_PLAYERS ],
	Float: p_PlayerBuggerY			[ MAX_PLAYERS ],
	Float: p_PlayerBuggerZ			[ MAX_PLAYERS ],
	p_DamageSpamTime				[ MAX_PLAYERS ],
	p_DamageSpamCount				[ MAX_PLAYERS char ],
	p_PingImmunity                  [ MAX_PLAYERS char ],
	p_Fires                         [ MAX_PLAYERS ],
	p_ApartmentEnter                [ MAX_PLAYERS char ],
	p_ApartmentEditing              [ MAX_PLAYERS ],
	p_ApartmentSpawnLocation        [ MAX_PLAYERS ] = { -1, ... },
	p_AntiTieSpam                   [ MAX_PLAYERS ],
	p_RansomPlacer                  [ MAX_PLAYERS ] = { INVALID_PLAYER_ID, ... },
	p_RansomAmount                  [ MAX_PLAYERS ],
	p_LastDrovenPoliceVeh			[ MAX_PLAYERS ] = { INVALID_VEHICLE_ID, ... },
	p_AntiTazeSpam                  [ MAX_PLAYERS ],
	Text3D: p_SpawnKillLabel		[ MAX_PLAYERS ] = { Text3D: INVALID_3DTEXT_ID, ... },
	p_AntiSpawnKill                 [ MAX_PLAYERS ],
    bool: p_AntiSpawnKillEnabled	[ MAX_PLAYERS char ],
    p_HitsComplete                  [ MAX_PLAYERS ],
    /*p_CopTutorial                   [ MAX_PLAYERS char ],
    p_CopTutorialProgress			[ MAX_PLAYERS char ],
    p_CopTutorialTick               [ MAX_PLAYERS ],*/
	p_WeaponDealTick				[ MAX_PLAYERS ],
	p_WeaponDealer					[ MAX_PLAYERS ] = { INVALID_PLAYER_ID, ... },
	p_WeaponDealMenu				[ MAX_PLAYERS char ],
	p_WeaponLockerMenu				[ MAX_PLAYERS char ],
	bool: p_WeaponDealing			[ MAX_PLAYERS char ],
	p_BlowjobOfferer				[ MAX_PLAYERS ],
	p_BlowjobDealTick				[ MAX_PLAYERS ],
	p_LastEnteredEntrance          	[ MAX_PLAYERS ] = { -1, ... },
	p_ViewingGangTalk               [ MAX_PLAYERS ] = { -1, ... },
	p_SearchedCountTick	        	[ MAX_PLAYERS ],
	p_SellingWeedTick               [ MAX_PLAYERS ],
	p_AntiKidnapSpam                [ MAX_PLAYERS ],
	p_JoinTimestamp                 [ MAX_PLAYERS ],
	p_PasswordedHouse               [ MAX_PLAYERS ],
	p_HouseWeaponAddSlot            [ MAX_PLAYERS char ],
	Text3D: p_AdminLabel         	[ MAX_PLAYERS ] = { Text3D: INVALID_3DTEXT_ID, ... },
	bool: p_AdminOnDuty             [ MAX_PLAYERS char ],
	p_SelectedFurniture				[ MAX_PLAYERS ] [ 2 ],
	p_FurnitureCategory             [ MAX_PLAYERS char ],
	p_FurnitureRotAxis              [ MAX_PLAYERS char ],
	Float: p_ProgressStatus         [ MAX_PLAYERS ],
	bool: p_ProgressStarted         [ MAX_PLAYERS char ],
	p_HouseCrackingPW				[ MAX_PLAYERS ],
	p_PawnStoreExport				[ MAX_PLAYERS ] = { 0xFFFF, ... },
	p_Burglaries                    [ MAX_PLAYERS ],
    p_ArmyBanned                    [ MAX_PLAYERS char ],
	Text3D: p_DetainedLabel       	[ MAX_PLAYERS ] = { Text3D: INVALID_3DTEXT_ID, ... },
	p_BailTimestamp					[ MAX_PLAYERS ],
	p_AFKTime						[ MAX_PLAYERS ],
	bool: p_ClassSelection			[ MAX_PLAYERS char ],
	p_MiningExport					[ MAX_PLAYERS ] = { 0xFFFF, ... },
	Text3D: p_WeedLabel				[ MAX_PLAYERS ] = { Text3D: INVALID_3DTEXT_ID, ... },
	LastPickupTimestamp				[ MAX_PLAYERS ],
	PreviousPickupID				[ MAX_PLAYERS ],
	//p_LastAnimIndex					[ MAX_PLAYERS ],
	p_SpawningCity					[ MAX_PLAYERS char ],
	bool: p_UsingRadio				[ MAX_PLAYERS char ],
	p_UsingRobberySafe 				[ MAX_PLAYERS ] = { -1, ... },
	bool: p_CancelProgress 			[ MAX_PLAYERS char ],
	p_LumberjackMapIcon 			[ MAX_PLAYERS ] = { 0xFFFF, ... },
	p_PawnStoreMapIcon 				[ MAX_PLAYERS ] = { 0xFFFF, ... },
	p_SpectateWeapons 				[ MAX_PLAYERS ] [ 13 ] [ 2 ],
	bool: p_LeftCuffed 				[ MAX_PLAYERS char ],
	p_LabelColor					[ MAX_PLAYERS ] = { COLOR_GREY, ... },
	p_RapidFireTickCount			[ MAX_PLAYERS ],
	p_RapidFireShots				[ MAX_PLAYERS char ],
	p_BulletInvulnerbility 			[ MAX_PLAYERS ],
	p_ProgressUpdateTimer			[ MAX_PLAYERS ] = { 0xFFFF, ... },
	p_DeathMessage 					[ MAX_PLAYERS ] [ 32 ],
	p_ViewingInterior 				[ MAX_PLAYERS char ],
	p_MethYielded 					[ MAX_PLAYERS ],
	p_CarsJacked 					[ MAX_PLAYERS ],
	p_BankBlown						[ MAX_PLAYERS ],
	p_JailsBlown					[ MAX_PLAYERS ],
	p_AntiExportCarSpam 			[ MAX_PLAYERS ],
	p_AntiMechFlipSpam 				[ MAX_PLAYERS ],
	bool: p_inAlcatraz 				[ MAX_PLAYERS char ],
	Float: p_LastPickupPos 			[ MAX_PLAYERS ] [ 3 ],
	Text3D: p_TiedLabel       		[ MAX_PLAYERS ] = { Text3D: INVALID_3DTEXT_ID, ... },
	p_TiedBy 						[ MAX_PLAYERS ],
	p_BlowjobPrice 					[ MAX_PLAYERS ],
	p_DesyncTime 					[ MAX_PLAYERS ],
	p_AnswerDelay					[ MAX_PLAYERS ],
	p_PlayerIP 						[ MAX_PLAYERS ] [ 16 ],
	p_PlayerName 					[ MAX_PLAYERS ] [ MAX_PLAYER_NAME ],
	p_LastPlayerState 				[ MAX_PLAYERS char ],
	p_RespondDelay 					[ MAX_PLAYERS ],
	p_VisibleOnRadar 				[ MAX_PLAYERS ],
	p_InGarage 						[ MAX_PLAYERS ] = { -1, ... },
	p_WorkCooldown 					[ MAX_PLAYERS ],
	p_AntiSpammyTS 					[ MAX_PLAYERS ],
	p_TruckedCargo 					[ MAX_PLAYERS ],
	Float: p_IrresistibleCoins 		[ MAX_PLAYERS ],
	p_KidnapImmunity				[ MAX_PLAYERS ],
	p_GangSplitProfits 				[ MAX_PLAYERS ],
	Float: p_IrresistiblePoints 	[ MAX_PLAYERS ],
	p_CoinMarketListitem			[ MAX_PLAYERS char ],
	bool: p_CoinMarketSecondPage 	[ MAX_PLAYERS char ],
	p_SafeHelperTimer				[ MAX_PLAYERS ] = { -1, ... },
	p_HouseOfferer					[ MAX_PLAYERS ],
	p_HouseOfferTicks				[ MAX_PLAYERS ],
	p_HouseSellingID				[ MAX_PLAYERS ],
	p_HouseSellingPrice				[ MAX_PLAYERS ],
	p_RansomTimestamp 				[ MAX_PLAYERS ],
	p_QuitToAvoidTimestamp 			[ MAX_PLAYERS ],
	p_TimeTiedAt 					[ MAX_PLAYERS ],
	p_CopRefillTimestamp			[ MAX_PLAYERS ],
	p_AdminCommandPause 			[ MAX_PLAYERS ],
	p_VipPackageName				[ MAX_PLAYERS ] [ 16 ],
	p_WeaponKills					[ MAX_PLAYERS ] [ MAX_WEAPONS ],
	p_ExtraAssetSlots 				[ MAX_PLAYERS char ],
	p_forcedAnticheat				[ MAX_PLAYERS ],
	p_TiedAtTimestamp 				[ MAX_PLAYERS ],
	bool: p_AutoSpin				[ MAX_PLAYERS char ],
	p_InBusiness 					[ MAX_PLAYERS ] = { -1, ... },
	p_VehicleBringCooldown 			[ MAX_PLAYERS ],
	p_BusinessSpawnLocation 		[ MAX_PLAYERS ] = { -1, ... }
;

/* ** Server Data ** */
new
	dbHandle,
    g_Checkpoints           		[ ALL_CHECKPOINTS ],
    szSmallString                  	[ 32 ],
    szBigString                 	[ 256 ],
    szLargeString                   [ 1024 ],
    szHugeString 					[ 2048 ],
	g_redeemVipWait 				= 0,
	g_TrolleyVehicles               [ 5 ],
	engine, lights, doors, bonnet, boot, objective, alarm, panels, tires,
	g_RestoreRobberiesBribes  		= 0,
	g_ServerUptime 					= 0,
	rl_ServerUpdate					= 0xFF,
	rl_ZoneUpdate                   = 0xFF,
	rl_AutoVehicleRespawner         = 0xFF,
	bool: g_adminSpawnedCar     	[ MAX_VEHICLES char ],
	g_WorldClockSeconds             = 0,
	g_WorldDayCount                 = 0,
	g_WorldWeather                  = 10,
	g_LogsInStock 					= 0,
	g_PingLimit                     = 1024,
	g_circleall_CD                  = false,
	g_randomMessageTick 			= 0,
	log__Text						[ 6 ][ 90 ],
	szReportsLog 					[ 8 ][ 128 ],
	szQuestionsLog 					[ 8 ][ 128 ],
	g_preloadedObjectCount          = 0,
	bool: g_ServerLocked            = false,
	bool: g_CommandLogging			= false,
	bool: g_DialogLogging			= false,
	szRules							[ 3300 ],
 	g_BannedDrivebyWeapons 			[ ] =
 	{
 		24, 26, 27, 34, 33
 	},
 	bool: g_Debugging 				= false,
 	bool: g_Driveby 				= false,
 	bool: g_VipPrivateMsging 		= false,
 	bool: g_HappyHour				= false,
 	Float: g_HappyHourRate			= 0.0,
 	g_iTime 						= 0,
 	g_VehicleLastAttacker 			[ MAX_VEHICLES ] = { INVALID_PLAYER_ID, ... },
 	g_VehicleLastAttacked 			[ MAX_VEHICLES ],
	g_TopDonorWall 					= INVALID_OBJECT_ID
;

/* ** Forwards ** */
public OnPlayerDriveVehicle( playerid, vehicleid );
public OnServerUpdate( );
public OnHelpHTTPResponse( index, response_code, data[ ] );
public OnRulesHTTPResponse( index, response_code, data[ ] );
public OnRevCTRLHTTPResponse( index, response_code, data[ ] );
public OnTwitterHTTPResponse( index, response_code, data[ ] );
public OnDonationRedemptionResponse( index, response_code, data[ ] );
public OnPlayerChainsawTree( playerid, treeid );
public OnPlayerArrest( playerid, victimid, totalarrests, totalpeople );
public OnPlayerProgressUpdate( playerid, progressid, params );
public OnPlayerProgressComplete( playerid, progressid, params );
public OnPlayerUnjailed( playerid, reasonid );
public onSafeBust( playerid, robberyid, type, index );
public OnMethamphetamineCooking( playerid, vehicleid, last_chemical );
public VendingMachineUsed( playerid, Float: fHealthGiven );
public OnPlayerUseSlotMachine( playerid, slotid, first_combo, second_combo, third_combo );
public OnPlayerHoldupStore( playerid, clerkid, step );
public OnRouletteWheelStop( rouletteid, winner );
public OnSpinRouletteTable( rouletteid, elapsed, steps );
public OnRouletteMarkerUpdate( playerid );

/* ** Functions ** */
stock Float: distanceFromSafe( iPlayer, iRobbery, &Float: fDistance = Float: 0x7F800000 )
{
    static
    	Float: fX, Float: fY, Float: fZ;

    if ( iRobbery == -1 )
    	return fDistance;

	if ( g_robberyData[ iRobbery ] [ E_WORLD ] != -1 && g_robberyData[ iRobbery ] [ E_WORLD ] != GetPlayerVirtualWorld( iPlayer ) )
		return fDistance;

    if ( GetDynamicObjectPos( g_robberyData[ iRobbery ] [ E_SAFE ], fX, fY, fZ ) )
		fDistance = GetPlayerDistanceFromPoint( iPlayer, fX, fY, fZ );

    return fDistance;
}

main()
{
	print( "\n" #SERVER_NAME "\n" );
}

public OnGameModeInit()
{
	SetGameModeText( "Cops And Robbers" );
	SetServerRule( "hostname", SERVER_NAME );
	SetServerRule( "language", "All (English)" );
	UsePlayerPedAnims( );
	AllowInteriorWeapons( 0 );
	EnableStuntBonusForAll( 0 );
	DisableInteriorEnterExits( );
	// MapAndreas_Init( MAP_ANDREAS_MODE_MINIMAL );

	// mysql_log( LOG_ALL );
	//SetBannedWeapons( 17, 35, 36, 37, 38, 39, 44, 45 );

	//EnableVehicleFriendlyFire( );
	//SetServerRule( "mapname", "San Fierro" );

	/* ** Intalize Data ** */
	InitializeIGTextdraws( );
	initializeTextDraws( );
	initializeCheckpoints( );
	initializeVehicles( );
	initializeServerObjects( );
	initializeObjects( );
	initializeVendingMachines( );
	initializeActors( );

	/* ** Loading default string values - Makes it efficient. ** */
	for( new i = 0; i < sizeof( g_houseInteriors ); i++ ) {
		format( szg_houseInteriors, sizeof( szg_houseInteriors ), "%s%s%s\n", szg_houseInteriors, g_houseInteriors[ i ] [ E_VIP ] ? ( COL_GOLD ) : "", g_houseInteriors[ i ] [ E_NAME ] );
	}

	for( new i = 0; i < sizeof( g_garageInteriorData ); i++ )
		format( szg_garageInteriors, sizeof( szg_garageInteriors ), "%s"COL_GREY"%d Vehicle Slots"COL_WHITE"\t%s\n", szg_garageInteriors, g_garageInteriorData[ i ] [ E_VEHICLE_CAPACITY ], g_garageInteriorData[ i ] [ E_NAME ] );

	strins( g_RadioStations, ""COL_GREY"Custom URL "COL_GOLD"[V.I.P]"COL_WHITE"\n", 0 );
    for( new i = 0; i < sizeof( g_RadioData ); i++ ) {
	    format( g_RadioStations, sizeof( g_RadioStations ), "%s%s\n", g_RadioStations, g_RadioData[ i ] [ E_NAME ] );
	}

	for( new i = 0; i < sizeof( g_informationPickupsData ); i++ )
	{
		g_informationPickupsData[ i ] [ E_PICKUP_ID ] = CreateDynamicPickup( 1239, 2, g_informationPickupsData[ i ] [ E_X ], g_informationPickupsData[ i ] [ E_Y ], g_informationPickupsData[ i ] [ E_Z ] );

		// dont need map icons for interior infos
		if ( g_informationPickupsData[ i ] [ E_Z ] < 800.0 )
			CreateDynamicMapIcon( g_informationPickupsData[ i ] [ E_X ], g_informationPickupsData[ i ] [ E_Y ], g_informationPickupsData[ i ] [ E_Z ], 37, 0, -1, -1, -1, 50.0 );
	}

	/* ** Database Configuration ** */
	dbHandle = mysql_connect( MYSQL_HOST, MYSQL_USER, MYSQL_DB, MYSQL_PASS );

	if ( mysql_errno( dbHandle )  )
		print( "[MYSQL]: Couldn't connect to MySQL database." ), g_ServerLocked = true;
	else
		print( "[MYSQL]: Connection to database is successful." );

	/* ** Server Variables ** */
	AddServerVariable( "taxrate", "5.0", GLOBAL_VARTYPE_FLOAT );
	AddServerVariable( "doublexp", "0", GLOBAL_VARTYPE_INT );
	AddServerVariable( "eventbank", "0", GLOBAL_VARTYPE_INT );
	AddServerVariable( "eventhost", "0", GLOBAL_VARTYPE_INT );
	AddServerVariable( "vip_discount", "1.0", GLOBAL_VARTYPE_FLOAT );
	AddServerVariable( "vip_bonus", "0.0", GLOBAL_VARTYPE_FLOAT );
	AddServerVariable( "proxyban", "0", GLOBAL_VARTYPE_INT );
	AddServerVariable( "roulette_bets", "0.0", GLOBAL_VARTYPE_FLOAT );
	AddServerVariable( "roulette_wins", "0.0", GLOBAL_VARTYPE_FLOAT );
	AddServerVariable( "blackjack_bets", "0.0", GLOBAL_VARTYPE_FLOAT );
	AddServerVariable( "blackjack_wins", "0.0", GLOBAL_VARTYPE_FLOAT );
	AddServerVariable( "connectsong", "http://files.irresistiblegaming.com/game_sounds/Stevie%20Wonder%20-%20Skeletons.mp3", GLOBAL_VARTYPE_STRING );

	mysql_function_query( dbHandle, "SELECT * FROM `SERVER`", true, "OnLoadServerVariables", "" );

	/* ** CIVILIAN ** */
	AddPlayerClass( 119, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 0
	AddPlayerClass( 289, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 1
	AddPlayerClass( 273, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 2
	AddPlayerClass( 271, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 3
	AddPlayerClass( 208, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 4
	AddPlayerClass( 268, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 5
	AddPlayerClass( 292, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 6
	AddPlayerClass( 293, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 7
	AddPlayerClass(  3, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 	8
	AddPlayerClass(  4, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 	9
	AddPlayerClass(  2, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //  10
	AddPlayerClass(  7, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //  11
	AddPlayerClass( 12, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //  12
	AddPlayerClass( 13, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //  13
	AddPlayerClass( 14, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //  14
	AddPlayerClass( 15, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //  15
	AddPlayerClass( 17, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //  16
	AddPlayerClass( 19, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //  17
	AddPlayerClass( 20, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //  18
	AddPlayerClass( 21, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //  19
	AddPlayerClass( 22, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 	20
	AddPlayerClass( 23, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 	21
	AddPlayerClass( 24, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 	22
	AddPlayerClass( 26, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 	23
	AddPlayerClass( 28, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 	24
	AddPlayerClass( 29, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 	25
	AddPlayerClass( 30, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 	26
	AddPlayerClass( 31, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 	27
	AddPlayerClass( 32, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //	28
	AddPlayerClass( 33, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //	29
	AddPlayerClass( 34, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //	30
	AddPlayerClass( 35, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //	31
	AddPlayerClass( 36, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //	32
	AddPlayerClass( 37, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //	33
	AddPlayerClass( 38, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //	34
	AddPlayerClass( 46, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 	35
	AddPlayerClass( 47, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 	36
	AddPlayerClass( 48, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 	37
	AddPlayerClass( 59, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 	38
	AddPlayerClass( 60, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 	39

	AddPlayerClass( 63, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //	40
	AddPlayerClass( 64, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //	41
	AddPlayerClass( 152, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //	42
	AddPlayerClass( 237, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //	43
	AddPlayerClass( 78, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); //	44
	AddPlayerClass( 79, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 	45
	AddPlayerClass( 134, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 46
	AddPlayerClass( 100, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 47
	AddPlayerClass( 101, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 48
	AddPlayerClass( 137, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 49

	/* ** FBI ** */
	AddPlayerClass( 286, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 50
	AddPlayerClass( 71, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 );  // 51
	AddPlayerClass( 285, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 52

	/* ** ARMY ** */
	AddPlayerClass( 287, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 53

	/* ** CIA ** */
	AddPlayerClass( 303, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 54
	AddPlayerClass( 304, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 55
	AddPlayerClass( 305, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 56

	/* ** FIRE ** */
	AddPlayerClass( 277, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 57
	AddPlayerClass( 278, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 58
	AddPlayerClass( 279, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 59

	/* ** MEDIC ** */
	AddPlayerClass( 274, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 60
	AddPlayerClass( 275, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 61
	AddPlayerClass( 276, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 62
	AddPlayerClass( 308, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 63

	/* ** MAYOR ** */
	// AddPlayerClass( 187, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 64
	// AddPlayerClass( 148, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 65

	/* ** POLICE ** */
	AddPlayerClass( 265, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 66
	AddPlayerClass( 266, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 67
	AddPlayerClass( 267, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 68
	AddPlayerClass( 306, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 69
	AddPlayerClass( 280, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 70
	AddPlayerClass( 281, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 71
	AddPlayerClass( 284, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 72
	AddPlayerClass( 307, default_X, default_Y, default_Z, default_Angle, 0, 0, 0, 0, 0, 0 ); // 73

 	/* ** Discord configuration ** */
 	#if ENABLE_DISCORD == true
	discordGuild = DCC_FindGuildById( DISCORD_GENERAL );
	discordGeneralChan = DCC_FindChannelById( DISCORD_GENERAL );
	discordSpamChan = DCC_FindChannelById( DISCORD_SPAM );

	discordRoleExecutive = DCC_FindRoleById( DISCORD_ROLE_EXEC );
	discordRoleHead = DCC_FindRoleById( DISCORD_ROLE_HEAD );
	discordRoleLead = DCC_FindRoleById( DISCORD_ROLE_LEAD );
	discordRoleVIP = DCC_FindRoleById( DISCORD_ROLE_VIP );
	discordRoleVoice = DCC_FindRoleById( DISCORD_ROLE_VOICE );

	DCC_SendChannelMessage( discordGeneralChan, "**The discord plugin has been initiaized.**" );
	#endif

	/* ** Robbery Points ** */
	CreateRobberyCheckpoint( "Bank of San Fierro - Safe 1", 5000, -1400.84180, 862.85895, 984.17200, -90.00000, g_bankvaultData[ CITY_SF ] [ E_WORLD ] );
	CreateRobberyCheckpoint( "Bank of San Fierro - Safe 2", 5000, -1400.84180, 861.17932, 985.07251, -90.00000, g_bankvaultData[ CITY_SF ] [ E_WORLD ] );
	CreateRobberyCheckpoint( "Bank of San Fierro - Safe 3", 5000, -1400.84180, 856.08679, 985.07251, -90.00000, g_bankvaultData[ CITY_SF ] [ E_WORLD ] );
	CreateRobberyCheckpoint( "Bank of San Fierro - Safe 4", 5000, -1400.84180, 858.61407, 984.17200, -90.00000, g_bankvaultData[ CITY_SF ] [ E_WORLD ] );
	CreateRobberyCheckpoint( "San Fierro Airport - Safe 1", 4000, -1894.15894, -17.17650, 1060.88428, 90.00000, -1 );
	CreateRobberyCheckpoint( "San Fierro Airport - Safe 2", 4000, -1894.15808, -19.11643, 1060.88428, 90.00000, -1 );

	CreateRobberyCheckpoint( "Dope's Casino - Safe 1", 3000, -2049.279541, 415.303710, 1959.170898, 0.000000, 68 );
	CreateRobberyCheckpoint( "Dope's Casino - Safe 2", 3000, -2048.228515, 415.303710, 1959.170898, 0.000000, 68 );

	CreateRobberyCheckpoint( "Desperado Cafe", 1500, 2113.085693, -1784.566406, 12.950445, 180.000000, -1 );
	CreateRobberyCheckpoint( "Ahmyy's Cafe", 3000, 2540.558593, 2013.840209, 10.289649, 90.000000, -1 );
	CreateRobberyCheckpoint( "FaZe's Cafe", 3000, 1978.845336, 2066.297607, 10.285301, 90.000000, -1 );

	CreateRobberyCheckpoint( "Le Flawless Cafe", 	3000, -1968.0526, 107.814460, 27.09287800, 0.0000000, -1 );

	CreateRobberyCheckpoint( "Hospital", 			4000, -2638.04638, 662.66967, 969.852905, -90.0000, -1 );

	CreateRobberyCheckpoint( "Sex Shop", 			3000, -108.37336, -8.5235140, 1000.188232, 90.000000, 16, 32, 51, 64 );
	CreateRobberyNPC( "Sex Shop Clerk",				1000, -104.7642, -8.9156, 1000.7188, 181.2191, 126, 16, 32, 51, 64 );

	CreateRobberyCheckpoint( "Off Track Betting", 	3000, 822.189086, 8.22311500, 1004.423278, 169.80003, -1 );
	CreateRobberyNPC( "Betting Clerk",				1000, 820.1871, 2.4114, 1004.1797, 270.8091, 147, -1 );

	CreateRobberyCheckpoint( "Zero's RC Shop", 		3000, -2221.7243, 133.067214, 1035.223022, 180.00000, 6 );
	CreateRobberyNPC( "Zero",						1000, -2238.1279, 128.5869, 1035.4141, 357.9158, 11, 6 );

	CreateRobberyCheckpoint( "Prolaps", 			3000, 204.282577, -126.42620, 1002.937255, 0.0000000, 39, 36 );
	CreateRobberyNPC( "Prolaps Clerk",				1000, 206.3402, -127.8070, 1003.5078, 182.5186, 211, 39, 36 );

	CreateRobberyCheckpoint( "Disco", 				3000, 503.733581, -24.120403, 1000.119323, 270.00000, 17, 71 );
	CreateRobberyNPC( "Disco Bartender",			1000, 501.6992,-20.5021,1000.6797,89.2442, 46, 17, 71 );

	CreateRobberyCheckpoint( "Restaurant", 			3000, -221.27993, 1407.57409, 27.22343200, 0.0000000, 53, 54 );
	CreateRobberyNPC( "Restaurant Owner",			1000, -223.3083,1403.9852,27.7734,91.9926, 168, 53, 54 );

	CreateRobberyCheckpoint( "Brothel", 			3000, 972.080322, -44.324848, 1001.677368, 270.00000, 42 );
	CreateRobberyNPC( "Brothel Manager",			1000, 970.8360, -44.8730, 1001.1172, 92.0651, 113, 42 );

	CreateRobberyCheckpoint( "Ammu-Nation", 		3000, 299.844482, -41.299987, 1000.945068, -137.0001, 15 );
	CreateRobberyNPC( "Gunsdealer",					1000, 296.4001,-40.2152,1001.5156,0.9079, 179, 15 );

	CreateRobberyCheckpoint( "Ammu-Nation", 		3000, 293.467559, -83.653007, 1000.905151, 90.000000, 41, 74 );
	CreateRobberyNPC( "Gunsdealer",					1000, 295.4592,-82.5274,1001.5156,359.9681, 179, 41, 74 );

	CreateRobberyCheckpoint( "Ammu-Nation", 		3000, 313.817565, -168.97615, 999.0332640, -90.00000, 42, 45, 47, 5, 75, 32, 23, 27 );
	CreateRobberyNPC( "Gunsdealer",					1000, 312.8466,-167.7639,999.5938,359.6548, 179, 42, 45, 47, 5, 75, 32, 23, 27 );

	CreateRobberyCheckpoint( "ZIP", 				3000, 163.403289, -79.763473, 1001.274536, -90.00000, 3, 45, 59, 27 );
	CreateRobberyNPC( "ZIP Clerk",					1000, 162.7249, -81.1920,1001.8047, 182.6196, 217, 3, 45, 59, 27 );

	CreateRobberyCheckpoint( "Binco", 				3000, 207.486953, -96.436981, 1004.707275, 0.0000000, 12, 47, 48, 53 );
	CreateRobberyNPC( "Binco Clerk",				1000, 208.8378,-98.7054,1005.2578,183.2461, 217, 12, 47, 48, 53 );

	CreateRobberyCheckpoint( "Victim", 				3000, 200.075378, -5.8953800, 1000.650390, 180.00000, 1, 21, 49 );
	CreateRobberyNPC( "Victim Clerk",				1000, 204.6066, -9.2214, 1001.2109, 268.2160, 211, 1, 21, 49 );

	CreateRobberyCheckpoint( "Suburban", 			3000, 204.337600, -42.350822, 1001.254699, 180.00000, 21, 41, 39 );
	CreateRobberyNPC( "Suburban Clerk",				1000, 203.2509,-41.6712, 1001.8047, 178.8591, 211, 21, 41, 39 );

	CreateRobberyCheckpoint( "Bar", 				3000, 498.197845, -80.020515, 999.3255610, 180.00000, 7, 54, 55, 56, 50, 52, 51, 15, 10, 21, 58, 48, 17, 36, 41, 22 );
	CreateRobberyNPC( "Bartender",					1000, 497.0969,-77.5612,998.7651,1.5118, 124, 7, 54, 55, 56, 50, 52, 51, 15, 10, 21, 58, 48, 17, 36, 41, 22 );

	CreateRobberyCheckpoint( "Burger Shot", 		3000, 381.988861, -56.470348, 1000.957275, 0.0000000, 4, 9, 13, 32, 33, 34, 35, 25, 71, 82 );
	CreateRobberyNPC( "Burger Worker",				1000, 376.5223,-65.8494,1001.5078,182.3066, 205, 4, 9, 13, 32, 33, 34, 35, 25, 71, 82 );

	CreateRobberyCheckpoint( "Cluckin' Bell", 		3000, 371.999816, -2.8117490, 1002.278808, 0.0000000, 5, 14, 35, 36, 62, 60, 23, 39, 13, 16, 12, 70 );
	CreateRobberyNPC( "Chicken Worker",				1000, 368.1003,-4.4928,1001.8516,182.3297, 168, 5, 14, 35, 36, 62, 60, 23, 39, 13, 16, 12, 70 );

	CreateRobberyCheckpoint( "Well Stacked Pizza", 	3000, 380.331146, -116.33708, 1000.951721, -90.00000, 2, 20, 43, 44, 46, 12, 31, 75, 66, 14 );
	CreateRobberyNPC( "Pizza Worker",				1000, 374.6979,-117.2789,1001.4922,182.6662, 155, 2, 20, 43, 44, 46, 12, 31, 75, 66, 14 );

	CreateRobberyCheckpoint( "24/7",      			3000, -8.1804670, -180.76544, 1002.996337, 180.00000, 37, 38, 39, 40, 41, 42, 43, 44, 47, 49 ,51, 48, 11 );
	CreateRobberyNPC( "24/7 Worker",				1000, -27.9842,-186.8359,1003.5469,359.3645, 170, 37, 38, 39, 40, 41, 42, 43, 44, 47, 49 ,51, 48, 11 );

	CreateRobberyCheckpoint( "Barber", 				3000, 408.697540, -56.045413, 1001.337951, 180.00000, 23, 24, 48, 21, 18, 22, 20 );
	CreateRobberyNPC( "Barber",						1000, 408.9915,-53.8337,1001.8984,270.7148, 176, 23, 24, 48, 21, 18, 22, 20 );

	CreateRobberyCheckpoint( "Donut Shop", 			3000, 382.513519, -186.95924, 1001.132995, -90.00000, 19, 20, 10 );
	CreateRobberyNPC( "Donut Worker",				1000, 380.7286,-189.1152,1000.6328,182.3538, 8, 19, 20, 10 );

	CreateRobberyCheckpoint( "Strip Club", 			3000, 1211.94897, -16.312891, 1001.421752, 180.00000, 3, 22 );
	CreateRobberyNPC( "Stripper",					1000, 1214.2621,-15.2605,1000.9219,359.1004, 246, 3, 22 );

	CreateRobberyCheckpoint( "Otto's cars", 		3000, -1657.9169, 1206.51867, 6.709994000, 180.00000, 0 );
	CreateRobberyNPC( "Otto",						1000, -1656.4574,1207.9980,7.2500,329.9846, 113, 0 );

	CreateRobberyCheckpoint( "Wang Cars", 			3000, -1950.5010, 302.176483, 34.91876200, -90.00000, 0 );
	CreateRobberyNPC( "Salesman",					1000, -1955.2711,302.1761,35.4688,89.4329, 17, 0 );

	CreateRobberyCheckpoint( "Jizzy's", 			3000, -2664.4997, 1425.92639, 906.3808590, -90.00000, 18 );
	CreateRobberyNPC( "Jizzy",						1000, -2655.5063,1407.4214,906.2734,268.8851, 296, 18 );

	CreateRobberyCheckpoint( "Didier Sachs", 		3000, 206.808502, -154.71282, 999.953369, 0.0000000, 14 );
	CreateRobberyNPC( "Didier Sach Clerk",			1000, 203.2169,-157.8303,1000.5234,180.5475, 211, 14 );

	CreateRobberyCheckpoint( "Steakhouse", 			3000, 441.5401, -81.9713, 999.0115, 90.00000, 53, 54, 23, 27, 22 );
	CreateRobberyNPC( "Steakhouse Owner",			1000, 449.4273, -82.2324, 999.5547, 179.9200, 168, 53, 54, 23, 27, 22 );

	CreateRobberyCheckpoint( "Church", 				3000, 1964.06933, -349.55651, 1096.640380, 0.0000000, 1 );
	CreateRobberyNPC( "Priest",						1000, 1964.0864,-371.6995,1093.7289,358.7696, 68, 1 );

	CreateRobberyCheckpoint( "Church", 				3000, 2391.02685, 3195.78417, 1016.920837, -90.00000, 39, 40, 41, 62, 24 );
	CreateRobberyNPC( "Priest",						1000, 2383.1968,3193.2842,1017.7320,1.0113, 68, 39, 40, 41, 62, 24 );

	CreateRobberyCheckpoint( "Hotel de Solanum", 	3000, -1967.8662, 1367.76819, 6.879500000, 86.700000, 0 );
	CreateRobberyNPC( "Hotel Bartender",			1000, -1944.5562,1362.2947,7.3546,86.4801, 126, 0 );

	CreateRobberyCheckpoint( "Vehicle Dealership",	3000, -1862.6997, -652.83700, 1001.578125, -89.80000, 0 );
	CreateRobberyNPC( "Vehicle Dealer",				1000, -1864.9419,-648.5046,1002.1284,357.5644, 186, 0 );

	CreateRobberyCheckpoint( "Vehicle Dealership",	3000, -125.97293, 122.011770, 1004.083740, 0.000000, 31, 32 );
	CreateRobberyNPC( "Vehicle Dealer",				1000, -125.2779,121.3010,1004.7233,345.3443, 186, 31, 32 );

	CreateRobberyCheckpoint( "Bank",				3000, 2164.90844, 1649.77392, 1041.061889, 90.000000, 45, 24, 25, 78 );
	CreateRobberyNPC( "Banker",						1000, 2157.9255,1647.9972,1041.6124,270.1911, 17, 45, 24, 25, 78 );

	CreateRobberyCheckpoint( "Pawnshop", 			3000, 1331.449707, -1079.761108, 967.495605, -90.00000, 11, 22, 33 );
	CreateRobberyNPC( "Pawnbroker",					1000, 1330.7424,-1081.0117,968.0360,270.1916, 261, 11, 22, 33 );

	CreateRobberyCheckpoint( "Gas Station",      	3000, -20.58315, -58.06674, 1002.99329, 180.00000, 28, 29, 49, 32, 33, 34, 20, 52, 56, 73, 92, 68, 74, 77 );
	CreateRobberyNPC( "Gas Cashier",				1000, -22.2767,-57.6385,1003.5469,354.5035, 7, 28, 29, 49, 32, 33, 34, 20, 52, 56, 73, 92, 68, 74, 77 );

	CreateRobberyCheckpoint( "Drug House", 			7000, 2201.00952, -1212.8709, 1048.462890, 0.0000000, 11, 26, 27, 94, 31, 44, 10, 15 );
	CreateRobberyNPC( "Triad Boss",					2500, 2200.4556,-1218.9237,1049.0234,30.6198, 120, 11, 44, 27, 94 ); // TRIADS
	CreateRobberyNPC( "Mafia Boss",					2500, 2200.4556,-1218.9237,1049.0234,30.6198, 272, 31, 26, 10, 15 ); // Mafia

	CreateRobberyCheckpoint( "Film Studio", 		3000, 2327.25122, 914.138305, 1056.10510, -90.00000, -1 ); // custom obj
	CreateRobberyCheckpoint( "Grotti Cars", 		3000, 542.361816, -1303.5104, 16.725925, 180.00000, -1 );
	CreateRobberyCheckpoint( "Supa Save", 			3000, -2396.8779, 769.094421, 1056.135864, 0.00000, -1 );
	CreateRobberyCheckpoint( "Driving School", 		3000, -2036.3061, -116.89804, 1034.611328, 90.000000, -1 ); // needs mapping
	CreateRobberyCheckpoint( "Tattoo Parlour", 		3000, -200.06947, -22.932298, 1001.712890, -90.00000, 22, 46, 42 ); // needs mapping
	CreateRobberyCheckpoint( "Gym", 				3000, 754.936767, -18.894632, 1000.045532, 90.000000, 8 ); // needs mapping

	#if ENABLE_CITY_LV == true
	CreateRobberyCheckpoint( "Bank of Las Venturas - Safe 1", 3000, 2105.44214, 1246.16467, 1016.50110, 0.00000, g_bankvaultData[ CITY_LV ] [ E_WORLD ] );
	CreateRobberyCheckpoint( "Bank of Las Venturas - Safe 2", 3000, 2110.46143, 1246.16467, 1016.50110, 0.00000, g_bankvaultData[ CITY_LV ] [ E_WORLD ] );
	CreateRobberyCheckpoint( "Bank of Las Venturas - Safe 3", 3000, 2108.79370, 1246.16467, 1017.41492, 0.00000, g_bankvaultData[ CITY_LV ] [ E_WORLD ] );
	CreateRobberyCheckpoint( "Bank of Las Venturas - Safe 4", 3000, 2107.12280, 1246.16467, 1017.41492, 0.00000, g_bankvaultData[ CITY_LV ] [ E_WORLD ] );
	CreateRobberyCheckpoint( "Caligulas Casino - Safe 1", 	  3000, 2143.75757, 1642.64050, 993.93701, 0.0, -1 );
	CreateRobberyCheckpoint( "Caligulas Casino - Safe 2", 	  3000, 2145.47656, 1642.73230, 993.02612, 0.0, -1 );
	CreateRobberyCheckpoint( "4 Dragons Casino", 	4000, 1953.98730, 1018.13159, 991.9517800, -90.00000, -1 );
	CreateRobberyCheckpoint( "Gym", 				3000, 760.740173, -78.740097, 1000.094909, 180.00000, 9 );
	#endif

	#if ENABLE_CITY_LS == true
	CreateRobberyCheckpoint( "Bank of Los Santos - Safe 1", 3000, 2105.44214, 1246.16467, 1016.50110, 0.00000, g_bankvaultData[ CITY_LS ] [ E_WORLD ] );
	CreateRobberyCheckpoint( "Bank of Los Santos - Safe 2", 3000, 2110.46143, 1246.16467, 1016.50110, 0.00000, g_bankvaultData[ CITY_LS ] [ E_WORLD ] );
	CreateRobberyCheckpoint( "Bank of Los Santos - Safe 3", 3000, 2108.79370, 1246.16467, 1017.41492, 0.00000, g_bankvaultData[ CITY_LS ] [ E_WORLD ] );
	CreateRobberyCheckpoint( "Bank of Los Santos - Safe 4", 3000, 2107.12280, 1246.16467, 1017.41492, 0.00000, g_bankvaultData[ CITY_LS ] [ E_WORLD ] );
	CreateRobberyCheckpoint( "Gym", 				3000, 755.338684, 7.457977, 1000.139587, 90.00000, 10 );
	#endif
	/* ** Entrances/Exits ** */

	// Create roulette machine
	CreateRouletteTable( 2242.36719, 1589.18750, 1006.22662, -90.0000 );
	CreateRouletteTable( 2242.36719, 1594.75781, 1006.22662, 90.00000 );
	CreateRouletteTable( 2230.57031, 1589.18750, 1006.22662, -90.0000 );
	CreateRouletteTable( 2230.57031, 1594.75781, 1006.22662, 90.00000 );
	CreateRouletteTable( 2230.57031, 1614.59375, 1006.22662, -90.0000 );
	CreateRouletteTable( 2230.57031, 1619.65625, 1006.22662, 90.00000 );
	CreateRouletteTable( 2241.44531, 1614.55469, 1006.22662, -90.0000 );
	CreateRouletteTable( 2241.44531, 1619.60938, 1006.22662, 90.00000 );
	CreateRouletteTable( 1963.71094, 1025.69531, 992.507810, 0.000000 );
	CreateRouletteTable( 1959.39844, 1025.69531, 992.507810, 0.000000 );
	CreateRouletteTable( 1963.71094, 1010.11719, 992.507810, 0.000000 );
	CreateRouletteTable( 1959.39844, 1010.11719, 992.507810, 0.000000 );

	// Create blackjack tables
	CreateBlackjackTable( 25000, 2230.37500, 1602.75000, 1006.15631, 0.00000, 82 );
	CreateBlackjackTable( 25000, 2232.18750, 1604.43750, 1006.15631, 90.0000, 82 );
	CreateBlackjackTable( 25000, 2228.49219, 1604.45313, 1006.15631, -90.000, 82 );
	CreateBlackjackTable( 25000, 2230.37500, 1606.27344, 1006.15631, 180.000, 82 );
	CreateBlackjackTable( 100000, 2241.31250, 1602.75000, 1006.15631, 0.00000, 82 );
	CreateBlackjackTable( 100000, 2243.12500, 1604.43750, 1006.15631, 90.0000, 82 );
	CreateBlackjackTable( 100000, 2239.42969, 1604.45313, 1006.15631, -90.000, 82 );
	CreateBlackjackTable( 100000, 2241.31250, 1606.27344, 1006.15631, 180.000, 82 );
	CreateBlackjackTable( 1000000, 1962.34375, 1015.66412, 992.46881, 90.00000, 23 );
	CreateBlackjackTable( 1000000, 1960.36719, 1015.66412, 992.46881, -90.0000, 23 );
	CreateBlackjackTable( 1000000, 1960.74829, 1020.31189, 992.46881, -90.0000, 23 );
	CreateBlackjackTable( 10000000, 1962.34375, 1020.17969, 992.46881, 90.00000, 23 );

	// Houses
	/*CreateEntrance( "[ROOFTOP]", 			-2440.5149, 820.9702, 35.1838, -2438.1204, 819.7362, 65.5078, 			0,   0, false, true ); // Jendral
	CreateEntrance( "[ROOFTOP]", 			-2475.4238, 161.5239, 35.1406, -2476.4043, 155.6541, 64.9332, 			0,   0, false, true ); // Queens' Rooftop
	CreateEntrance( "[ROOFTOP]", 			-2281.2776, 923.6173, 66.7333, -2280.6958, 907.2256, 96.8359, 			0,   0, false, true ); // Juniper Hill Rooftop
	CreateEntrance( "[ROOFTOP]", 			-2372.5613, 851.7944, 41.0832, -2372.9949, 856.7742, 57.6094, 			0,   0, false, true ); // Near-supa Rooftop
	CreateEntrance( "[ROOFTOP]", 			-1696.3392, 1030.7318, 45.210, -1693.0250, 1030.273, 56.906, 			0,   0, false, true ); // MrFreeze's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-2113.2771, 1087.924, 71.5219, -2120.263, 1060.5692, 96.9456, 			0,   0, false, true ); // Arros' Rooftop
	CreateEntrance( "[ROOFTOP]", 			-1991.5497, 821.0363, 45.4453, -1984.2457, 821.7531, 92.3203, 			0,   0, false, true ); // Deedz's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-1887.0532, 761.1137, 45.4469, -1860.1149, 783.4689, 93.9143, 			0,   0, false, true ); // Arntz's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-2018.7081, 1194.185, 45.4574, -2019.5271, 1198.3176, 80.750, 			0,   0, false, true ); // Deedz's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-1782.7190, 1216.257, 32.6563, -1718.9036, 1208.9364, 48.7988, 			0,   0, false, true ); // MrFreeze's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-2160.8496, 648.1808, 52.3672, -2163.1775, 648.1913, 60.6982, 			0,   0, false, true ); // Dope's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-2724.6169, 73.51550, 4.33590, -2727.8027, 60.5538, 11.1953, 			0,   0, false, true ); // Cake's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-1948.4548, 827.3771, 42.5405, -1947.5352, 813.5648, 77.7300,			0,   0, false, true ); // [RR]Natushi's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-1779.6537, 1013.5704, 24.8906, -1774.9280, 1019.5374, 97.6932,			0,   0, false, true ); // Diller's Rooftop
	CreateEntrance( "[HOUSE]", 				-2121.4160, 659.9059, 52.3985, -2120.5251, 659.9581, 60.7005, 			0,   0, false, false ); // _[Esteban]_'s Rooftop
	CreateEntrance( "[HOUSE]", 				-2106.3545, 659.9128, 52.3932, -2107.2461, 659.8979, 60.7005, 			0,   0, false, false ); // _[Esteban]_'s Rooftop
	CreateEntrance( "[ROOFTOP]", 			2238.6887, 2225.6982, 10.8203, 2220.8872, 2245.8870, 24.9297, 			0,   0, false, true ); // PrinZeco's Rooftop
	CreateEntrance( "[STUDIO]", 			-692.3306, 939.6115, 13.6328, -699.7916, 6335.1655, 84.2296, 			0,   0, true , true ); // Uuri's Rooftop
	CreateEntrance( "[SECURITY ROOM]", 		-2042.2239, 246.3592, 29.0572, -2040.1056, 273.7458, 904.9886, 			0,   0, true , true ); // Gal's Rooftop
	CreateEntrance( "[ROOFTOP]",			-1757.2357, 774.0584, 45.2970, -1739.3662, 787.6291, 167.6535, 			0, 	 0, false, true ); // Executive Esuite Roof
	CreateEntrance( "[HOUSE]",				-1737.0885, 801.0515, 24.8906, -1757.2689, 805.6949, 45.3265, 			0, 	 0, false, true ); // Executive Esuite Roof
	CreateEntrance( "[ROOFTOP]", 			1370.8140, -1341.3876, 13.5469, 1378.1222, -1381.7068, 34.5537, 		0,   0, false, true ); // Assassin's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-2591.5420, 147.2977, 4.3359, -2586.2024, 142.7569, 17.6344, 			0,   0, false, true ); // Versec's Rooftop
	CreateEntrance( "[ROOFTOP]",			-2496.0562, 92.0874, 25.6172, -2506.0942, 105.3671, 35.1719,			0,	 0,	false, true ); // levi69's Rooftop
	CreateEntrance( "[ROOFTOP]",			-1732.3933, 632.2880, 25.0978, -1734.8120, 634.4911, 105.1406,			0,	 0,	false, true ); // Robox's Rooftop
	CreateEntrance( "[ROOFTOP]",			-1975.7041, 743.8552, 45.4453, -1981.0834, 759.7982, 85.9219,			0,	 0,	false, true ); // Amy's Rfooftop
	CreateEntrance( "[ROOFTOP]",			2408.4724, 2005.9023, 10.8203, 2400.1514, 1997.0370, 19.1563,			0,	 0,	false, true ); // Zorba's Rooftop
	CreateEntrance( "[ROOFTOP]",			2576.9863, 2082.4280, 10.8130, 2592.8230, 2091.7559, 15.6720,			0,	 0,	false, true ); // iTHUG's Rooftop
	CreateEntrance( "[ROOFTOP]", 			2119.9629, 1483.1409, 10.8302, 2162.6362, 1452.8992, 24.1406,			0,	 0,	false, true ); // Chrome_TV's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-2455.2925, -113.9168, 26.0669, -2450.1252, -129.2207, 51.8439,			0,	 0,	false, true ); // Rexer's Rooftop
	CreateEntrance( "[ROOFTOP]", 			606.6136, -1447.5503, 14.1969, 595.2242, -1484.3589, 73.8816,			0,	 0,	false, true ); // Zorba's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-2421.5044, -730.3824, 133.1481, -2432.5017, -747.6622, 141.2511,		0,	 0,	false, true ); // Gal's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-1681.3436, 1349.8549, 7.1722, -1691.0605, 1333.9678, 16.2976,			0,	 0,	false, true ); // Gal's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-1990.2039, 767.3861, 45.4453, -1982.2228, 790.7831, 107.0313,			0,	 0,	false, true ); // Thecover's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-2517.2058, 234.8540, 16.5137, -2517.2146, 233.6684, 21.9738,			0,	 0,	false, true ); // Niels's Rooftop
	CreateEntrance( "[HOUSE]", 				-2521.8391, 248.8841, 11.0938, -2521.7922, 248.8820, 16.4937,			0,	 0,	false, true ); // Niels's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-2430.8696, 1.8262, 35.3203, -2435.1899, -3.0185, 47.9531,				0,	 0,	false, true ); // Miley's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-2246.1819, 457.2802, 40.4719,-2275.6460, 444.2489, 46.7418,			0,	 0,	false, true ); // Gal's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-1833.8469, 679.3009, 35.1919,-1840.6748, 685.3052, 81.3984,			0,	 0,	false, true ); // Kidz's Rooftop
	CreateEntrance( "[VAULT]", 				-2912.6204,461.5075,9.7935, -2875.3625, 459.9657, 1240.3340,			0,	 0,	true, false ); // Wolf's Rooftop
	CreateEntrance( "[SUBMARINE]",			-34.6946, 234.4038, 2.1994, -35.3430, 244.1769, 770.9557,				0,	 0,	true, false ); // Wolf's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-2533.1726, 72.5313, 10.3846, -2575.0229, 60.0100, 18.0653,				0,	 0,	false, true ); // Daniel's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-1806.3270, 998.9644, 24.8906, -1823.3782, 988.7065, 77.1422,			0,	 0,	false, true ); // Syndicate's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-1977.4973, 955.7825, 45.4453, -1988.9637, 967.9180, 50.9922,			0,	 0,	false, true ); // Bang.'s Rooftop
	CreateEntrance( "[ROOFTOP]", 			-1880.3057, 960.5383, 35.1719, -1860.1345, 977.6763, 49.8047,			0,	 0,	false, true ); // Biscuits's Rooftop
	CreateEntrance( "[ROOFTOP]", 			-1962.5211, 743.8117, 45.4453, -1964.0610, 758.8718, 84.6016,			0,	 0,	false, true ); // Retrieval's Rooftop
	CreateEntrance( "[UNDERWATER]", 		-2705.6335, -448.8924, 4.5261, -2714.9460, -442.7717, -12.2039,			0,	 0,	false, false ); // Veloxity_'s Rooftop
	CreateEntrance( "[ROOFTOP]", 			-2629.4785, 696.2841, 27.9394, -2697.6145, 689.0028, 66.0922,			0,	 0,	false, true ); // Faze's Rooftop*/

	// Custom Interiors
	CreateEntrance( "[SEWER]",				-1990.7736, 1033.7378, 55.7266, 3638.4670, 5215.5024, 1203.3168, 		1,   1, true, true, -1 ); // Milky
	CreateEntrance( "[CASINO]", 			-2056.7678, 454.2312, 35.1719, -2059.0774, 388.7253, 1959.7297, 		0,  68, true, false, 44 ); // Dope Casino
	CreateEntrance( "[BANK]", 				-1493.1296, 920.1409, 7.1875, -1444.2537, 831.0490, 985.7027, 			0,  g_bankvaultData[ CITY_SF ] [ E_WORLD ], true, false, 52 );

	// San Fierro
	CreateEntrance( "[VICTIM]", 			-1694.4019, 951.0486, 24.8906, 227.3678, -8.3722, 1002.2109, 			5,   1, false, false, 45 );
	CreateEntrance( "[PIZZA]", 				-1808.6377, 945.8018, 24.8906, 372.2738, -133.5248, 1001.4922, 			5,   2, false, false, 29 );
	CreateEntrance( "[ZIP]", 				-1882.4294, 866.1778, 35.1719, 161.2982, -97.1033, 1001.8047, 			18,  3, false, false, 45 );
	CreateEntrance( "[BURGER SHOT]", 		-1912.2883, 828.0681, 35.2204, 362.8823, -75.1634, 1001.5078, 			10,  4, false, false, 10 );
	CreateEntrance( "[CLUCKING BELL]", 		-1816.5820, 618.0572, 35.1719, 364.9896, -11.8441, 1001.8516, 			9,   5, false, false, 14 );
	CreateEntrance( "[ZERO'S RC SHOP]", 	-2241.9248, 128.5363, 35.3203, -2240.7827,137.2215,1035.4141, 			6,   6, false, false, 47 );
	CreateEntrance( "[MISTY'S]", 			-2242.1438, -88.0866, 35.3203, 501.9013, -67.5635, 998.7578, 			11,  7, false, false, 49 );
	CreateEntrance( "[GYM]", 				-2270.6448, -155.983, 35.3203, 774.1244, -50.4720, 1000.5859, 			6,   8, false, false, 54 );
	CreateEntrance( "[BURGER SHOT]", 		-2336.8657, -166.889, 35.5547, 362.8823, -75.1634, 1001.5078, 			10,  9, false, false, 10 );
	CreateEntrance( "[DRIVING SCHOOL]",		-2026.6505, -102.0638, 35.1641, -2026.8767, -103.6028, 1035.1831, 		3,  10, false, false, 36 );
	CreateEntrance( "[DRUG HOUSE]", 		-2203.2300, 1043.400, 80.0131, 2196.8398, -1204.4272, 1049.0234, 		6,  11, false, false, 24 );
	CreateEntrance( "[BINCO]", 				-2373.8457, 910.1376, 45.4453, 207.6674,-111.2659,1005.1328, 			15, 12, false, false, 45 );
	CreateEntrance( "[BURGER SHOT]", 		-2355.8369, 1008.2708, 50.8984, 362.8823, -75.1634, 1001.5078, 			10, 13, false, false, 10 );
	CreateEntrance( "[CLUCKING BELL]", 		-2672.2297, 258.2861, 4.6328, 364.9896, -11.8441, 1001.8516, 			9,  14, false, false, 14 );
	CreateEntrance( "[BARBER]", 			-2571.3015, 246.8040, 10.4512, 411.8917,-54.4434,1001.8984, 			12, 23, false, false,  7 );
	CreateEntrance( "[DISCO]", 				-2551.0127, 194.3636, 6.2266, 493.4810, -24.9531, 1000.6719, 			17, 17, false, false, 48 );
	CreateEntrance( "[JIZZY'S]", 			-2625.4006, 1412.331, 7.0938, -2636.7698, 1402.4551, 906.4609, 			3,  18, false, false, 49 );
	CreateEntrance( "[RUSTY BROWN DONUT]", -2767.8628, 788.7215, 52.7813, 377.1306, -193.3048, 1000.6328, 			17, 19, false, false, 17 );
	CreateEntrance( "[PIZZA]", 				-1720.9558, 1359.7795, 7.1853, 372.2738, -133.5248, 1001.4922, 			5,  20, false, false, 29 );
	CreateEntrance( "[SUBURBAN]", 			-2489.9392, -29.0578, 25.6172, 203.8414, -50.6566, 1001.8047, 			1,  21, false, false, 45 );
	CreateEntrance( "[TATTOO]", 			-2490.9966, -38.7627, 25.6172, -204.4172,-27.3470,1002.2734, 			16, 22, false, false, 39 );
	CreateEntrance( "[CHURCH]", 			-1989.7933, 1117.9083, 54.4688, 1964.0679, -349.6309, 1092.9454, 		1,   1, true , false, -1 );
	CreateEntrance( "[AIRPORT]", 			-1422.4063, -286.5081, 14.1484, -1796.6152, 56.8790, 1061.4613, 		14, 24, true , false,  5 );
	CreateEntrance( "[CITY HALL]", 			-2766.4087, 375.5447, 6.3347, 390.7462, 173.7627, 1008.3828, 			3,   1, false, false, -1 );
	CreateEntrance( "[DRUG HOUSE]", 		-2027.8260, -40.6628, 38.8047, 2196.8398, -1204.4272, 1049.0234, 		6,  26, false, false, 24 );
	CreateEntrance( "[DRUG HOUSE]", 		-2552.3325,55.2304,16.4219, 2196.8398, -1204.4272, 1049.0234, 			6,  27, false, false, 24 );
	CreateEntrance( "[GAS STATION]", 		-2420.1538, 969.8716, 45.2969, -27.2923, -58.0535, 1003.5469, 			6,  28, false, false, 55 );
	CreateEntrance( "[GAS STATION]", 		-1676.1494, 432.2187, 7.1797, -27.2923, -58.0535, 1003.5469, 			6,  29, false, false, 55 );
	CreateEntrance( "[REVELATION CHURCH]",  -2482.0703, 2406.6750, 17.1094, 2013.3900, 1589.8300, 977.0594, 		1,   1, false, false, -1 );
	CreateEntrance( "[VEHICLE DEALERSHIP]", -2521.1895, -624.9482, 132.7838, -1868.0262, -617.5386, 1002.1284, 		9,  32, true , false, 55 );
	CreateEntrance( "[SOCCER STADIUM]",		-2109.6680, -444.1471, 38.7344, -1807.8997, 435.8948, 1039.4382, 		9,  32, true , false, 33 );
	CreateEntrance( "[BOXING STADIUM]",		-2051.5239, -407.7723, 38.7344, -281.8263, 10.5794, 2217.3096, 			9,  32, true , false, 33 );
	CreateEntrance( "[FILM STUDIO]",		-2591.4668, 170.4937, 4.7348, 2330.5608, 897.3838, 1054.8489, 			1,  21, true , false, 38 );
	CreateEntrance( "[FREEFALL]", 			-1749.2736, 871.2025, 25.0859, -1753.7821, 883.8984, 295.6010, 			0,   0, false, false, -1 );
	CreateEntrance( "[PAWNSHOP]", 			-2490.2256, -16.9206, 25.6172, 1329.7720, -1084.7529, 968.0360, 		2,  11, true , false, 25 );
	CreateEntrance( "[AMMU-NATION]", 		-2626.6299, 208.2514, 4.8125, 285.4629, -41.7990, 1001.5156, 			1,  15, false, false,  6 );
	CreateEntrance( "[POLICE DEPT.]", 		-1605.3304, 711.6586, 13.8672, 246.3872, 107.3055, 1003.2188, 			10, 30, true , false, 30 ); // The jail world (30) needs to be changed otherwise gg.
	CreateEntrance( "[HOSPITAL]",			-2655.0923, 640.1625, 14.4545, -2656.3079, 640.9360, 970.4332, 			1,  22, true , false, 22 );

	// Hardcoded
	g_SupaSave = 			CreateEntrance( "[SUPA SAVE]",			-2442.5710, 754.6293, 35.1719, -2418.3743, 772.8492, 1056.7056, 		1,   1, true , false, 62 );

	// VIP Lounge
	g_VIPLounge[ CITY_SF ] = CreateEntrance( "[V.I.P Lounge]", 		-1880.7598, 822.3964, 35.1778, -1971.5508, 825.5823, 1209.4420, 		18, 25, true , true , 33 ); // SF
	g_VIPLounge[ CITY_LS ] = CreateEntrance( "[V.I.P Lounge]", 		1797.444091, -1578.955810, 14.085495, 39.7270, 105.4883, 1015.2939, 	18, 92, true , true , 33 ); // LS
	g_VIPLounge[ CITY_LV ] = CreateEntrance( "[V.I.P Lounge]", 		1965.0455, 1623.2230, 12.8620, 39.7270, 105.4883, 1015.2939, 			18, 25, true , true , 33 ); // LV

	#if ENABLE_CITY_LV == true
	// Las Venturas
	CreateEntrance( "[BANK]", 				2447.6885, 2376.2515, 12.1635, 2162.4661, 1226.5592, 1017.1369, 		1,  g_bankvaultData[ CITY_LV ] [ E_WORLD ], true ,false, 52 );
	CreateEntrance( "[BURGER SHOT]", 		2367.0581, 2071.0891, 10.8203, 362.8823, -75.1634, 1001.5078, 			10, 32, false, false, 10 );
	CreateEntrance( "[BURGER SHOT]", 		2472.8640, 2034.1476, 11.0625, 362.8823, -75.1634, 1001.5078, 			10, 33, false, false, 10 );
	CreateEntrance( "[BURGER SHOT]", 		1139.5267, 2080.2134, 11.0547, 362.8823, -75.1634, 1001.5078, 			10, 34, false, false, 10 );
	CreateEntrance( "[BURGER SHOT]", 		2169.4082, 2795.8718, 10.8203, 362.8823, -75.1634, 1001.5078, 			10, 25, false, false, 10 );
	CreateEntrance( "[BURGER SHOT]", 		1872.2546, 2071.8691, 11.0625, 362.8823, -75.1634, 1001.5078, 			10, 82, false, false, 10 );
	CreateEntrance( "[CLUCKING BELL]", 		2393.2661, 2041.5591, 10.8203, 364.9896, -11.8441, 1001.8516, 			9,  35, false, false, 14 );
	CreateEntrance( "[CLUCKING BELL]", 		2101.8945, 2228.8604, 11.0234, 364.9896, -11.8441, 1001.8516, 			9,  36, false, false, 14 );
	CreateEntrance( "[CLUCKING BELL]", 		2638.5894, 1671.8162, 11.0234, 364.9896, -11.8441, 1001.8516, 			9,  70, false, false, 14 );
	CreateEntrance( "[24/7]", 				2452.4753, 2065.1895, 10.8203, -25.9472, -188.2597, 1003.5469, 			17, 37, false, false, 61 );
	CreateEntrance( "[24/7]", 				2097.6931, 2224.7014, 11.0234, -25.9472, -188.2597, 1003.5469, 			17, 38, false, false, 61 );
	CreateEntrance( "[24/7]", 				2247.6357, 2396.1694, 10.8203, -25.9472, -188.2597, 1003.5469, 			17, 39, false, false, 61 );
	CreateEntrance( "[24/7]", 				1937.8262, 2307.2012, 10.8203, -25.9472, -188.2597, 1003.5469, 			17, 40, false, false, 61 );
	CreateEntrance( "[24/7]", 				2194.9402, 1991.0054, 12.2969, -25.9472, -188.2597, 1003.5469, 			17, 41, false, false, 61 );
	CreateEntrance( "[24/7]", 				2546.5657, 1972.6659, 10.8203, -25.9472, -188.2597, 1003.5469, 			17, 49, false, false, 61 );
	CreateEntrance( "[CHURCH]", 			2519.4944, 2033.3417, 11.1719, 2383.1277, 3204.1130, 1017.516, 			2,  39, true , false, -1 );
	CreateEntrance( "[CHURCH]", 			2225.0847, 2522.8762, 11.2222, 2383.1277, 3204.1130, 1017.516, 			2,  40, true , false, -1 );
	CreateEntrance( "[AMMU-NATION]", 		2159.5447, 943.24390, 10.8203, 285.8562, -86.7820, 1001.5229, 			4,  41, false, false,  6 );
	CreateEntrance( "[AMMU-NATION]", 		2539.5420, 2084.0510, 10.8203, 316.3490, -170.2974, 999.5938, 			6,  42, false, false,  6 );
	CreateEntrance( "[PIZZA]", 				2083.3840, 2224.6987, 11.0234, 372.2738, -133.5248, 1001.4922, 			5,  43, false, false, 29 );
	CreateEntrance( "[PIZZA]", 				2351.7537, 2533.6287, 10.8203, 372.2738, -133.5248, 1001.4922, 			5,  44, false, false, 29 );
	CreateEntrance( "[PIZZA]", 				2638.7852, 1849.8058, 11.0234, 372.2738, -133.5248, 1001.4922, 			5,  14, false, false, 29 );
	CreateEntrance( "[ZIP]", 				2090.5588, 2224.7007, 11.0234, 161.2982, -97.1033, 1001.8047, 			18, 45, false, false, 45 );
	CreateEntrance( "[ZIP]", 				2572.0657, 1904.9449, 11.0234, 161.2982, -97.1033, 1001.8047, 			18, 59, false, false, 45 );
	CreateEntrance( "[TATTOO]", 			2094.7612, 2122.8645, 10.8203, -204.417, -27.3470, 1002.2734, 			16, 46, false, false, 39 );
	CreateEntrance( "[BINCO]", 				1657.0360, 1733.3674, 10.8281, 207.6674, -111.2659, 1005.1328, 			15, 47, false, false, 45 );
	CreateEntrance( "[BINCO]", 				2101.8931, 2257.4358, 11.0234, 207.6674, -111.2659, 1005.1328, 			15, 48, false, false, 45 );
	CreateEntrance( "[BINCO]", 				2101.8931, 2257.4358, 11.0234, 207.6674, -111.2659, 1005.1328, 			15, 48, false, false, 45 );
	CreateEntrance( "[GAS STATION]", 		2117.4756, 896.77590, 11.1797, -27.2923, -58.0535, 1003.5469, 			6,  49, false, false, 55 );
	CreateEntrance( "[GAS STATION]", 		2150.7961, 2733.8657, 11.1763, -27.2923, -58.0535, 1003.5469, 			6,  20, false, false, 55 );
	CreateEntrance( "[GAS STATION]", 		2187.7136, 2469.6372, 11.2422, -27.2923, -58.0535, 1003.5469, 			6,  56, false, false, 55 );
	CreateEntrance( "[GAS STATION]", 		1598.9939, 2221.7271, 11.0625, -27.2923, -58.0535, 1003.5469, 			6,  73, false, false, 55 );
	CreateEntrance( "[POLICE DEPT.]", 		2337.0854, 2459.3132, 14.9742, 288.8254, 166.9291, 1007.1719, 			3,  30, false, false, 30 );
	CreateEntrance( "[POLICE DEPT.]", 		2287.0601, 2432.3679, 10.8203, 238.7245, 138.6265, 1003.0234, 			3,  30, false, false, -1 );
	CreateEntrance( "[SEX SHOP]", 			2085.1206, 2074.0837, 11.0547, -100.3562, -25.0387, 1000.7188, 			3,  51, false, false, 21 );
	CreateEntrance( "[CALIGULAS CASINO]",	2196.9648, 1677.1042, 12.3672, 2233.9617, 1714.6832, 1012.3828, 		1,  82, false, false, 25 );
	CreateEntrance( "[STEAKHOUSE]", 		2369.2261, 1984.2435, 10.8203, 460.5569, -88.6348, 999.5547, 			4,  53, false, false, 50 );
	CreateEntrance( "[STEAKHOUSE]", 		1694.1072, 2208.9211, 11.0692, 460.5569, -88.6348, 999.5547, 			4,  23, false, false, 50 );
	CreateEntrance( "[THE CRAW BAR]", 		2441.1377, 2065.4844, 10.8203, 501.9013, -67.5635, 998.7578, 			11, 54, false, false, 49 );
	CreateEntrance( "[4 DRAGONS CASINO]",	2019.3126, 1007.6581, 10.8203, 2019.0719, 1017.8998, 996.8750, 			10, 23, false, false, 43 );
	CreateEntrance( "[CITY HALL]", 			2412.5024, 1123.8776, 10.8203, 390.7462, 173.7627, 1008.3828, 			3,   2, false, false, -1 );
	CreateEntrance( "[BARBER]", 			2080.3018, 2122.8655, 10.8203, 411.8917,-54.4434, 1001.8984, 			12, 20, false, false,  7 );
	CreateEntrance( "[PD ROOFTOP]",			2282.1907, 2423.1160, 3.4766, 2279.8276, 2458.7380, 38.6875, 			0,   0, false, false, -1 );
	CreateEntrance( "[GYM]", 				1968.7761, 2295.8728, 16.4559, 773.9163, -78.8474, 1000.6628, 			7,   9, false, false, 54 );
	CreateEntrance( "[VEHICLE DEALERSHIP]", 1948.6849, 2068.6914, 11.0610, -126.9255, 98.1966, 1004.7233, 			10, 31, true , false, 55 );
	CreateEntrance( "[PAWNSHOP]", 			2482.4395, 1326.4077, 10.8203, 1329.7720, -1084.7529, 968.0360, 		2,  22, true , false, 25 );

	// Creek
	CreateEntrance( "[CLUCKING BELL]", 		2838.3081, 2407.5620, 11.0690, 364.9896, -11.8441, 1001.8516, 			9,  23, false, false, 14 );
	CreateEntrance( "[24/7]", 				2884.5488, 2454.0413, 11.0690, -25.9472, -188.2597, 1003.5469, 			17, 47, false, false, 61 );
	CreateEntrance( "[VICTIM]", 			2802.8586, 2430.7910, 11.0625, 227.3678, -8.3722, 1002.2109, 			5,  21, false, false, 45 );
	CreateEntrance( "[SUBURBAN]", 			2779.7080, 2453.9395, 11.0625, 203.8414, -50.6566, 1001.8047, 			1,  41, false, false, 45 );
	CreateEntrance( "[PIZZA]", 				2756.7673, 2477.3511, 11.0625, 372.2738, -133.5248, 1001.4922, 			5,  46, false, false, 29 );
	CreateEntrance( "[PROLAPS]", 			2826.0977, 2407.5505, 11.0625, 207.0255, -140.3765, 1003.5078, 			3,  36, false, false, 45 );
	#endif

	#if ENABLE_CITY_LS == true
	// Los Santos
	CreateEntrance( "[BANK]", 				595.380371, -1250.299194, 18.278293, 2162.4661, 1226.5592, 1017.1369, 			2,  g_bankvaultData[ CITY_LS ] [ E_WORLD ], true , false, 52 );
	CreateEntrance( "[GYM]", 				2229.9028, -1721.258, 13.5612, 772.3065, -5.51570, 1000.7285, 			 		5,  10, false, false, 54 );
	CreateEntrance( "[TEN GREEN BOTTLES]",	2309.987548, -1643.436279, 14.827047, 501.9013, -67.5635, 998.7578, 			11, 58, false, false, 49 );
	CreateEntrance( "[CLUCKING BELL]", 		2397.816650, -1899.185058, 13.546875, 364.9896, -11.8441, 1001.8516, 			9,  39, false, false, 14 );
	CreateEntrance( "[CLUCKING BELL]", 		928.915588, -1353.043823, 13.343750, 364.9896, -11.8441, 1001.8516, 			9,  13, false, false, 14 );
	CreateEntrance( "[CLUCKING BELL]", 		2419.702636, -1509.045654, 24.000000, 364.9896, -11.8441, 1001.8516, 			9,  16, false, false, 14 );
	CreateEntrance( "[BINCO]", 				2244.381347, -1665.566650, 15.476562, 207.6674, -111.2659, 1005.1328, 			15, 53, false, false, 45 );
	CreateEntrance( "[AMMU-NATION]", 		2400.493408, -1981.995605, 13.546875, 285.8562, -86.7820, 1001.5229, 			4,  74, false, false,  6 );
	CreateEntrance( "[AMMU-NATION]", 		1369.000122, -1279.712646, 13.546875, 316.3490, -170.2974, 999.5938, 			6,  75, false, false,  6 );
	CreateEntrance( "[SEX SHOP]", 			1940.006225, -2115.978027, 13.695312, -100.3562, -25.0387, 1000.7188, 			3,  64, false, false, 21 );
	CreateEntrance( "[SEX SHOP]", 			1087.683471, -922.481994, 43.390625, -100.3562, -25.0387, 1000.7188, 			3,  32, false, false, 21 );
	CreateEntrance( "[GAS STATION]", 		1928.580932, -1776.264892, 13.546875, -27.2923, -58.0535, 1003.5469, 			6,  68, false, false, 55 );
	CreateEntrance( "[GAS STATION]", 		-78.360862, -1169.870605, 2.135507, -27.2923, -58.0535, 1003.5469, 				6,  92, false, false, 55 );
	CreateEntrance( "[BURGER SHOT]", 		810.484741, -1616.128906, 13.546875, 362.8823, -75.1634, 1001.5078, 			10, 35, false, false, 10 );
	CreateEntrance( "[BURGER SHOT]", 		1199.256347, -918.142150, 43.123218, 362.8823, -75.1634, 1001.5078, 			10, 71, false, false, 10 );
	CreateEntrance( "[BARBER]", 			824.059570, -1588.316894, 13.543567, 411.8917,-54.4434,1001.8984, 				12, 21, false, false,  7 );
	CreateEntrance( "[BARBER]", 			2070.632568, -1793.837036, 13.546875, 411.8917,-54.4434,1001.8984, 				12, 22, false, false,  7 );
	CreateEntrance( "[POLICE DEPT.]", 		1555.501220, -1675.639038, 16.195312, 246.8373,62.3343,1003.6406, 				6,  30, false, false, 30 );
	CreateEntrance( "[PIZZA]", 				2105.488281, -1806.570434, 13.554687, 372.2738, -133.5248, 1001.4922, 			5,  12, false, false, 29 );
	CreateEntrance( "[STRIP CLUB]", 		2421.597900, -1219.242675, 25.561447, 1204.7625,-13.8523,1000.9219, 			2,  22, false, false, -1 );
	CreateEntrance( "[DISCO]", 				1837.038696, -1682.395996, 13.322851, 493.4810, -24.9531, 1000.6719, 			17, 71, false, false, 48 );
	CreateEntrance( "[24/7]", 				1833.777343, -1842.623657, 13.578125, -25.9472, -188.2597, 1003.5469, 			17, 51, false, false, 61 );
	CreateEntrance( "[24/7]", 				1000.593017, -919.916809, 42.328125, -25.9472, -188.2597, 1003.5469, 			17, 48, false, false, 61 );
	CreateEntrance( "[TATTOO]", 			2068.582763, -1779.853881, 13.559624, -204.417, -27.3470, 1002.2734, 			16, 42, false, false, 39 );
	//CreateEntrance( "[VEHICLE DEALERSHIP]", 542.2485000, -1293.922200, 17.242000, -126.9255, 98.1966, 1004.7233, 			11, 32, true , false, 55 );
	CreateEntrance( "[SUBURBAN]", 			2112.8643, -1211.4548, 23.9629, 203.8414, -50.6566, 1001.8047, 					1,  39, false, false, 45 );
	CreateEntrance( "[VICTIM]", 			461.707031, -1500.845092, 31.044902, 227.3678, -8.3722, 1002.2109, 				5,  49, false, false, 45 );
	CreateEntrance( "[DRUG HOUSE]", 		1449.219360, -1849.375000, 13.973744, 2196.8398, -1204.4272, 1049.0234, 		6,  94, false, false, 24 );
	CreateEntrance( "[DRUG HOUSE]", 		2290.139404, -1796.005371, 13.546875, 2196.8398, -1204.4272, 1049.0234, 		6,  31, false, false, 24 );
	CreateEntrance( "[DRUG HOUSE]", 		2165.931152, -1671.195190, 15.073156, 2196.8398, -1204.4272, 1049.0234, 		6,  44, false, false, 24 );
	CreateEntrance( "[DRUG HOUSE]", 		2486.490722, -1644.531616, 14.077178, 2196.8398, -1204.4272, 1049.0234, 		6,  10, false, false, 24 );
	CreateEntrance( "[DRUG HOUSE]", 		2351.937255, -1170.664672, 28.074649, 2196.8398, -1204.4272, 1049.0234, 		6,  15, false, false, 24 );
	CreateEntrance( "[JIM'S STICKY DONUTS]",1038.096191, -1340.726074, 13.745031, 377.1306, -193.3048, 1000.6328, 			17, 10, false, false, 17 );
	CreateEntrance( "[CITY HALL]", 			1481.037719, -1772.312622, 18.795755, 390.7462, 173.7627, 1008.3828, 			3,   5, false, false, -1 );
	CreateEntrance( "[JEFFERSON MOTEL]", 	2233.292968, -1159.849243, 25.890625, 2214.3845, -1150.4780, 1025.7969, 		15, 21, false, false, -1 );
	CreateEntrance( "[PROLAPS]", 			499.5353000, -1360.6348, 16.3690, 207.0255, -140.3765, 1003.5078, 				3,  39, false, false, 45 );
	CreateEntrance( "[ZIP]", 				1457.0670, -1137.1027, 23.9441, 161.2982, -97.1033, 1001.8047, 					18, 27, false, false, 45 );
	CreateEntrance( "[PAWNSHOP]", 			2507.3076, -1724.6044, 13.5469, 1329.7720, -1084.7529, 968.0360, 				2,  33, true , false, 25 );
	CreateEntrance( "[DIDIER SACHS]",		454.2061, -1477.9880, 30.8142, 204.3547, -168.8608, 1000.5234, 					14, 14, true , false, 22 );

	// Angel Pine
	CreateEntrance( "[AMMU-NATION]", 		-2093.670898, -2464.938964, 30.625000, 316.3490, -170.2974, 999.5938, 			6,  32, false, false,  6 );
	CreateEntrance( "[CLUCKING BELL]", 		-2155.283447, -2460.122070, 30.851562, 364.9896, -11.8441, 1001.8516, 			9,  12, false, false, 14 );
	CreateEntrance( "[GAS STATION]", 		-2231.472900, -2558.297119, 31.921875, -27.2923, -58.0535, 1003.5469, 			6,  74, false, false, 55 );
	CreateEntrance( "[STEAKHOUSE]", 		-2103.568603, -2342.283203, 30.625000, 460.5569, -88.6348, 999.5547, 			4,  27, false, false, 50 );

	// Blueberry
	CreateEntrance( "[STEAKHOUSE]", 		293.340881, -195.475814, 1.778619, 460.5569, -88.6348, 999.5547, 				4,  22, false, false, 50 );
	CreateEntrance( "[AMMU-NATION]", 		243.294967, -178.334701, 1.582162, 316.3490, -170.2974, 999.5938, 				6,  23, false, false,  6 );
	CreateEntrance( "[PIZZA]", 				203.481597, -201.936798, 1.578125, 372.2738, -133.5248, 1001.4922, 				5,  31, false, false, 29 );

	// Dillimore
	CreateEntrance( "[BAR]", 				681.612243, -473.346771, 16.536296, 501.9013, -67.5635, 998.7578, 				11, 17, false, false, 49 );
	CreateEntrance( "[BARBER]", 			672.088317, -496.847564, 16.335937, 411.8917,-54.4434,1001.8984, 				12, 18, false, false,  7 );
	CreateEntrance( "[24/7]", 				694.930969, -500.131072, 16.335937, -25.9472, -188.2597, 1003.5469, 			17, 11, false, false, 61 );

	// Montgomery
	CreateEntrance( "[PIZZA]", 				1367.548950, 248.235580, 19.566932, 372.2738, -133.5248, 1001.4922, 			5,  75, false, false, 29 );
	CreateEntrance( "[GAS STATION]", 		1383.270507, 465.549926, 20.191875, -27.2923, -58.0535, 1003.5469, 				6,  77, false, false, 55 );
	CreateEntrance( "[BAR]", 				1359.643920, 205.083831, 19.755516, 501.9013, -67.5635, 998.7578, 				11, 36, false, false, 49 );
	CreateEntrance( "[BAR]", 				1244.703735, 205.342956, 19.645431, 501.9013, -67.5635, 998.7578, 				11, 41, false, false, 49 );

	// Palomino Creek
	CreateEntrance( "[PIZZA]", 				2331.810058, 75.064132, 26.620975, 372.2738, -133.5248, 1001.4922, 				5,  66, false, false, 29 );
	CreateEntrance( "[AMMU-NATION]", 		2333.088867, 61.584743, 26.705789, 316.3490, -170.2974, 999.5938, 				6,  27, false, false,  6 );
	CreateEntrance( "[BANK]", 				2303.827880, -16.152278, 26.484375, 2155.0652,1651.0916,1041.6198, 				69, 78, true , false, 52 );
	CreateEntrance( "[SEX SHOP]", 			2304.576416, 14.248206, 26.484375, -100.3562, -25.0387, 1000.7188, 				3,  16, false, false, 21 );
	CreateEntrance( "[BAR]", 				2332.996337, -17.302047, 26.484375, 501.9013, -67.5635, 998.7578, 				11, 22, false, false, 49 );
	CreateEntrance( "[CHURCH]", 			2256.691406, -44.642879, 26.883434, 2383.1277, 3204.1130, 1017.516, 			2,  41, true , false, -1 );
	#endif

	// Fort Carson
	CreateEntrance( "[RESTAURANT]", 		-53.82020, 1188.7482, 19.3594, -229.2946, 1401.1322, 27.7656, 			18, 53, false, false, 50 );
	CreateEntrance( "[LIL' PROBE INN]", 	-89.61480, 1378.2664, 10.4698, -229.2946, 1401.1322, 27.7656, 			18, 54, false, false, 50 );
	CreateEntrance( "[BANK]", 				-179.1860, 1133.1830, 19.7422, 2155.0652,1651.0916,1041.6198, 			69, 45, true , false, 52 );
	CreateEntrance( "[CHURCH]", 			-207.8720, 1119.1965, 20.4297, 2383.1277, 3204.1130, 1017.516, 			2,  24, true , false, -1 );
	CreateEntrance( "[CACTUS BAR]", 		-179.6980, 1087.5027, 19.7422, 501.9013, -67.5635, 998.7578, 			11, 56, false, false, 49 );
	CreateEntrance( "[24/7]", 				-180.7307, 1034.8035, 19.7422, -25.9472, -188.2597, 1003.5469, 			17, 42, false, false, 61 );
	CreateEntrance( "[KING RING DONUTS]", 	-144.0186, 1225.2097, 19.8992, 377.1306, -193.3048, 1000.6328, 			17, 20, false, false, 17 );
	CreateEntrance( "[BARBER]", 			-206.1856, 1062.1968, 19.7422, 411.8917,-54.4434,1001.8984, 			12, 48, false, false,  7 );
	CreateEntrance( "[AMMU-NATION]", 		-316.1613, 829.79550, 14.2422, 316.3490, -170.2974, 999.5938, 			6,   5, false, false,  6 );

	// El Casillo del Diablo
	CreateEntrance( "[CHURCH]", 			-361.7441, 2222.3257, 43.0078, 2383.1277, 3204.1130, 1017.516, 			1,  62, true , false, -1 );
	CreateEntrance( "[BAR]", 				-384.8090, 2206.1194, 42.4235, 501.9013, -67.5635, 998.7578, 			11, 10, false, false, 49 );

	// Bone Country
	CreateEntrance( "[AMMU-NATION]", 		776.72050, 1871.4076, 4.90660, 316.3490, -170.2974, 999.5938, 			6,  45, false, false,  6 );
	CreateEntrance( "[BROTHEL]", 			693.69150, 1967.6844, 5.53910, 968.1353, -53.2577, 1001.1246, 			3,  42, false, false, 49 );
	CreateEntrance( "[GAS STATION]", 		663.14670, 1716.3582, 7.18750, -27.2923, -58.0535, 1003.5469, 			6,  32, false, false, 55 );
	CreateEntrance( "[CLUCKING BELL]", 		172.98640, 1177.1807, 14.7578, 364.9896, -11.8441, 1001.8516, 			9,  62, false, false, 14 );

	// Tierra Robada
	CreateEntrance( "[CLUCKING BELL]", 		-1213.7229, 1830.2632, 41.9297, 364.9896, -11.8441, 1001.8516, 			9,  60, false, false, 14 );
	CreateEntrance( "[GAS STATION]", 		-1320.5590, 2698.6082, 50.2663, -27.2923, -58.0535, 1003.5469, 			6,  33, false, false, 55 );
	CreateEntrance( "[GAS STATION]", 		-1465.8094, 1873.4160, 32.6328, -27.2923, -58.0535, 1003.5469, 			6,  34, false, false, 55 );
	CreateEntrance( "[TIERRA BAR]", 		-1271.3542, 2713.3086, 50.2663, 501.9013, -67.5635, 998.7578, 			11, 55, false, false, 49 );
	CreateEntrance( "[JAY'S BAR]", 			-1942.1311, 2379.4358, 49.7031, 501.9013, -67.5635, 998.7578, 			11, 15, false, false, 49 );

	// Las Barrancas
	CreateEntrance( "[STEAKHOUSE]", 		-857.9400, 1535.3420, 22.5870, 460.5569, -88.6348, 999.5547, 			4,  54, false, false, 50 );
	CreateEntrance( "[BANK]", 				-828.1797, 1504.5967, 19.8528, 2155.0652,1651.0916,1041.6198, 			69, 24, true , false, 52 );
	CreateEntrance( "[24/7]", 				-780.3192, 1501.4674, 23.7957, -25.9472, -188.2597, 1003.5469, 			17, 43, false, false, 61 );

	// El Quebrados
	CreateEntrance( "[AMMU-NATION]", 		-1508.8550, 2610.7004, 55.8359, 316.3490, -170.2974, 999.5938, 			6,  47, false, false,  6 );
	CreateEntrance( "[BAR]", 				-1519.1434, 2610.3274, 55.8359, 501.9013, -67.5635, 998.7578, 			11, 50, false, false, 49 );
	CreateEntrance( "[BARBER]", 			-1449.8353, 2591.9045, 55.8359, 411.8917,-54.4434,1001.8984, 			12, 24, false, false,  7 );
	CreateEntrance( "[24/7]", 				-1480.8905, 2591.6638, 55.8359, -25.3519, -188.1018, 1003.5469, 		17,  44, false, false, 61 );

	// Las Payasadas
	CreateEntrance( "[BANK]", 				-288.8788, 2689.7905, 62.8125, 2155.0652,1651.0916,1041.6198, 			69, 25, true , false, 52 );
	CreateEntrance( "[BAR]", 				-255.1494, 2603.2395, 62.8582, 501.9013, -67.5635, 998.7578, 			11, 52, false, false, 49 );

	// Unknown
	CreateEntrance( "[BAR]", 				-314.0455, 1774.7166, 43.6406, 501.9013, -67.5635, 998.7578, 			11, 21, false, false, 49 );
	CreateEntrance( "[GAS STATION]", 		-736.2042, 2747.8445, 47.2266, -27.2923, -58.0535, 1003.5469, 			6,  52, false, false, 55 );

	/* ** Map Icons ** */
	CreateDynamicMapIcon( -1547.4066, 123.6555, 3.55470,  9, 0, -1, -1, -1, 750.0 ); // ShipYard
	CreateDynamicMapIcon( -1657.7573, 1210.275, 7.25000, 55, 0, -1, -1, -1, 750.0 ); // Otto's Cars
	CreateDynamicMapIcon( -1923.3926, 303.6380, 41.0469,  8, 0, -1, -1, -1, 750.0 ); // BombShop
	CreateDynamicMapIcon( -1951.9911, 300.2070, 35.4688, 55, 0, -1, -1, -1, 750.0 ); // WangCars
	CreateDynamicMapIcon( -1979.9883, 138.0498, 27.6875, 42, 0, -1, -1, -1, 750.0 ); // TrainStation
	CreateDynamicMapIcon( -2172.2017, 252.1113, 35.3388, 19, 0, -1, -1, -1, 750.0 ); // Paintball
	CreateDynamicMapIcon( -2455.4487, 503.9236, 30.0781, 30, 0, -1, -1, -1, 750.0 ); // CIA-FBI
	CreateDynamicMapIcon( -2489.8660, -16.8687, 25.6172, 58, 0, -1, -1, -1, 750.0 ); // Pawn Store
	CreateDynamicMapIcon( -1840.3867, 1015.350, 45.6626, 46, 0, -1, -1, -1, 750.0 ); // Weed Farm
	CreateDynamicMapIcon( -1935.8773, 243.1236, 36.2211, 27, 0, -1, -1, -1, 750.0 ); // Modshop
	CreateDynamicMapIcon( -2720.6104, 217.7127, 4.31920, 27, 0, -1, -1, -1, 750.0 ); // Modshop
	CreateDynamicMapIcon( -2426.3296, 1021.7617, 50.8859, 63, 0, -1, -1, -1, 750.0 ); // Paint n Spray
	CreateDynamicMapIcon( -1903.7902, 283.97430, 41.7187, 63, 0, -1, -1, -1, 750.0 ); // Paint n Spray

	// Las Venturas
	CreateDynamicMapIcon( 2597.58000, 2464.270, 10.8200, 46, 0, -1, -1, -1, 750.0 ); // Weed Farm
	CreateDynamicMapIcon( 1973.2057, 2162.2651, 10.6314, 63, 0, -1, -1, -1, 750.0 ); // Paint n Spray - Las Venturas
	CreateDynamicMapIcon( 1607.2659, 1815.2485, 10.8203, 22, 0, -1, -1, -1, 750.0 ); // Hospital - Las Venturas
	CreateDynamicMapIcon( -320.1947, 1048.2355, 20.3403, 22, 0, -1, -1, -1, 750.0 ); // Hospital - Fort Carson
	CreateDynamicMapIcon( -217.8446, 979.07470, 19.5039, 30, 0, -1, -1, -1, 750.0 ); // Police Department - Fort Carson
	CreateDynamicMapIcon( -1514.7529, 2518.9282, 56.070, 22, 0, -1, -1, -1, 750.0 ); // Hospital - El Quebrados
	CreateDynamicMapIcon( -1390.0563, 2639.0264, 55.984, 30, 0, -1, -1, -1, 750.0 ); // Police Department - El Quebrados
	CreateDynamicMapIcon( 1998.7263, 2298.5562, 10.8203,  8, 0, -1, -1, -1, 750.0 ); // BombShop - Las Venturas
	CreateDynamicMapIcon( -431.2023, 2241.0063, 42.9834, 30, 0, -1, -1, -1, 750.0 ); // Police Department - El Castillo del Diablo
	CreateDynamicMapIcon( 1633.7454, 2330.6860, 10.8203,  9, 0, -1, -1, -1, 750.0 ); // ShipYard
	CreateDynamicMapIcon( 2386.8342, 1048.7100, 10.1765, 27, 0, -1, -1, -1, 750.0 ); // Modshop

	// Los Santos
	CreateDynamicMapIcon( 2597.5800,  2464.2700, 10.8200, 46, 0, -1, -1, -1, 750.0 ); // Weed Farm
	CreateDynamicMapIcon( 626.96450, -571.74460, 17.9207, 30, 0, -1, -1, -1, 750.0 ); // Police Department - Dillimore
	CreateDynamicMapIcon( 2031.3892, -1417.7322, 16.9922, 22, 0, -1, -1, -1, 750.0 ); // Hospital - Los Santos
	CreateDynamicMapIcon( 1167.1241, -1335.4282, 28.9784, 22, 0, -1, -1, -1, 750.0 ); // Hospital - Los Santos
	CreateDynamicMapIcon( 487.39340, -1740.4929, 10.6892, 63, 0, -1, -1, -1, 750.0 ); // Paint n Spray - Los Santos
	CreateDynamicMapIcon( 1024.9385, -1025.0437, 31.6611, 63, 0, -1, -1, -1, 750.0 ); // Paint n Spray - Los Santos
	CreateDynamicMapIcon( 2065.3052, -1831.7053, 13.1126, 63, 0, -1, -1, -1, 750.0 ); // Paint n Spray - Los Santos
	CreateDynamicMapIcon( 2644.8589, -2038.8060, 13.5500, 27, 0, -1, -1, -1, 750.0 ); // Modshop
	CreateDynamicMapIcon( 1041.5466, -1023.0604, 31.7067, 27, 0, -1, -1, -1, 750.0 ); // Modshop
	CreateDynamicMapIcon( 2635.2529, -2227.0149, 16.2969,  9, 0, -1, -1, -1, 750.0 ); // ShipYard
	CreateDynamicMapIcon( 2456.1423, -1714.9557, 13.1630, 46, 0, -1, -1, -1, 750.0 ); // Weed Farm
	CreateDynamicMapIcon( 1642.1968, -2335.4983, 13.5469,  5, 0, -1, -1, -1, 750.0 ); // Airport
	CreateDynamicMapIcon( 1519.1024, -1451.9186, 13.6816, 30, 0, -1, -1, -1, 750.0 ); // CIA-FBI
	CreateDynamicMapIcon( 1749.2073, -1948.8389, 13.4137, 42, 0, -1, -1, -1, 750.0 ); // TrainStation
	CreateDynamicMapIcon( 815.69880, -1347.7256, 13.1043, 42, 0, -1, -1, -1, 750.0 ); // TrainStation
	CreateDynamicMapIcon( 1911.2578, -1775.8676, 12.9470,  8, 0, -1, -1, -1, 750.0 ); // BombShop

	/* ** Navigation Points ** */
	CreateNavigation( "Shipyard", 				-1547.4066, 123.6555, 3.55472, CITY_SF ); // 1
	CreateNavigation( "Otto's Cars", 			-1657.7573, 1210.2754, 7.2500, CITY_SF ); // 2
	CreateNavigation( "Bombshop", 				-1923.3926, 303.6380, 41.0469, CITY_SF ); // 3
	CreateNavigation( "Wang Cars",				-1951.9911, 300.2070, 35.4688, CITY_SF ); // 4
	CreateNavigation( "Hospital", 				-2658.3201, 639.5060, 14.4531, CITY_SF ); // 5
	CreateNavigation( "Train Station", 			-1979.9883, 138.0498, 27.6875, CITY_SF ); // 6
	CreateNavigation( "Bank", 					-1496.8027, 919.8218, 7.18752, CITY_SF ); // 7
	CreateNavigation( "Police Station", 		-1609.2813, 712.9857, 13.7334, CITY_SF ); // 8
	CreateNavigation( "City Hall", 				-2766.4087, 375.5447, 6.33470, CITY_SF ); // 9
	CreateNavigation( "Supa Save", 				-2446.3350, 752.2393, 35.1719, CITY_SF ); // 10
	CreateNavigation( "Vehicle Dealership", 	-2521.1895, -624.942, 132.780, CITY_SF ); // 11
	//CreateNavigation( "Vehicle Impound", 		-1370.2954, -206.7451, 6.0000, CITY_SF ); // 12
	CreateNavigation( "Paintball", 				-2172.2017, 252.1113, 35.3388, CITY_SF ); // 13
	CreateNavigation( "Airport",                -1422.4063, -286.5081, 14.148, CITY_SF ); // 15
	CreateNavigation( "V.I.P Lounge",           -1880.7598, 822.3964, 35.1778, CITY_SF ); // 16
	CreateNavigation( "Lumberjack",          	-2323.5676, -97.25822, 35.307, CITY_SF ); // 17
	CreateNavigation( "Ammu-Nation",			-2626.6299, 208.2514, 4.81250, CITY_SF ); // 18
	CreateNavigation( "Pawnshop",				-2490.2256, -16.9206, 25.6172, CITY_SF ); // 19

	#if ENABLE_CITY_LV == true
	// Las Venturas
	CreateNavigation( "Airport", 				1705.3646, 1607.9652, 10.0580, CITY_LV ); // 1
	CreateNavigation( "City Hall", 				2414.9258, 1123.4523, 10.8203, CITY_LV ); // 2
	CreateNavigation( "Hospital", 				1606.8169, 1837.1116, 10.8203, CITY_LV ); // 3
	CreateNavigation( "Ammu-Nation", 			2537.8972, 2083.8586, 10.8203, CITY_LV ); // 4
	CreateNavigation( "Bombshop", 				1998.7263, 2298.5562, 10.8203, CITY_LV ); // 5
	CreateNavigation( "Bank",					2442.1279, 2376.0293, 11.5376, CITY_LV ); // 6
	CreateNavigation( "Autobahn", 				1948.6851, 2068.7463, 11.0610, CITY_LV ); // 7
	CreateNavigation( "Police Department", 		2288.0063, 2429.8960, 10.8203, CITY_LV ); // 8
	CreateNavigation( "4 Dragons Casino",		2025.3047, 1008.4356, 10.3846, CITY_LV ); // 8
	CreateNavigation( "Caligula's Casino", 		2191.3186, 1677.9497, 11.9736, CITY_LV ); // 10
	CreateNavigation( "Shipyard", 				1633.7454, 2330.6860, 10.8203, CITY_LV ); // 11
	CreateNavigation( "Stadium", 				1099.3146, 1608.5789, 12.5469, CITY_LV ); // 12
	CreateNavigation( "Quarry", 				343.09180, 877.98650, 20.4063, CITY_LV ); // 13
	CreateNavigation( "V.I.P Lounge", 			1966.8428, 1623.2175, 12.8621, CITY_LV ); // 14
	CreateNavigation( "Pawnshop",				2482.4395, 1326.4077, 10.8203, CITY_LV ); // 15
	CreateNavigation( "Fort Carson", 			-135.5214, 1148.3502, 19.5938, CITY_LV ); // 16
	CreateNavigation( "Ammu-Nation F.C.", 		-311.6576, 830.07060, 14.2422, CITY_LV ); // 17
	CreateNavigation( "Las Payasadas", 			-233.0320, 2700.0896, 62.5391, CITY_LV ); // 18
	CreateNavigation( "El Quebrados", 			-1491.172, 2603.0425, 55.6897, CITY_LV ); // 19
	CreateNavigation( "Las Barrancas",          -805.4283, 1539.6168, 26.9609, CITY_LV ); // 20
	#endif

	#if ENABLE_CITY_LS == true
	// Los Santos
	CreateNavigation( "Vehicle Dealership", 	540.27090, -1282.3586, 17.2422, CITY_LS ); // 1
	CreateNavigation( "Bank", 					593.73800, -1244.3899, 18.0622, CITY_LS ); // 2
	CreateNavigation( "Airport", 				1961.4990, -2193.5586, 13.5469, CITY_LS ); // 3
	CreateNavigation( "City Hall", 				1480.1451, -1737.7921, 13.5469, CITY_LS ); // 4
	CreateNavigation( "Police Station", 		1539.8739, -1675.8989, 13.5469, CITY_LS ); // 5
	CreateNavigation( "Ammu-Nation", 			1362.1816, -1282.4746, 13.5469, CITY_LS ); // 6
	CreateNavigation( "Ferris Wheel", 			373.71490, -2032.6777, 7.67190, CITY_LS ); // 7
	CreateNavigation( "V.I.P Lounge", 			1805.5667, -1582.5602, 13.4951, CITY_LS ); // 8
	CreateNavigation( "Bombshop", 				1911.2462, -1775.8755, 13.3828, CITY_LS ); // 9
	CreateNavigation( "Grove Street", 			2487.0481, -1668.7418, 13.3438, CITY_LS ); // 10
	CreateNavigation( "Modshop", 				1041.0688, -1027.9791, 32.1016, CITY_LS ); // 11
	CreateNavigation( "Trainstation", 			1750.6547, -1945.8823, 13.5613, CITY_LS ); // 12
	CreateNavigation( "Lowrider Modshop", 		2645.3145, -2033.6381, 13.5540, CITY_LS ); // 13
	CreateNavigation( "Shipyard", 				2615.8606, -2226.5325, 13.3828, CITY_LS ); // 14
	CreateNavigation( "Pawnshop",				2507.3076, -1724.6044, 13.5469, CITY_LS ); // 15
	CreateNavigation( "Angel Pine", 			-2143.302, -2395.7650, 30.6250, CITY_LS ); // 16
	CreateNavigation( "Blueberry", 				234.78340, -128.77670, 1.42970, CITY_LS ); // 17
	CreateNavigation( "Dillimore", 				680.57570, -539.80190, 16.1803, CITY_LS ); // 18
	CreateNavigation( "Montgomery", 			1317.5898, 313.541300, 19.4063, CITY_LS ); // 19
	CreateNavigation( "Palomino Creek", 		2335.9343, 31.8564000, 26.4819, CITY_LS ); // 20
	#endif

	/* ** Weapon Locker ** */
	CreateAmmunationLocker( -1614.41992, 672.565246, -4.90625, 180.0000 );
	CreateAmmunationLocker( 2245.062988, 2434.94458, 10.82031, -90.0000 );
	CreateAmmunationLocker( 1525.003051, -1669.4093, 6.228725, 90.00000 );
	CreateAmmunationLocker( 1527.936645, -1462.0344, 9.500000, -90.0000 );
	CreateAmmunationLocker( 937.0916130, 1733.15197, 8.851562, 90.00000 );
	CreateAmmunationLocker( -2458.59399, 501.431365, 30.02399, 0.000000 );

	/* ** ATM Points ** */

	// San Fierro
	CreateATM( -1938.123291, 883.547668, 38.087814, 270.000000 ); // 0
	CreateATM( -2408.914794, 720.656738, 34.751876, 180.000000 ); // 1
	CreateATM( -1980.711669, 122.112731, 27.267499, 90.000000  ); // 2
	CreateATM( -2647.664306, -22.565168, 5.7128110, 180.000000 ); // 3
	CreateATM( -1917.654418, 558.118347, 34.743148, 270.000000 ); // 4
	CreateATM( -2635.699951, 631.200012, 14.079999, 180.000000 ); // 5
	CreateATM( -2636.040000, 208.560000, 3.8800000, 360.000000 ); // 6
	CreateATM( -2512.100000, 2340.74000, 4.5799990, 180.000000 ); // 7
	CreateATM( -2525.250000, -624.97000, 132.41000, 360.000000 ); // 8

	// Las Venturas
	CreateATM( 2544.055175, 2242.881835, 10.471873, 180.000000 ); // 0
	CreateATM( 2110.729736, 2061.529052, 10.500308, 180.000000 ); // 1
	CreateATM( 2233.845703, 957.4488520, 10.470303, 90.0000000 ); // 2
	CreateATM( 2413.644287, 1114.202758, 10.452508, -90.000000 ); // 3
	CreateATM( 1900.780151, 1102.897583, 10.459669, 180.000000 ); // 4
	CreateATM( 2349.165283, 1543.896972, 10.469670, 180.000000 ); // 5
	CreateATM( 2845.597412, 1286.504272, 11.030617, 0.00000000 ); // 6
	CreateATM( 1879.681396, 722.8941040, 10.440302, 180.000000 ); // 7
	CreateATM( 997.7407220, 2086.763427, 10.459657, -90.000000 ); // 8
	CreateATM( 1480.238769, 2206.801025, 10.663430, -90.000000 ); // 9
	CreateATM( 1677.719604, 2756.413330, 10.459667, -90.000000 ); // 10
	CreateATM( -16.0785670, 1221.418579, 19.012741, -90.000000 ); // 11
	CreateATM( -792.090637, 2744.119140, 45.490905, 180.000000 ); // 12
	CreateATM( -1505.61242, 2622.352050, 55.470737, -90.000000 ); // 13
	CreateATM( -1952.57629, 2388.553466, 49.139991, 20.0000000 ); // 14
	CreateATM( -856.524902, 1528.208496, 22.238605, -90.000000 ); // 15

	// Los Santos
	CreateATM( 2234.733398, 51.345561000, 26.134365, 0.000000, 0.0 ); // 0
	CreateATM( 1381.069213, 259.56204200, 19.156929, 157.0000, 0.0 ); // 1
	CreateATM( 255.4551690, -197.5846250, 1.2381240, -90.0000, 0.0 ); // 2
	CreateATM( 661.3598020, -555.1714470, 15.965932, -90.0000, 0.0 ); // 3
	CreateATM( -2177.50292, -2435.006591, 30.214990, 52.00000, 0.0 ); // 4
	CreateATM( 1367.251464, -1284.611938, 13.156874, -90.6000, 0.0 ); // 5
	CreateATM( 1928.592651, -1771.088012, 13.172806, 90.00000, 0.0 ); // 6
	CreateATM( 2323.767333, -1644.993896, 14.442724, 0.000000, 0.0 ); // 7
	CreateATM( 2043.748779, -1416.704711, 16.810766, -90.0000, 0.0 ); // 8
	CreateATM( 2387.751464, -1981.961669, 13.156866, -180.000, 0.0 ); // 9
	CreateATM( 1494.450195, -1768.979492, 18.365745, -90.0000, 0.0 ); // 10
	CreateATM( 1051.627075, -1026.406616, 31.661567, 0.000000, 0.0 ); // 11
	CreateATM( 816.8725580, -1356.521240, 13.156099, -180.000, 0.0 ); // 12
	CreateATM( 1808.732177, -1567.267822, 13.063967, 37.00000, 0.0 ); // 13
	CreateATM( 2412.541259, -1492.666992, 23.628126, -180.000, 0.0 ); // 14
	CreateATM( 2431.131347, -1219.477539, 25.022165, 0.000000, 0.0 ); // 15

	// Casinos
	CreateATM( 1985.135253, 1003.277404, 994.097290, 0.000 ); // 4 Drags
	CreateATM( 1986.635253, 1032.391113, 994.097290, 180.0 ); // 4 Drags
	CreateATM( 2230.132324, 1647.986816, 1007.97900, -90.0 ); // Caligs
	CreateATM( 2241.676269, 1649.486816, 1007.97900, 90.00 ); // Caligs

	/* ** Lumberjack ** */
	CreateLumberjackTree( -2358.10000000, -84.60000000, 34.10000000 );
	CreateLumberjackTree( -2349.90000000, -85.40000000, 34.10000000 );
	CreateLumberjackTree( -2341.20000000, -86.20000000, 34.10000000 );
	CreateLumberjackTree( -2341.20000000, -93.70000000, 34.10000000 );
	CreateLumberjackTree( -2350.90000000, -92.80000000, 34.10000000 );
	CreateLumberjackTree( -2357.40000000, -92.20000000, 34.10000000 );
	CreateLumberjackTree( -2357.90000000, -97.40000000, 34.10000000 );
	CreateLumberjackTree( -2350.90000000, -98.10000000, 34.10000000 );
	CreateLumberjackTree( -2341.70000000, -99.00000000, 34.10000000 );
	CreateLumberjackTree( -2334.80000000, -86.00000000, 34.10000000 );
	CreateLumberjackTree( -2334.90000000, -93.20000000, 34.10000000 );
	CreateLumberjackTree( -2334.80000000, -98.80000000, 34.10000000 );
	CreateLumberjackTree( -2335.00000000, -103.9000000, 34.10000000 );
	CreateLumberjackTree( -2341.50000000, -103.5000000, 34.10000000 );
	CreateLumberjackTree( -2350.40000000, -103.3000000, 34.10000000 );
	CreateLumberjackTree( -2358.34000000, -103.0300000, 34.10000000 );

	/* ** Mining Rock ** */
	CreateMiningRock( ORE_COAL, 	868, -2751.8393, 1245.06689, 11.4003100, 0.000000, 0.000000, -54.8999 );
	CreateMiningRock( ORE_COAL, 	867, -2746.3259, 1241.43030, 11.1903100, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_COAL, 	867, -2738.7551, 1259.25769, 11.1903100, 0.000000, 0.000000, 147.5000 );
	CreateMiningRock( ORE_COAL, 	868, -2751.0561, 1263.11548, 11.4003100, 0.000000, 0.000000, -115.800 );
	CreateMiningRock( ORE_COAL, 	867, -2758.5654, 1252.22095, 11.1903100, 0.000000, 0.000000, 169.4000 );
	CreateMiningRock( ORE_IRON, 	868, -2745.1460, 1259.26074, 11.1703100, 0.000000, 0.000000, 80.19992 );
	CreateMiningRock( ORE_IRON,		868, -2735.3110, 1245.65906, 11.2103100, 0.000000, 0.000000, -158.099 );
	CreateMiningRock( ORE_IRON,		868, -2736.8037, 1242.34534, 10.8966600, 0.000000, 0.000000, 8.999990 );
	CreateMiningRock( ORE_IRON,		868, -2737.9262, 1245.05554, 11.0432500, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_IRON,		867, -2749.1315, 1260.08789, 11.1903100, 0.000000, 0.000000, -10.6999 );
	CreateMiningRock( ORE_IRON,		868, -2740.4924, 1232.87720, 10.8966600, 0.000000, 0.000000, 14.15999 );
	CreateMiningRock( ORE_GOLD, 	868, -2737.0988, 1235.62610, 11.0432500, 0.000000, 0.000000, 172.3799 );
	CreateMiningRock( ORE_BAUXITE, 	867, -2741.5380, 1236.00732, 11.1903100, 0.000000, 0.000000, 240.8608 );
	CreateMiningRock( ORE_GOLD, 	868, -2744.7741, 1248.38403, 11.4003100, 0.000000, 0.000000, -54.8999 );
	CreateMiningRock( ORE_GOLD, 	868, -2748.1691, 1250.73535, 11.4003100, 0.000000, 0.000000, -88.8000 );
	CreateMiningRock( ORE_BAUXITE, 	867, -2734.9423, 1251.73816, 11.1903100, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_BAUXITE, 	867, -2735.5700, 1255.47192, 11.1903100, 0.000000, 0.000000, -139.019 );
	CreateMiningRock( ORE_BAUXITE, 	867, -2748.3437, 1235.13391, 11.1903100, 0.000000, 0.000000, -99.6000 );
	CreateMiningRock( ORE_BAUXITE, 	867, -2747.8896, 1238.57886, 11.1903100, 0.000000, 0.000000, 174.6602 );
	CreateMiningRock( ORE_PLATINUM, 868, 645.557128, 884.099853, -42.842994, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_PLATINUM, 867, 648.377441, 885.626892, -42.872383, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_EMERALD, 	868, 648.093261, 865.079772, -42.976993, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_EMERALD, 	867, 648.093261, 867.079772, -42.976993, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_PLATINUM, 868, 685.774841, 909.739135, -40.452533, 10.89999, 0.000000, -105.500 );
	CreateMiningRock( ORE_EMERALD, 	868, 679.863281, 925.253662, -41.573390, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_DIAMOND, 	868, 684.565002, 921.632324, -41.270782, 0.400041, 0.000000, 120.0000 );
	CreateMiningRock( ORE_AMETHYST, 867, 527.286315, 842.197082, -43.581855, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_AMETHYST, 867, 569.048278, 840.496887, -42.454177, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_PLATINUM, 868, 570.629943, 841.765747, -42.634399, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_PLATINUM, 868, 598.894470, 847.992004, -43.830204, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_AMETHYST, 867, 604.275024, 848.331298, -43.830204, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_DIAMOND, 	868, 629.993469, 823.527526, -43.400970, 0.000000, 0.000000, 85.90009 );
	CreateMiningRock( ORE_COAL, 	867, 626.069946, 851.749389, -43.610939, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_EMERALD, 	867, 658.767028, 812.288208, -43.610939, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_EMERALD, 	867, 659.874877, 812.647521, -43.610939, 0.000000, 0.000000, 90.00000 );
	CreateMiningRock( ORE_AMETHYST, 868, 657.839660, 837.129272, -43.610939, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_COAL, 	867, 657.596984, 834.139099, -43.610939, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_DIAMOND, 	867, 652.896362, 846.951110, -43.610939, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_DIAMOND, 	867, 660.239624, 841.461730, -43.610939, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_SAPHHIRE, 867, 659.540588, 860.061401, -43.610939, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_IRON, 	867, 638.540527, 830.990112, -43.610939, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_COAL, 	867, 630.540527, 830.990112, -43.610939, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_COAL, 	868, 688.510498, 906.781005, -40.194725, -5.20000, 0.000000, 133.1999 );
	CreateMiningRock( ORE_COAL, 	867, 622.073303, 874.670532, -43.610939, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_SAPHHIRE, 867, 606.893066, 877.988037, -43.610939, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_IRON, 	868, 600.279541, 870.543884, -43.557388, 0.000000, 0.000000, 45.00000 );
	CreateMiningRock( ORE_IRON, 	867, 579.832519, 893.789855, -44.315792, 0.000000, 0.000000, 15.00000 );
	CreateMiningRock( ORE_DIAMOND, 	867, 614.769104, 921.359924, -42.239196, 15.20000, -7.40000, 0.000000 );
	CreateMiningRock( ORE_SAPHHIRE, 867, 609.398437, 914.821777, -43.654232, 12.70000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_BAUXITE, 	867, 635.195068, 919.271728, -42.244331, 17.80000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_BAUXITE, 	867, 654.036071, 926.508178, -40.387538, 14.20000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_SAPHHIRE, 868, 670.923217, 915.094238, -41.392536, 0.000000, 0.000000, 0.000000 );
	CreateMiningRock( ORE_SAPHHIRE, 867, 685.852478, 899.059631, -40.304836, 0.000000, -3.60000, 0.000000 );
	CreateMiningRock( ORE_RUBY, 	867, 691.398437, 903.649169, -39.766517, -5.20000, 0.000000, 133.1990 );
	CreateMiningRock( ORE_RUBY, 	867, 692.537475, 898.189575, -39.629940, -4.79999, -5.69999, 0.000000 );
	CreateMiningRock( ORE_RUBY, 	867, 680.914611, 892.820068, -40.536987, 10.99999, -3.60000, -106.900 );
	CreateMiningRock( ORE_GOLD,	 	867, 692.731994, 894.016052, -39.744705, 7.099992, -2.00000, -106.900 );
	CreateMiningRock( ORE_GOLD, 	867, 691.096679, 888.700439, -39.801738, -0.80000, 1.200000, 173.1999 );
	CreateMiningRock( ORE_GOLD, 	867, 684.758605, 885.710876, -40.225788, 0.000000, 0.000000, 15.00000 );

	/* ** Drug Dealer ** */

	// San Fierro
	CreateWeedPlant( -1840.90, 1034.53, 45.70, 0.00, 0.00, 0.00 );
	CreateWeedPlant( -1846.17, 1027.93, 45.70, 0.00, 0.00, 0.00 );
	CreateWeedPlant( -1835.89, 1030.38, 45.70, 0.00, 0.00, 0.00 );
	CreateWeedPlant( -1846.73, 1016.40, 45.72, 11.5, 1.86, 0.00 );
	CreateWeedPlant( -1840.48, 1022.97, 46.12, 11.5, 1.86, 0.00 );
	CreateWeedPlant( -1835.85, 1017.52, 45.82, 6.72, 0.84, 0.00 );
	CreateWeedPlant( -1842.32, 1011.92, 45.82, 6.72, 0.84, 0.00 );
	CreateWeedPlant( -1836.99, 1008.02, 45.82, 6.72, 0.84, 0.00 );
	CreateWeedPlant( -1838.05, 997.580, 45.82, 6.72, 0.84, 0.00 );
	CreateWeedPlant( -1847.71, 1005.00, 45.82, 6.72, 0.84, 0.00 );
	CreateWeedPlant( -1842.39, 1001.95, 45.82, 6.72, 0.84, 0.00 );
	CreateWeedPlant( -1838.40, 990.090, 45.82, 6.72, 0.84, 0.00 );
	CreateWeedPlant( -1832.22, 1012.22, 45.82, 6.72, 0.84, 0.00 );
	CreateWeedPlant( -1831.87, 1025.52, 45.82, 6.72, 0.84, 0.00 );

	#if ENABLE_CITY_LV == true
	// Las Venturas
	CreateWeedPlant( 2567.580, 2463.27, 10.82, 0.00, 0.00, 0.00 );
	CreateWeedPlant( 2572.580, 2462.69, 10.82, 0.00, 0.00, 0.00 );
	CreateWeedPlant( 2577.580, 2464.02, 10.82, 0.00, 0.00, 0.00 );
	CreateWeedPlant( 2582.580, 2465.27, 10.82, 0.00, 0.00, 0.00 );
	CreateWeedPlant( 2587.580, 2462.27, 10.82, 0.00, 0.00, 0.00 );
	CreateWeedPlant( 2592.580, 2464.77, 10.82, 0.00, 0.00, 0.00 );
	CreateWeedPlant( 2597.580, 2464.27, 10.82, 0.00, 0.00, 0.00 );
	CreateWeedPlant( 2568.991, 2468.19, 10.82, 0.00, 0.00, 0.00 );
	CreateWeedPlant( 2573.991, 2469.39, 10.82, 0.00, 0.00, 0.00 );
	CreateWeedPlant( 2578.991, 2470.19, 10.82, 0.00, 0.00, 0.00 );
	CreateWeedPlant( 2583.991, 2469.19, 10.82, 0.00, 0.00, 0.00 );
	CreateWeedPlant( 2588.991, 2467.19, 10.82, 0.00, 0.00, 0.00 );
	CreateWeedPlant( 2593.991, 2468.19, 10.82, 0.00, 0.00, 0.00 );
	CreateWeedPlant( 2598.991, 2470.19, 10.82, 0.00, 0.00, 0.00 );
	CreateWeedPlant( 2603.093, 2466.90, 10.82, 0.00, 0.00, 0.00 );
	#endif

	#if ENABLE_CITY_LS == true
	CreateWeedPlant( 2447.354, -1711.075, 13.5094, 0.0, 0.0, 0.0000 );
	CreateWeedPlant( 2450.854, -1711.075, 13.5094, 0.0, 0.0, -13.59 );
	CreateWeedPlant( 2446.565, -1715.559, 13.5094, 0.0, 0.0, 39.599 );
	CreateWeedPlant( 2451.853, -1716.996, 13.5094, 0.0, 0.0, 0.0000 );
	CreateWeedPlant( 2455.603, -1711.075, 13.5094, 0.0, 0.0, 59.900 );
	CreateWeedPlant( 2455.434, -1714.954, 13.5094, 0.0, 0.0, 59.900 );
	CreateWeedPlant( 2460.162, -1713.718, 13.5094, 0.0, 0.0, 59.900 );
	CreateWeedPlant( 2462.092, -1710.387, 13.5094, 0.0, 0.0, 59.900 );
	CreateWeedPlant( 2465.872, -1712.579, 13.5094, 0.0, 0.0, 59.900 );
	CreateWeedPlant( 2463.214, -1717.164, 13.5094, 0.0, 0.0, 59.900 );
	CreateWeedPlant( 2468.758, -1715.719, 13.5094, 0.0, 0.0, 59.900 );
	CreateWeedPlant( 2470.875, -1712.068, 13.5094, 0.0, 0.0, 59.900 );
	CreateWeedPlant( 2467.420, -1718.029, 13.5094, 0.0, 0.0, 59.900 );
	CreateWeedPlant( 2459.837, -1717.633, 13.5094, 0.0, 0.0, 9.0000 );
	CreateWeedPlant( 2454.947, -1718.407, 13.5094, 0.0, 0.0, -21.49 );
	#endif

	/* ** Secure Truck Mod ** */
#if ENABLED_SECURE_TRUCK == true
	g_secureTruckVehicle 	= AddStaticVehicle( 428, 2000.0, 2000.0, 2000.0, 180.0, -1, -1 );

	for( new i = 0; i < sizeof( g_secureTruckOffsets ); i++ ) {
  		g_secureTruckVehicleLabel[ i ] = CreateDynamic3DTextLabel( "100%", setAlpha( COLOR_GREY, 0x90 ), g_secureTruckOffsets[ i ] [ E_X ], g_secureTruckOffsets[ i ] [ E_Y ], g_secureTruckOffsets[ i ] [ E_Z ], 25.0, INVALID_PLAYER_ID, g_secureTruckVehicle );
	}

	ConnectNPC( SECURE_TRUCK_DRIVER_NAME, "secureguard" );
#endif

	/* ** Custom Vehicles ** */
	g_TrolleyVehicles[ 0 ] = AddStaticVehicle( 457, -2511.7935, 760.5610, 34.8990, 90.6223, 123, 1 ); // trolley
	g_TrolleyVehicles[ 1 ] = AddStaticVehicle( 457, -2511.5742, 766.5329, 34.8990, 91.5108, 112, 1 ); // trolley
	g_TrolleyVehicles[ 2 ] = AddStaticVehicle( 457, -2511.8782, 763.1669, 34.8990, 89.6839, 116, 1 ); // trolley
	g_TrolleyVehicles[ 3 ] = AddStaticVehicle( 457, -2511.4871, 769.7538, 34.8990, 91.3486, 116, 1 ); // trolley
	g_TrolleyVehicles[ 4 ] = AddStaticVehicle( 457, -2512.2607, 772.9983, 34.9006, 91.2577, 116, 1 ); // trolley

	for( new i; i < sizeof( g_TrolleyVehicles ); i++ )
		ChangeVehicleModel( g_TrolleyVehicles[ i ], 1349, 270.0 + 180.0 );

	/* ** Objects ** */
	// MISC
	CreateDynamicObject(1498, 308.68, 312.10, 1002.30, 0.00, 0.00, 0.00); // Michelle's interior door
	CreateDynamicObject(19312, 191.16823, 1870.02869, 21.45658, 0.00, 0.00, 0.00); // Area 51
	CreateDynamicObject(1535, 968.46094, -53.96051, 1000.04688,   0.00000, 0.00000, 90.00000); // Brothel
	CreateDynamicObject(19364, 968.48914, -53.16937, 1001.84052,  0.00000, 0.00000, 0.00000); // Brothel
	CreateDynamicObject(1503, 2200.23975, 2065.48755, 10.19629,   0.00000, 0.00000, 90.00000); // Random LV Ramp
	CreateDynamicObject(8493, 1957.39600, 1510.48401, 24.97500,   0.00000, 0.00000, -159.14101); // [LVA] Pirateship
	CreateDynamicObject(9159, 1957.35095, 1510.50696, 24.95900,   0.00000, 0.00000, 200.78101);
	CreateDynamicObject(3886, 1991.42395, 1540.09497, 11.60500,   0.00000, 0.00000, 293.84100);
	CreateDynamicObject(3886, 1984.21106, 1536.94897, 11.58000,   0.00000, 0.00000, 112.57700);
	CreateDynamicObject(3886, 1962.28796, 1527.29602, 11.70500,   0.00000, 0.00000, 113.46300);
	CreateDynamicObject(3886, 1969.43604, 1530.47705, 11.68000,   0.00000, 0.00000, 293.84100); // [LVA] End of Pirateship
	CreateDynamicObject(19362, 1417.20593, 7.58543, 1008.36200,   0.00000, 0.00000, 90.00000); // Warehouse 1 Door

	// Billboards
	CreateBillboard( "Want V.I.P? Consider Donating!\n"COL_GREY"donate.irresistiblegaming.com", -2016.22, 326.580, 37.950, 48.9000 );
	CreateBillboard( "Save us on your favourites!\n"#SERVER_IP"", -1809.64, -590.29, 19.360, -147.30 );
	CreateBillboard( "You can catch updates on our website!\n"COL_GREY""#SERVER_WEBSITE"", -1571.11, 939.860, 10.030, 45.9600 );
	CreateBillboard( "Remember to check the "COL_GREY"/rules"COL_WHITE"!\nDisobeying the rules can lead to punishment!", -1911.05, 858.870, 36.290, 44.5200 );
	CreateBillboard( "Want to view the commands?\n Use "COL_GREY"/commands{FFFFFF}!", -2423.40, -621.18, 135.46, -195.90 );
	CreateBillboard( "Need help with something?\nUse "COL_GREY"/ask"COL_WHITE" to contact an admin!", -2659.78, 1277.70, 9.8600, 125.100 );
	CreateBillboard( "Saw a cheater? Report him by typing "COL_GREY"/report{FFFFFF}!", -2443.63, 719.970, 37.900, 0.00000 );
	CreateBillboard( "You can use "COL_GREY"/vipcmds"COL_WHITE" to view your\nV.I.P commands!", -1958.975830, 841.130798, 1208.881469, -43.700046 );

	// Signs - User friendly addition
	SetDynamicObjectMaterialText( CreateDynamicObject( 7301, -2418.657714, 743.686523, 1058.593750, 0.000000, 0.000000, -44.899974 ), 0, "Use /shop!", 120, "impact", 100, 0, -65536, 0, 1 );
	SetDynamicObjectMaterialText( CreateDynamicObject( 19353, -2337.8610, -107.4217, 36.2978, 0.0000, 0.0000, 90.0551 ), 0, "Wood Chipper", 130, "impact", 80, 0, -1, 0, 1 );
	SetDynamicObjectMaterialText( CreateDynamicObject( 19353, -2336.3244, -113.2057, 40.6778, 0.0000, 0.0000, 179.9560 ), 0, "Lumberjack", 130, "impact", 100, 0, -1, 0, 1 );
	SetDynamicObjectMaterialText( CreateDynamicObject( 19353, -1496.6134, 920.0287, 6.0990, 0.0, -90.0, -180 ), 0, "BANK", 100, "Times New Roman", 100, 0, -9170, 0, 1 );
	SetDynamicObjectMaterialText( ( g_LogCountObject = CreateDynamicObject(3074, -2329.4724, -106.0164, 33.1678, 0.0000, 0.0000, 90.000000) ), 0, "0 Logs Ready", 130, "Arial", 0, 1, -1, 0, 1);

	// Parking
 	CreateObject( 19485, -1909.55, 497.22, 25.71,   0.00, 0.00, 0.00, 500.0 );

 	// Random replacements made by sa-mp
	CreateObject( 19794, 1787.13281, -1565.67969, 11.96880, 0.00000, 0.00000, 0.00000, 500.0 );
	CreateObject( 11692, 199.343800, 1943.789060, 18.20310, 0.00000, 0.00000, 0.00000, 500.0 );
	CreateObject( 19484, -1875.02344, -65.328130, 15.06250, 0.00000, 0.00000, 0.00000, 500.0 );
	CreateObject( 19595, 1160.96094, -1180.57813, 70.41406, 0.00000, 0.00000, 0.00000, 500.0 );
	CreateObject( 19798, 1160.96094, -1180.57813, 20.50000, 0.00000, 0.00000, 0.00000, 500.0 );

	// V.I.P Lounge
	CreateDynamicObject( 3532, -1881.90, 823.73, 40.22, 0.00, 0.00, -48.84 );
	CreateDynamicObject( 3532, -1877.85, 824.96, 40.22, 0.00, 0.00, -103.02 );
	CreateDynamicObject( 3532, -1883.50, 819.35, 40.22, 0.00, 0.00, 8.82 );
	CreateDynamicObject( 18652, -1881.10, 822.92, 40.04, 0.00, 0.00, -49.68 );
	SetDynamicObjectMaterialText( CreateDynamicObject( 19353, -1882.8883, 824.6093, 40.3129, 0.0000, 0.0000, 133.4854 ), 0, "VIP LOUNGE", 90, "Impact", 64, 0, 0xFFFFFFFF, 0, 1 ); //0xFFFFDC2E

	// Apartments
	CreateObject( 4587, -1971.51, 1356.26, 65.32,   0.00, 0.00, -180.00 );
	CreateObject( 3781, -1971.50, 1356.27, 28.26,   0.00, 0.00, -180.00 );
	CreateObject( 3781, -1971.50, 1356.27, 55.54,   0.00, 0.00, -180.00 );
	CreateObject( 3781, -1971.50, 1356.27, 82.77,   0.00, 0.00, -180.00 );
	CreateObject( 3781, -1971.50, 1356.27, 109.89,  0.00, 0.00, -180.00 );
	CreateObject( 4605, -1992.10, 1353.31, 1.11,    0.00, 0.00, -180.00 );

	g_apartmentElevator = CreateDynamicObject( 18755, -1955.09, 1365.51, 8.36, 0.00, 0.00, 90.00 );

	for( new level, Float: Z; level < MAX_AFLOORS; level++ )
	{
		switch( level )
		{
		    case 0:     Z = 8.36;
		    case 1:     Z = 17.03;
		    default:    Z = 17.03 + ( ( level - 1 ) * 5.447 );
		}
		g_apartmentElevatorDoor1[ level ] = CreateDynamicObject( 18756, -1955.05, 1361.64, Z, 0.00, 0.00, -90.00 );
		g_apartmentElevatorDoor2[ level ] = CreateDynamicObject( 18757, -1955.05, 1361.64, Z, 0.00, 0.00, -90.00 );
	}

	// Houses
	SetObjectMaterialText( CreateObject( 10447, -2550.1719, 54.5625, 14.3906, 0.00, 0.00, 0.00, 500.0 ), "The Lost", 7, 40, "Times New Roman", 24, 1, -1, -16777216, 1 ); // The Lost

	// Lumberjack
	SetObjectMaterial( CreateObject( 12814, -2337.1, -94.00, 34.28, 0.0, 0.0, 270.0, 500.0 ), 0, 19381, "all_walls", "desgreengrass" );
	SetObjectMaterial( CreateObject( 12814, -2337.6, -105.3, 34.28, 0.0, 0.0, 90.00, 500.0 ), 0, 19381, "all_walls", "desgreengrass" );

	// Mining
	SetObjectMaterial( CreateObject(9864, -2724.33, 1230.44, 30.70, 0.0, 0.0, 0.0, 500.000 ), 3, 4845, "griffobs_las", "dirt64b2" );

	// Open warehouse near driving school
	CreateDynamicObject( 19486, -2111.13, -27.23, 36.95, 0.00, 0.00, -90.00 );

	// Bank
	g_bankvaultData[ CITY_SF ] [ E_OBJECT ] = CreateDynamicObject( 18766, -1412.565063, 859.274536, 983.132873, 0.000000, 90.000000, 90.000000 );
	g_bankvaultData[ CITY_LV ] [ E_OBJECT ] = CreateDynamicObject( 2634, 2114.742431, 1233.155273, 1017.616821, 0.000000, 0.000000, -90.000000, g_bankvaultData[ CITY_LV ] [ E_WORLD ] );
	g_bankvaultData[ CITY_LS ] [ E_OBJECT ] = CreateDynamicObject( 2634, 2114.742431, 1233.155273, 1017.616821, 0.000000, 0.000000, -90.000000, g_bankvaultData[ CITY_LS ] [ E_WORLD ] );
	SetDynamicObjectMaterial( g_bankvaultData[ CITY_SF ] [ E_OBJECT ], 0, 18268, "mtbtrackcs_t", "mp_carter_cage", -1 );

	// Wall of Donors
	SetDynamicObjectMaterialText( CreateDynamicObject( 3074, -1574.3559, 885.1296, 28.4690, 0.0000, 0.0000, -0.0156 ), 0, "Thx Monthly Donors", 130, "Times New Roman", 64, 1, -65536, 0, 1 );

	g_TopDonorWall = CreateDynamicObject( 3074, -1574.3559, 885.1296, 14.0153, 0.0000, 0.0000, -0.0156 );
	SetDynamicObjectMaterialText( g_TopDonorWall, 0, "Nobody donated :(", 130, "Arial", 48, 0, -65536, 0, 1 );

	// Alcatraz
	tmpVariable = CreateObject( 16109, -2080.595703, 1734.933837, -3.897439, 0.000000, 0.000000, 0.000000, 500.0 );
	SetObjectMaterial( tmpVariable, 0, 10452, "sfsroadshotel", "dirtgaz64b", 0 );
	SetObjectMaterial( tmpVariable, 1, 9957, "multistory_sfe", "grassgrn256", 0 );
	SetObjectMaterial( tmpVariable, 2, 13673, "mullho03a_lahills", "sw_rockgrass1", 0 );
	SetObjectMaterial( tmpVariable, 3, 13673, "mullho03a_lahills", "sw_rockgrass1", 0 );
	SetObjectMaterial( tmpVariable, 4, 13673, "mullho03a_lahills", "sw_rockgrass1", 0 );

	tmpVariable = CreateObject( 16149, -1912.565917, 1698.053833, -12.757503, 0.000000, 0.000000, 0.000000, 500.0 );
	SetObjectMaterial( tmpVariable, 0, 13673, "mullho03a_lahills", "sw_rockgrass1", 0 );
	SetObjectMaterial( tmpVariable, 2, 9957, "multistory_sfe", "grassgrn256", 0 );
	SetObjectMaterial( tmpVariable, 3, 13673, "mullho03a_lahills", "sw_rockgrass1", 0 );
	SetObjectMaterial( tmpVariable, 4, 13673, "mullho03a_lahills", "sw_rockgrass1", 0 );
	SetObjectMaterial( tmpVariable, 5, 9957, "multistory_sfe", "grassgrn256", 0 );
	SetObjectMaterial( tmpVariable, 6, 9957, "multistory_sfe", "grassgrn256", 0 );

	tmpVariable = CreateObject( 16147, -1926.906250, 1901.545288, -11.262178, 0.000000, 0.000000, 0.000000, 500.0 );
	SetObjectMaterial( tmpVariable, 0, 9957, "multistory_sfe", "grassgrn256", 0 );
	SetObjectMaterial( tmpVariable, 1, 9957, "multistory_sfe", "grassgrn256", 0 );
	SetObjectMaterial( tmpVariable, 2, 13673, "mullho03a_lahills", "sw_rockgrass1", 0 );
	SetObjectMaterial( tmpVariable, 3, 13673, "mullho03a_lahills", "sw_rockgrass1", 0 );
	SetObjectMaterial( tmpVariable, 4, 13673, "mullho03a_lahills", "sw_rockgrass1", 0 );
	SetObjectMaterial( tmpVariable, 5, 13673, "mullho03a_lahills", "sw_rockgrass1", 0 );
	SetObjectMaterial( tmpVariable, 6, 10452, "sfsroadshotel", "dirtgaz64b", 0 );

	tmpVariable = CreateObject( 16148, -2088.817626, 1913.784423, -1.467424, 0.000000, 0.000000, 0.000000, 500.0 );
	SetObjectMaterial( tmpVariable, 0, 9957, "multistory_sfe", "grassgrn256", 0 );
	SetObjectMaterial( tmpVariable, 1, 13673, "mullho03a_lahills", "sw_rockgrass1", 0 );
	SetObjectMaterial( tmpVariable, 2, 13673, "mullho03a_lahills", "sw_rockgrass1", 0 );
	SetObjectMaterial( tmpVariable, 3, 13673, "mullho03a_lahills", "sw_rockgrass1", 0 );
	SetObjectMaterial( tmpVariable, 5, 5134, "wasteland_las2", "concretenewb256", 0 );
	SetObjectMaterial( tmpVariable, 6, 5134, "wasteland_las2", "concretenewb256", 0 );
	SetObjectMaterial( tmpVariable, 8, 5134, "wasteland_las2", "concretenewb256", 0 );

	/* ** Dirty Mechanic ** */
	// SF
	CreateCarjackerContainer( -1580.637817, 125.17828, 4.009482, 45.0, 	{ -1579.241090, 121.606070, 3.939500 }, { -1577.006840, 123.784420, 3.939500 }, { -55.0, 	0.0 }, { 45.00, -135.0 } );
	CreateCarjackerContainer( -1559.313354, 134.51689, 4.004680, -45.0, { -1562.892940, 133.132600, 3.939500 }, { -1560.726070, 130.873600, 3.939500 }, { -160.0, -90.0 }, { -45.0, -225.0 } );

	// LV
	CreateCarjackerContainer( 1637.343627, 2317.039062, 11.280317, 270.0, { 1633.789916, 2318.572753, 11.210318 }, { 1633.749877, 2315.451904, 11.210318 }, { 163.0, -152.0 }, { 270.0, 90.0 } );
	CreateCarjackerContainer( 1637.307006, 2326.375000, 11.280316, 270.0, { 1633.789916, 2327.905517, 11.210318 }, { 1633.749877, 2324.812988, 11.210318 }, { 156.0, -150.0 }, { 270.0, 90.0 } );

	// LS
	CreateCarjackerContainer( 2613.762939, -2213.233398, 14.002803, 0.000, { 2612.225830, -2216.737060, 13.936882 }, { 2615.337646, -2216.776367, 13.936882 }, { -105.0, -31.5 }, { 0.0, 180.0 } );
	CreateCarjackerContainer( 2616.617187, -2240.118652, 14.016877, 180.0, { 2618.161132, -2236.586425, 13.956872 }, { 2615.048828, -2236.566406, 13.956872 }, { 50.0, 138.8 }, { 180.0, 360.0 } );

	/* ** Pickups ** */
	CreateDynamicPickup( 337, 2, -2744.6367, 1264.8502, 11.77030 ); // Spade @Mining
	CreateDynamicPickup( 337, 2, 589.440800, 869.86900, -42.4973 ); // Spade @Mining
	CreateDynamicPickup( 371, 2, 1318.92200, 2002.7311, 1200.250 ); // Parachute @Shamal
	CreateDynamicPickup( 371, 2, -1745.2754, 59.301500, 866.4556 ); // Parachute @Veloxity

	/* ** RDM protection **
	static const
		Float: radius = 100.0;

	for( new i = 0; i < sizeof( g_SanFierroSpawns ); i++ )
		CreateNoDeathmatchZone( radius, g_SanFierroSpawns[ i ] [ RANDOM_SPAWN_X ], g_SanFierroSpawns[ i ] [ RANDOM_SPAWN_Y ] );

	//CreateNoDeathmatchZone( radius, g_FiremanSpawns[ 0 ] [ RANDOM_SPAWN_X ], g_FiremanSpawns[ 0 ] [ RANDOM_SPAWN_Y ] );
	CreateNoDeathmatchZone( radius, g_MedicSpawns[ 0 ] [ RANDOM_SPAWN_X ], g_MedicSpawns[ 0 ] [ RANDOM_SPAWN_Y ] );
	CreateNoDeathmatchZone( radius, g_ArmySpawns[ 0 ] [ RANDOM_SPAWN_X ], g_ArmySpawns[ 0 ] [ RANDOM_SPAWN_Y ] );
	CreateNoDeathmatchZone( radius, g_CIASpawns[ 0 ] [ RANDOM_SPAWN_X ], g_CIASpawns[ 0 ] [ RANDOM_SPAWN_Y ] );
	CreateNoDeathmatchZone( radius, g_PoliceSpawns[ 0 ] [ RANDOM_SPAWN_X ], g_PoliceSpawns[ 0 ] [ RANDOM_SPAWN_Y ] );*/

	/* ** Set everyone offline ** */
	mysql_single_query( "UPDATE `USERS` SET `ONLINE` = 0" );

	/* ** Update Donation TD ** */
	UpdateGlobalDonated( );

	/* ** Auto Inactive Deletion ** */
#if !defined DEBUG_MODE
	static
		szDelete[ 600 ];

	// Delete accounts older than 4 months
	strcat( szDelete, "DELETE a1, a2, a3, a4, a5, a6, a7, a8, a9 FROM `USERS` AS a1 " );
	strcat( szDelete, "LEFT JOIN `HOUSES` AS a2 ON a2.`OWNER` = a1.`NAME` " );
	strcat( szDelete, "LEFT JOIN `VEHICLES` AS a3 ON a3.`OWNER` = a1.`ID` " );
	strcat( szDelete, "LEFT JOIN `FURNITURE` as a4 ON a4.`OWNER` = a1.`ID` " );
	strcat( szDelete, "LEFT JOIN `APARTMENTS` as a5 ON a5.`OWNER` = a1.`NAME` " );
	strcat( szDelete, "LEFT JOIN `GATES` as a6 ON a6.`OWNER` = a1.`ID` " );
	strcat( szDelete, "LEFT JOIN `TOY_UNLOCKS` as a7 ON a7.`USER_ID` = a1.`ID` " );
	strcat( szDelete, "LEFT JOIN `SETTINGS` as a8 ON a8.`USER_ID` = a1.`ID` " );
	strcat( szDelete, "LEFT JOIN `TOYS` as a9 ON a9.`USER_ID` = a1.`ID` " );
	strcat( szDelete, "LEFT JOIN `GARAGES` as a10 ON a10.`OWNER` = a1.`ID` " );
	strcat( szDelete, "WHERE UNIX_TIMESTAMP()-a1.`LASTLOGGED` > 10368000" );

	mysql_function_query( dbHandle, szDelete, true, "onRemoveInactiveRows", "d", 0 );
	// Truncate accounts older than 4 months
	mysql_function_query( dbHandle, "UPDATE USERS SET CASH =0,BANKMONEY=0,COINS=0.0 WHERE UNIX_TIMESTAMP()-`LASTLOGGED`>5259487", true, "onRemoveInactiveRows", "d", 1 );

	// Remove inactive homes older than 2 weeks
	mysql_function_query( dbHandle, "DELETE a2,a3 FROM `USERS` a1 " \
									"LEFT JOIN `FURNITURE` a2 on a1.`ID` = a2.`OWNER` "\
									"LEFT JOIN `APARTMENTS` a3 on a1.`NAME` = a3.`OWNER` "\
									"WHERE UNIX_TIMESTAMP()-a1.`LASTLOGGED` > 1209600;", true, "onRemoveInactiveRows", "d", 2 );

	mysql_function_query( dbHandle, "UPDATE `USERS` a1 JOIN `HOUSES` a2 ON a1.`NAME` = a2.`OWNER` "\
									"SET a2.`NAME`='Home', a2.`OWNER`='No-one', a2.`TX`=" #H_DEFAULT_X ", a2.`TY`=" #H_DEFAULT_Y ", a2.`TZ`=" #H_DEFAULT_Z ", a2.`INTERIOR`=2, a2.`PASSWORD`='N/A', a2.`WEAPONS`='0.0.0.0.0.0.0.', a2.`AMMO`='-1.-1.-1.-1.-1.-1.-1.' "\
									"WHERE UNIX_TIMESTAMP()-a1.`LASTLOGGED` > 1209600;", true, "onRemoveInactiveRows", "d", 3 );

	// Truncate banned players after 2 weeks
	mysql_function_query( dbHandle, "UPDATE `USERS` a1 JOIN `BANS` a2 ON a1.`NAME` = a2.`NAME` "\
									"SET a1.`BANKMONEY`=0, a1.`CASH`=0 "\
									"WHERE UNIX_TIMESTAMP()-a1.`LASTLOGGED` > 1209600;", true, "onRemoveInactiveRows", "d", 4 );

	// Update vehicles with inactive garages.
	mysql_function_query( dbHandle, "UPDATE `VEHICLES` v JOIN `GARAGES` g ON g.`ID` = v.`GARAGE` JOIN `USERS` u ON u.`ID` = v.`OWNER` "\
									"SET v.`X`=g.`X`, v.`Y`=g.`Y`, v.`Z`=g.`Z`, v.`GARAGE`=-1 "\
									"WHERE v.`GARAGE` != -1 AND UNIX_TIMESTAMP()-u.`LASTLOGGED` > 1209600;", true, "onRemoveInactiveRows", "d", 5 );

	// mysql_function_query( dbHandle, "UPDATE `GARAGES` g JOIN `USERS` u ON u.`ID` = g.`OWNER` SET g.`OWNER`=0, g.`INTERIOR`=0 WHERE UNIX_TIMESTAMP()-u.`LASTLOGGED` > 1209600;", true, "onRemoveInactiveRows", "d", 6 );
	mysql_function_query( dbHandle, "DELETE g FROM `GARAGES` g JOIN `USERS` u ON u.`ID` = g.`OWNER` WHERE UNIX_TIMESTAMP()-u.`LASTLOGGED` > 1209600;", true, "onRemoveInactiveRows", "d", 6 );

	// Remove 25% of wealth off 2 weeks inactive players.
	mysql_function_query( dbHandle, "UPDATE `USERS` SET `CASH`=`CASH`*0.75,`BANKMONEY`=`BANKMONEY`*0.75 WHERE UNIX_TIMESTAMP()-`LASTLOGGED`>1209600", true, "onRemoveInactiveRows", "d", 7 );

	// Remove inactive gang members
	mysql_single_query( "UPDATE `USERS` SET `GANG_ID`=-1 WHERE UNIX_TIMESTAMP()-`USERS`.`LASTLOGGED` > 1209600" );
#endif

	/* ** Houses/Bribes/ETC **/
	printf( "[ENTRANCES]: %d entrances have been successfully loaded.", Iter_Count(entrances) );
	printf( "[ROBBERIES]: %d robberies have been successfully loaded.", Iter_Count(RobberyCount) );
	printf( "[ROBBERIES]: %d robbery NPCs have been successfully loaded.", Iter_Count(RobberyNpc) );

 	g_preloadedObjectCount = Streamer_GetUpperBound( STREAMER_TYPE_OBJECT ); // To look more efficiently, preloaded doesn't worry that way.
	mysql_function_query( dbHandle, "SELECT * FROM `HOUSES`", true, "OnHouseLoad", "" );
	mysql_function_query( dbHandle, "SELECT * FROM `BRIBES`", true, "OnBribeLoad", "" );
	mysql_function_query( dbHandle, "SELECT * FROM `APARTMENTS`", true, "OnApartmentLoad", "" );
	mysql_function_query( dbHandle, "SELECT * FROM `FURNITURE`", true, "OnFurnitureLoad", "" );
	mysql_function_query( dbHandle, "SELECT * FROM `GATES`", true, "OnGatesLoad", "" );
	mysql_function_query( dbHandle, "SELECT * FROM `GARAGES`", true, "OnGaragesLoad", "" );
	mysql_function_query( dbHandle, "SELECT * FROM `ENTRANCES`", true, "OnEntrancesLoad", "" );
	mysql_function_query( dbHandle, "SELECT * FROM `CASINO_POOLS`", true, "OnCasinoPoolsLoad", "" );
	mysql_function_query( dbHandle, "SELECT * FROM `BUSINESSES`", true, "OnBusinessLoad", "" );

	/* ** Timers ** */
	rl_ServerUpdate = SetTimer( "OnServerUpdate", 960, true );
	rl_ZoneUpdate = SetTimer( "ZoneTimer", 980, true );

	HTTP( 0, HTTP_GET, "files.irresistiblegaming.com/en_rules.txt", "", "OnRulesHTTPResponse" );

	printf( "[SF-CNR] SF-CnR has been successfully initiaized. (Build: "#FILE_BUILD" | Time: %d)", ( g_ServerUptime = gettime( ) ) );
	return 1;
}

public OnDonationRedemptionResponse( index, response_code, data[ ] )
{
    if ( response_code == 200 )
    {
		if ( strmatch( data, "{FFFFFF}Unable to identify transaction." ) ) ShowPlayerDialog( index, DIALOG_NULL, DIALOG_STYLE_MSGBOX, ""COL_GOLD"Irresistible Gaming Donation", data, "Okay", "" );
		else
		{
			static aDonation[ E_DONATION_DATA ];
			sscanf( data, "p<|>e<s[17]s[24]s[11]s[64]d>", aDonation );

			// printf("donation {id:%s, name:%s, amount:%s, purpose:%s, date:%d}", aDonation[ E_TRANSACTION_ID ],aDonation[ E_NAME ],aDonation[ E_AMOUNT ],aDonation[ E_PURPOSE ],aDonation[ E_DATE ]);
			if ( strfind( aDonation[ E_PURPOSE ], "San Fierro: Cops And Robbers" ) == -1 )
			{
				ShowPlayerDialog( index, DIALOG_NULL, DIALOG_STYLE_MSGBOX, ""COL_GOLD"Irresistible Gaming Donation", ""COL_WHITE"This donation is not specifically for this server thus you are unable to retrieve anything.", "Okay", "" );
				return 0;
			}

			// SELECT * FROM `REDEEMED` WHERE `ID` = MD5('%s7resta#ecacakumedeM=yespawr!d@et') LIMIT 0,1
			format( szNormalString, sizeof( szNormalString ), "SELECT * FROM `REDEEMED` WHERE `ID` = MD5('%s%s') LIMIT 0,1", mysql_escape( aDonation[ E_TRANSACTION_ID ] ), szRedemptionSalt );
	 		mysql_function_query( dbHandle, szNormalString, true, "OnCheckForRedeemedVIP", "is", index, data );
		}
	}
 	else ShowPlayerDialog( index, DIALOG_NULL, DIALOG_STYLE_MSGBOX, ""COL_GOLD"Irresistible Gaming Donation", ""COL_WHITE"Unable to connect to the donation database. Please try again later.", "Okay", "" );
	return 1;
}

thread OnCheckForRedeemedVIP( playerid, data[ ] )
{
	static
		aDonation[ E_DONATION_DATA ],
	    rows, fields
	;
    cache_get_data( rows, fields );

	if ( rows )
	{
		static
			szName[ MAX_PLAYER_NAME ];

		cache_get_field_content( 0, "REDEEMER", szName );
		ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_MSGBOX, ""COL_GOLD"Irresistible Gaming Donation", sprintf( ""COL_WHITE"Sorry this transaction ID has already been redeemed by %s.", szName ), "Okay", "" );
	}
	else
	{
		g_redeemVipWait = g_iTime + 10;

		sscanf( data, "p<|>e<s[17]s[24]s[11]s[64]d>", aDonation );

		format( szNormalString, sizeof( szNormalString ), "INSERT INTO `REDEEMED`(`ID`, `REDEEMER`) VALUES (MD5('%s%s'), '%s')", mysql_escape( aDonation[ E_TRANSACTION_ID ] ), szRedemptionSalt, ReturnPlayerName( playerid ) );
		mysql_single_query( szNormalString );

		//printf( "%s\n%s | %s | %f | %s | %d", data, aDonation[ E_TRANSACTION_ID ], aDonation[ E_EMAIL ], floatstr( aDonation[ E_AMOUNT ] ), aDonation[ E_PURPOSE ], aDonation[ E_DATE ]);

		new
			Float: fAmount = floatstr( aDonation[ E_AMOUNT ] ),
			Float: iCoins = fAmount * ( 1 + GetGVarFloat( "vip_bonus" ) ) * 100.0
		;

		if ( p_Uptime[ playerid ] > 604800 )
		{
			if ( fAmount < 1.99999 )
				return SendError( playerid, "Thanks for donating! As this donation was under $2.00 USD, no coin has been issued." );
		}
		else
		{
			if ( fAmount < 4.99999 )
				return SendError( playerid, "Thanks for donating! As this donation was under $5.00 USD, no coins have been issued." );
		}

		p_IrresistibleCoins[ playerid ] += iCoins;
		SetPVarFloat( playerid, "just_donated", fAmount );

		SendClientMessageFormatted( playerid, -1, ""COL_GOLD"[VIP PACKAGE]"COL_WHITE" You have received %0.0f Irresistible Coins! Thanks for donating %s!!! :D", iCoins, ReturnPlayerName( playerid ) );

		format( szBigString, 256, ""COL_GREY"Transaction ID:\t"COL_WHITE"%s\n"COL_GREY"Donor Name:\t"COL_WHITE"%s\n"COL_GREY"Amount:\t"COL_WHITE"$%0.2f\n"COL_GREY"Total Coins:\t"COL_WHITE"%0.0f\n"COL_GREY"Time Ago:\t"COL_WHITE"%s",
				aDonation[ E_TRANSACTION_ID ], aDonation[ E_NAME ], floatstr( aDonation[ E_AMOUNT ] ), iCoins, secondstotime( g_iTime - aDonation[ E_DATE ] ) );

		ShowPlayerDialog( playerid, DIALOG_DONATED, DIALOG_STYLE_MSGBOX, ""COL_GOLD"Irresistible Gaming Donation", szBigString, "Continue", "" );
	}
	return 1;
}

thread onRemoveInactiveRows( type )
{
	new
		iRemoved = cache_affected_rows( );

	if ( iRemoved )
	{
		switch( type )
		{
			case 0: format( szNormalString, 96, "[%s %s] Removed approximately %d inactive rows.\r\n", getCurrentDate( ), getCurrentTime( ), iRemoved );
	   		case 1: format( szNormalString, 96, "[%s %s] Flushed around %d accounts.\r\n", getCurrentDate( ), getCurrentTime( ), iRemoved );
	   		case 2: format( szNormalString, 96, "[%s %s] Flushed %d inactive owners' furniture.\r\n", getCurrentDate( ), getCurrentTime( ), iRemoved );
	   		case 3: format( szNormalString, 96, "[%s %s] Auctioned %d inactive homes. \r\n", getCurrentDate( ), getCurrentTime( ), iRemoved );
	   		case 4: format( szNormalString, 96, "[%s %s] Flushed around %d banned accounts. \r\n", getCurrentDate( ), getCurrentTime( ), iRemoved );
	   		case 5: format( szNormalString, 96, "[%s %s] Repositioned approximately %d vehicles from inactive garages. \r\n", getCurrentDate( ), getCurrentTime( ), iRemoved );
	   		case 6: format( szNormalString, 96, "[%s %s] Flushed around %d garages. \r\n", getCurrentDate( ), getCurrentTime( ), iRemoved );
	   		case 7: format( szNormalString, 96, "[%s %s] 25 percent of %d accounts wealth wiped. \r\n", getCurrentDate( ), getCurrentTime( ), iRemoved );
	   	}
	    AddFileLogLine( "inactive_rows.txt", szNormalString );

		strreplace( szNormalString, "\r\n", "" );
	    printf( "[INACTIVITY] %s", szNormalString );
	}
	return 1;
}

public OnDynamicObjectMoved( objectid )
{
	if ( objectid == g_apartmentElevator )
	{
		DestroyDynamicObject( g_apartmentElevatorGate ), g_apartmentElevatorGate = INVALID_OBJECT_ID;

		new Float: Y, Float: Z, i = g_apartmentElevatorLevel;
		GetDynamicObjectPos( g_apartmentElevatorDoor1[ i ], Y, Y, Z );
		MoveDynamicObject( g_apartmentElevatorDoor1[ i ], -1956.8068, Y, Z, 5.0 );

		GetDynamicObjectPos( g_apartmentElevatorDoor2[ i ], Y, Y, Z );
		MoveDynamicObject( g_apartmentElevatorDoor2[ i ], -1953.3468, Y, Z, 5.0 );
		return 1;
	}
	return 1;
}

public OnPlayerSelectObject(playerid, type, objectid, modelid, Float:fX, Float:fY, Float:fZ)
{
	CallRemoteFunction( "mapEditor_OnPlayerSelectObject", "ddddfff", playerid, type, objectid, modelid, fX, fY, fZ );
	return 1;
}

public OnPlayerEditObject(playerid, playerobject, objectid, response, Float:fX, Float:fY, Float:fZ, Float:fRotX, Float:fRotY, Float:fRotZ)
{
	CallRemoteFunction( "mapEditor_OnPlayerEditObject", "ddddffffff", playerid, playerobject, objectid, response, fX, fY, fZ, fRotX, fRotY, fRotZ );
	return 1;
}

public OnPlayerSelectDynamicObject( playerid, objectid, modelid, Float:x, Float:y, Float:z )
{
    if ( p_InHouse[ playerid ] != -1 ) {
   	 	if ( !strmatch( g_houseData[ p_InHouse[ playerid ] ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this house." );
    } else {
	    if ( IsValidApartment( p_ApartmentEditing{ playerid } ) ) {
	    	if ( !strmatch( g_apartmentData[ p_ApartmentEditing{ playerid } ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this apartment." );
	    } else return SendError( playerid, "You're not inside any house or not editing any specific apartment." );
    }

	if ( isFurnitureObject( modelid ) )
    	p_SelectedFurniture[ playerid ][ 0 ] = objectid, p_SelectedFurniture[ playerid ][ 1 ] = modelid, ShowPlayerDialog( playerid, DIALOG_FURNITURE_OPTION, DIALOG_STYLE_LIST, "Furniture", "Use Editor\nEdit Rotation X\nEdit Rotation Y\nEdit Rotation Z\nSell Object", "Select", "Back" );
	else
		SendError( playerid, "This is not a piece of furniture." ), ShowPlayerDialog( playerid, DIALOG_FURNITURE, DIALOG_STYLE_LIST, "{FFFFFF}Furniture", "Purchase Furniture\nSelect Furniture Easily\nSelect Furniture Manually\nSelect Furniture Nearest\n"COL_RED"Remove All Furniture\nSelect Furniture Nearest", "Confirm", "Back" );

	CancelEdit( playerid );
	return 1;
}

stock Float: getFloorZOffset( floor )
	return ( 14.9689 + ( floor * 5.42 ) );

stock IsPlayerInApartmentArea( playerid, floor )
{
	new Float: apartmentZ = getFloorZOffset( floor );
	return ( IsPlayerInArea3D( playerid, -2007.4579, -1915.5035, 1325.3346, 1384.0671, apartmentZ, apartmentZ + 5.5 ) && GetPlayerInterior( playerid ) == 0 );
}

public OnPlayerEditDynamicObject( playerid, objectid, response, Float:x, Float:y, Float:z, Float:rx, Float:ry, Float:rz )
{
	new gateItem = GetPVarInt( playerid, "gate_edititem" );

	if ( gateItem > 6 )
	{
		if ( response == EDIT_RESPONSE_FINAL )
		{
			new
				gID = GetPVarInt( playerid, "gate_editing" );

			switch( gateItem )
			{
				case 8:
				{
					g_gateData[ gID ] [ E_X ] = x;
					g_gateData[ gID ] [ E_Y ] = y;
					g_gateData[ gID ] [ E_Z ] = z;
					g_gateData[ gID ] [ E_RX ] = float( floatround( rx ) );
					g_gateData[ gID ] [ E_RY ] = float( floatround( ry ) );
					g_gateData[ gID ] [ E_RZ ] = float( floatround( rz ) );
					SendClientMessageFormatted( playerid, -1, ""COL_PINK"[GATE]"COL_WHITE" Gate Open Position: "COL_GREY" %f, %f, %f, %f, %f, %f", g_gateData[ gID ] [ E_X ], g_gateData[ gID ] [ E_Y ], g_gateData[ gID ] [ E_Z ], g_gateData[ gID ] [ E_RX ], g_gateData[ gID ] [ E_RY ], g_gateData[ gID ] [ E_RZ ] );
				}
				case 9:
				{
					g_gateData[ gID ] [ E_MOVE_X ] = x;
					g_gateData[ gID ] [ E_MOVE_Y ] = y;
					g_gateData[ gID ] [ E_MOVE_Z ] = z;
					g_gateData[ gID ] [ E_MOVE_RX ] = float( floatround( rx ) );
					g_gateData[ gID ] [ E_MOVE_RY ] = float( floatround( ry ) );
					g_gateData[ gID ] [ E_MOVE_RZ ] = float( floatround( rz ) );
					SendClientMessageFormatted( playerid, -1, ""COL_PINK"[GATE]"COL_WHITE" Gate Open Position: "COL_GREY" %f, %f, %f, %f, %f, %f", g_gateData[ gID ] [ E_MOVE_X ], g_gateData[ gID ] [ E_MOVE_Y ], g_gateData[ gID ] [ E_MOVE_Z ], g_gateData[ gID ] [ E_MOVE_RX ], g_gateData[ gID ] [ E_MOVE_RY ], g_gateData[ gID ] [ E_MOVE_RZ ] );
				}
			}
			UpdateGateData( gID );
			cmd_editgate( playerid, sprintf( "%d", gID ) );
			SyncObject( playerid );
		}
		return 1;
	}


#if ENABLE_COMPONENTS_SYSTEM == true
	if ( GetPVarType( playerid, "components_editing" ) != 0 )
	{
		new
	    	ownerid = INVALID_PLAYER_ID,
	    	vehicleid = GetPlayerVehicleID( playerid ),
	    	slotid = GetPVarInt( playerid, "components_editing" ),
	    	v = getVehicleSlotFromID( vehicleid, ownerid )
		;

		if ( v == -1 )
			return CancelEdit( playerid ), SendError( playerid, "You need to be in a buyable vehicle." );

		if ( playerid != ownerid )
			return CancelEdit( playerid ), SendError( playerid, "This vehicle does not belong to you." );

		if ( !g_vehiclePimpData[ ownerid ] [ v ] [ E_CREATED ] [ slotid ] )
			return CancelEdit( playerid ), SendError( playerid, "Internal Server Error (0x1C)." );

		if ( g_vehiclePimpData[ ownerid ] [ v ] [ E_OBJECT ] [ slotid ] != objectid )
			return CancelEdit( playerid ), SendError( playerid, "Internal Server Error (0x2D)." );

		static
			Float: X, Float: Y, Float:Z, Float: Angle;

		if ( response == EDIT_RESPONSE_FINAL )
		{
			// Grab positions prior
			GetVehicleZAngle( vehicleid, Angle );
			GetVehiclePos( vehicleid, X, Y, Z );

			// Calculate offsets
			new
				Float: fDistance = VectorSize( x - X, y - Y, 0.0 ),
				Float: fAngle = Angle - atan2( y - Y, x - X ),
				Float: finalX = fDistance * floatcos( fAngle, degrees ),
				Float: finalY = fDistance * floatsin( -fAngle, degrees ),
				Float: finalZ = z - Z
			;

			// Get model size
			GetVehicleModelInfo( GetVehicleModel( vehicleid ), VEHICLE_MODEL_INFO_SIZE, X, Y, Z );

			// Half because we're using pretty much the radius, not circumference (way to look at it)
			X /= 2.0, Y /= 2.0;

			if ( floatabs( finalX ) > X + 0.35 ) {
				SendServerMessage( playerid, "The object breaches the X axis limit for this vehicle (%0.1f). It has been moved.", ( finalX = X + 0.35 ) );
			}

			if ( floatabs( finalY ) > Y + 0.35 ) {
				SendServerMessage( playerid, "The object breaches the Y axis limit for this vehicle (%0.1f). It has been moved.", ( finalY = Y + 0.35 ) );
			}

			if ( floatabs( finalZ ) > Z + 0.35 ) {
				SendServerMessage( playerid, "The object breaches the Z axis limit for this vehicle (%0.1f). It has been moved.", ( finalZ = Z + 0.35 ) );
			}

			// Readjust variables
			g_vehiclePimpData[ ownerid ] [ v ] [ E_X ] [ slotid ] = finalX;
			g_vehiclePimpData[ ownerid ] [ v ] [ E_Y ] [ slotid ] = finalY;
			g_vehiclePimpData[ ownerid ] [ v ] [ E_Z ] [ slotid ] = finalZ;
			g_vehiclePimpData[ ownerid ] [ v ] [ E_RX ] [ slotid ] = rx;
			g_vehiclePimpData[ ownerid ] [ v ] [ E_RY ] [ slotid ] = ry;
			g_vehiclePimpData[ ownerid ] [ v ] [ E_RZ ] [ slotid ] = rz - Angle;

			format( szNormalString, sizeof( szNormalString ), "UPDATE `COMPONENTS` SET `X`=%f,`Y`=%f,`Z`=%f,`RX`=%f,`RY`=%f,`RZ`=%f WHERE `ID`=%d", finalX, finalY, finalZ, rx, ry, rz - Angle, g_vehiclePimpData[ ownerid ] [ v ] [ E_SQL_ID ] [ slotid ] );
			mysql_single_query( szNormalString );

			//DestroyDynamicObject( g_vehiclePimpData[ ownerid ] [ v ] [ E_OBJECT ] [ slotid ] );
			//g_vehiclePimpData[ ownerid ] [ v ] [ E_OBJECT ] [ slotid ] = CreateDynamicObject( g_vehiclePimpData[ ownerid ] [ v ] [ E_MODEL ] [ slotid ], 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 );
			AttachDynamicObjectToVehicle( g_vehiclePimpData[ ownerid ] [ v ] [ E_OBJECT ] [ slotid ], vehicleid, finalX, finalY, finalZ, rx, ry, rz - Angle );

			GetVehiclePos( vehicleid, X, Y, Z );
			return SetVehiclePos( vehicleid, X, Y, Z + 0.05 );
		}
		else if ( response == EDIT_RESPONSE_CANCEL )
		{
			//DestroyDynamicObject( g_vehiclePimpData[ ownerid ] [ v ] [ E_OBJECT ] [ slotid ] );
			//g_vehiclePimpData[ ownerid ] [ v ] [ E_OBJECT ] [ slotid ] = CreateDynamicObject( g_vehiclePimpData[ ownerid ] [ v ] [ E_MODEL ] [ slotid ], 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 );
			AttachDynamicObjectToVehicle( g_vehiclePimpData[ ownerid ] [ v ] [ E_OBJECT ] [ slotid ], vehicleid,
											g_vehiclePimpData[ ownerid ] [ v ] [ E_X ] [ slotid ], g_vehiclePimpData[ ownerid ] [ v ] [ E_Y ] [ slotid ], g_vehiclePimpData[ ownerid ] [ v ] [ E_Z ] [ slotid ],
											g_vehiclePimpData[ ownerid ] [ v ] [ E_RX ] [ slotid ], g_vehiclePimpData[ ownerid ] [ v ] [ E_RY ] [ slotid ], g_vehiclePimpData[ ownerid ] [ v ] [ E_RZ ] [ slotid ] );

			// Sync new position
			if ( GetVehiclePos( vehicleid, X, Y, Z ) ) {
				SetVehiclePos( vehicleid, X, Y, Z + 0.05 );
			}
		}
		return 1;
	}
#endif

    if ( p_InHouse[ playerid ] != -1 ) {
   	 	if ( !strmatch( g_houseData[ p_InHouse[ playerid ] ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this house." );
    } else {
	    if ( p_ApartmentEditing{ playerid } != -1 ) {
	    	if ( !strmatch( g_apartmentData[ p_ApartmentEditing{ playerid } ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this apartment." );
	    } else return SendError( playerid, "You're not inside any house or not editing any specific apartment." );
    }

	new
		Float: lastX, Float: lastY, Float: lastZ,
 		Float: lastRX, Float: lastRY, Float: lastRZ
 	;
	GetDynamicObjectPos( objectid, lastX, lastY, lastZ );
	GetDynamicObjectRot( objectid, lastRX, lastRY, lastRZ );

	switch( response )
	{
	    case EDIT_RESPONSE_FINAL:
	    {
	    	if ( IsPlayerInApartmentArea( playerid, p_ApartmentEditing{ playerid } ))
	    	{
		    	new Float: apartmentZ = getFloorZOffset( p_ApartmentEditing{ playerid } );

		    	if ( IsPointInPolygon( x, y, -1956.6293,1364.0175, -1956.6394,1367.0598, -1953.5428,1367.0598, -1953.5472,1364.0171 ) )
		    	{
		    		SendError( playerid, "You cannot place furniture within the elevator area. Doing so will remove your apartment!" );
		    		goto cancel_editing;
		    	}

		    	if ( !IsPointInPolygon( x, y,
						-2003.7538,1331.1801, -2004.5574,1332.0103, -2004.5818,1380.1896, -2003.7008,1381.0961, -1979.9607,1381.2789, -1979.5481,1375.6516, -1946.1802,1375.4758, -1942.3969,1374.2631, -1940.0063,1372.0107, -1938.4290,1368.7505, -1938.3868,1361.0717, -1939.0577,1358.9238,
						-1940.5144,1357.2417, -1942.4861,1356.2926, -1967.5673,1356.2303, -1979.4148,1345.7229, -1979.5145,1337.6086, -1980.3810,1334.8680, -1982.6312,1332.4343, -1984.9004,1331.3530
					) || z < apartmentZ || z > ( apartmentZ + 5.42 ) )
		    	{
		    		SendError( playerid, "The furniture you place must be within the apartment's area.");
		    		goto cancel_editing;
		    	}
		    }
			SetDynamicObjectPos( objectid, x, y, z );
			SetDynamicObjectRot( objectid, rx, ry, rz );

			format( szBigString, sizeof( szBigString ), "UPDATE `FURNITURE` SET `X`='%f',`Y`='%f',`Z`='%f',`RX`='%f',`RY`='%f',`RZ`='%f' WHERE `X`='%f' AND `Y`='%f'", x, y, z, rx, ry, rz, lastX, lastY );
			mysql_single_query( szBigString );

			SendServerMessage( playerid, "Furniture has been successfully updated." );
        	ShowPlayerDialog( playerid, DIALOG_FURNITURE, DIALOG_STYLE_LIST, "{FFFFFF}Furniture", "Purchase Furniture\nSelect Furniture Easily\nSelect Furniture Manually\nSelect Furniture Nearest\n"COL_RED"Remove All Furniture", "Confirm", "Back" );
		}
		case EDIT_RESPONSE_CANCEL:
		{
			SendServerMessage( playerid, "You have canceled editing the piece of furniture selected." );
			cancel_editing:
			{
				SetDynamicObjectPos( objectid, lastX, lastY, lastZ );
				SetDynamicObjectRot( objectid, lastRX, lastRY, lastRZ );
	        	ShowPlayerDialog( playerid, DIALOG_FURNITURE, DIALOG_STYLE_LIST, "{FFFFFF}Furniture", "Purchase Furniture\nSelect Furniture Easily\nSelect Furniture Manually\nSelect Furniture Nearest\n"COL_RED"Remove All Furniture", "Confirm", "Back" );
			}
		}
	}
	return 1;
}

public OnPlayerTakeOutFire( playerid, fireid )
{
	Achievement::HandleExtinguishedFires( playerid );
    SendClientMessageToFireman( -1, "{A83434}[FIREMAN]{FFFFFF} %s(%d) has extinguished house fire %d.", ReturnPlayerName( playerid ), playerid, fireid );
	GivePlayerScore( playerid, 2 );
	GivePlayerCash( playerid, 5000 );
	g_fireData[ fireid ] [ E_CREATED ]	= false;
    g_fireData[ fireid ] [ E_HOUSE ] 	= -1;
    DestroyDynamicObject				( g_fireData[ fireid ] [ E_OBJECT ] );
    g_fireData[ fireid ] [ E_OBJECT ] 	= INVALID_OBJECT_ID;
    DestroyDynamic3DTextLabel			( g_fireData[ fireid ] [ E_LABEL ] );
    g_fireData[ fireid ] [ E_LABEL ] 	= Text3D: 0xFFFF;
	return 1;
}

public OnPlayerChainsawTree( playerid, treeid )
{
	new
	    Float: X, Float: Y, Float: Z
	;
	GetDynamicObjectPos( g_treeData[ treeid ] [ E_OBJECT ], X, Y, Z );
	MoveDynamicObject( g_treeData[ treeid ] [ E_OBJECT ], X + 0.1, Y + 0.1, Z + 0.1, ( 0.05 ), 90.0, 0.0, 0.0 );
	g_treeData[ treeid ] [ E_CUT ] = true;
	return 1;
}

function lumberjack_RemoveWood( obj ) return StopDynamicObject( obj ), DestroyDynamicObject( obj ), 1;

public OnGameModeExit( )
{
    mysql_close( );
	KillTimer( rl_ServerUpdate );
	KillTimer( rl_ZoneUpdate );
    for( new t; t != MAX_TEXT_DRAWS; t++ ) TextDrawDestroy( Text: t );
	//SendRconCommand( "exit" );
	return 1;
}

public OnServerUpdate( )
{
	static
		iState, iVehicle, iWeapon, iAmmo, iKeys,
		Float: fX, Float: fY, Float: fZ, Float: fLastRate
	;

	// Random messages
	if ( ( g_iTime = gettime( ) ) > g_randomMessageTick )
	{
		new
			iRandomMessage = random( sizeof( g_randomMessages ) );

		if ( strmatch( g_randomMessages[ iRandomMessage ], "SLOT_MACHINES" ) )
		{
			new
				iRandom = random( 2 );

			if ( iRandom )
				SendClientMessageToAllFormatted( -1, "{8ADE47}Stephanie:"COL_WHITE" Four Dragons Casino has a prize pool of "COL_GREY"%s"COL_WHITE", use a slot machine to try win!", ConvertPrice( g_casinoPoolData[ 1 ] [ E_POOL ] ) );
			else
				SendClientMessageToAllFormatted( -1, "{8ADE47}Stephanie:"COL_WHITE" Caligulas Casino has a prize pool of "COL_GREY"%s"COL_WHITE", use a slot machine to try win!", ConvertPrice( g_casinoPoolData[ 0 ] [ E_POOL ] ) );
		}
		else
		{
	 		SendClientMessageToAll( -1, g_randomMessages[ iRandomMessage ] );
		}

		// throttle
		g_randomMessageTick = g_iTime + 30;
	}

 	// Happy Hour
 	new
 		playersOnline = Iter_Count(Player);

	if ( ( g_HappyHour = playersOnline <= 20 ) == true ) {
		// Maximum of 25% decrease
		g_HappyHourRate = 0.25 - ( playersOnline / 80.0 );

		// Only update colors if neccessary
		if ( fLastRate != g_HappyHourRate )
		{
			TextDrawSetString( g_NotManyPlayersTD, sprintf( "Coin generation increased by %0.1f%% as there aren't many players online!", g_HappyHourRate * 100.0 ) );
			TextDrawColor( g_NotManyPlayersTD, setAlpha( COLOR_RED, floatround( 200.0 - 10.0 * float( playersOnline ) ) ) );
			TextDrawShowForAllSpawned( g_NotManyPlayersTD );
		}

		// Update last rate
		fLastRate = g_HappyHourRate;
	} else {
		 // Disable Color
		g_HappyHourRate = 0.0;
		TextDrawColor( g_NotManyPlayersTD, 0 );
		TextDrawHideForAll( g_NotManyPlayersTD );
	}

	// Begin iterating all players
	foreach(new playerid : Player)
	{
		if ( g_WorldClockSeconds >= 1437 ) p_TaxTime{ playerid } = true; // The reason it aint in if statement below is because people may skip it...

		if ( IsPlayerSpawned( playerid ) && p_PlayerLogged{ playerid } )
		{
			iVehicle 	= GetPlayerVehicleID( playerid );
			iWeapon 	= GetPlayerWeapon( playerid );
			iState 		= GetPlayerState( playerid );

		    GetPlayerKeys( playerid, iKeys, tmpVariable, tmpVariable );

		    // Generally Updated textdraws
			PlayerTextDrawSetString( playerid, p_LocationTD[ playerid ], GetPlayerArea( playerid ) );
			PlayerTextDrawSetString( playerid, p_ExperienceTD[ playerid ], sprintf( "%08d", p_XP[ playerid ] ) );

			// Toggle total coin bar
			if ( !p_PlayerSettings[ playerid ] { SETTING_COINS_BAR } )
				PlayerTextDrawSetString( playerid, p_CoinsTD[ playerid ], sprintf( "%05.3f", p_IrresistibleCoins[ playerid ] ) );

			// Decrementing Weed Opacity Label
		    if ( p_WeedLabel[ playerid ] != Text3D: INVALID_3DTEXT_ID )
				UpdateDynamic3DTextLabelText( p_WeedLabel[ playerid ], setAlpha( COLOR_GREEN, floatround( ( float( GetPlayerDrunkLevel( playerid ) ) / 5000.0 ) * 255.0 ) ), "Blazed W33D Recently!" );

			// Not near kidnapper then untie
			if ( IsPlayerTied( playerid ) && isNotNearPlayer( playerid, p_TiedBy[ playerid ] ) && ( g_iTime - p_TiedAtTimestamp[ playerid ] ) >= 8 )
				UntiePlayer( playerid );

			// Not near detained player then uncuff
			if ( IsPlayerDetained( playerid ) && isNotNearPlayer( playerid, p_DetainedBy[ playerid ] ) && ( g_iTime - p_TiedAtTimestamp[ playerid ] ) >= 8 )
				Uncuff( playerid );

			// Trucking Trailers
			if ( iState == PLAYER_STATE_DRIVER && iVehicle && p_hasTruckingJob{ playerid } && !IsTrailerAttachedToVehicle( iVehicle ) && p_TruckingCancelTimer[ playerid ] == 0xFFFF )
		 		cancelPlayerTruckingCourier( playerid, iVehicle, .ticks = 60 );

		 	// Surfing a criminal vehicle
		 	if ( p_WantedLevel[ playerid ] < 6 && p_Class[ playerid ] != CLASS_POLICE )
		 	{
		 		new
		 			surfing_vehicle = GetPlayerSurfingVehicleID( playerid );

		 		if ( surfing_vehicle != INVALID_VEHICLE_ID )
		 		{
		 			new
		 				driverid = GetVehicleDriver( surfing_vehicle );

		 			if ( IsPlayerConnected( driverid ) && p_WantedLevel[ driverid ] > 2 && p_Class[ driverid ] != CLASS_POLICE ) {
		 				GivePlayerWantedLevel( playerid, 6 - p_WantedLevel[ playerid ] );
		 			}
		 		}
		 	}

		 	// Failed to pay ticket
		 	if ( p_TicketTimestamp[ playerid ] != 0 && g_iTime > p_TicketTimestamp[ playerid ] )
		 	{
		 		// inform user
		 		SendServerMessage( playerid, "You have resisted to pay your ticket and have become a wanted criminal." );
		 		SendClientMessageToCops( -1, ""COL_BLUE"[CRIME]"COL_WHITE" %s(%d) has resisted to pay his ticket.", ReturnPlayerName( playerid ), playerid );

				// remove ticket
				p_TicketTimestamp[ playerid ] = 0;
				p_TicketIssuer[ playerid ] = INVALID_PLAYER_ID;
				GivePlayerWantedLevel( playerid, 6 );
		 	}

		#if ENABLED_NPC_ROBBERIES == true

			new
				npcid = GetPlayerTargetPlayer( playerid );

			if ( FCNPC_IsValid( npcid ) && p_Class[ playerid ] != CLASS_POLICE )
			{
				new
					clerkid = GetRobberyNpcFromPlayer( npcid );

				if ( clerkid != -1 )
				{
					if ( g_robberyNpcData[ clerkid ] [ E_TIMEOUT ] < g_iTime && g_robberyNpcData[ clerkid ] [ E_HOLDUP_TIMER ] == -1 && g_robberyNpcData[ clerkid ] [ E_LOOT ] && ! g_robberyNpcData[ clerkid ] [ E_PROVOKED ] )
					{
						GivePlayerWantedLevel( playerid, 6 );
						PlayerTextDrawSetString( playerid, p_RobberyRiskTD[ playerid ], "~y~~h~Clerk is confused" );
						PlayerTextDrawShow( playerid, p_RobberyRiskTD[ playerid ] );
						PlayerTextDrawSetString( playerid, p_RobberyAmountTD[ playerid ], "Robbed ~g~~h~$0" );
						PlayerTextDrawShow( playerid, p_RobberyAmountTD[ playerid ] );

						FCNPC_ApplyAnimation( npcid, "SHOP", "SHP_Rob_React", 4.1, 0, 1, 1, 1, 0 );
						FCNPC_SetAnimationByName( npcid, "SHOP:SHP_Rob_React", 4.1, 0, 1, 1, 1, 0 );
						g_robberyNpcData[ clerkid ] [ E_HOLDUP_TIMER ] = SetTimerEx( "OnPlayerHoldupStore", 3000, false, "ddd", playerid, clerkid, 0 );

						TriggerClosestCivilians( playerid, clerkid );
					}
				}
				else
				{
					new
						civilianid = GetCivilianNpcFromPlayer( npcid );

					if ( civilianid != -1 ) {
						TriggerClosestCivilians( playerid, GetClosestRobberyNPC( getClosestRobberySafe( playerid ) ) );
					}
				}
			}

		#endif

			// AFK Players
			if ( ( GetTickCount( ) - p_AFKTime[ playerid ] ) >= 45000 )
			{
				// AFK Jail
				if ( p_WantedLevel[ playerid ] >= 6 && p_InHouse[ playerid ] == -1 && !IsPlayerAdminOnDuty( playerid ) && !IsPlayerInEntrance( playerid, g_VIPLounge[ CITY_SF ] ) && !IsPlayerInEntrance( playerid, g_VIPLounge[ CITY_LV ] ) && !IsPlayerInEntrance( playerid, g_VIPLounge[ CITY_LS ] ) && !IsPlayerTied( playerid ) && !IsPlayerKidnapped( playerid ) && !IsPlayerDetained( playerid ) && !IsPlayerCuffed( playerid ) && !IsPlayerTazed( playerid ) ) {
			    	JailPlayer( playerid, 60, 1 );
		        	SendGlobalMessage( -1, ""COL_GOLD"[JAIL]{FFFFFF} %s(%d) has been sent to jail for 60 seconds by the server "COL_LRED"[AFK Wanted]", ReturnPlayerName( playerid ), playerid );
				}

				// AFK Admins
				if ( IsPlayerAdminOnDuty( playerid ) )
					cmd_aod( playerid, "" );
			}

			// Anti Camping In Vault
			if ( IsPlayerInBank( playerid ) )
			{
			 	if ( IsPlayerInArea( playerid, -1412.215209, -1400.443237, 853.086669, 865.716735 ) && !g_bankvaultData[ CITY_SF ] [ E_DISABLED ] )
				{
					SendServerMessage( playerid, "You've been moved as you've entered the vault whilst it's closed." );
					SetPlayerPos( playerid, -1416.3499, 859.2744, 984.7126 );
				}

				if ( IsPlayerInArea( playerid, 2102.2590, 2113.5295, 1229.8595, 1246.2588 ) )
				{
					new
						world = GetPlayerVirtualWorld( playerid );

					if ( ( world == g_bankvaultData[ CITY_LV ] [ E_WORLD ] && !g_bankvaultData[ CITY_LV ] [ E_DISABLED ] ) || ( world == g_bankvaultData[ CITY_LS ] [ E_WORLD ] && !g_bankvaultData[ CITY_LS ] [ E_DISABLED ] ) )
					{
						SendServerMessage( playerid, "You've been moved as you've entered the vault whilst it's closed." );
						SetPlayerPos( playerid, 2121.7827, 1233.3225, 1017.1369 );
					}
				}
			}

			// Decrementing Wanted Level
			if ( p_WantedLevel[ playerid ] > 2 && !IsPlayerAdminOnDuty( playerid ) )
			{
				new
					Float: fDistance = FLOAT_INFINITY, iWanted;

				GetClosestPlayerEx( playerid, CLASS_POLICE, fDistance );

				if ( fDistance >= 500.0 ) {
					if ( GetPVarInt( playerid, "LoseWantedCD" ) < g_iTime ) {
						if ( p_WantedLevel[ playerid ] > 1800 ) 		iWanted = 24;
						else if ( p_WantedLevel[ playerid ] > 1000 ) iWanted = 12;
						else if ( p_WantedLevel[ playerid ] > 500 )	iWanted = 6;
						else if ( p_WantedLevel[ playerid ] > 250 )	iWanted = 4;
						else if ( p_WantedLevel[ playerid ] > 12 ) 	iWanted = 2;
						GivePlayerWantedLevel( playerid, -iWanted );
						SetPVarInt( playerid, "LoseWantedCD", g_iTime + 30 );
					}
				}
			}

			// Tied probably?
			if ( IsPlayerTied( playerid ) && g_iTime - p_TimeTiedAt[ playerid ] > MAX_TIME_TIED ) {
				ShowPlayerHelpDialog( playerid, 1200, "You have been tied for %s.~n~~n~Your tie is loose. Type ~y~~h~/cuttie", secondstotime( g_iTime - p_TimeTiedAt[ playerid ] ) );
			}

			// Alcatraz Escape Mechanism
			if ( g_iTime > p_AlcatrazEscapeTS[ playerid ] && iState != PLAYER_STATE_SPECTATING )
			{
				if ( IsPlayerAFK( playerid ) )
					p_AlcatrazEscapeTS[ playerid ] = g_iTime + ALCATRAZ_TIME_PAUSE; // Money farmers?

				if ( IsPlayerInArea( playerid, -2204.4255, -1884.5057, 1605.3810, 2052.6060 ) )
				{
					if ( !IsPlayerJailed( playerid ) && !IsPlayerDetained( playerid ) && p_Class[ playerid ] != CLASS_POLICE )
					{
						if ( GetPVarInt( playerid, "AlcatrazWantedCD" ) < g_iTime )
						{
							SetPVarInt( playerid, "AlcatrazWantedCD", g_iTime + ALCATRAZ_TIME_WANTED );
							GivePlayerWantedLevel( playerid, 24 );
							ShowPlayerHelpDialog( playerid, 6000, "Warning! You are now wanted for accessing a ~r~~h~prohibited area!" );
						}
					}
				}
				else
				{
					if ( IsPlayerJailed( playerid ) && IsPlayerSpawned( playerid ) && !IsPlayerAdminOnDuty( playerid ) )
					{
						if ( p_inAlcatraz{ playerid } )
						{
							if ( p_Class[ playerid ] != CLASS_POLICE && !IsPlayerAdminJailed( playerid ) && !IsPlayerAFK( playerid ) )
							{
								SetPVarInt( playerid, "AlcatrazWantedCD", g_iTime + ALCATRAZ_TIME_WANTED );
							    PlainUnjailPlayer 		( playerid );
								SetPlayerColorToTeam	( playerid );
								SetPlayerHealth 		( playerid, 100.0 );
								p_inAlcatraz 			{ playerid } = false;

							    if ( GetPVarInt( playerid, "AlcatrazGiveWantedCD" ) < g_iTime ) {
							    	GivePlayerWantedLevel( playerid, 64 );
									SendGlobalMessage( -1, ""COL_GOLD"[JAIL ESCAPE]{FFFFFF} %s(%d) has escaped from Alcatraz, 64 wanted goes to him!", ReturnPlayerName( playerid ), playerid );
									SetPVarInt( playerid, "AlcatrazGiveWantedCD", g_iTime + 60 );
							    }
							    else SendGlobalMessage( -1, ""COL_GOLD"[JAIL ESCAPE]{FFFFFF} %s(%d) has escaped from Alcatraz!", ReturnPlayerName( playerid ), playerid );
							}
							else
							{
								SendError( playerid, "You cannot leave the prison. It's prohibited." );
								SetPlayerPosToPrison( playerid );
							}
						}
					}
				}
			}

		#if ENABLED_EASTER_EGG == true
			// Easter Egg Hunt
			if ( !p_AdminLevel[ playerid ] )
			{
				if ( g_EasterHunt )
				{
					foreach(new easterid : eastereggs)
					{
						if ( IsPlayerInRangeOfPoint( playerid, 2.0, g_EasterEggs[ easterid ] [ E_X ], g_EasterEggs[ easterid ] [ E_Y ], g_EasterEggs[ easterid ] [ E_Z ] ) )
						{
						    new
						    	iMoney, Float: iCoins, szPrize[ 16 ];

							switch( random( 4 ) )
							{
							    case 0:
							    {
							    	szPrize = "a home";
	    							AddPlayerNote( playerid, -1, ""COL_GOLD"Treasure Hunt Home" #COL_WHITE );
							    	SendClientMessage( playerid, -1, ""COL_GOLD"[HOUSE]"COL_GREY" You have won a house, contact a level 5 admin to redeem a house at a favourable location." );
							    }
							    case 1:
							    {
							    	szPrize = "a car";
	    							AddPlayerNote( playerid, -1, ""COL_GOLD"Treasure Hunt Car" #COL_WHITE );
							    	SendClientMessage( playerid, -1, ""COL_GOLD"[CAR]"COL_GREY" You have won a car, contact a level 5 admin to redeem a car of your choice!" );
							    }
							    case 2:
							    {
							    	GivePlayerCash( playerid, ( iMoney = RandomEx( 600000, 1500000 ) ) );
							    	format( szPrize, sizeof( szPrize ), "%s", ConvertPrice( iMoney ) );
							    }
							    case 3:
							    {
							    	p_IrresistibleCoins[ playerid ] += ( iCoins = fRandomEx( 75.0, 250.0 ) );
							    	format( szPrize, sizeof( szPrize ), "%0.2f coins", iCoins );
							    }
							}

				            DestroyEasterEgg( easterid );
				            SendGlobalMessage( -1, ""COL_GOLD""#EASTEREGG_LABEL""COL_WHITE" %s(%d) has found a " #EASTEREGG_NAME " and has won "COL_GOLD"%s{FFFFFF}.", ReturnPlayerName( playerid ), playerid, szPrize );

							if ( !Iter_Count(eastereggs) )
							{
							    g_EasterHunt = false;
								SendClientMessage( playerid, -1, ""COL_PINK"[ADMIN]"COL_GOLD" Treasure Hunt has been de-activated. All " #EASTEREGG_NAME "s were found." );
							}
							break;
						}
					}
				}
			}
		#endif

			// Taking Out Fires
		    if ( p_Class[ playerid ] == CLASS_FIREMAN && ( iKeys & KEY_FIRE ) || ( iKeys & KEY_WALK ) )
			{
				if ( iWeapon == 42 || GetVehicleModel( iVehicle ) == 407 )
				{
					for( new i; i < sizeof( g_fireData ); i ++ ) if ( g_fireData[ i ] [ E_CREATED ] )
				    {
				 		if ( GetDynamicObjectPos( g_fireData[ i ] [ E_OBJECT ], fX, fY, fZ ) )
				 		{
							fZ += 2.3;

							if ( IsPlayerInRangeOfPoint( playerid, ( GetVehicleModel( iVehicle ) == 407 ? 25.0 : 10.0 ), fX, fY, fZ ) )
							{
								if ( IsPlayerAimingAt( playerid, fX, fY, fZ, ( GetVehicleModel( iVehicle ) == 407 ? 3.0 : 1.0 ) ) )
								{
								    if ( g_fireData[ i ] [ E_HEALTH ] > 0.0 )
									{
										if ( ( g_fireData[ i ] [ E_HEALTH ] -= GetVehicleModel( iVehicle ) == 407 ? ( 2.85 + fRandomEx( 1.0, 5.0 ) ) : ( 1.25 + fRandomEx( 1.0, 5.0 ) ) ) < 0.0 )
											g_fireData[ i ] [ E_HEALTH ] = 0.0;

						             	UpdateDynamic3DTextLabelText( g_fireData[ i ] [ E_LABEL ], COLOR_YELLOW, sprintf( "%0.1f", g_fireData[ i ] [ E_HEALTH ] ) );
									}
									else
								    {
								        g_fireData[ i ] [ E_HEALTH ] = 0.0;
					             	    CallLocalFunction( "OnPlayerTakeOutFire", "dd", playerid, i );
						             	UpdateDynamic3DTextLabelText( g_fireData[ i ] [ E_LABEL ], COLOR_YELLOW, sprintf( "%0.1f", g_fireData[ i ] [ E_HEALTH ] ) );
								    }
									break;
								}
							}
						}
					}
				}
			}

			if ( ( iKeys & KEY_FIRE ) && iWeapon == 9 ) // Lumberjack
			{
			    for( new i; i < MAX_TREES; i++ ) if ( !( g_treeData[ i ] [ E_CREATED ] == false || g_treeData[ i ] [ E_CUT ] == true ) )
			    {
			 		if ( GetDynamicObjectPos( g_treeData[ i ] [ E_OBJECT ], fX, fY, fZ ) )
			 		{
						fZ += 2.3;

						if ( IsPlayerInRangeOfPoint( playerid, 2.0, fX, fY, fZ ) )
						{
							if ( g_treeData[ i ] [ E_HEALTH ] > 0.0 )
							{
								if ( ( g_treeData[ i ] [ E_HEALTH ] -= ( 1.75 + fRandomEx( 1, 5 ) ) ) < 0.0 )
									g_treeData[ i ] [ E_HEALTH ] = 0.0;

					           	UpdateDynamic3DTextLabelText( g_treeData[ i ] [ E_LABEL ], COLOR_YELLOW, sprintf( "%0.1f", g_treeData[ i ] [ E_HEALTH ] ) );
							}
							else
				   			{
					            GivePlayerCash( playerid, 250 );
							    g_treeData[ i ] [ E_HEALTH ] = 0.0;
				            	CallLocalFunction( "OnPlayerChainsawTree", "dd", playerid, i );
					            SendServerMessage( playerid, "You have cut the tree down, now chop the logs down! "COL_ORANGE"/wood chop{FFFFFF}!" );
					           	UpdateDynamic3DTextLabelText( g_treeData[ i ] [ E_LABEL ], COLOR_YELLOW, sprintf( "%0.1f", g_treeData[ i ] [ E_HEALTH ] ) );
							}
							break;
						}
					}
			    }
			}

			// Check if the player's VIP has expired
			CheckPlayerVipExpiry( playerid );

			// Anti Money Hack
			if ( GetPlayerCash( playerid ) != GetPlayerMoney( playerid ) ) {
	            ResetPlayerMoney( playerid );
	         	GivePlayerMoney( playerid, GetPlayerCash( playerid ) );
			}

			// GPS System
		    if ( p_GPSToggled{ playerid } == true )
		    {
		        new
		        	id = p_GPSLocation[ playerid ];

		        if ( IsPlayerInRangeOfPoint( playerid, 10.0, g_gpsData[ id ] [ E_X ], g_gpsData[ id ] [ E_Y ], g_gpsData[ id ] [ E_Z ] ) )
		        {
	  				TextDrawHideForPlayer	( playerid, p_GPSInformation[ playerid ] );
					DestroyDynamicObject	( p_GPSObject[ playerid ] );
					KillTimer				( p_GPSTimer[ playerid ] );

		           	p_GPSLocation	[ playerid ] = 0;
					p_GPSToggled	{ playerid } = false;
					p_GPSTimer		[ playerid ] = 0xFF;
				  	p_GPSObject		[ playerid ] = INVALID_OBJECT_ID;

				  	SendServerMessage( playerid, "You have reached your destination." );
		        }
		    }

		#if ENABLED_SECURE_TRUCK == true
			if ( IsPlayerConnected( g_secureTruckDriver ) )
		    {
				if ( IsSecurityDriverAFK( ) )
				{
					if ( g_secureTruckData[ E_MAP_ICON ] != 0xFFFF ) {
						SetVehicleParamsCarDoors( g_secureTruckVehicle, 0, 0, 0, 0 );
						DestroyDynamicMapIcon( g_secureTruckData[ E_MAP_ICON ] );
						g_secureTruckData[ E_MAP_ICON ] = 0xFFFF;
					}
				}
				else
				{
			    	if ( GetPlayerPos( g_secureTruckDriver, fX, fY, fZ ) ) {
						DestroyDynamicMapIcon( g_secureTruckData[ E_MAP_ICON ] ); // Should not look sketchy
						g_secureTruckData[ E_MAP_ICON ] = CreateDynamicMapIcon( fX, fY, fZ, 52, 0, -1, -1, -1, 300.0 );
			    	}
				}
		    }
		#endif

			if ( IsPlayerInAnyVehicle( playerid ) )
			{
			    if ( iState == PLAYER_STATE_PASSENGER )
			    {
			    	if ( GetVehicleModel( iVehicle ) == 416 )
			    	{
			    		new
			    			iDriver = GetVehicleDriver( iVehicle );

			    		if ( IsPlayerConnected( iDriver ) )
			    		{
			    			if ( p_Class[ iDriver ] == CLASS_MEDIC )
			    			{
			    				new
			    					Float: fHealth;

			    				if ( GetPlayerHealth( playerid, fHealth ) && fHealth < 100.0 )
			    			 		SetPlayerHealth( playerid, fHealth + 2.0 ), GivePlayerCash( iDriver, 10 );
			    			}
			    		}
			    	}
			    }
			}

			if ( p_AdminLevel[ playerid ] < 1 )
			{
			    /* ANTICHEAT */
				if ( g_PingLimit > 500 && GetPlayerPing( playerid ) > g_PingLimit && !p_PingImmunity{ playerid } )
				{
					SendGlobalMessage( -1, ""COL_PINK"[ANTI-CHEAT]{FFFFFF} %s(%d) has been kicked for excessive ping [%d/%d].", ReturnPlayerName( playerid ), playerid, GetPlayerPing( playerid ), g_PingLimit );
				    KickPlayerTimed( playerid );
				}
				if ( GetPlayerSpecialAction( playerid ) == SPECIAL_ACTION_USEJETPACK )
				{
					SendGlobalMessage( -1, ""COL_PINK"[ANTI-CHEAT]{FFFFFF} %s(%d) has been banned for spawning a jetpack.", ReturnPlayerName( playerid ), playerid );
					AdvancedBan( playerid, "Server", "Jetpack", ReturnPlayerIP( playerid ) );
				}
				if ( IsWeaponBanned( iWeapon ) ) {
					SendGlobalMessage( -1, ""COL_PINK"[ANTI-CHEAT]{FFFFFF} %s(%d) has been banned for spawning an illegal weapon.", ReturnPlayerName( playerid ), playerid );
					AdvancedBan( playerid, "Server", "Illegal Weapon", ReturnPlayerIP( playerid ) );
				}
				GetPlayerWeaponData( playerid, 0, iAmmo, iAmmo );
				if ( iAmmo == 1000 ) {
					SendGlobalMessage( -1, ""COL_PINK"[ANTI-CHEAT]{FFFFFF} %s(%d) has been banned for aimbot.", ReturnPlayerName( playerid ), playerid );
					AdvancedBan( playerid, "Server", "Aimbot", ReturnPlayerIP( playerid ) );
				}
			}

			// samp ac force
			if ( p_forcedAnticheat[ playerid ] > 0 && ! IsPlayerUsingSampAC( playerid ) ) {
				SendGlobalMessage( -1, ""COL_PINK"[ANTI-CHEAT]{FFFFFF} %s(%d) has been kicked for disabling SAMP-AC. "COL_YELLOW"(www.samp-ac.com)", ReturnPlayerName( playerid ), playerid );
				KickPlayerTimed( playerid );
			}
		}
	}

	// Update Criminal Report Markers
	foreach (new ir : InformedRobbery)
	{
		if ( ( g_informedRobberies[ ir ] [ E_ALPHA ] -= 7 ) <= 0 )
		{
			new
				cur = ir;

			DestroyDynamicMapIcon( g_informedRobberies[ ir ] [ E_MAP_ICON ] );
			Iter_SafeRemove(InformedRobbery, cur, ir);
		}
		else Streamer_SetIntData( STREAMER_TYPE_MAP_ICON, g_informedRobberies[ ir ] [ E_MAP_ICON ], E_STREAMER_COLOR, setAlpha( COLOR_YELLOW, g_informedRobberies[ ir ] [ E_ALPHA ] ) );
	}

	// Make civilians react
	foreach (new civilianid : CivilianNpc)
	{
		if ( g_civilianNpcData[ civilianid ] [ E_HOSTILE ] && g_civilianNpcData[ civilianid ] [ E_PROVOKED ] )
		{
			new
				Float: distance = FLOAT_INFINITY,
				closestid = GetClosestPlayer( g_civilianNpcData[ civilianid ] [ E_NPC_ID ], distance );

			if ( IsPlayerConnected( closestid ) && 0.0 < distance < 5625 )
				FCNPC_AimAtPlayer( g_civilianNpcData[ civilianid ] [ E_NPC_ID ], closestid, .shoot = true );

			else
			{
				if ( ! g_civilianNpcData[ civilianid ] [ E_TIMEOUT ] )
					g_civilianNpcData[ civilianid ] [ E_TIMEOUT ] = g_iTime + 30;

				if ( g_civilianNpcData[ civilianid ] [ E_TIMEOUT ] != 0 && g_iTime > g_civilianNpcData[ civilianid ] [ E_TIMEOUT ] ) {
					// Reset civilian variables
					g_civilianNpcData[ civilianid ] [ E_TIMEOUT ] = 0;
					g_civilianNpcData[ civilianid ] [ E_PROVOKED ] = false;

					// Respawn
					if ( FCNPC_IsDead( g_civilianNpcData[ civilianid ] [ E_NPC_ID ] ) ) {
						FCNPC_Respawn( g_civilianNpcData[ civilianid ] [ E_NPC_ID ] );
					} else {
						FCNPC_NeutralState( g_civilianNpcData[ civilianid ] [ E_NPC_ID ] );
						FCNPC_SetAngle( g_civilianNpcData[ civilianid ] [ E_NPC_ID ], g_civilianNpcData[ civilianid ] [ E_RZ ] );
					}
				}
			}
		}
	}

	// Restore and Replenish Stuff
    if ( g_iTime > g_RestoreRobberiesBribes )
    {
    	// Replenish Bribes
		foreach(new bribeid : BribeCount) if ( ( GetTickCount( ) - g_bribeData[ bribeid ] [ E_TIMESTAMP ] ) > MAX_BRIBE_WAIT && g_bribeData[ bribeid ] [ E_DISABLED ] == true )
			UpdateDynamic3DTextLabelText( g_bribeData[ bribeid ] [ E_LABEL ], COLOR_GOLD, sprintf( "Bribe(%d)", bribeid ) ), g_bribeData[ bribeid ] [ E_DISABLED ] = false;

		// Replenish Robberies
		foreach(new robberyid : RobberyCount) if ( g_iTime > g_robberyData[ robberyid ] [ E_ROB_TIME ] && g_robberyData[ robberyid ] [ E_ROBBED ] )
 			setSafeReplenished( robberyid );

		// Replenish NPC Robberies
		foreach(new clerkid : RobberyNpc) if ( g_iTime > g_robberyNpcData[ clerkid ] [ E_TIMEOUT ] && ! g_robberyNpcData[ clerkid ] [ E_LOOT ] )
 			ReplenishRobberyNpc( clerkid );

 		// Replenish Atms
 		for( new i = 0; i < sizeof( g_atmData ); i++ ) if ( g_atmData[ i ] [ E_CREATED ] && g_atmData[ i ] [ E_DISABLED ] && g_iTime > g_atmData[ i ] [ E_TIMESTAMP ] ) {
			UpdateDynamic3DTextLabelText( g_atmData[ i ] [ E_LABEL ], COLOR_GOLD, "[ATM]\n"COL_GREY"100%" );
			DestroyDynamicPickup( g_atmData[ i ] [ E_PICKUP ] ), g_atmData[ i ] [ E_PICKUP ] = -1;
			g_atmData[ i ] [ E_LOOT ] = 0, g_atmData[ i ] [ E_DISABLED ] = false, g_atmData[ i ] [ E_HEALTH ] = 100.0;
			ReplaceObjectModel( g_atmData[ i ] [ E_OBJECT ], 19324 );
 		}


 		// Replenish product
 		foreach (new businessid : business)
 		{
 			if ( g_businessData[ businessid ] [ E_PROD_TIMESTAMP ] != 0 && g_businessData[ businessid ] [ E_PROD_TIMESTAMP ] < g_iTime ) {

 				// update the timestamps and switch stock for product
 				g_businessData[ businessid ] [ E_PRODUCT ] += g_businessData[ businessid ] [ E_SUPPLIES ];
 				g_businessData[ businessid ] [ E_PROD_TIMESTAMP ] = 0;
 				g_businessData[ businessid ] [ E_SUPPLIES ] = 0;

 				// alert any associates
 				foreach (new p : Player) if ( IsBusinessAssociate( p, businessid ) )  {
 					SendClientMessageFormatted( p, -1, ""COL_GREY"[BUSINESS]"COL_WHITE" Production has completed for "COL_GREY"%s"COL_WHITE".", g_businessData[ businessid ] [ E_NAME ] );
 				}

 				// update db
 				UpdateBusinessData( businessid );
 			}

 			// update label anyway
 			UpdateBusinessProductionLabel( businessid );
 		}

    	// Replenish Vaults
		for( new i = 0; i < MAX_CITIES; i++ ) if ( g_bankvaultData[ i ] [ E_DISABLED ] && g_iTime > g_bankvaultData[ i ] [ E_TIMESTAMP_CLOSE ] )
		{
			StopDynamicObject	( g_bankvaultData[ i ] [ E_OBJECT ] );
			DestroyDynamicObject( g_bankvaultData[ i ] [ E_OBJECT ] );

			g_bankvaultData[ i ] [ E_TIMESTAMP_CLOSE ] = 0;
			g_bankvaultData[ i ] [ E_DISABLED ] = false;

			switch( g_bankvaultData[ i ] [ E_CITY ] )
			{
				case CITY_SF: SetDynamicObjectMaterial( ( g_bankvaultData[ i ] [ E_OBJECT ] = CreateDynamicObject( 18766, -1412.565063, 859.274536, 983.132873, 0.000000, 90.000000, 90.000000 ) ), 0, 18268, "mtbtrackcs_t", "mp_carter_cage", -1 );
				case CITY_LV: g_bankvaultData[ i ] [ E_OBJECT ] = CreateDynamicObject( 2634, 2114.742431, 1233.155273, 1017.616821, 0.000000, 0.000000, -90.000000, g_bankvaultData[ i ] [ E_WORLD ] );
				case CITY_LS: g_bankvaultData[ i ] [ E_OBJECT ] = CreateDynamicObject( 2634, 2114.742431, 1233.155273, 1017.616821, 0.000000, 0.000000, -90.000000, g_bankvaultData[ i ] [ E_WORLD ] );
			}
		}

		g_RestoreRobberiesBribes = g_iTime + 10;
	}
	return 1;
}

stock GetGangCapturedTurfs( gangid )
{
	new
		z,
		c;

	for( z = 0; z < sizeof( g_gangzoneData ); z++ )
	{
		if ( g_gangzoneData[ z ] [ E_GANG_OWNER ] != INVALID_GANG_ID && g_gangzoneData[ z ] [ E_GANG_OWNER ] == gangid )
			c++;
	}

	return c;
}

public ZoneTimer( )
{
    new
    	iKeys, iUpDownKeys, iLeftRightKeys;

	SendRconCommand( sprintf( "worldtime %s, %s", GetDayToString( g_WorldDayCount ), TimeConvert( g_WorldClockSeconds++ ) ) );

 	if ( g_WorldClockSeconds >= 1440 )
 	{
 	    g_WorldWeather = randarg( 10, 11, 12 );
 	    g_WorldClockSeconds = 0;
        g_WorldDayCount = ( g_WorldDayCount == 6 ? 0 : g_WorldDayCount + 1 );
		TextDrawSetString( g_WorldDayTD, GetDayToString( g_WorldDayCount ) );

		CreateFire( );
		RenewWeed( );

		foreach(new p : Player) {
			if ( !p_VIPLevel[ p ] && !IsPlayerUsingRadio( p ) ) {
				PlayAudioStreamForPlayer( p, "http://files.irresistiblegaming.com/game_sounds/pls_donate.mp3" );
			}
		}

		foreach(new m : miningrock)
		{
			g_miningData[ m ] [ E_ORES ] = g_miningData[ m ] [ E_MAX_ORES ]; // Replenish
			format( szNormalString, 14, "%s\n%d/%d", getOreName( g_miningData[ m ] [ E_ORE ] ), g_miningData[ m ] [ E_ORES ], g_miningData[ m ] [ E_MAX_ORES ] );
			UpdateDynamic3DTextLabelText( g_miningData[ m ] [ E_LABEL ], g_miningData[ m ] [ E_COLOR ], szNormalString );
		}

		foreach(new g : gangs)
		{
			new
				iPlayers = GetOnlineGangMembers( g );

			if ( iPlayers >= TAKEOVER_NEEDED_PEOPLE )
			{
				new
					iCaptured = GetGangCapturedTurfs( g ) * TURF_PAYOUT;

				g_gangData[ g ] [ E_BANK ] += iCaptured;

		    	if ( iCaptured )
		    		SaveGangData( g ), SendClientMessageToGang( g, g_gangData[ g ] [ E_COLOR ], "[GANG] "COL_GOLD"%s"COL_WHITE" has been earned from territories and deposited in the gang bank account.", ConvertPrice( iCaptured ) );
    		}
    	}

		for( new i; i < 20; i++ )
		{
			if ( g_roadblockData[ i ] [ E_CREATED ] ) 	destroyRoadBlockStrip( i );
			if ( Iter_Contains( SpikeStrip, i ) ) 		destroySpikeStrip( i );

			if ( i < MAX_TREES )
			{
				if ( g_treeData[ i ] [ E_CREATED ] == true && g_treeData[ i ] [ E_CHOPPED ] == true )
				{
					DestroyDynamicObject( g_treeData[ i ] [ E_OBJECT ] );
					g_treeData[ i ] [ E_CREATED ] = true;
					g_treeData[ i ] [ E_CUT ] = false;
					g_treeData[ i ] [ E_CHOPPED ] = false;
					g_treeData[ i ] [ E_HEALTH ] = 100.0;
					UpdateDynamic3DTextLabelText( g_treeData[ i ] [ E_LABEL ], COLOR_YELLOW, "100.0" );
					g_treeData[ i ] [ E_OBJECT ] = CreateDynamicObject( 618, g_treeData[ i ] [ E_X ], g_treeData[ i ] [ E_Y ], g_treeData[ i ] [ E_Z ], 0.0, 0.0, 0.0 );
				}
			}
		}

		// Update All Map Tax Labels
		// mysql_function_query( dbHandle, "SELECT `MAP_TAX`.`ID`,`MAP_TAX`.`USER_ID`,`USERS`.`NAME` as `USERNAME` FROM `MAP_TAX` INNER JOIN `USERS` ON `USERS`.`ID` = `MAP_TAX`.`USER_ID`", true, "UpdateMapTaxNames", "" );
	}


	new
		oCount = 0;

    for( new z; z < sizeof( g_gangzoneData ); z++ )
	{
	    if ( g_gangzoneAttacker[ z ] != INVALID_GANG_ID )
	    {
	        if ( GetPlayersInGangZone( z, g_gangzoneAttacker[ z ] ) >= TAKEOVER_NEEDED_PEOPLE )
	        {
	          	if ( g_gangzoneData[ z ] [ E_GANG_OWNER ] != INVALID_GANG_ID )
		        {
					oCount = GetPlayersInGangZone( z, g_gangzoneData[ z ] [ E_GANG_OWNER ] );
		        }
	            if ( g_gangzoneAttackCount[ z ] < TURF_TAKEOVER_TIME && oCount == 0 )
	            {
	            	g_gangzoneAttackCount[ z ] ++;
                 	g_gangzoneAttackTimeout[ z ] = 0;
					continue;
				}
	            else if ( g_gangzoneAttackCount[ z ] >= TURF_TAKEOVER_TIME )
	            {
	            	static
	            		szLocation[ MAX_ZONE_NAME ], szCity[ MAX_ZONE_NAME ];

				    Get2DCity 				( szCity, g_gangzoneData[ z ] [ E_MIN_X ], g_gangzoneData[ z ] [ E_MIN_Y ] );
				    GetZoneFromCoordinates 	( szLocation, g_gangzoneData[ z ] [ E_MIN_X ], g_gangzoneData[ z ] [ E_MIN_Y ] );

	                GangZoneStopFlashForAll	( g_gangzoneID[ z ] );
					GangZoneShowForAll 		( g_gangzoneID[ z ], setAlpha( g_gangData[ g_gangzoneAttacker[ z ] ] [ E_COLOR ], 0x80 ) );

                    SendClientMessageToGang	( g_gangzoneAttacker[ z ], g_gangData[ g_gangzoneAttacker[ z ] ] [ E_COLOR ], "[GANG]{FFFFFF} We have captured a turf near %s in %s!", szLocation, szCity );

                 	// Give Gangmembers XP & Wanted
					foreach(new d : Player)
					{
						if ( IsPlayerSpawned( d ) && p_Class[ d ] == CLASS_CIVILIAN && p_GangID[ d ] == g_gangzoneAttacker[ z ] && !p_inPaintBall{ d } )
						{
							GivePlayerScore( d, 2, .multiplier = 0.5 );
							GivePlayerWantedLevel( d, 6 );
						}
					}

					g_gangzoneData[ z ] [ E_COLOR ]  	 = setAlpha( g_gangData[ g_gangzoneAttacker[ z ] ] [ E_COLOR ], 0x80 );
	                g_gangzoneData[ z ] [ E_GANG_OWNER ] = g_gangzoneAttacker[ z ];

                 	g_gangzoneAttacker 		[ z ] = INVALID_GANG_ID;
	                g_gangzoneAttackCount	[ z ] = 0;
                 	g_gangzoneAttackTimeout	[ z ] = 0;
				}
	        }
	        else
	        {
	        	if ( !g_gangzoneAttackTimeout[ z ] ) {
	        		g_gangzoneAttackTimeout[ z ] = g_iTime + 10;
                    SendClientMessageToGang( g_gangzoneAttacker[ z ], g_gangData[ g_gangzoneAttacker[ z ] ] [ E_COLOR ], "[GANG]{FFFFFF} Warning! You have 5 seconds to have three gang members in the area until the turf war is stopped!" );
	        	}
	        	else if ( g_iTime > g_gangzoneAttackTimeout[ z ] )
				{
		         	g_gangzoneAttackCount[ z ] = 0;
		         	g_gangzoneAttackTimeout[ z ] = 0;
		     		GangZoneStopFlashForAll( g_gangzoneID[ z ] );
		            g_gangzoneAttacker[ z ] = INVALID_GANG_ID;
				}
	        }
		}
		foreach(new playerid : Player)
		{
			if ( !p_PlayerLogged{ playerid } )
				continue;

		    if ( GetPlayerInterior( playerid ) == 0 && GetPlayerVirtualWorld( playerid ) == 0 && !p_inMovieMode{ playerid } )
		    {
			    if ( IsPlayerInArea( playerid, g_gangzoneData[ z ] [ E_MIN_X ], g_gangzoneData[ z ] [ E_MAX_X ], g_gangzoneData[ z ] [ E_MIN_Y ], g_gangzoneData[ z ] [ E_MAX_Y ] ) )
	   			{
	   			    format( szNormalString, sizeof( szNormalString ), "~r~~h~(TERRITORY)~n~~w~~h~%s", ReturnGangName( g_gangzoneData[ z ] [ E_GANG_OWNER ] ) );
				    TextDrawSetString( g_ZoneOwnerTD[ z ], szNormalString );
				    TextDrawShowForPlayer( playerid, g_ZoneOwnerTD[ z ] );
			    }
				else
				{
				    TextDrawHideForPlayer( playerid, g_ZoneOwnerTD[ z ] );
				}
			}
			else TextDrawHideForPlayer( playerid, g_ZoneOwnerTD[ z ] );

			// OTHER CODE THAT DO NOT REQUIRE ZONE LOOP
	  		if ( !z ) // I'm an efficient cunt.
			{
				SetPlayerWeather( playerid, ( GetPlayerInterior( playerid ) || GetPlayerVirtualWorld( playerid ) ) ? 1 : g_WorldWeather );
				UpdatePlayerTime( playerid );

				if ( g_iTime > p_AntiSpawnKill[ playerid ] && p_AntiSpawnKillEnabled{ playerid } )
				{
					DisableRemoteVehicleCollisions( playerid, p_AdminOnDuty{ playerid } );
					SetPlayerHealth( playerid, p_AdminOnDuty{ playerid } == true ? float( INVALID_PLAYER_ID ) : 100.0 );
					Delete3DTextLabel( p_SpawnKillLabel[ playerid ] );
					p_SpawnKillLabel[ playerid ] = Text3D: INVALID_3DTEXT_ID;
					p_AntiSpawnKillEnabled{ playerid } = false;
				}

				// Increment Variables Whilst Not AFK
				if ( !IsPlayerAFK( playerid ) ) // New addition
				{
					// Increase Time Online
					p_Uptime[ playerid ]++;

					// Increase Irresistible Coins (1/20 = cred/min)
   					if ( GetPlayerKeys( playerid, iKeys, iUpDownKeys, iLeftRightKeys ) && ! IsPlayerOnRoulette( playerid ) && ! IsPlayerOnSlotMachine( playerid ) && GetPlayerVehicleSeat( playerid ) <= 0 )
					{
						if ( iKeys != 0 || iUpDownKeys != 0 || iLeftRightKeys != 0 ) { // GetPlayerScore( playerid ) > 10 &&

							new
								Float: iCoinGenRate = 35.0;

							// VIP check
							if ( p_VIPLevel[ playerid ] >= VIP_DIAMOND )
								iCoinGenRate *= 0.75; // Reduce by 25% if Diamond

							else if ( p_VIPLevel[ playerid ] == VIP_PLATINUM )
								iCoinGenRate *= 0.90; // Reduce by 10% if Diamond

							// Happy Hour
							if ( g_HappyHour && ( 0.0 <= g_HappyHourRate <= 0.25 ) )
								iCoinGenRate *= 1.0 - g_HappyHourRate;

							p_IrresistibleCoins[ playerid ] += ( 1.0 / iCoinGenRate ) / 60.0; // Prev 25.92
						}
					}
				}

				// CIA Visible On Radar after firing a shot
				if ( p_VisibleOnRadar[ playerid ] != 0 && p_VisibleOnRadar[ playerid ] < g_iTime )
					SetPlayerColorToTeam( playerid ), p_VisibleOnRadar[ playerid ] = 0;

				// Player Online Achievemnt
				switch( p_Uptime[ playerid ] )
				{
				    //case 300: 	ShowAchievement( playerid, "You have been online for ~r~5~w~~h~ minutes!", 1 );
				    case 1200: 	ShowAchievement( playerid, "You have been online for ~r~20~w~~h~ minutes!", 2 );
				    case 3600: 	ShowAchievement( playerid, "You have been online for ~r~1~w~~h~ hour!", 4 );
				    case 18000: ShowAchievement( playerid, "You have been online for ~r~5~w~~h~ hours!", 6 );
				    case 36000: ShowAchievement( playerid, "You have been online for ~r~10~w~~h~ hours!", 8 );
				    case 54000: ShowAchievement( playerid, "You have been online for ~r~15~w~~h~ hours!", 10 );
				    case 72000: ShowAchievement( playerid, "You have been online for ~r~20~w~~h~ hours!", 12 );
				    case 86400: ShowAchievement( playerid, "You have been online for ~r~1~w~~h~ day!", 15 );
				}
			}
		}
	}
	return 1;
}

public OnRulesHTTPResponse( index, response_code, data[ ] )
{
    if ( response_code == 200 )
    {
    	printf( "[RULES] Rules have been updated! Character Size: %d", strlen( data ) );
    	strcpy( szRules, data );
    }
	return 1;
}

public OnTwitterHTTPResponse( index, response_code, data[ ] )
{
    if ( response_code == 200 ) //Did the request succeed?
 		ShowPlayerDialog( index, DIALOG_NULL, DIALOG_STYLE_MSGBOX, "{00CCFF}@IrresistibleDev"COL_WHITE" - Twitter", data, "Okay", "" );
	else
		ShowPlayerDialog( index, DIALOG_NULL, DIALOG_STYLE_MSGBOX, "{00CCFF}@IrresistibleDev"COL_WHITE" - Twitter", ""COL_WHITE"An error has occurred, try again later.", "Okay", "" );
	return 1;
}

public OnRevCTRLHTTPResponse( index, response_code, data[ ] )
{
    if ( response_code == 200 ) //Did the request succeed?
 		ShowPlayerDialog( index, DIALOG_NULL, DIALOG_STYLE_MSGBOX, "{00CCFF}IrresistibleDev/SF-CNR"COL_WHITE" - RevCTRL", data, "Okay", "" );
	else
		ShowPlayerDialog( index, DIALOG_NULL, DIALOG_STYLE_MSGBOX, "{00CCFF}IrresistibleDev/SF-CNR"COL_WHITE" - RevCTRL", ""COL_WHITE"An error has occurred, try again later.", "Okay", "" );
	return 1;
}

public OnPlayerRequestClass( playerid, classid )
{
	TextDrawHideForPlayer( playerid, g_AdminLogTD );
    TextDrawShowForPlayer( playerid, g_ClassBoxTD );
    TextDrawShowForPlayer( playerid, g_ClassBoxTD1 );
	TextDrawShowForPlayer( playerid, p_ClassTitleTD[ playerid ] );
	TextDrawHideForPlayer( playerid, g_WebsiteTD );
	PlayerTextDrawHide( playerid, p_WantedLevelTD[ playerid ] );
	TextDrawHideForPlayer( playerid, g_MotdTD );
	TextDrawHideForPlayer( playerid, g_NotManyPlayersTD );
	TextDrawHideForPlayer( playerid, p_FPSCounterTD[ playerid ] );
	TextDrawHideForPlayer( playerid, g_AdminOnDutyTD );
	TextDrawHideForPlayer( playerid, g_WorldDayTD );
	PlayerTextDrawHide( playerid, p_LocationTD[ playerid ] );
	PlayerTextDrawHide( playerid, p_PlayerRankTD[ playerid ] );
	PlayerTextDrawHide( playerid, p_PlayerRankTextTD[ playerid ] );
	TextDrawShowForPlayer( playerid, p_ClassInfoTD[ playerid ] );
	KillTimer( p_TrackingTimer[ playerid ] );
	p_TrackingTimer[ playerid ] = INVALID_TIMER_ID;
	TextDrawHideForPlayer( playerid, p_TrackPlayerTD[ playerid ] );
	PlayerTextDrawHide( playerid, p_ExperienceTD[ playerid ] );
	HidePlayerTogglableTextdraws( playerid );
	TextDrawHideForPlayer( playerid, g_CurrentRankTD );
	TextDrawHideForPlayer( playerid, g_currentXPTD );
	TextDrawHideForPlayer( playerid, g_DoubleXPTD );
	KillTimer( p_FireDistanceTimer[ playerid ] );
	p_FireDistanceTimer[ playerid ] = 0xFF;
	TextDrawHideForPlayer( playerid, p_FireDistance1[ playerid ] );
	TextDrawHideForPlayer( playerid, p_FireDistance2[ playerid ] );
	p_MoneyBag{ playerid } = false;
	RemovePlayerAttachedObject( playerid, 1 );

	SetPlayerPos(			playerid, 	-1971.1536, 129.4870, 27.6875 );
	SetPlayerInterior(		playerid, 	0);
	SetPlayerFacingAngle(	playerid,	90.0 );
	//SetPlayerCameraPos(		playerid, 	-1974.1431, 133.3700, 29.7107 );
	//SetPlayerCameraLookAt(	playerid, 	-1970.6431, 129.3700, 28.2107 );

	if ( p_ClassSelection{ playerid } == false )
	{
		InterpolateCameraPos( playerid, -1976.4252, 119.9899, 30.0, -1974.0302, 133.0427, 27.6940, 10000, CAMERA_MOVE );
		InterpolateCameraLookAt( playerid, -1974.0302,133.0427,27.6940, -1971.1536,129.4870,27.6875, 10000, CAMERA_MOVE );

		p_ClassSelection{ playerid } = true;
	}

	//ApplyAnimation( playerid, "FOOD", "FF_Sit_Look", 4.0, 1, 0, 0, 0, 0 );
	ApplyAnimation( playerid, "MISC", "SEAT_TALK_02", 2.0, 1, 0, 0, 0, 0 );

	p_Spawned				{ playerid } = false;
	p_InfectedHIV			{ playerid } = false;

	switch( classid )
	{
	    case 0..49:
	    {
			p_Class[ playerid ] = ( CLASS_CIVILIAN );
			//SetPlayerTeam( playerid, NO_TEAM );
			SetPlayerColorToTeam( playerid );
			p_inFBI{ playerid } = false;
			p_inArmy{ playerid } = false;
			p_inCIA{ playerid } = false;
			// p_inMayor{ playerid } = false;

			TextDrawSetString( p_ClassInfoTD[ playerid ], "~g~~h~CLASS INFORMATION:~w~~n~> Select different types of Jobs~n~> Can rob places for score~n~> Can team up with players" );
	    	TextDrawSetString( p_ClassTitleTD[ playerid ], "~g~~h~CLASS NAME:~w~ Civilian" );
	    }
	    case 50..52:
	    {
			p_Class[ playerid ] = ( CLASS_POLICE );
			//SetPlayerTeam( playerid, CLASS_POLICE );
			SetPlayerColor( playerid, COLOR_FBI );
			p_inFBI{ playerid } = true;
			p_inArmy{ playerid } = false;
			p_inCIA{ playerid } = false;
			// p_inMayor{ playerid } = false;

			TextDrawSetString( p_ClassInfoTD[ playerid ], "~g~~h~CLASS INFORMATION:~w~~n~> Protect the City from criminals~n~> Has access to many features~n~> Can call enforcements~n~> Can jail/arrest people~n~> Can set roadblocks on roads~n~> Can set spike traps~n~> Needs ~r~10000~w~ XP or more" );
	    	TextDrawSetString( p_ClassTitleTD[ playerid ], "~g~~h~CLASS NAME:~w~~n~Federal Bureau of Investigation" );
	    }
	    case 53:
	    {
			p_Class[ playerid ] = ( CLASS_POLICE );
			SetPlayerColor( playerid, COLOR_ARMY );
			//SetPlayerTeam( playerid, CLASS_POLICE );
			p_inFBI{ playerid } = true;
			p_inArmy{ playerid } = true;
			p_inCIA{ playerid } = true;
			// p_inMayor{ playerid } = false;

			TextDrawSetString( p_ClassInfoTD[ playerid ], "~g~~h~CLASS INFORMATION:~w~~n~> Protect the City from criminals~n~> Has access to many features~n~> Can call enforcements~n~> Can jail/arrest people~n~> Can set roadblocks on roads~n~> Can set spike traps~n~> Can use strong air support~n~> Needs ~r~20000~w~ XP or more" );
	    	TextDrawSetString( p_ClassTitleTD[ playerid ], "~g~~h~CLASS NAME:~w~~n~San Fierro Army" );
	    }
	    case 54..56:
	    {
			p_Class[ playerid ] = ( CLASS_POLICE );
			SetPlayerColor( playerid, COLOR_CIA );
			//SetPlayerTeam( playerid, CLASS_POLICE );
			p_inFBI{ playerid } = true;
			p_inArmy{ playerid } = false;
			p_inCIA{ playerid } = true;
			// p_inMayor{ playerid } = false;

			TextDrawSetString( p_ClassInfoTD[ playerid ], "~g~~h~CLASS INFORMATION:~w~~n~> Protect the City from criminals~n~> Has access to many features~n~> Can call enforcements~n~> Can jail/arrest people~n~> Can set roadblocks on roads~n~> Can set spike traps~n~> Can turn electronic devices off~n~> Needs ~r~15000~w~ XP or more" );
	    	TextDrawSetString( p_ClassTitleTD[ playerid ], "~g~~h~CLASS NAME:~w~~n~Central Intelligence Agency" );
	    }
	    case 57..59:
		{
			p_Class[ playerid ] = ( CLASS_FIREMAN );
			SetPlayerColor( playerid, COLOR_FIREMAN );
			//SetPlayerTeam( playerid, NO_TEAM );
			p_inFBI{ playerid } = false;
			p_inArmy{ playerid } = false;
			p_inCIA{ playerid } = false;
			// p_inMayor{ playerid } = false;

			TextDrawSetString( p_ClassInfoTD[ playerid ], "~g~~h~CLASS INFORMATION:~w~~n~> Protect the City from fires~n~> Can extinguish fires~n~> Needs ~r~1000~w~ XP or more" );
	    	TextDrawSetString( p_ClassTitleTD[ playerid ], "~g~~h~CLASS NAME:~w~ Fire Man" );
		}
		case 60..63:
		{
			p_Class[ playerid ] = ( CLASS_MEDIC );
			SetPlayerColor( playerid, COLOR_MEDIC );
			//SetPlayerTeam( playerid, NO_TEAM );
			p_inFBI{ playerid } = false;
			p_inArmy{ playerid } = false;
			p_inCIA{ playerid } = false;
			// p_inMayor{ playerid } = false;

			TextDrawSetString( p_ClassInfoTD[ playerid ], "~g~~h~CLASS INFORMATION:~w~~n~> Can cure diseases~n~> Can heal players~n~> Needs ~r~2000~w~ XP or more" );
	    	TextDrawSetString( p_ClassTitleTD[ playerid ], "~g~~h~CLASS NAME:~w~ Paramedic" );
		}
	    /*case 64..65:
	    {
			p_Class[ playerid ] = ( CLASS_POLICE );
			SetPlayerColor( playerid, COLOR_MAYOR );
			//SetPlayerTeam( playerid, CLASS_POLICE );
			p_inFBI{ playerid } = false;
			p_inArmy{ playerid } = false;
			p_inCIA{ playerid } = false;
			p_inMayor{ playerid } = true;

			TextDrawSetString( p_ClassInfoTD[ playerid ], "~g~~h~CLASS INFORMATION:~w~~n~> Enforces police agenda~n~> Dictates the law in the game~n~> Can issue warrants~n~> Can jail/arrest people~n~> Limited to 1 person every 60 min~n~> Needs ~r~5000~w~ XP or more" );
	    	TextDrawSetString( p_ClassTitleTD[ playerid ], "~g~~h~CLASS NAME:~r~~h~ The Mayor" );
	    }
	  	case 66..73:*/
	  	case 64..73:
	    {
			p_Class[ playerid ] = ( CLASS_POLICE );
			SetPlayerColor( playerid, COLOR_POLICE );
			//SetPlayerTeam( playerid, CLASS_POLICE );
			p_inFBI{ playerid } = false;
			p_inArmy{ playerid } = false;
			p_inCIA{ playerid } = false;
			// p_inMayor{ playerid } = false;

			TextDrawSetString( p_ClassInfoTD[ playerid ], "~g~~h~CLASS INFORMATION:~w~~n~> Protect the City from criminals~n~> Has access to many features~n~> Can call enforcements~n~> Can jail/arrest people" );
	    	TextDrawSetString( p_ClassTitleTD[ playerid ], "~g~~h~CLASS NAME:~w~ Police Officer" );
	    }
	}
	return 1;
}

public OnPlayerFloodControl( playerid, iCount, iTimeSpan ) {
	static
		szIP[ 16 ];

    GetPlayerIp( playerid, szIP, sizeof( szIP ) );

    if ( iCount > 2 && iTimeSpan < 10000 ) {
    	if ( !IsPlayerNpcEx( playerid ) ) {
        	BanEx( playerid, "BOT-SPAM" );
    	}
    }
}

thread OnPlayerRegisterCheck( playerid )
{
	if ( GetPVarInt( playerid, "banned_connection" ) == 1 ) return 1; // Stop anything from happening.

	new
	    rows, fields
	;
    cache_get_data( rows, fields );
	if ( rows )
    {
        format( szBigString, sizeof( szBigString ), "{FFFFFF}Welcome, this account ("COL_GREEN"%s"COL_WHITE") is registered.\nPlease enter the password to login.\n\n"COL_GREY"If you are not the owner of this account, leave and rejoin with a different nickname.", ReturnPlayerName( playerid ) );
        ShowPlayerDialog(playerid, DIALOG_LOGIN, DIALOG_STYLE_PASSWORD, "{FFFFFF}Account - Authentication", szBigString, "Login", "Leave");
    }
    else
    {
		format( szNormalString, sizeof( szNormalString ), "SELECT `IP` FROM `USERS` WHERE `IP` = '%s' LIMIT 5", mysql_escape( ReturnPlayerIP( playerid ) ) );
 		mysql_function_query( dbHandle, szNormalString, true, "OnPlayerDuplicateAccountCheck", "i", playerid );
    }
	return 1;
}

thread OnPlayerDuplicateAccountCheck( playerid )
{
	new
		rows, fields;

	cache_get_data( rows, fields );
	if ( rows > 3 )
	{
		SendError( playerid, "Sorry, this IP has more than 3 users registered to it which is the maximum limit of users per IP." );
		KickPlayerTimed( playerid );
	}
	else
	{
        format( szBigString, sizeof( szBigString ), "{FFFFFF}Welcome, this account ("COL_RED"%s"COL_WHITE") is not registered.\nPlease enter your desired password for this account.\n\n"COL_GREY"Once you are registered, do not share your password with anyone besides yourself!", ReturnPlayerName( playerid ) );
        ShowPlayerDialog(playerid, DIALOG_REGISTER, DIALOG_STYLE_INPUT, "{FFFFFF}Account - Register", szBigString, "Register", "Leave");
	}
	return 1;
}

public OnPlayerConnect( playerid )
{
    static
        Query[ 200 ], szName[ MAX_PLAYER_NAME ], szIP[ 16 ];

    GetPlayerIp( playerid, szIP, sizeof( szIP ) );
    GetPlayerName( playerid, szName, sizeof( szName ) );

	if ( IsPlayerNPC( playerid ) )
	{
		#if ENABLED_SECURE_TRUCK == true
			if ( strmatch( szName, SECURE_TRUCK_DRIVER_NAME ) ) {
				g_secureTruckDriver = playerid;
				g_secureTruckData[ E_MAP_ICON ] = 0xFFFF;
				SetPlayerColor( playerid, COLOR_SECURITY );
				PutPlayerInVehicle( playerid, g_secureTruckVehicle, 0 );
				return 1;
			}
		#endif
		#if ENABLED_NPC_ROBBERIES == true
			if ( strmatch( szIP, "127.0.0.1" ) ) {
				SetPlayerColor( playerid, 0xFFFFFF20 );
				return 1;
			}
		#endif
	 	return Kick( playerid ), 1;
	}

	strcpy( p_PlayerIP[ playerid ], szIP );
	strcpy( p_PlayerName[ playerid ], szName );

	if ( strlen( ReturnPlayerName( playerid ) ) <= 2 )
		return Kick( playerid ), 1;

	if ( !( 0 <= playerid < MAX_PLAYERS ) )
		return Kick( playerid ), 1;

	if ( strmatch( ReturnPlayerName( playerid ), "No-one" ) )
		return Kick( playerid ), 1;

	if ( textContainsIP( ReturnPlayerName( playerid ) ) )
	    return Kick( playerid ), 1;

	if ( g_ServerLocked )
	    return SendError( playerid, "The server is locked due to false server configuration. Please wait for the operator." ), KickPlayerTimed( playerid ), 1;

	// Ultra fast queries...
	format( Query, sizeof( Query ), "SELECT * FROM `BANS` WHERE (`NAME`='%s' OR `IP`='%s') AND `SERVER`=0 LIMIT 0,1", mysql_escape( ReturnPlayerName( playerid ) ), mysql_escape( ReturnPlayerIP( playerid ) ) );
	mysql_function_query( dbHandle, Query, true, "OnPlayerBanCheck", "i", playerid );

	TogglePlayerClock( playerid, 1 );
    ClearPlayerWantedLevel( playerid );
	SetPlayerColor( playerid, COLOR_GREY );
	ResetPlayerCash( playerid );

	// Create player textdraws and remove buildings
	initializePlayerTextDraws( playerid );
	removeExcessiveBuildings( playerid );
	initializePlayerInteriors( playerid );

	// Reset some variables
	p_Spawned 			{ playerid } = false;
    p_GangID 			[ playerid ] = INVALID_GANG_ID;
	justConnected		{ playerid } = true;
	p_ClassSelection	{ playerid } = false;
	p_FPS_DrunkLevel	[ playerid ] = 0;
	p_FPS 				[ playerid ] = 0;
	p_UsingRobberySafe	[ playerid ] = -1;

	// reset roullete chips incase
	for ( new i = 0; i < sizeof( g_rouletteOffsets ); i ++ ) {
		g_rouletteChip[ playerid ] [ i ] = -1;
		g_rouletteChipLabel[ playerid ] [ i ] = Text3D: INVALID_3DTEXT_ID;
		g_rouletteChipValue[ playerid ] [ i ] = 0;
	}

	// reset jails
	jailDoors( playerid, false, false );

	SendClientMessage( playerid, 0xa9c4e4ff, "{FF0000}[WARNING]{a9c4e4} The concept in this server and GTA in general may be considered explicit material." );
	SendClientMessage( playerid, 0xa9c4e4ff, "{FF0000}[INFO]{a9c4e4} The server is currently operating on version " # FILE_BUILD "." );

	if ( GetGVarType( "connectsong" ) != GLOBAL_VARTYPE_NONE )
	{
		GetGVarString( "connectsong", szNormalString );
		PlayAudioStreamForPlayer( playerid, szNormalString );
	}

	PreloadAnimationLibrary( playerid, "MISC" );
    p_JoinTimestamp[ playerid ] = g_iTime;
	return 1;
}

public OnLookupComplete( playerid, success )
{
	/*if ( IsProxyUser( playerid ) )
	{
		if ( IsProxiesBanned( ) )
		{
			for( new i = 0; i < sizeof( g_ispUnbans ); i++ )
			{
				if ( strfind( GetPlayerISP( playerid ), g_ispUnbans[ i ] ) == -1 )
				{
					return KickPlayer( playerid );
					//return BanEx( playerid, "Proxy Detected!" );
				}
			}
		}
	}

	format( szLargeString, sizeof( szLargeString ), "SELECT * FROM `MEGABAN` WHERE `ISP`='%s' LIMIT 0,1", mysql_escape( GetPlayerISP( playerid ) ) );
	mysql_function_query( dbHandle, szLargeString, true, "OnPlayerMegaBanCheck", "i", playerid );*/

	SendDeathMessage( INVALID_PLAYER_ID, playerid, 200 );

	if ( IsProxyEnabledForPlayer( playerid ) ) {
		format( szNormalString, sizeof( szNormalString ), "%s(%d) has connected to the server! (%s)", ReturnPlayerName( playerid ), playerid, GetPlayerCountryName( playerid ) );
	} else {
		format( szNormalString, sizeof( szNormalString ), "%s(%d) has connected to the server!", ReturnPlayerName( playerid ), playerid );
	}

	foreach(new i : Player)
	{
		if ( p_PlayerSettings[ i ] { SETTING_CONNECTION_LOG } )
			SendClientMessage( i, COLOR_CONNECT, szNormalString );
	}

	format( szNormalString, sizeof( szNormalString ), "*%s*", szNormalString );
	DCC_SendChannelMessage( discordGeneralChan, szNormalString );
	return 1;
}

thread OnPlayerBanCheck( playerid )
{
	new
	    rows, fields
	;
    cache_get_data( rows, fields );
	if ( rows )
	{
	    new
			bannedUser[ 24 ],
			bannedIP[ 16 ],
			bannedbyUser[ 24 ],
			bannedReason[ 50 ],
			//bannedSerial[ 41 ],
			bannedExpire = 0,
			server = 1,
			serial = 0
		;

		server  	 = cache_get_field_content_int( 0, "SERVER", dbHandle );
		bannedExpire = cache_get_field_content_int( 0, "EXPIRE", dbHandle );

		cache_get_field_content( 0, "BANBY", bannedbyUser );
		cache_get_field_content( 0, "REASON", bannedReason );
		//cache_get_field_content( 0, "SERIAL", bannedSerial );
		cache_get_field_content( 0, "NAME", bannedUser );
		cache_get_field_content( 0, "IP", bannedIP );

		/*gpci( playerid, szNormalString, 41 );
		if ( strmatch( bannedSerial, szNormalString ) )
		{
			serial = 1;
			format( szBigString, sizeof( szBigString ), "[%s %s] %s => {%s, %s, %s, %s, %s}\n\r", getCurrentDate( ), getCurrentTime( ), ReturnPlayerName( playerid ), bannedbyUser, bannedReason, bannedSerial, bannedUser, bannedIP );
			AddFileLogLine( "gpcid.txt", szBigString );
		}*/

		// CNR BANS ONLY
		if ( !server )
		{
			if ( !bannedExpire )
			{
				// "COL_ORANGE"Ban evading will be fatal to your account. Do not do it.
				format( szLargeString, 600, "{FFFFFF}You are banned from this server.\n{FFFFFF}If you feel wrongfully banned, please appeal at "COL_BLUE""#SERVER_WEBSITE"{FFFFFF}\n\n"COL_RED"Username:{FFFFFF} %s\n"COL_RED"IP Address:{FFFFFF} %s\n", bannedUser, bannedIP );
				format( szLargeString, 600, "%s"COL_RED"Reason:{FFFFFF} %s\n"COL_RED"Server:{FFFFFF} %s\n"COL_RED"Banned by:{FFFFFF} %s%s", szLargeString, bannedReason, GetServerName( server ), bannedbyUser, strmatch( ReturnPlayerName( playerid ), bannedUser ) ? ("") : ( serial ? ("\n\n"COL_RED"Our ban evasion system picked you up! If this is in error then please visit our forums.") : ("\n\n"COL_RED"Your IP Address is banned, if this is a problem then visit our forums.") ) );
		      	ShowPlayerDialog( playerid, DIALOG_BANNED, DIALOG_STYLE_MSGBOX, "{FFFFFF}Ban Information", szLargeString, "Okay", "" );
		      	KickPlayerTimed( playerid );
		  		return 1;
			}
			else
			{
				if ( g_iTime > bannedExpire )
				{
					format( szNormalString, 100, "DELETE FROM `BANS` WHERE `NAME`= '%s' OR `IP` = '%s'", mysql_escape( ReturnPlayerName( playerid ) ), mysql_escape( ReturnPlayerIP( playerid ) ) ), mysql_single_query( szNormalString );
					SendServerMessage( playerid, "The suspension of this account has expired as of now, this account is available for playing." );
				}
				else
				{
					// "COL_ORANGE"Ban evading will be fatal to your account. Do not do it.
					format( szLargeString, 700, "{FFFFFF}You are suspended from this server.\n{FFFFFF}If you feel wrongfully suspended, please appeal at "COL_BLUE""#SERVER_WEBSITE"{FFFFFF}\n\n"COL_RED"Username:{FFFFFF} %s\n"COL_RED"IP Address:{FFFFFF} %s\n", bannedUser, bannedIP );
					format( szLargeString, 700, "%s"COL_RED"Reason:{FFFFFF} %s\n"COL_RED"Server:{FFFFFF} %s\n"COL_RED"Suspended by:{FFFFFF} %s\n"COL_RED"Expire Time:{FFFFFF} %s%s", szLargeString, bannedReason, GetServerName( server ), bannedbyUser, secondstotime( bannedExpire - g_iTime ), strmatch( ReturnPlayerName( playerid ), bannedUser ) ? (" ") : ("\n\n"COL_RED"Your IP Address is suspended, if this is a problem, visit our forums.") );
			      	ShowPlayerDialog( playerid, DIALOG_BANNED, DIALOG_STYLE_MSGBOX, "{FFFFFF}Suspension Information", szLargeString, "Okay", "" );
		      		KickPlayerTimed( playerid );
			  		return 1;
			  	}
			}
		}
		else SendClientMessageToAdmins( -1, ""COL_PINK"[ADMIN]"COL_GREY" %s(%d) has been identified as banned under %s.", ReturnPlayerName( playerid ), playerid, bannedbyUser );
	}

	// Pursue a registration check
	format( szNormalString, sizeof( szNormalString ), "SELECT `NAME` FROM `USERS` WHERE `NAME` = '%s' LIMIT 0,1", mysql_escape( ReturnPlayerName( playerid ) ) );
 	mysql_function_query( dbHandle, szNormalString, true, "OnPlayerRegisterCheck", "i", playerid );
	return 1;
}

/*thread OnPlayerMegaBanCheck( playerid )
{
	new
		rows, fields;

    cache_get_data( rows, fields );
	if ( rows )
	{
		new
			playerserial[ 45 ];

		gpci( playerid, playerserial, sizeof( playerserial ) );
	 	if ( g_Debugging ) {
	 		SendClientMessageToRCON( COLOR_YELLOW, "MEGABAN: %s blocked! GPCI: %s | ISP: %s", ReturnPlayerName( playerid ), playerserial, GetPlayerISP( playerid ) );
	 		printf("[DEBUG] [MEGABAN] %s blocked! GPCI: %s | ISP: %s", ReturnPlayerName( playerid ), playerserial, GetPlayerISP( playerid ) );
	 	}

		// IP Blocked
		//BlockIpAddress( ReturnPlayerIP( playerid ), 0 );
		//BanEx( playerid, "MEGABAN" );
		SendServerMessage( playerid, "You are banned from this server. (0xAF)" );
		KickPlayer( playerid );
	}
	else
	{
		if ( strmatch( GetPlayerISP( playerid ), "AS812 Rogers Cable Communications Inc." ) || strmatch( GetPlayerISP( playerid ), "AS6799 OTEnet S.A." ) )
			return 1;

		SendDeathMessage( INVALID_PLAYER_ID, playerid, 200 );

		if ( IsProxyEnabledForPlayer( playerid ) ) {
			format( szNormalString, sizeof( szNormalString ), "%s(%d) has connected to the server! (%s)", ReturnPlayerName( playerid ), playerid, GetPlayerCountryName( playerid ) );
		} else {
			format( szNormalString, sizeof( szNormalString ), "%s(%d) has connected to the server!", ReturnPlayerName( playerid ), playerid );
		}

		foreach(new i : Player)
		{
			if ( p_PlayerSettings[ i ] { SETTING_CONNECTION_LOG } )
				SendClientMessage( i, COLOR_CONNECT, szNormalString );
		}

		format( szNormalString, sizeof( szNormalString ), "*%s*", szNormalString );
		DCC_SendChannelMessage( discordGeneralChan, szNormalString );
	}
	return 1;
}*/

public OnPlayerDisconnect( playerid, reason )
{
	static
		string[ 64 ], color;

	#if ENABLED_SECURE_TRUCK == true
		if ( g_secureTruckDriver == playerid )
		{
			restartSecurityGuardProcess( .inform_npc = false );
			g_secureTruckDriver = INVALID_PLAYER_ID;
			print( "Driver Crashed, Restablishing." );
			ConnectNPC( SECURE_TRUCK_DRIVER_NAME, "secureguard" );
			return 1;
		}
	#endif

	// Filter out bots
	if ( ! ( 0 <= playerid < MAX_PLAYERS ) )
		return 1;

	// Reset player variables
    SavePlayerData( playerid, true );
	DisconnectFromGang( playerid );
	CheckPendingBusiness( playerid );
	dischargeVehicles( playerid );
	CutSpectation( playerid );
	LeavePlayerPaintball( playerid );
	resetPlayerStreaks( playerid );
	StopPlayerTruckingCourier( playerid );
    RemovePlayerFromRace( playerid );
	RemovePlayerFromRoulette( playerid );
	RemovePlayerFromBlackjack( playerid );
	p_Detained		{ playerid } = false;
	p_Tied			{ playerid } = false;
	p_Kidnapped		{ playerid } = false;
	p_Wood          [ playerid ] = 0;
	p_inAlcatraz 	{ playerid } = false;
	p_FPSCounter 	{ playerid } = false;
	p_Ropes			[ playerid ] = 0;
	p_Scissors      [ playerid ] = 0;
	DeathSpam       { playerid } = 0;
	p_Fires         [ playerid ] = 0;
	p_PingImmunity  { playerid } = 0;
	p_Robberies     [ playerid ] = 0;
	p_HitsComplete  [ playerid ] = 0;
	//p_CopTutorial   { playerid } = 0;
	p_Class			[ playerid ] = 0;
	p_isMining		{ playerid } = false;
	p_drillStrength [ playerid ] = 0;
	p_RansomAmount	[ playerid ] = 0;
	p_RansomPlacer	[ playerid ] = INVALID_PLAYER_ID;
	p_InAnimation	{ playerid } = false;
	p_LabelColor 	[ playerid ] = COLOR_GREY;
	p_Uptime        [ playerid ] = 0;
	p_Muted 		{ playerid } = false;
	p_AdminLog		{ playerid } = false;
	p_AdminLevel	[ playerid ] = 0;
 	p_Warns			[ playerid ] = 0;
	p_CopBanned		{ playerid } = 0;
	p_SpawningCity 	{ playerid } = CITY_SF;
	p_ArmyBanned    { playerid } = 0;
    p_PlayerLogged	{ playerid } = false;
    p_JobSet		{ playerid } = false;
    p_CitySet 		{ playerid } = false;
	p_MoneyBag		{ playerid } = false;
    p_inPaintBall	{ playerid } = false;
    p_Job			{ playerid } = 0;
    p_VIPJob 		{ playerid } = 0;
    p_CantUseReport { playerid } = false;
    p_BobbyPins     [ playerid ] = 0;
	p_Spawned		{ playerid } = false;
	p_AdminOnDuty   { playerid } = false;
	p_WantedLevel	[ playerid ] = 0;
	p_Tazed			{ playerid } = false;
	p_Jailed		{ playerid } = false;
	p_LeftPaintball { playerid } = false;
	p_AntiEMP       [ playerid ] = 0;
	p_LastVehicle	[ playerid ] = INVALID_VEHICLE_ID;
	p_Cuffed		{ playerid } = false;
	justConnected	{ playerid } = true;
 	p_Muted			{ playerid } = false;
	p_MetalMelter	[ playerid ] = 0;
	p_LeftCuffed 	{ playerid } = false;
	p_BailOfferer   [ playerid ] = INVALID_PLAYER_ID;
	p_PmResponder	[ playerid ] = INVALID_PLAYER_ID;
	p_ViewingStats  [ playerid ] = INVALID_PLAYER_ID;
	p_HealDealer    [ playerid ] = INVALID_PLAYER_ID;
	p_Spectating    { playerid } = false;
	p_UsingRadio 	{ playerid } = false;
	p_TicketIssuer	[ playerid ] = INVALID_PLAYER_ID;
	p_DetainedBy	[ playerid ] = INVALID_PLAYER_ID;
    p_GangID		[ playerid ] = INVALID_GANG_ID;
	p_InfectedHIV	{ playerid } = false;
	p_OwnedHouses	[ playerid ] = 0;
	p_OwnedVehicles [ playerid ] = 0;
	p_ToggledViewPM	{ playerid } = false;
	p_VIPExpiretime [ playerid ] = 0;
 	p_BankMoney		[ playerid ] = 0;
 	p_RapidFireShots{ playerid } = 0;
 	p_Kills			[ playerid ] = 0;
	p_Deaths		[ playerid ] = 0;
 	p_VIPLevel		[ playerid ] = 0;
	p_XP			[ playerid ] = 0;
	p_InHouse		[ playerid ] = -1;
	p_InGarage 		[ playerid ] = -1;
	p_inMovieMode	{ playerid } = false;
 	p_GPSLocation	[ playerid ] = 0;
	p_GPSToggled	{ playerid } = false;
	p_CantUseAsk    { playerid } = false;
	p_LastSkin      [ playerid ] = 0;
	p_SecureWallet	{ playerid } = false;
	p_WeedGrams		[ playerid ] = 0;
	p_Arrests		[ playerid ] = 0;
	p_AidsVaccine	{ playerid } = false;
	p_VIPWep1		{ playerid } = 0;
	p_VIPWep2		{ playerid } = 0;
	p_VIPWep3		{ playerid } = 0;
	p_WeaponDealing	{ playerid } = false;
	p_WeaponDealer	[ playerid ] = INVALID_PLAYER_ID;
	p_WeedDealer	[ playerid ] = INVALID_PLAYER_ID;
	p_JailTime		[ playerid ] = 0;
	p_Muted			{ playerid } = false;
	p_Burglaries	[ playerid ] = 0;
	p_MuriaticAcid	{ playerid } = 0;
	p_CausticSoda	{ playerid } = 0;
	p_MethYielded 	[ playerid ] = 0;
	p_CarsJacked 	[ playerid ] = 0;
	p_BankBlown		[ playerid ] = 0;
	p_JailsBlown	[ playerid ] = 0;
	p_AccountID		[ playerid ] = 0;
	p_DeathMessage	[ playerid ] [ 0 ] = '\0';
	p_TicketTimestamp[ playerid ] = 0;
	p_ExtraAssetSlots{ playerid } = 0;
	p_HitmarkerSound{ playerid } = 0;
	p_OwnedBusinesses[ playerid ] = 0;
	g_LastExportModel[ playerid ] = 0;
	p_usingSlotMachine[ playerid ] = -1;
	p_GangSplitProfits[ playerid ] = 0;
	p_IrresistibleCoins[ playerid ] = 0.0;
	p_QuitToAvoidTimestamp[ playerid ] = 0;
	p_IrresistiblePoints[ playerid ] = 0.0;
	p_AntiExportCarSpam[ playerid ] = 0;
	p_TruckedCargo[ playerid ] = 0;
	p_HydrogenChloride{ playerid } = 0;
	p_Methamphetamine{ playerid } = 0;
	p_ApartmentEditing{ playerid } = -1;
	p_PawnStoreExport[ playerid ] = 0xFFFF;
	p_LastEnteredEntrance[ playerid ] = -1;
	p_ViewingGangTalk[ playerid ] = -1;
	p_forcedAnticheat[ playerid ] = 0;
	p_StartedLumberjack{ playerid } = false;
	p_RconLoginFails{ playerid } = 0;
	p_BusinessSpawnLocation[ playerid ] = -1;
	p_IncorrectLogins{ playerid } = 0;
	p_VehicleBringCooldown[ playerid ] = 0;
	p_DamageSpamCount{ playerid } = 0;
	p_AntiTextSpamCount{ playerid } = 0;
	p_ApartmentSpawnLocation[ playerid ] = -1;
	p_treeExportLocation[ playerid ] = 0xFF;
	ResetPlayerVendingMachineData( playerid );
	Delete3DTextLabel( p_SpawnKillLabel[ playerid ] );
	p_SpawnKillLabel[ playerid ] = Text3D: INVALID_3DTEXT_ID;
    Delete3DTextLabel( p_AdminLabel[ playerid ] );
    p_AdminLabel[ playerid ] = Text3D: INVALID_3DTEXT_ID;
	Delete3DTextLabel( p_DetainedLabel[ playerid ] );
	p_DetainedLabel[ playerid ] = Text3D: INVALID_3DTEXT_ID;
	Delete3DTextLabel( p_TiedLabel[ playerid ] );
	p_TiedLabel[ playerid ] = Text3D: INVALID_3DTEXT_ID;
	DestroyDynamic3DTextLabel( p_WeedLabel[ playerid ] );
	p_WeedLabel[ playerid ] = Text3D: INVALID_3DTEXT_ID;
	p_AntiSpawnKillEnabled{ playerid } = false;
	//p_CopTutorialProgress{ playerid } = 0;
    DestroyDynamicRaceCP( p_LumberjackReturn[ playerid ] );
	p_LumberjackReturn[ playerid ] = 0xFFFF;
	DestroyDynamicRaceCP( p_LumberjackDeliver[ playerid ] );
	p_LumberjackDeliver[ playerid ] = 0xFFFF;
	DestroyDynamicRaceCP( p_MiningExport[ playerid ] );
	p_MiningExport[ playerid ] = 0xFFFF;
	DestroyDynamicMapIcon( p_LumberjackMapIcon[ playerid ] );
	p_LumberjackMapIcon[ playerid ]= 0xFFFF;
	KillTimer( p_FireDistanceTimer[ playerid ] );
	p_FireDistanceTimer[ playerid ] = 0xFF;
	DestroyDynamicObject( p_GPSObject[ playerid ] );
	KillTimer( p_GPSTimer[ playerid ] );
	p_GPSTimer[ playerid ] = 0xFF;
  	p_GPSObject[ playerid ] = INVALID_OBJECT_ID;
	p_ContractedAmount[ playerid ] = 0;
	p_HouseSpawnLocation[ playerid ] = -1;
	ClearPlayerWantedLevel( playerid );
	Delete3DTextLabel( p_InfoLabel[ playerid ] );
	p_InfoLabel[ playerid ] = Text3D: INVALID_3DTEXT_ID;
	p_LabelColor[ playerid ] = COLOR_GREY;
    unpause_Player( playerid );
    DestroyAllPlayerC4s( playerid, true );
	KillTimer( p_JailTimer[ playerid ] );
	KillTimer( p_CuffAbuseTimer[ playerid ] );
	p_ProgressStarted{ playerid } = false;
	p_CancelProgress{ playerid } = false;
	ResetPlayerCash( playerid );
	if ( !GetPVarInt( playerid, "banned_connection" ) ) SendDeathMessage( INVALID_PLAYER_ID, playerid, 201 );
	DestroyDynamicMapIcon( p_PawnStoreMapIcon[ playerid ] );
	p_PawnStoreMapIcon[ playerid ] = 0xFFFF;
	jailDoors( playerid, .remove = true, .set_closed = false );
	erase( p_VipPackageName[ playerid ] );
	resetPlayerToys( playerid, 0 );
	resetPlayerToys( playerid, 1 );
	resetPlayerToys( playerid, 2 );
	p_accountSecurityData[ playerid ] [ E_VERIFIED ] = false;
	p_accountSecurityData[ playerid ] [ E_ID ] = 0;
	p_accountSecurityData[ playerid ] [ E_LAST_DISABLED ] = 0;

	switch( reason )
	{
	    case 0: color = COLOR_TIMEOUT, 		format( string, sizeof( string ), "%s(%d) has timed out from the server!", ReturnPlayerName( playerid ), playerid );
	    case 1: color = COLOR_DISCONNECT, 	format( string, sizeof( string ), "%s(%d) has left the server!", ReturnPlayerName( playerid ), playerid );
	    case 2: color = COLOR_KICK, 		format( string, sizeof( string ), "%s(%d) has been kicked from the server!", ReturnPlayerName( playerid ), playerid );
	}


	for( new i; i < MAX_PLAYERS; i++ )
	{
		if ( IsPlayerConnected( i ) && p_PlayerSettings[ i ] { SETTING_CONNECTION_LOG } )
		{
			SendClientMessage( i, color, string ); // Send a message to people
		}

		if ( i < MAX_GANGS ) 	p_gangInvited[ playerid ] [ i ] = false;
		if ( i < MAX_SETTINGS ) p_PlayerSettings[ playerid ] { i } = false;
		if ( i < MAX_TOYS ) 	p_ToyUnlocked[ playerid ] { i } = false;
		if ( i < MAX_WEAPONS ) 	p_WeaponKills[ playerid ] [ i ] = 0;
		if ( i < MAX_RACES )	p_raceInvited[ playerid ] [ i ] = false;
		if ( i < MAX_STREAKS ) 	p_streakData[ playerid ] [ i ] [ E_BEST_STREAK ] = 0, p_streakData[ playerid ] [ i ] [ E_STREAK ] = 0;

		p_BlockedPM[ playerid ] [ i ] = false;
	}

	format( string, sizeof( string ), "*%s*", string );
	DCC_SendChannelMessage( discordGeneralChan, string );
	return 1;
}

public OnPlayerSpawn( playerid )
{
	new
		iTick = GetTickCount( );

	if ( IsPlayerSecurityDriver( playerid ) )
		return 1;

	UpdatePlayerTime( playerid );

	TextDrawHideForPlayer( playerid, g_ClassBoxTD);
    TextDrawHideForPlayer( playerid, g_ClassBoxTD1 );
	TextDrawHideForPlayer( playerid, p_ClassTitleTD[ playerid ] );
	TextDrawHideForPlayer( playerid, p_ClassInfoTD[ playerid ] );
	PlayerTextDrawHide( playerid, p_ExperienceTD[ playerid ] );
	HidePlayerTogglableTextdraws( playerid );
	TextDrawHideForPlayer( playerid, g_CurrentRankTD );
	TextDrawHideForPlayer( playerid, g_currentXPTD );

	if ( p_inMovieMode{ playerid } == false )
	{
		ShowPlayerTogglableTextdraws( playerid );
		ShowPlayerIrresistibleRank( playerid );
		TextDrawShowForPlayer( playerid, g_CurrentRankTD );
		TextDrawShowForPlayer( playerid, g_currentXPTD );
		PlayerTextDrawShow( playerid, p_LocationTD[ playerid ] );
		PlayerTextDrawShow( playerid, p_ExperienceTD[ playerid ] );
		TextDrawShowForPlayer( playerid, g_WebsiteTD );
		TextDrawShowForPlayer( playerid, g_MotdTD );
		if ( g_HappyHour ) TextDrawShowForPlayer( playerid, g_NotManyPlayersTD );
		TextDrawShowForPlayer( playerid, g_WorldDayTD );
		if ( p_AdminOnDuty{ playerid } ) TextDrawShowForPlayer( playerid, g_AdminOnDutyTD );
		if ( p_AdminLog{ playerid } ) TextDrawShowForPlayer( playerid, g_AdminLogTD );
		if ( p_FPSCounter{ playerid } ) TextDrawShowForPlayer( playerid, p_FPSCounterTD[ playerid ] );
		if ( IsDoubleXP( ) ) TextDrawShowForPlayer( playerid, g_DoubleXPTD );
	}

	p_Spawned{ playerid } = true;
	p_InfectedHIV{ playerid } = false;
	p_Kidnapped{ playerid } = false;
	p_ClassSelection{ playerid } = false;
	p_LastEnteredEntrance[ playerid ] = -1;
   	p_Tied{ playerid } = false;
	p_InHouse[ playerid ] = -1;
	p_InGarage[ playerid ] = -1;
	p_ApartmentEditing{ playerid } = -1;
	StopSound( playerid );
	CancelEdit( playerid );
	loadPlayerToys( playerid );

	// Approved spawn?
	if ( !approveClassSpawned( playerid ) ) {
		SendClientMessageToAdmins( -1, ""COL_PINK"[ABNORMAL SPAWN]"COL_GREY" %s(%d) - %d skin - %d ping - %s IP", ReturnPlayerName( playerid ), playerid, GetPlayerSkin( playerid ), GetPlayerPing( playerid ), ReturnPlayerIP( playerid ) );
	    return KickPlayerTimed( playerid ), 1;
	}

	// Money Bags
	if ( p_MoneyBag{ playerid } && p_Class[ playerid ] != CLASS_POLICE ) // SetPlayerAttachedObject( playerid, 1, 1550, 1, 0.131999, -0.140999, 0.053999, 11.299997, 65.599906, 173.900054, 0.652000, 0.573000, 0.594000 );
		RemovePlayerAttachedObject( playerid, 1 ), SetPlayerAttachedObject( playerid, 1, 1210, 7, 0.302650, -0.002469, -0.193321, 296.124053, 270.396881, 8.941717, 1.000000, 1.000000, 1.000000 );

	// Gang Zones
	for( new i = 0; i < sizeof( g_gangzoneData ); i++ )
		GangZoneShowForPlayer( playerid, g_gangzoneID[ i ], g_gangzoneData[ i ] [ E_COLOR ] );

	// VIP Skin
	if ( p_PlayerSettings[ playerid ] { SETTING_VIPSKIN } && p_VIPLevel[ playerid ] )
		SetPlayerSkin( playerid, p_LastSkin[ playerid ] );

	if ( justConnected{ playerid } == true )
	{
	    justConnected{ playerid } = false;
	    StopAudioStreamForPlayer( playerid );

	    // Preload all animations
	    PreloadAnimationLibrary( playerid, "DANCING" );
	    PreloadAnimationLibrary( playerid, "PED" );
	    PreloadAnimationLibrary( playerid, "PAULNMAC" );
	    PreloadAnimationLibrary( playerid, "INT_OFFICE" );
	    PreloadAnimationLibrary( playerid, "BEACH" );
	    PreloadAnimationLibrary( playerid, "SWEET" );
	    PreloadAnimationLibrary( playerid, "SNM" );
	    PreloadAnimationLibrary( playerid, "COP_AMBIENT" );
	    PreloadAnimationLibrary( playerid, "ON_LOOKERS" );
	    PreloadAnimationLibrary( playerid, "SHOP" );
	    PreloadAnimationLibrary( playerid, "RAPPING" );
	    PreloadAnimationLibrary( playerid, "DEALER" );
	    PreloadAnimationLibrary( playerid, "STRIP" );
	    PreloadAnimationLibrary( playerid, "RIOT" );
	    PreloadAnimationLibrary( playerid, "BLOWJOBZ" );
	    PreloadAnimationLibrary( playerid, "CRACK" );
	    PreloadAnimationLibrary( playerid, "GYMNASIUM" );
	    PreloadAnimationLibrary( playerid, "ROB_BANK" );
	    PreloadAnimationLibrary( playerid, "BOMBER" );
	    PreloadAnimationLibrary( playerid, "CARRY" );
	    PreloadAnimationLibrary( playerid, "VENDING" );
	    PreloadAnimationLibrary( playerid, "CASINO" );
	    PreloadAnimationLibrary( playerid, "GANGS" );
	    PreloadAnimationLibrary( playerid, "INT_HOUSE" );

	    // Show RDM Zones
		/*if ( !p_PlayerSettings[ playerid ] { SETTING_NORDM_ZONES } )
		{
		 	foreach(new r : rdmzone)
		 	{
				for( new i = 0; i < MAX_RDM_GANGZONES; i++ )
				{
			   		GangZoneShowForPlayer( playerid, g_antiDeathmatchZoneData[ r ] [ E_GANGZONES ] [ i ], COLOR_RDMZONES );
				}
		    }
		}*/

		// Jail people that left jailed
	    if ( p_JailTime[ playerid ] ) // We load this when the player logs in.
	    {
	    	JailPlayer( playerid, p_JailTime[ playerid ], p_AdminJailed{ playerid } );
        	SendGlobalMessage( -1, ""COL_GOLD"[JAIL]{FFFFFF} %s(%d) has been sent to jail "COL_LRED"[Left as a jailed person]", ReturnPlayerName( playerid ), playerid );
        	return 1;
	    }

	    // Jail quit to avoiders
	    if ( p_LeftCuffed{ playerid } )
	    {
	    	new
	    		szServing = 100 + GetPlayerScore( playerid );

	    	if ( szServing > 1000 ) szServing = 1000;

	    	p_LeftCuffed{ playerid } = false;
	    	JailPlayer( playerid, szServing, 1 );
        	SendGlobalMessage( -1, ""COL_GOLD"[JAIL]{FFFFFF} %s(%d) has been sent to jail for %d seconds by the server "COL_LRED"[Quit To Avoid]", ReturnPlayerName( playerid ), playerid, szServing );
        	return 1;
	    }

	    // Show wanted level
	    if ( p_WantedLevel[ playerid ] )
	    {
			format( szSmallString, sizeof( szSmallString ), "] %d ]", p_WantedLevel[ playerid ] );
			PlayerTextDrawSetString( playerid, p_WantedLevelTD[ playerid ], szSmallString );
			PlayerTextDrawShow( playerid, p_WantedLevelTD[ playerid ] );
	    }

	    // Show welcome messsage
	   	ShowPlayerHelpDialog( playerid, 10000, "Welcome %s!~n~~n~If you have any questions, ~g~/ask!~w~~h~~n~~n~If you see anyone being unfair, report them with ~r~/report!~w~~n~~n~Have fun playing and don't forget to invite your friends! :)", ReturnPlayerName( playerid ) );
	}
	else
	{
		// Reset wanted level when a player spawns
		if ( p_LastPlayerState{ playerid } != PLAYER_STATE_SPECTATING )
			ClearPlayerWantedLevel( playerid );
	}

	if ( p_Jailed{ playerid } ) // Because some people can still exit the jail and play...
		return SetPlayerHealth( playerid, INVALID_PLAYER_ID ), SetPlayerPosToPrison( playerid );

	if ( IsPlayerInPaintBall( playerid ) )
	{
	    if ( p_Class[ playerid ] != CLASS_CIVILIAN )
	    {
			SendError( playerid, "You must be a civilian to join paintball." );
			LeavePlayerPaintball( playerid );
		    SpawnPlayer( playerid );
			return 1;
		}

		SpawnToPaintball( playerid, p_PaintBallArena{ playerid } );
		return 1;
	}

	/* ** Anti-Spawn Kill ** */
	DisableRemoteVehicleCollisions( playerid, 1 );
	SetPlayerHealth( playerid, INVALID_PLAYER_ID );
	Delete3DTextLabel( p_SpawnKillLabel[ playerid ] );
	p_SpawnKillLabel[ playerid ] = Text3D: INVALID_3DTEXT_ID;
    p_SpawnKillLabel[ playerid ] = Create3DTextLabel( "Spawn Protected!", COLOR_GOLD, 0.0, 0.0, 0.0, 15.0, 0 );
    Attach3DTextLabelToPlayer( p_SpawnKillLabel[ playerid ], playerid, 0.0, 0.0, 0.3 );
    p_AntiSpawnKillEnabled{ playerid } = true;
	p_AntiSpawnKill[ playerid ] = g_iTime + 15;
	/* ** Anti-Spawn Kill ** */

	if ( p_Class[ playerid ] == CLASS_CIVILIAN )
	{
		if ( !p_JobSet{ playerid } )
		{
		    TogglePlayerControllable( playerid, 0 );
			ShowPlayerDialog( playerid, DIALOG_JOB, DIALOG_STYLE_LIST, "{FFFFFF}Job Selection", "Rapist\nKidnapper\nTerrorist\nHitman\nProstitute\nWeapon Dealer\nDrug Dealer\nDirty Mechanic\nBurglar", "Select", "" );
		}
		else
		{
			if ( p_LastPlayerState{ playerid } != PLAYER_STATE_SPECTATING )
			{
			    switch( p_Job{ playerid } )
				{
			        case JOB_RAPIST:
			        {
			            GivePlayerWeapon( playerid, 22, 150 );
			            GivePlayerWeapon( playerid, 30, 400 );
			        }
			        case JOB_KIDNAPPER:
			        {
			            GivePlayerWeapon( playerid, 29, 220 );
			            GivePlayerWeapon( playerid, 30, 400 );
			        }
			        case JOB_TERRORIST:
			        {
			            GivePlayerWeapon( playerid, 33, 50 );
			            GivePlayerWeapon( playerid, 30, 400 );
			        }
			        case JOB_HITMAN:
			        {
			            GivePlayerWeapon( playerid, 4, 1 );
			            GivePlayerWeapon( playerid, 23, 130 );
			            GivePlayerWeapon( playerid, 34, 30 );
			        }
			        case JOB_PROSTITUTE:
			        {
			            GivePlayerWeapon( playerid, 10, 1 );
			            GivePlayerWeapon( playerid, 25, 50 );
			            GivePlayerWeapon( playerid, 30, 300 );
			        }
			        case JOB_WEAPON_DEALER:
			        {
			            GivePlayerWeapon( playerid, 5 , 1 );
			            GivePlayerWeapon( playerid, 22, 150 );
			            GivePlayerWeapon( playerid, 31, 300 );
			        }
			        case JOB_DRUG_DEALER:
			        {
			            GivePlayerWeapon( playerid, 5 , 1 );
			            GivePlayerWeapon( playerid, 22, 150 );
			            GivePlayerWeapon( playerid, 25, 50 );
			        }
			        case JOB_DIRTY_MECHANIC:
			        {
			            GivePlayerWeapon( playerid, 22, 150 );
			            GivePlayerWeapon( playerid, 27, 90 );
					}
			        case JOB_BURGLAR:
			        {
			            GivePlayerWeapon( playerid, 23, 130 );
			            GivePlayerWeapon( playerid, 31, 300 );
					}
			    }
			}
		}
	}

    /*if ( p_Class[ playerid ] == CLASS_POLICE && p_CopTutorial{ playerid } == 0 ) // False value means they haven't passed it.
	{
		TogglePlayerSpectating( playerid, 1 );
		p_inMovieMode{ playerid } = false;
		cmd_moviemode( playerid, "" ); // Hide textdraws :3
		p_CopTutorialProgress{ playerid } = 0;
		p_CopTutorialTick[ playerid ] = g_iTime + 25;
		szLargeString[ 0 ] = '\0';
		strcat( szLargeString, "{FFFFFF}Welcome! This is a tutorial that every player must complete at some point in time! Within this tutorial, you'll be taught how become a successful\nlaw enforcement officer. Player colors are the most important thing to remember as an officer. You can view the player colors by simply typing '/pc'.\n\n" );
		strcat( szLargeString, "You can view a list of commands by typing '/commands (/cmds)' in the chat box, then selecting the 'Police Commands' option." );
		ShowPlayerDialog( playerid, DIALOG_POLICE_TUTORIAL, DIALOG_STYLE_MSGBOX, "{FFFFFF}Law Enforcement Officer Tutorial", szLargeString, "Next", "" );
		InterpolateCameraPos( playerid, -1495.9056, 1025.5458, 60.0000, -1557.7552, 620.3210, 30.0000, 20000 );
		InterpolateCameraLookAt( playerid, -1496.0648, 1024.5542, 60.0000, -1558.4092, 621.0837, 30.0000, 10000 );
        return 1;
    }*/

    new
    	bSpectated = ( IsPlayerAdmin( playerid ) && p_LastPlayerState{ playerid } == PLAYER_STATE_SPECTATING );

	if ( !bSpectated )
	{
		switch( p_Class[ playerid ] )
		{
			case CLASS_POLICE: GivePlayerLeoWeapons( playerid );

			case CLASS_FIREMAN:
			{
				GivePlayerWeapon( playerid, 22, 250 );
				GivePlayerWeapon( playerid, 25, 50 );
				GivePlayerWeapon( playerid, 9, 1 );
				GivePlayerWeapon( playerid, 42, 0xFFFF );
			}

			case CLASS_MEDIC:
			{
			    GivePlayerWeapon( playerid, 23, 250 );
			    GivePlayerWeapon( playerid, 25, 50 );
				GivePlayerWeapon( playerid, 41, 200 );
			}
		}
	}

	SetPlayerColorToTeam( playerid );
	SetPlayerVirtualWorld( playerid, 0 );
	SetPlayerRandomSpawn( playerid );

	if ( p_VIPLevel[ playerid ] > 0 && p_VIPWep1{ playerid } != 0 ) GivePlayerWeapon( playerid, p_VIPWep1{ playerid }, 200 );
	if ( p_VIPLevel[ playerid ] >= VIP_GOLD && p_VIPWep2{ playerid } != 0 ) GivePlayerWeapon( playerid, p_VIPWep2{ playerid }, 200 );
	if ( p_VIPLevel[ playerid ] > VIP_GOLD && p_VIPWep3{ playerid } != 0 ) GivePlayerWeapon( playerid, p_VIPWep3{ playerid }, 200 );
	if ( p_VIPLevel[ playerid ] >= VIP_GOLD ) SetPlayerArmour( playerid, 100.0 ); // Free armour on spawn.

	SendClientMessageFormatted( playerid, -1, ""COL_GOLD"[SPAWN INFO]"COL_WHITE" It has taken you %d milliseconds to spawn!", ( GetTickCount( ) - iTick ) );
	return 1;
}

public OnPlayerWeaponShot( playerid, weaponid, hittype, hitid, Float:fX, Float:fY, Float:fZ )
{
	new
		keys, ud, lr
	;
	GetPlayerKeys( playerid, keys, ud, lr );

	ResetPlayerVendingMachineData( playerid );

	// Simple. But effective. Anti-Shooting Hacks.
	if ( !( keys & KEY_FIRE )  ) {
		return 0;
	}

	if ( !( 22 <= weaponid <= 34 ) && weaponid != 38 ) {
		return 0;
	}

	if ( p_AdminLevel[ playerid ] < 1 && IsWeaponBanned( weaponid ) ) {
		return 0;
	}

	if ( hittype == BULLET_HIT_TYPE_PLAYER && ( ( fX >= 10.0 || fX <= -10.0 ) || ( fY >= 10.0 || fY <= -10.0 ) || ( fZ >= 10.0 || fZ <= -10.0 ) ) ) {
		return 0;
	}

	if ( IsPlayerAFK( playerid ) ) {
		return 0;
	}

	// Anti-Rapid Fire
	if ( !p_RapidFireTickCount[ playerid ] ) p_RapidFireTickCount[ playerid ] = GetTickCount( );
	else
	{
		new
			iInterval = GetTickCount( ) - p_RapidFireTickCount[ playerid ];

		if ( ( iInterval <= 35 && ( weaponid != 38 && weaponid != 28 && weaponid != 32 ) ) || ( iInterval <= 370 && ( weaponid == 34 || weaponid == 33 ) ) )
		{
			if ( p_RapidFireShots{ playerid }++ >= 5 )
			{
			 	if ( g_Debugging )
			 	{
			 		SendClientMessageToRCON( COLOR_YELLOW, "RAPID-FIRE: %s, weapon %s, rate %d, times fucked up: %d", ReturnPlayerName( playerid ), ReturnWeaponName( weaponid ), iInterval, p_RapidFireShots{ playerid } );
			 		printf("[DEBUG] [RAPID-FIRE] %s | %s | rate %d | times fucked up: %d", ReturnPlayerName( playerid ), ReturnWeaponName( weaponid ), iInterval, p_RapidFireShots{ playerid } );
			 	}

				SendGlobalMessage( -1, ""COL_PINK"[ANTI-CHEAT]{FFFFFF} %s(%d) has been kicked for rapid-firing.", ReturnPlayerName( playerid ), playerid );
			 	KickPlayer( playerid );
		    	return 0;
			}
		}
		else p_RapidFireShots{ playerid } = 0;
		p_RapidFireTickCount[ playerid ] = GetTickCount( );
	}

	if ( hittype == BULLET_HIT_TYPE_PLAYER )
	{
		if ( IsPlayerNPC( hitid ) )
			return 1; // fcnpc

		// Cop shoots innocent, they /q - so jail
		if ( p_Class[ playerid ] == CLASS_POLICE && p_WantedLevel[ hitid ] > 2 )
			p_QuitToAvoidTimestamp[ hitid ] = g_iTime + 3;

		if ( p_Class[ playerid ] == CLASS_POLICE && p_Class[ hitid ] != CLASS_POLICE && !p_WantedLevel[ hitid ] && GetPlayerState( hitid ) != PLAYER_STATE_WASTED && ! IsPlayerInEvent( playerid ) )
		 	return ShowPlayerHelpDialog( playerid, 2000, "You cannot hurt innocent civilians, you're a ~b~cop~w~~h~!" ), 0;

		// CIA Exposure when weapon is shot
		if ( p_Class[ playerid ] == CLASS_POLICE && p_inFBI{ playerid } && p_inCIA{ playerid } && !p_inArmy{ playerid } )
			SetPlayerColor( playerid, setAlpha( COLOR_CIA, 0xFF ) ), p_VisibleOnRadar[ playerid ] = g_iTime + 2;

		if ( IsPlayerConnected( hitid ) && p_BulletInvulnerbility[ hitid ] > g_iTime )
		 	return ShowPlayerHelpDialog( playerid, 2000, "This player is immune from bullets!" ), 0;

		if ( IsPlayerAdminOnDuty( playerid ) )
			return 0;

		if ( IsPlayerConnected( hitid ) && ( IsPlayerTazed( hitid ) || IsPlayerCuffed( hitid ) || IsPlayerDetained( hitid ) || IsPlayerKidnapped( hitid ) || IsPlayerTied( hitid ) || IsPlayerLoadingObjects( hitid ) || IsPlayerAdminOnDuty( hitid ) || p_AntiSpawnKillEnabled{ hitid } ) )
			return 0;

		if ( p_AntiSpawnKill[ playerid ] > g_iTime && p_AntiSpawnKillEnabled{ playerid } )
		 	return ( p_AntiSpawnKill[ playerid ] = 0 ), SendServerMessage( playerid, "Your spawn protection is no longer active!" ), 0;
	}

	else if ( hittype == BULLET_HIT_TYPE_VEHICLE )
	{
		new
			Float: X, Float: Y, Float:Z,
			Float: Health, Float: Damage,
			iModel = GetVehicleModel( hitid )
		;

		g_VehicleLastAttacker[ hitid ] = playerid;
		g_VehicleLastAttacked[ hitid ] = g_iTime;

		// BMX, Bike, Mountain Bike, Train, Train Cargo, Train Passenger, Tram, Freight Box
		if ( iModel != 481 && iModel != 509 && iModel != 510 && iModel != 537 && iModel != 569 && iModel != 570 && iModel != 538 && iModel != 449 && iModel != 590 ) {
			GetPlayerPos( playerid, X, Y, Z );
			GetVehicleHealth( hitid, Health );

			Damage = GetWeaponDamageFromDistance( weaponid, GetVehicleDistanceFromPoint( hitid, X, Y, Z ) );

			#if ENABLED_SECURE_TRUCK == true
				// Secured Truck!
				if ( g_secureTruckVehicle == hitid && GetPlayerSurfingVehicleID( playerid ) != g_secureTruckVehicle && IsPlayerConnected( g_secureTruckDriver ) && p_Class[ playerid ] != CLASS_POLICE )
				{
					if ( IsSecurityDriverAFK( ) )
						return 1; // Nothing cheeky when he's disabled.

					for( new i = 0; i < sizeof( g_secureTruckOffsets ); i++ ) if ( g_secureTruckOffsets[ i ] [ E_ENABLED ] )
					{
						if ( IsPointToPoint( 0.25, fX, fY, fZ, g_secureTruckOffsets[ i ] [ E_X ], g_secureTruckOffsets[ i ] [ E_Y ], g_secureTruckOffsets[ i ] [ E_Z ] ) )
						{
							new Float: hingeDamage = floatdiv( Damage, 4 );
							if ( floatround( g_secureTruckOffsets[ i ] [ E_HP ] -= hingeDamage ) > 0.0 ) {
								SendClientMessage( g_secureTruckDriver, 0x112233FF, "[0x01][NPC] PROVOKED." );
								format( szNormalString, 6, "%0.0f%%", g_secureTruckOffsets[ i ] [ E_HP ] );
								UpdateDynamic3DTextLabelText( g_secureTruckVehicleLabel[ i ], setAlpha( COLOR_GREY, 0x90 ), szNormalString );
							} else {
								g_secureTruckOffsets[ i ] [ E_HP ] = 0.0;
								g_secureTruckOffsets[ i ] [ E_ENABLED ] = false;
								UpdateDynamic3DTextLabelText( g_secureTruckVehicleLabel[ i ], setAlpha( COLOR_RED, 0x90 ), "0%" );

								if ( allSecurityOffsetsShot( ) ) {
									g_secureTruckData[ E_LOOT ] 		= RandomEx( 12000, 15000 );
									g_secureTruckData[ E_ROBBED ] 		= false;
									g_secureTruckData[ E_OPEN ] 		= true;
									g_secureTruckData[ E_BEING_ROBBED ] = false;
									SetVehicleParamsCarDoors( hitid, 0, 0, 1, 1 );
									ShowPlayerHelpDialog( playerid, 5000, "You've successfully disabled the security truck.~n~~n~To rob it, press ~r~~k~~SNEAK_ABOUT~~w~ behind the truck." );
									SendClientMessage( g_secureTruckDriver, 0x112233FF, "[0x00][NPC] TRUCK DISABLED." );
								}
							}
							break;
						}
					}
					return 1;
				}
			#endif

			new
				iDriver = GetVehicleDriver( hitid );

			if ( iDriver == INVALID_PLAYER_ID )
			{
				if ( weaponid == 38 ) Damage *= 20.0;

				switch( GetVehicleModel( hitid ) )
				{
					case 573: Damage /= 6.0; // Dune
					case 508: Damage /= 4.0; // Journey
					case 498: Damage /= 2.0; // Boxville
				}

				if ( Health >= 250.0 ) {
					SetVehicleHealth( hitid, Health - Damage );
				}
				else
				{
					if ( GetGVarType( "respawning_veh", hitid ) == GLOBAL_VARTYPE_NONE )
				 		SetGVarInt( "respawning_veh", SetTimerEx( "RespawnaVehicle", 9000, false, "d", hitid ), hitid );
				}
			}
			else
			{
				// Disable team vehicle damage
				if ( p_Class[ iDriver ] == CLASS_POLICE && p_Class[ playerid ] == CLASS_POLICE )
					return 0;

				// Can't damage admin on duty vehicles
				if ( IsPlayerAdminOnDuty( iDriver ) )
					return 0;

				// Anti Random Deathmatch
				if ( IsRandomDeathmatch( playerid, iDriver ) && !IsPlayerInPaintBall( playerid ) && !IsPlayerInEvent( playerid ) )
					return 0;

				if ( p_WantedLevel[ playerid ] <= 2 && p_Class[ playerid ] != CLASS_POLICE && p_Class[ iDriver ] == CLASS_POLICE && GetPVarInt( playerid, "ShotCopWantedCD" ) < g_iTime )
					SendServerMessage( playerid, "You have physically touched an officer, thus you have been wanted." ), GivePlayerWantedLevel( playerid, 6 ), SetPVarInt( playerid, "ShotCopWantedCD", g_iTime + 120 );
			}
		}
	}

	else if ( hittype == BULLET_HIT_TYPE_NONE )
	{
		if ( IsPlayerLorenc( playerid ) && weaponid == 30 ) {
			CreateExplosion( fX, fY, fZ, 12, 10.0 );
		}
	}
    return 1;
}

public OnPlayerShootDynamicObject( playerid, weaponid, objectid, Float:x, Float:y, Float:z )
{
	new
		Float: X, Float: Y, Float: Z, Float: rZ,
		modelid = Streamer_GetIntData( STREAMER_TYPE_OBJECT, objectid, E_STREAMER_MODEL_ID )
	;

	switch( modelid )
	{
		// C4
		case 19602:
		{
			foreach(new p : Player)
			{
				for( new i = 0; i < MAX_C4; i++ )
				{
					if ( objectid == g_C4Data[ p ] [ i ] [ E_OBJECT ] )
					{
						ExplodePlayerC4s( p, i, i + 1 );
						break;
					}
				}
			}
		}

		// ATM
		case 19324:
		{
			if ( p_Class[ playerid ] == CLASS_POLICE )
				return 1; // Prevent police from damaging atms

			new
				Float: Damage = GetWeaponDamageFromDistance( weaponid, GetPlayerDistanceFromPoint( playerid, x, y, z ) );

			for( new i = 0; i < sizeof( g_atmData ); i++ ) if ( g_atmData[ i ] [ E_CREATED ] ) {

				if ( g_atmData[ i ] [ E_OBJECT ] == objectid && !g_atmData[ i ] [ E_DISABLED ] )
				{
					if ( GetDynamicObjectPos( objectid, X, Y, Z ) && IsPointToPoint( 1.0, X + x, Y + y, Z + z, X, Y, Z ) ) {
						new
							Float: atmDamage = floatdiv( Damage, 4 );

						if ( ( g_atmData[ i ] [ E_HEALTH ] -= atmDamage ) > 0.0 ) {
							format( szNormalString, 24, "[ATM]\n"COL_GREY"%0.0f%%", g_atmData[ i ] [ E_HEALTH ] );
							UpdateDynamic3DTextLabelText( g_atmData[ i ] [ E_LABEL ], COLOR_GOLD, szNormalString );
						} else {
							UpdateDynamic3DTextLabelText( g_atmData[ i ] [ E_LABEL ], COLOR_GOLD, "[ATM]\n"COL_RED"Disabled" );
							ReplaceObjectModel( g_atmData[ i ] [ E_OBJECT ], 2943 );

							g_atmData[ i ] [ E_TIMESTAMP ] = g_iTime + 240;
							g_atmData[ i ] [ E_DISABLED ] = true;

							if ( random( 101 ) <= 20 ) {
								new
									szLocation[ MAX_ZONE_NAME ];

								GetPlayerPos 			( playerid, X, Y, Z );
								GetZoneFromCoordinates	( szLocation, X, Y, Z );

								CreateCrimeReport( playerid );
								SendClientMessageToCops( -1, ""COL_BLUE"[ROBBERY]"COL_WHITE" %s has failed robbing an ATM near %s, suspect is armed and dangerous.", ReturnPlayerName( playerid ), szLocation );
								SendServerMessage( playerid, "There seems to be no money in the ATM that you have breached." );
							} else {
								GetDynamicObjectRot( objectid, rZ, rZ, rZ );
								g_atmData[ i ] [ E_PICKUP ] = CreateDynamicPickup( 1550, 1, X + 1.0 * -floatsin( -rZ, degrees ), Y + 1.0 * -floatcos( -rZ, degrees ), Z + 0.33 );
								g_atmData[ i ] [ E_LOOT ] = RandomEx( 320, 750 );

								if ( IsPlayerConnected( playerid ) && p_MoneyBag{ playerid } == true )
									g_atmData[ i ] [ E_LOOT ] *= 2;

								SendServerMessage( playerid, "You've breached an ATM! Rob the money that has been dispensed for quick pocket change!" );
							}
						}
						break;
					}
				}
			}
		}
	}
	return 1;
}

function RespawnaVehicle( vehicleid ) {
	new	Float: health;
	DeleteGVar( "respawning_veh", vehicleid );
	GetVehicleHealth( vehicleid, health );
	if ( health < 250.0 ) SetVehicleToRespawn( vehicleid );
}

#if defined AC_INCLUDED
public OnPlayerTakePlayerDamage( playerid, issuerid, &Float: amount, weaponid, bodypart )
{
	if ( !IsPlayerStreamedIn( issuerid, playerid ) || IsPlayerAFK( issuerid ) )
		return 0;

	if ( IsPlayerJailed( playerid ) || IsPlayerJailed( issuerid ) )
		return 0;

	if ( weaponid == WEAPON_KNIFE && amount > 256.0 && IsRandomDeathmatch( issuerid, playerid ) )
	{
		new
			iSeconds;

		if ( ( iSeconds = 60 + GetPlayerScore( issuerid ) ) > 500 )
			iSeconds = 500;

		JailPlayer( issuerid, iSeconds, 1 );
		SendGlobalMessage( -1, ""COL_GOLD"[JAIL]{FFFFFF} %s(%d) has been sent to jail for %d seconds by the server "COL_GREEN"[REASON: Random Deathmatch]", ReturnPlayerName( issuerid ), issuerid, iSeconds );
		return 1; // Need damage to pass through
	}

	/*if ( p_Class[ issuerid ] == CLASS_POLICE && p_Class[ playerid ] != CLASS_POLICE && !p_WantedLevel[ playerid ] && GetPlayerState( playerid ) != PLAYER_STATE_WASTED ) {
		ShowPlayerHelpDialog( issuerid, 2000, "You should not hurt innocent civilians, you're a ~b~cop~w~~h~!" );
	}*/
	if ( p_Class[ issuerid ] == CLASS_POLICE && p_Class[ playerid ] != CLASS_POLICE && !p_WantedLevel[ playerid ] && GetPlayerState( playerid ) != PLAYER_STATE_WASTED && ! IsPlayerInEvent( issuerid ) )
	 	return ShowPlayerHelpDialog( issuerid, 2000, "You cannot hurt innocent civilians, you're a ~b~cop~w~~h~!" ), 0;

	// Heal player (paramedic)
	if ( p_Class[ issuerid ] == CLASS_MEDIC && weaponid == WEAPON_SPRAYCAN )
	{
		new
			Float: fHealth = AC_GetPlayerHealth( playerid );

		if ( fHealth < 100.0 )
	 		AC_AddPlayerHealth( playerid, amount );

	 	return 0;
	}

	if ( p_Class[ playerid ] == p_Class[ issuerid ] && p_Class[ playerid ] != CLASS_CIVILIAN  )
		return 0;

	if ( p_BulletInvulnerbility[ playerid ] > g_iTime )
	 	return ShowPlayerHelpDialog( issuerid, 2000, "This player is immune from damage!" ), 0;

	if ( p_BulletInvulnerbility[ issuerid ] > g_iTime )
	 	return ShowPlayerHelpDialog( issuerid, 2000, "You cannot damage players as you're immune!" ), 0;

	if ( IsPlayerOnSlotMachine( playerid ) && ! p_WantedLevel[ playerid ] )
	 	return ShowPlayerHelpDialog( issuerid, 2000, "This player cannot be killed as they are doing something!" ), 0;

	if ( IsPlayerTazed( playerid ) || IsPlayerCuffed( playerid ) || IsPlayerDetained( playerid ) || IsPlayerKidnapped( playerid ) || IsPlayerTied( playerid ) || IsPlayerLoadingObjects( playerid ) || IsPlayerAdminOnDuty( playerid ) || p_AntiSpawnKillEnabled{ playerid } )
		return 0;

	// Anti RDM and gang member damage
	if ( !IsPlayerInEvent( playerid ) && !IsPlayerInPaintBall( playerid ) )
	{
		if ( IsPlayerInPlayerGang( issuerid, playerid ) )
		 	return ShowPlayerHelpDialog( issuerid, 2000, "You cannot damage your homies!" ), 0;

		// Anti Random Deathmatch
		if ( IsRandomDeathmatch( issuerid, playerid ) )
			return ShowPlayerHelpDialog( issuerid, 2000, "You cannot ~r~~h~random deathmatch~w~~h~ in this location!" ), 0;
	}

	// No passenger, no bullets
	if ( GetPlayerState( issuerid ) == PLAYER_STATE_PASSENGER )
	{
		new
			iVehicle = GetPlayerVehicleID( issuerid );

		if ( GetVehicleDriver( iVehicle ) == INVALID_PLAYER_ID )
	 		return ShowPlayerHelpDialog( issuerid, 2000, "You cannot drive-by without a driver!" ), 0;
	}

	// Wanted on shoot!
	if ( p_WantedLevel[ issuerid ] <= 2 && p_Class[ issuerid ] != CLASS_POLICE && p_Class[ playerid ] == CLASS_POLICE && GetPVarInt( issuerid, "ShotCopWantedCD" ) < g_iTime )
		GivePlayerWantedLevel( issuerid, 6 ), SetPVarInt( issuerid, "ShotCopWantedCD", g_iTime + 120 );

	// Headshots
	if ( ( weaponid == WEAPON_SNIPER || weaponid == WEAPON_RIFLE ) && bodypart == 9 )
		amount *= 1.5;

	// Increasing weapon damages
	switch( weaponid )
	{
		// Melee
		case WEAPON_BRASSKNUCKLE:
			amount *= 8.0;

		case WEAPON_GOLFCLUB:
			amount *= 4.0;

		case WEAPON_NITESTICK:
			amount *= 5.0;

		case WEAPON_KNIFE:
			amount *= 7.0;

		case WEAPON_BAT:
			amount *= 4.0;

		case WEAPON_SHOVEL:
			amount *= 3.0;

		case WEAPON_POOLSTICK:
			amount *= 3.0;

		case WEAPON_KATANA:
			amount *= 15.0;

		case WEAPON_DILDO .. WEAPON_VIBRATOR2:
			amount *= 3.0;

		case WEAPON_CANE:
			amount *= 4.0;

		// Guns with increased damage
		case WEAPON_RIFLE:
			amount *= 1.666;

		case WEAPON_SILENCED:
			amount *= 1.5;
	}

	// Hitmarker
	if ( p_PlayerSettings[ issuerid ] { SETTING_HITMARKER } )
	{
		new
			soundid = p_VIPLevel[ issuerid ] ? p_HitmarkerSound{ issuerid } : 0;

    	PlayerPlaySound( issuerid, g_HitmarkerSounds[ soundid ] [ E_SOUND_ID ], 0.0, 0.0, 0.0 );

    	PlayerTextDrawSetString( issuerid, p_DamageTD[ issuerid ], sprintf( "~r~~h~%0.2f DAMAGE", amount ) );
    	PlayerTextDrawShow( issuerid, p_DamageTD[ issuerid ] );

	    KillTimer( p_DamageTDTimer[ issuerid ] );
		p_DamageTDTimer[ issuerid ] = SetTimerEx( "hidedamagetd_Timer", 3000, false, "d", issuerid );
	}
	return 1;
}
#endif

function hidedamagetd_Timer( playerid )
	return PlayerTextDrawHide( playerid, p_DamageTD[ playerid ] );

stock getPlayerTax( playerid )
{
	new
		iTax = floatround( ( p_Cash[ playerid ] + ( p_BankMoney[ playerid ] * 0.6 ) ) / 1000 * GetTaxRate( ) );

	return iTax > 0 ? iTax : 0;
}

#if defined AC_INCLUDED
public OnPlayerDeathEx( playerid, killerid, reason, Float: damage, bodypart )
#else
public OnPlayerDeath(playerid, killerid, reason)
#endif
{
	if ( !p_PlayerLogged{ playerid } )
	    return SendServerMessage( playerid, "Possible Fake-kill detected - 0x0A" ), KickPlayerTimed( playerid );

	switch( g_iTime - LastDeath[ playerid ] )
	{
		case 0 .. 3:
		{
			if ( DeathSpam{ playerid }++ == 3 )
			{
				SendGlobalMessage( -1, ""COL_PINK"[ANTI-CHEAT]{FFFFFF} %s(%d) has been banned for fake-killing.", ReturnPlayerName( playerid ), playerid );
				BanEx( playerid, "Fake-kill" );
				return 1;
			}
		}
		default: DeathSpam{ playerid } = 0;
	}

	// Robbery system
	if ( IsPlayerNPC( killerid ) )
	{
		new
			clerkid = GetRobberyNpcFromPlayer( killerid );

		if ( clerkid != -1 ) {
			ReplenishRobberyNpc( clerkid, .fullreplenish = false );
		}
	}

	// Reset player variables
	LastDeath[ playerid ] = g_iTime;
    p_Spawned{ playerid } = false;
    p_QuitToAvoidTimestamp[ playerid ] = 0;
    CutSpectation( playerid );
    StopPlayerNpcRobbery( playerid );
    RemovePlayerFromRace( playerid );
    RemovePlayerStolensFromHands( playerid );
    StopPlayerUsingSlotMachine( playerid );
    RemoveEquippedOre( playerid );
    KillTimer( p_CuffAbuseTimer[ playerid ] );
    RemovePlayerFromRoulette( playerid );
	RemovePlayerFromBlackjack( playerid );
    PlayerTextDrawHide( playerid, p_LocationTD[ playerid ] );
	p_Tazed{ playerid } = false;
	p_WeaponDealing{ playerid } = false;
	p_WeaponDealer[ playerid ] = INVALID_PLAYER_ID;
	p_Cuffed{ playerid } = false;
	p_DetainedBy[ playerid ] = INVALID_PLAYER_ID;
	p_LastVehicle[ playerid ] = INVALID_VEHICLE_ID;
	Delete3DTextLabel( p_DetainedLabel[ playerid ] );
	p_DetainedLabel[ playerid ] = Text3D: INVALID_3DTEXT_ID;
	Delete3DTextLabel( p_TiedLabel[ playerid ] );
	p_TiedLabel[ playerid ] = Text3D: INVALID_3DTEXT_ID;
	DestroyDynamic3DTextLabel( p_WeedLabel[ playerid ] );
	p_WeedLabel[ playerid ] = Text3D: INVALID_3DTEXT_ID;
	p_Tied{ playerid } = false;
	p_TicketTimestamp[ playerid ] = 0;
	p_Kidnapped{ playerid } = false;
    p_Detained{ playerid } = false;
	p_ClassSelection{ playerid } = false;
	p_TicketIssuer[ playerid ] = INVALID_PLAYER_ID;
	KillTimer( p_TrackingTimer[ playerid ] );
	p_TrackingTimer[ playerid ] = INVALID_TIMER_ID;
	p_GPSLocation	[ playerid ] = 0;
	p_GPSToggled	{ playerid } = false;
	TextDrawHideForPlayer( playerid, p_GPSInformation[ playerid ] );
	DestroyDynamicObject( p_GPSObject[ playerid ] );
	KillTimer( p_GPSTimer[ playerid ] );
	DeletePVar( playerid, "AlcatrazWantedCD" );
	DeletePVar( playerid, "ShotCopWantedCD" );
	p_GPSTimer[ playerid ] = 0xFF;
  	p_GPSObject[ playerid ] = INVALID_OBJECT_ID;
	TextDrawHideForPlayer( playerid, p_TrackPlayerTD[ playerid ] );
	PlayerTextDrawHide( playerid, p_ExperienceTD[ playerid ] );
	TextDrawHideForPlayer( playerid, g_WebsiteTD );
	PlayerTextDrawHide( playerid, p_WantedLevelTD[ playerid ] );
	TextDrawHideForPlayer( playerid, g_MotdTD );
	TextDrawHideForPlayer( playerid, g_NotManyPlayersTD );
	TextDrawHideForPlayer( playerid, p_FPSCounterTD[ playerid ] );
	TextDrawHideForPlayer( playerid, g_AdminOnDutyTD );
	TextDrawHideForPlayer( playerid, g_WorldDayTD );
	TextDrawHideForPlayer( playerid, g_AdminLogTD );
	TextDrawHideForPlayer( playerid, g_DoubleXPTD );
	PlayerTextDrawHide( playerid, p_PlayerRankTD[ playerid ] );
	PlayerTextDrawHide( playerid, p_PlayerRankTextTD[ playerid ] );
	TextDrawHideForPlayer( playerid, g_CurrentRankTD );
	TextDrawHideForPlayer( playerid, g_currentXPTD );
	HidePlayerTogglableTextdraws( playerid );
	resetPlayerStreaks( playerid );

	if ( p_InAnimation{ playerid } == true ) {
		TextDrawHideForPlayer( playerid, g_AnimationTD );
		p_InAnimation{ playerid } = false;
	}

	/* ** Tax And Medical Fees ** */
	if ( ( g_iTime - p_JoinTimestamp[ playerid ] ) > 120 ) // Player has been online for at least 2 minutes.
	{
		new
			szTaxable[ 128 ], iMoney = p_inPaintBall{ playerid } == true ? 0 : ( GetPlayerTotalCash( playerid ) > 200000 ? 1500 : 100 );

		format( szTaxable, sizeof( szTaxable ), "~w~You have paid ~r~%s~w~ in medical fees", ConvertPrice( iMoney ) );
		GivePlayerCash( playerid, -( iMoney ) );

		if ( p_TaxTime{ playerid } == true )
		{
		    new iTax = p_inPaintBall{ playerid } == true ? 0 : getPlayerTax( playerid );
			GivePlayerCash( playerid, -iTax );
			UpdateServerVariable( "eventbank", GetGVarInt( "eventbank" ) + floatround( iTax * 0.10 ), 0.0, "", GLOBAL_VARTYPE_INT );
			if ( strlen( szTaxable ) ) format( szTaxable, sizeof( szTaxable ), "%s and ~r~%s~w~ in tax", ConvertPrice( iTax ) );
			else format( szTaxable, sizeof( szTaxable ), "~w~You have paid ~r~%s~w~ in tax", ConvertPrice( iTax ) );
			p_TaxTime{ playerid } = false;
		}
		ShowPlayerHelpDialog( playerid, 5000, szTaxable );
	}
	/* ** End Of Tax And Medical Fees ** */

	if ( p_StartedLumberjack{ playerid } == true )
	{
    	p_StartedLumberjack{ playerid } = false;
	 	GameTextForPlayer( playerid, "~r~job stopped!", 4000, 0 );
        DestroyDynamicRaceCP( p_LumberjackReturn[ playerid ] );
        p_LumberjackReturn[ playerid ] = 0xFFFF;
        DestroyDynamicRaceCP( p_LumberjackDeliver[ playerid ] );
        p_LumberjackDeliver[ playerid ] = 0xFFFF;
        p_treeExportLocation[ playerid ] = 0xFF;
		DestroyDynamicMapIcon( p_LumberjackMapIcon[ playerid ] );
		p_LumberjackMapIcon[ playerid ] = 0xFFFF;
	}

	// To deny kills etc.
	if ( IsPlayerConnected( killerid ) ) {
		if ( p_inPaintBall{ playerid } == true && p_inPaintBall{ killerid } == false ) killerid = INVALID_PLAYER_ID;
	}

	new
		playerGangId = p_GangID[ playerid ];

    if ( ! IsPlayerNPC( killerid ) && IsPlayerConnected( killerid ) && GetPVarInt( playerid, "used_cmd_kill" ) != 1 )
    {
		if ( !IsPlayerStreamedIn( killerid, playerid ) ) {
			printf( "[DEBUG] %s was killed for possible fake kill. (0x1B)", ReturnPlayerName( playerid ) );
	    	return SendServerMessage( playerid, "Possible Fake-kill detected - 0x1B" ), KickPlayerTimed( playerid );
		}

		/*if ( GetPVarInt( killerid, "last_shot" ) != playerid ) {
			printf( "[DEBUG] %s was killed for possible fake kill (last shot %d). (0x0C)", ReturnPlayerName( playerid ), GetPVarInt( killerid, "last_shot" ) );
	    	return SendServerMessage( playerid, "Possible Fake-kill detected - 0x0C" ), KickPlayerTimed( playerid );
		}
		DeletePVar( killerid, "last_shot" );*/

		SendDeathMessage( killerid, playerid, reason );

		if ( p_inPaintBall{ killerid } == true )
		{
			new
				a = p_PaintBallArena{ killerid };

			if ( g_paintballData[ a ] [ E_REFILLER ] )
			{
				SetPlayerHealth( killerid, g_paintballData[ a ] [ E_HEALTH ] );
				SetPlayerArmour( killerid, g_paintballData[ a ] [ E_ARMOUR ] );
			}
			return 1;
		}

		DCC_SendChannelMessageFormatted( discordGeneralChan, "*%s(%d) has killed %s(%d) - %s!*", ReturnPlayerName( killerid ), killerid,  ReturnPlayerName( playerid ), playerid, ReturnWeaponName( reason ) );

		if ( !IsPlayerAdminOnDuty( killerid ) )
		{
			new
				killerGangId = p_GangID[ killerid ];

			if ( killerGangId != INVALID_GANG_ID )
				SaveGangData( killerGangId ), g_gangData[ killerGangId ] [ E_KILLS ]++;

			switch( p_Kills[ killerid ]++ )
			{
				case 5:    	ShowAchievement( killerid, "Noob Killer - 5 Kills!", 3 );
				case 20:    ShowAchievement( killerid, "Rookie Killer - 20 Kills!", 6 );
				case 50:    ShowAchievement( killerid, "Novice Killer - 50 Kills!", 9 );
				case 100:   ShowAchievement( killerid, "Corporal Killer - 100 Kills!", 12 );
				case 200:   ShowAchievement( killerid, "Monster Killer - 200 Kills!", 15 );
				case 500:   ShowAchievement( killerid, "General Killer - 500 Kills!", 18 );
				case 1000:  ShowAchievement( killerid, "Master Killer - 1000 Kills!", 25 );
			}

			incrementPlayerWeaponKills( killerid, reason );
			incrementPlayerStreak( killerid, STREAK_KILL );

			if ( p_VIPLevel[ killerid ] && !isnull( p_DeathMessage[ killerid ] ) ) {
    			GameTextForPlayer( playerid, p_DeathMessage[ killerid ], 4000, 6 );
			}
		}

		if ( p_Class[ killerid ] == CLASS_POLICE )
	    {
	        if ( p_Class[ killerid ] == p_Class[ playerid ] ) {
	            // SendClientMessageToAdmins( -1, ""COL_PINK"[FAKE-KILL]{FFFFFF} Traces of fake-kill have came from %s: "COL_GREY"%s", ReturnPlayerName( playerid ), ReturnPlayerIP( playerid ) );
	            // KickPlayerTimed( playerid );
	            SendClientMessageFormatted( killerid, -1, ""COL_BLUE"[INNOCENT KILL]{FFFFFF} You have killed a team mate %s, you have lost 2 score and "COL_GOLD"$10,000{FFFFFF}.", ReturnPlayerName( playerid ) );
				GivePlayerCash( killerid, -10000 );
				GivePlayerScore( killerid, -2 );
				JailPlayer( killerid, 200, 1 );
				cmd_rules( killerid, "" );
				WarnPlayerClass( killerid, p_inArmy{ killerid } );
				SendGlobalMessage( -1, ""COL_GOLD"[JAIL]{FFFFFF} %s(%d) has been sent to jail for 200 seconds by the server "COL_GREEN"[REASON: Killing Teammate(s)]", ReturnPlayerName( killerid ), killerid );
				return 1;
			}
			else
			{
				if ( !DeathSpam{ playerid } ) // If the player doesn't even have a death-spam count.
				{
					if ( !IsPlayerInEvent( killerid ) ) // Allow in event
					{
					    if ( p_WantedLevel[ playerid ] > 5 )
						{
					        new cashEarned = ( p_WantedLevel[ playerid ] < MAX_WANTED_LVL ? p_WantedLevel[ playerid ] : MAX_WANTED_LVL ) * ( reason == 38 ? 170 : 270 );
					        GivePlayerCash( killerid, cashEarned );
					        GivePlayerScore( killerid, 2 );
					        if ( cashEarned > 20000 ) printf("[police kill] %s -> %s - %s", ReturnPlayerName( killerid ), ReturnPlayerName( playerid ), ConvertPrice( cashEarned ) ); // 8hska7082bmahu
					       	if ( p_WantedLevel[ playerid ] > 64 ) SendGlobalMessage( -1, ""COL_GOLD"[POLICE KILL]{FFFFFF} %s(%d) has %s %s(%d) who had a wanted level of %d!", ReturnPlayerName( killerid ), killerid, killedWords[ random( sizeof( killedWords ) ) ], ReturnPlayerName( playerid ), playerid, p_WantedLevel[ playerid ] );
					    	SendClientMessageFormatted( killerid, -1, ""COL_GOLD"[ACHIEVE]{FFFFFF} You have killed %s(%d) with a wanted level of %d; earning you "COL_GOLD"%s{FFFFFF} and 2 score!", ReturnPlayerName( playerid ), playerid, p_WantedLevel[ playerid ], ConvertPrice( cashEarned ) );
					    }
					    else
					    {
					        if ( p_WantedLevel[ playerid ] <= 0 ) {
								SendClientMessageFormatted( killerid, -1, ""COL_BLUE"[INNOCENT KILL]{FFFFFF} You have killed innocent %s, you have lost 2 score and "COL_GOLD"$10,000{FFFFFF}.", ReturnPlayerName( playerid ) );
								GivePlayerCash( killerid, -10000 );
								GivePlayerScore( killerid, -2 );
								JailPlayer( killerid, 200, 1 );
								cmd_rules( killerid, "" );
								WarnPlayerClass( killerid, p_inArmy{ killerid } );
								SendGlobalMessage( -1, ""COL_GOLD"[JAIL]{FFFFFF} %s(%d) has been sent to jail for 200 seconds by the server "COL_GREEN"[REASON: Killing Innocent(s)]", ReturnPlayerName( killerid ), killerid );
							}
							else if ( p_WantedLevel[ playerid ] <= 5 ) {
								SendClientMessageFormatted( killerid, -1, ""COL_BLUE"[INNOCENT KILL]{FFFFFF} You have killed low suspect %s, you have lost 2 score and "COL_GOLD"$5,000{FFFFFF}.", ReturnPlayerName( playerid ) );
		                        GivePlayerCash( killerid, -5000 );
								GivePlayerScore( killerid, -2 );
							}
					    }
					}
				}
			}
	    }

		if ( p_Class[ playerid ] == CLASS_POLICE && p_Class[ killerid ] == CLASS_CIVILIAN )
		{
		    new
				szLocation[ MAX_ZONE_NAME ], szCity[ MAX_ZONE_NAME ];

			if ( GetPlayerLocation( killerid, szCity, szLocation ) )
				SendClientMessageToCops( -1, ""COL_BLUE"[POLICE RADIO]"COL_WHITE" %s has murdered %s near %s in %s.", ReturnPlayerName( killerid ), ReturnPlayerName( playerid ), szLocation, szCity );
			else
				SendClientMessageToCops( -1, ""COL_BLUE"[POLICE RADIO]"COL_WHITE" %s has murdered %s.", ReturnPlayerName( killerid ), ReturnPlayerName( playerid ) );

			CreateCrimeReport( killerid );
		}


        if ( p_Class[ killerid ] == CLASS_CIVILIAN && JobEquals( killerid, JOB_HITMAN ) && p_ContractedAmount[ playerid ] > 0 )
		{
			new
				iContractAmount = p_ContractedAmount[ playerid ];

			if ( iContractAmount >= 50000 && GetPlayerScore( killerid ) < 50 )
			{
				SendServerMessage( playerid, "Your contract is incomplete as you have been killed by a player with lower than 50 score." );
				SendError( killerid, "You need at least 50 score to complete contracts above $50,000." );
			}
			else
			{
			    SendGlobalMessage( -1, ""COL_ORANGE"[CONTRACT]"COL_WHITE" %s(%d) has completed the contract on %s(%d), he has earned "COL_GOLD"%s"COL_WHITE".", ReturnPlayerName( killerid ), killerid, ReturnPlayerName( playerid ), playerid, ConvertPrice( iContractAmount ) );
				GivePlayerCash( killerid, iContractAmount );
				p_ContractedAmount[ playerid ] = 0;
			   	switch( ++p_HitsComplete[ killerid ] )
			   	{
			   	    case 5:     ShowAchievement( killerid, "Completed ~r~5~w~~h~~h~ contracts!", 3 );
			   	    case 20:    ShowAchievement( killerid, "Completed ~r~20~w~~h~~h~ contracts!", 6 );
			   	    case 50:    ShowAchievement( killerid, "Completed ~r~50~w~~h~~h~ contracts!", 9 );
			   	    case 100:   ShowAchievement( killerid, "Completed ~r~100~w~~h~~h~ contracts!", 12 );
			   	    case 200:   ShowAchievement( killerid, "Completed ~r~200~w~~h~~h~ contracts!", 15 );
			   	    case 500:   ShowAchievement( killerid, "Completed ~r~500~w~~h~~h~ contracts!", 18 );
			   	    case 1000:  ShowAchievement( killerid, "Completed ~r~1000~w~~h~~h~ contracts!", 25 );
				}
			}
		}

		if ( p_Class[ killerid ] != CLASS_POLICE ) GivePlayerWantedLevel( killerid, 12 ), GivePlayerScore( killerid, 1, .multiplier = 0.2 );
	}
	else if ( IsPlayerNPC( killerid ) ) SendDeathMessage( killerid, playerid, reason );
	else
	{
		DCC_SendChannelMessageFormatted( discordGeneralChan, "*%s(%d) has committed suicide!*", ReturnPlayerName( playerid ), playerid );
	    SendDeathMessage( INVALID_PLAYER_ID, playerid, 53 );
	    DeletePVar( playerid, "used_cmd_kill" );
	}

	if ( !p_inPaintBall{ playerid } && !p_LeftPaintball{ playerid } && !IsPlayerAdminOnDuty( playerid ) )
	{
		if ( playerGangId != INVALID_GANG_ID )
			SaveGangData( playerGangId ), g_gangData[ playerGangId ] [ E_DEATHS ]++;

		p_Deaths[ playerid ] ++; // Usually other events do nothing
		GivePlayerIrresistiblePoints( playerid, -1 ); // Deduct points, it's meant to be hard!!!
	}

    ClearPlayerWantedLevel( playerid );
	return 1;
}

public OnVehicleSpawn( vehicleid )
{
	KillEveryoneInShamal( vehicleid );
    ResetVehicleBurglaryData( vehicleid );
    ResetVehicleMethlabData( vehicleid, true );

	if ( g_buyableVehicle{ vehicleid } == true )
		RespawnBuyableVehicle( vehicleid );
	return 1;
}

public OnVehicleDeath( vehicleid, killerid )
{
	printf("1.OnVehicleDeath(%d, %d) -> bus vid %d", vehicleid, killerid,g_isBusinessVehicle[ vehicleid ] );
	if ( g_isBusinessVehicle[ vehicleid ] != -1 && Iter_Contains( business, g_isBusinessVehicle[ vehicleid ] ) )
	{
		new
			businessid = g_isBusinessVehicle[ vehicleid ], attackerid = g_VehicleLastAttacker[ vehicleid ],
			payout = floatround( float( g_businessData[ businessid ] [ E_EXPORT_VALUE ] * ( MAX_DROPS - g_businessData[ businessid ] [ E_EXPORTED_AMOUNT ] ) ) * ( p_Class[ killerid ] == CLASS_POLICE ? 0.3 : 0.25 ) )
		;

		if ( g_businessData[ businessid ] [ E_EXPORT_STARTED ] == 1 )
		{
			printf("2.is associate %d, ticks %d", IsBusinessAssociate( attackerid, businessid ), g_iTime - g_VehicleLastAttacked[ vehicleid ] );
			if ( IsPlayerConnected( attackerid ) && ! IsBusinessAssociate( attackerid, businessid ) && ( g_iTime - g_VehicleLastAttacked[ vehicleid ] ) < 8 )
			{
				GivePlayerScore( attackerid, 2 );
				GivePlayerCash( attackerid, payout );
				if ( p_Class[ attackerid ] != CLASS_POLICE ) GivePlayerWantedLevel( attackerid, 6 );
				SendGlobalMessage( -1, ""COL_GREY"[BUSINESS]"COL_WHITE" %s(%d) has destroyed a business vehicle and earned "COL_GOLD"%s"COL_WHITE"!", ReturnPlayerName( attackerid ), attackerid, ConvertPrice( payout ) );
			}
			else
			{
				if ( IsPlayerConnected( killerid ) ) {
					if ( IsBusinessAssociate( killerid, businessid ) ) SendGlobalMessage( -1, ""COL_GREY"[BUSINESS]"COL_WHITE" %s(%d)'s business vehicle with "COL_GOLD"%s"COL_WHITE" in inventory got destroyed!", ReturnPlayerName( killerid ), killerid, ConvertPrice( g_businessData[ businessid ] [ E_EXPORT_VALUE ] * ( MAX_DROPS - g_businessData[ businessid ] [ E_EXPORTED_AMOUNT ] ) ) );
					else
					{
						GivePlayerScore( killerid, 2 );
						GivePlayerCash( killerid, payout );
						if ( p_Class[ killerid ] != CLASS_POLICE ) GivePlayerWantedLevel( killerid, 6 );
						SendGlobalMessage( -1, ""COL_GREY"[BUSINESS]"COL_WHITE" %s(%d) has destroyed a business vehicle and earned "COL_GOLD"%s"COL_WHITE"!", ReturnPlayerName( killerid ), killerid, ConvertPrice( payout ) );
					}
				}
			}

			// stop the mission
			StopBusinessExportMission( businessid );
		}
	}


    ResetVehicleBurglaryData( vehicleid );
    KillEveryoneInShamal( vehicleid );
    ResetVehicleMethlabData( vehicleid, true );
	return 1;
}

public OnPlayerUnjailed( playerid, reasonid )
{
	switch( reasonid )
	{
		case 0: SendGlobalMessage( -1, ""COL_GOLD"[JAIL]{FFFFFF} %s(%d) has been released from jail "COL_GREEN"[Served his time]", ReturnPlayerName( playerid ), playerid );
		case 1: SendGlobalMessage( -1, ""COL_GOLD"[JAIL]{FFFFFF} %s(%d) has been released from jail "COL_BLUE"[Paid his bail]", ReturnPlayerName( playerid ), playerid );
		case 2: SendGlobalMessage( -1, ""COL_GOLD"[JAIL]{FFFFFF} %s(%d) has been released from jail "COL_GREEN"[Melted the metal and escaped!]", ReturnPlayerName( playerid ), playerid );
		//case 4: SendGlobalMessage( -1, ""COL_GOLD"[JAIL]{FFFFFF} %s(%d) has been released from jail "COL_GREY"[Busted Out!]", ReturnPlayerName( playerid ), playerid );
	}

    if ( reasonid != 5 )
    {
    	SetPlayerVirtualWorld( playerid, 30 );
		TogglePlayerControllable( playerid, 0 );
		SetTimerEx( "ope_Unfreeze", 3000, false, "d", playerid );
    }

    if ( reasonid < 4 )
   	{
   		SetPlayerHealth( playerid, 100.0 );
   		if ( p_inAlcatraz{ playerid } )
   		{
   			SetPlayerPosEx( playerid, -2038.38, 1833.896, 21.934200, 0 );
   			SetPVarInt( playerid, "AlcatrazWantedCD", g_iTime + ALCATRAZ_TIME_WANTED );
   			SetPlayerVirtualWorld( playerid, 0 );
   		}
   		else
   		{
	   		switch( GetPlayerInterior( playerid ) )
	   		{
	   			case 3:	 SetPlayerPosEx( playerid, 202.2303, 168.4880, 1003.0234, 3 );
	   			case 6:  SetPlayerPosEx( playerid, 266.5086, 90.97350, 1001.0391, 6 );
	   			default: SetPlayerPosEx( playerid, 216.7583, 120.1729, 999.0156, 10 );
	   		}
   		}
	}

    PlainUnjailPlayer 		( playerid );
	SetPlayerColorToTeam	( playerid );
    ClearPlayerWantedLevel	( playerid );
	return 1;
}

public OnPlayerText( playerid, text[ ] )
{
	new
		time = g_iTime;

#if ENABLED_SECURE_TRUCK == true
	if ( IsPlayerSecurityDriver( playerid ) ) {
		if ( strmatch( text, "End Security Guard" ) ) {
			restartSecurityGuardProcess( );
			return 0;
		}
		return 1;
	}
#endif

	if ( GetPlayerScore( playerid ) < 10 )
		return SendServerMessage( playerid, "You need at least 10 score to talk. "COL_GREY"Use /ask or /report to talk to an admin in the meanwhile." ), 0;

	if ( !p_PlayerLogged{ playerid } )
		return SendError( playerid, "You must be logged in to talk." ), 0;

#if !defined DEBUG_MODE
	GetServerVarAsString( "rcon_password", szNormalString, sizeof( szNormalString ) ); // Anti-rcon spam poop
	if ( strfind( text, szNormalString, true ) != -1 )
	    return SendError( playerid, "An error occured, please try again." ), 0;
#endif

	if ( textContainsIP( text ) )
		return SendServerMessage( playerid, "Please do not advertise." ), 0;

	if ( !hasTickcountPassed( p_AntiTextSpam[ playerid ], 750 ) )
	{
		p_AntiTextSpam[ playerid ] = GetTickCount( );
	    p_AntiTextSpamCount{ playerid } ++;
	 	SendError( playerid, "You must wait 0.75 seconds before posting again. "COL_GREY"[%d/3]", p_AntiTextSpamCount{ playerid } );

	 	if ( p_AntiTextSpamCount{ playerid } >= 3 ) {
			SendServerMessage( playerid, "You have been kicked for chat flooding. Please refrain from flooding the chat." );
			KickPlayerTimed( playerid );
		}
		return 0;
	}

	if ( GetPVarString( playerid, "last_message", szNormalString, sizeof( szNormalString ) ) && strmatch( szNormalString, text ) )
		return SendError( playerid, "You cannot repeat the same phrase." ), 0;

	SetPVarString( playerid, "last_message", text );

	p_AntiTextSpamCount{ playerid } = 0;
	p_AntiTextSpam[ playerid ] = GetTickCount( );

	if ( p_Muted{ playerid } )
	{
	 	if ( time > p_MutedTime[ playerid ] ) p_Muted{ playerid } = false;
		else
		{
		    SendError( playerid, "You cannot speak as you are muted for %s.", secondstotime( p_MutedTime[ playerid ] - time ) );
			return 0;
		}
	}

	if ( !p_PlayerSettings[ playerid ] { SETTING_CHAT_PREFIXES } )
	{
		switch( text[ 0 ] )
		{
		    case '!':
			{
			    if ( p_Class[ playerid ] == CLASS_POLICE )
				{
				    format( szBigString, 144, "%s", text );
				    for( new i; i < sizeof( g_coptenCodes ); i++ ) {
			        	if ( strfind( szBigString, g_coptenCodes[ i ] [ E_CODE ] ) != -1 ) {
							strreplace( szBigString, g_coptenCodes[ i ] [ E_CODE ], g_coptenCodes[ i ] [ E_SUBJECT ] );
						}
					}
				    SendClientMessageToCops( -1, ""COL_BLUE"<Police Radio> %s(%d):"COL_WHITE" %s", ReturnPlayerName( playerid ), playerid, szBigString[ 1 ] );
				    return 0;
				}

				else if ( p_Class[ playerid ] == CLASS_FIREMAN )
				{
				    SendClientMessageToFireman( -1, "{A83434}<Fireman Radio> %s(%d):"COL_WHITE" %s", ReturnPlayerName( playerid ), playerid, text[ 1 ] );
				    return 0;
				}

				else if ( p_Class[ playerid ] == CLASS_MEDIC )
				{
				    SendClientMessageToAmbulance( -1, "{00CC00}<Paramedic Radio> %s(%d):"COL_WHITE" %s", ReturnPlayerName( playerid ), playerid, text[ 1 ] );
				    return 0;
				}

				else if ( p_Class[ playerid ] == CLASS_CIVILIAN && p_GangID[ playerid ] != INVALID_GANG_ID )
				{
			        SendClientMessageToGang( p_GangID[ playerid ], g_gangData[ p_GangID[ playerid ] ] [ E_COLOR ], "<Gang Chat> %s(%d):{FFFFFF} %s", ReturnPlayerName( playerid ), playerid, text[ 1 ] );
					return 0;
				}
			}
			case '@':
			{
				if ( p_AdminLevel[ playerid ] > 0 )
				{
					SendClientMessageToAdmins( -1, ""COL_PINK"<Admin Chat> %s(%d):"COL_GREY" %s", ReturnPlayerName( playerid ), playerid, text[ 1 ] );
				    return 0;
				}
			}
			case '#':
			{
			    if ( p_VIPLevel[ playerid ] > 0 )
			    {
					DCC_SendChannelMessageFormatted( discordGeneralChan, "__**(VIP) %s(%d):**__ %s", ReturnPlayerName( playerid ), playerid, text[ 1 ] );
					SendClientMessageToAllFormatted( 0x3eff3eff, "[VIP] %s(%d):{9ec34f} %s", ReturnPlayerName( playerid ), playerid, text[ 1 ] );
			        return 0;
			    }
			}
			case '$':
			{
			    if ( p_VIPLevel[ playerid ] > 0 )
			    {
					SendClientMessageToVips( -1, ""COL_GOLD"<VIP Chat> %s(%d):"COL_GREY" %s", ReturnPlayerName( playerid ), playerid, text[ 1 ] );
				    return 0;
			    }
			}
		}
	}
	DCC_SendChannelMessageFormatted( discordGeneralChan, "**%s(%d):** %s", ReturnPlayerName( playerid ), playerid, text ); // p_Class[ playerid ] == CLASS_POLICE ? 12 : 4
	return 1;
}

function Untaze( playerid )
{
	if ( !IsPlayerConnected( playerid ) || p_Detained{ playerid } == true || !p_Tazed{ playerid } )
	    return 0;

	if ( !IsPlayerTied( playerid ) )
		TogglePlayerControllable( playerid, 1 );

	ClearAnimations( playerid );
	p_BulletInvulnerbility[ playerid ] = g_iTime + 3;
	p_Tazed{ playerid } = false;
	return 1;
}

function Uncuff( playerid )
{
	if ( !IsPlayerConnected( playerid ) || !IsPlayerCuffed( playerid ) || !IsPlayerAttachedObjectSlotUsed( playerid, 2 ) )
	    return 0;

	TogglePlayerControllable( playerid, 1 );
 	RemovePlayerAttachedObject( playerid, 2 );
	SetPlayerSpecialAction( playerid, SPECIAL_ACTION_NONE );
	if ( !IsPlayerInAnyVehicle( playerid ) ) {
		ClearAnimations( playerid );
	}
	p_Cuffed{ playerid } = false;
	p_Detained{ playerid } = false;
	Delete3DTextLabel( p_DetainedLabel[ playerid ] );
	p_DetainedLabel[ playerid ] = Text3D: INVALID_3DTEXT_ID;
	p_DetainedBy[ playerid ] = INVALID_PLAYER_ID;
	p_BulletInvulnerbility[ playerid ] = g_iTime + 5;

   	SendGlobalMessage( -1, ""COL_GREY"[SERVER]{FFFFFF} %s(%d) has been uncuffed and undetained by the anti-abuse system.", ReturnPlayerName( playerid ), playerid );
	return 1;
}

function RapeDamage( playerid )
{
	if ( !IsPlayerConnected( playerid ) || !IsPlayerSpawned( playerid ) || p_InfectedHIV{ playerid } == false || p_Jailed{ playerid } == true )
		return 0;

	new Float: Health;

	if ( !IsPlayerTied( playerid ) || !IsPlayerTazed( playerid ) || !p_pausedToLoad{ playerid } )
	{
	    GetPlayerHealth( playerid, Health );
	  	SetPlayerHealth( playerid, ( Health - 5.0 ) );
	}

	return SetTimerEx( "RapeDamage", 5000, false, "d", playerid );
}

function circleall_Countdown( time, countdown_cmd )
{
	static string[ 6 ];
	if ( time <= 0 )
	{
	    GameTextForAll( "~g~GO!", 2000, 3 );
	    g_circleall_CD = false;
	    foreach(new i : Player) {
			PlayerPlaySound( i, 1057, 0.0, 0.0, 0.0 );
			if ( !countdown_cmd ) TogglePlayerControllable( i, 1 );
		}
	}
	else
	{
	    format( string, sizeof( string ), "~y~%d", time );
		GameTextForAll( string, 2000, 3 );
	    foreach(new i : Player) { PlayerPlaySound( i, 1056, 0.0, 0.0, 0.0 ); }
		SetTimerEx( "circleall_Countdown", 960, false, "dd", time - 1, countdown_cmd );
	}
}

function BlowJob( playerid, pID, step )
{
	switch( step )
	{
	    case 0:
	    {
			ApplyAnimation( pID, "BLOWJOBZ", "BJ_STAND_LOOP_P", 2.0, 1, 1, 1, 0, 0, 1 );
			ApplyAnimation( playerid, "BLOWJOBZ", "BJ_STAND_LOOP_W", 2.0, 1, 1, 1, 0, 0, 1 );
            SetTimerEx( "BlowJob", 10000, false, "ddd", playerid, pID, 1 );
	    }
	    case 1:
	    {
			ApplyAnimation( pID, "BLOWJOBZ", "BJ_STAND_END_P", 2.0, 0, 1, 1, 0, 0, 1 );
			ApplyAnimation( playerid, "BLOWJOBZ", "BJ_STAND_END_W", 2.0, 1, 1, 1, 0, 0, 1 );
            SetTimerEx( "BlowJob", 2500, false, "ddd", playerid, pID, 2 );
	    }
	    case 2:
	    {
			TogglePlayerControllable( playerid, 1 );
			TogglePlayerControllable( pID, 1 );
	        ClearAnimations( playerid ), SetCameraBehindPlayer( playerid );
	        ClearAnimations( pID ), SetCameraBehindPlayer( pID );
			p_GivingBlowjob{ playerid } = false;
			p_GivingBlowjob{ pID } = false;
			p_GettingBlowjob{ pID } = false;
			p_GettingBlowjob{ playerid } = false;
	    }
	}
}

stock UntiePlayer( playerid )
{
	if ( !IsPlayerConnected( playerid ) || ( !p_Tied{ playerid } && !p_Kidnapped{ playerid } ) )
	    return;

	TogglePlayerControllable( playerid, 1 );
	p_Tied{ playerid } = false;
	p_Kidnapped{ playerid } = false;
	Delete3DTextLabel( p_TiedLabel[ playerid ] );
	p_TiedLabel[ playerid ] = Text3D: INVALID_3DTEXT_ID;
	p_BulletInvulnerbility[ playerid ] = g_iTime + 5;
	SendGlobalMessage( -1, ""COL_GREY"[SERVER]{FFFFFF} %s(%d) has been untied by the anti-abuse system.", ReturnPlayerName( playerid ), playerid );
}

function emp_deactivate( vehicleid )
{
	if ( !IsValidVehicle( vehicleid ) ) return 0;
	GetVehicleParamsEx( vehicleid, engine, lights, alarm, doors, bonnet, boot, objective );
	SetVehicleParamsEx( vehicleid, VEHICLE_PARAMS_ON, lights, alarm, doors, bonnet, boot, objective );
	return 1;
}

function OnPlayerFireDistanceUpdate( playerid )
{
    new
	    Float: X, Float: Y, Float: Z, Float: dis,
		szFire1[ 128 ], szFire2[ 128 ]
	;

	for( new i; i < sizeof( g_fireData ); i++ )
	{
	    GetDynamicObjectPos( g_fireData[ i ] [ E_OBJECT ], X, Y, Z );
	    dis = GetPlayerDistanceFromPoint( playerid, X, Y, Z );
	    if ( i < floatround( sizeof( g_fireData ) / 2 ) )
	    {
		    if ( g_fireData[ i ] [ E_CREATED ] == false ) format( szFire1, sizeof( szFire1 ), "%s~r~FIRE %d:%s ~g~Stopped~n~", szFire1, i,i==1?(" "):("") );
			else format( szFire1, sizeof( szFire1 ), "%s~r~FIRE %d:%s~w~ %0.0f m~n~", szFire1, i,i==1?("_"):(""), dis );
		}
		else
		{
		    if ( g_fireData[ i ] [ E_CREATED ] == false ) format( szFire2, sizeof( szFire2 ), "%s~r~FIRE %d:%s ~g~Stopped~n~", szFire2, i,i==1?(" "):("") );
			else format( szFire2, sizeof( szFire2 ), "%s~r~FIRE %d:%s~w~ %0.0f m~n~", szFire2, i,i==1?("_"):(""), dis );
		}
	}
	TextDrawSetString( p_FireDistance1[ playerid ], szFire1 );
	TextDrawSetString( p_FireDistance2[ playerid ], szFire2 );
	TextDrawShowForPlayer( playerid, p_FireDistance1[ playerid ] );
	TextDrawShowForPlayer( playerid, p_FireDistance2[ playerid ] );
	return 1;
}

public OnPlayerLeaveGang( playerid, gangid, reason )
{
	switch( reason )
	{
	    case GANG_LEAVE_KICK:
	    	SendClientMessageToGang( gangid, g_gangData[ gangid ] [ E_COLOR ], "[GANG]{FFFFFF} %s(%d) has left the gang (KICKED)", ReturnPlayerName( playerid ), playerid );

	    case GANG_LEAVE_QUIT:
	    	SendClientMessageToGang( gangid, g_gangData[ gangid ] [ E_COLOR ], "[GANG]{FFFFFF} %s(%d) has left the gang (LEFT)", ReturnPlayerName( playerid ), playerid );

	    case GANG_LEAVE_UNKNOWN:
	    	SendClientMessageToGang( gangid, g_gangData[ gangid ] [ E_COLOR ], "[GANG]{FFFFFF} %s(%d) has left the gang (UNKNOWN)", ReturnPlayerName( playerid ), playerid );
	}
	return 1;
}

public OnPlayerProgressUpdate( playerid, progressid, params )
{
	static
		Float: X, Float: Y, Float: Z, bool: canceled;

	canceled = p_CancelProgress{ playerid };
	p_CancelProgress{ playerid } = false;

	if ( progressid == PROGRESS_CRACKING || progressid == PROGRESS_BRUTEFORCE ) {
        if ( !IsPlayerSpawned( playerid ) || !IsPlayerInDynamicCP( playerid, g_houseData[ p_HouseCrackingPW[ playerid ] ] [ E_CHECKPOINT ] [ 0 ] ) || !IsPlayerConnected( playerid ) || IsPlayerInAnyVehicle( playerid ) || canceled )
        	return g_houseData[ p_HouseCrackingPW[ playerid ] ] [ E_BEING_CRACKED ] = false, StopProgressBar( playerid ), 1;
	}
	if ( progressid == PROGRESS_MINING )
	{
		new m = p_MiningOre{ playerid };
		GetDynamicObjectPos( g_miningData[ m ] [ E_OBJECT ], X, Y, Z );

		if ( !IsPlayerSpawned( playerid ) || !IsPlayerInRangeOfPoint( playerid, 3.0, X, Y, Z ) || !IsPlayerConnected( playerid ) || IsPlayerInAnyVehicle( playerid ) || canceled )
			return g_miningData[ m ] [ E_MINING ] = INVALID_PLAYER_ID, p_isMining{ playerid } = false, StopProgressBar( playerid ), 1;
	}
	if ( progressid == PROGRESS_ROBBING || progressid == PROGRESS_SAFEPICK )
	{
		new
			Float: distance = distanceFromSafe( playerid, params );

		new abort = ( !IsPlayerSpawned( playerid ) || !IsPlayerConnected( playerid ) || IsPlayerTied( playerid ) || IsPlayerInAnyVehicle( playerid ) || GetPlayerState( playerid ) == PLAYER_STATE_WASTED || IsPlayerAFK( playerid ) || params == -1 || distance > 1.5 || distance < 0.0 || canceled );

		if ( g_Debugging )
		{
			//SendClientMessageFormatted( playerid, COLOR_YELLOW, "distance: %f, params: %d, player: %d, jacked: %d", distance, params, p_UsingRobberySafe	[ playerid ], g_robberyData[ params ] [ E_STATE ] );
			new robberyid = params; printf("[DEBUG] [ROBBERY] [%d] Robbing/Picking [progress : %d, distance : %f, abort : %d] { open : %d, robbed : %d, c4: %d, drill : %d, dplacer : %d, deffect : %d, replenish : %d, raw ts : %d, current ts : %d, name : %s, velocity : %f, state : %d }",
				robberyid, progressid, distance, abort,
				g_robberyData[ robberyid ] [ E_OPEN ], g_robberyData[ robberyid ] [ E_ROBBED ], g_robberyData[ robberyid ] [ E_C4 ],
				g_robberyData[ robberyid ] [ E_DRILL ], g_robberyData[ robberyid ] [ E_DRILL_PLACER ], g_robberyData[ robberyid ] [ E_DRILL_EFFECT ], g_robberyData[ robberyid ] [ E_ROB_TIME ] - g_iTime,
				g_robberyData[ robberyid ] [ E_ROB_TIME ], g_iTime, g_robberyData[ robberyid ] [ E_NAME ], g_robberyData[ robberyid ] [ E_VELOCITY ], g_robberyData[ robberyid ] [ E_STATE ] );
		}

		if ( abort )
		{
			RemovePlayerAttachedObject( playerid, 0 );
			g_robberyData 		[ params ] [ E_STATE ] = STATE_NONE;
			p_UsingRobberySafe	[ playerid ] = -1;
			return StopProgressBar( playerid ), 1;
		}
	}
	if ( progressid == PROGRESS_CHEMICAL || progressid == PROGRESS_GRAB_METH )
	{
		if ( !IsPlayerInRangeOfPoint( playerid, 2.0, 1476.0264, 1463.6255, 1011.8170 ) || !IsPlayerInMethlab( playerid ) || canceled )
			return DeletePVar( playerid, "pouring_chemical" ), StopProgressBar( playerid ), 1;
	}
#if ENABLED_SECURE_TRUCK == true
	if ( progressid == PROGRESS_ROBTRUCK )
	{
		static Float: Angle;
		GetVehiclePos( g_secureTruckVehicle, X, Y, Z );
		GetVehicleZAngle( g_secureTruckVehicle, Angle );
		X += ( SECURE_TRUCK_DISTANCE * floatsin( -Angle + 180, degrees ) );
		Y += ( SECURE_TRUCK_DISTANCE * floatcos( -Angle + 180, degrees ) );

		if ( !IsPlayerInRangeOfPoint( playerid, SECURE_TRUCK_RADIUS, X, Y, Z ) || !IsPlayerSpawned( playerid ) || !IsPlayerConnected( playerid ) || IsPlayerInAnyVehicle( playerid ) || GetPlayerState( playerid ) == PLAYER_STATE_WASTED || canceled )
		{
			g_secureTruckData[ E_BEING_ROBBED ] = false;
			StopProgressBar( playerid );
			return 1;
		}
	}
#endif
	return 1;
}

public OnPlayerProgressComplete( playerid, progressid, params )
{
	static
	    iRandom, Float: X, Float: Y, Float: Z;

	switch( progressid )
	{
		case PROGRESS_MINING:
		{
			new
				m = p_MiningOre{ playerid };

			iRandom = random( 101 );

			p_isMining{ playerid } = false;
			g_miningData[ m ] [ E_MINING ] = INVALID_PLAYER_ID;

			if ( ( g_miningData[ m ] [ E_ORE ] == ORE_IRON && iRandom > 80 ) ||
				( g_miningData[ m ] [ E_ORE ] == ORE_BAUXITE && iRandom > 85 ) ||
				( g_miningData[ m ] [ E_ORE ] == ORE_GOLD && iRandom > 45 ) ||
				( g_miningData[ m ] [ E_ORE ] == ORE_COAL && iRandom > 90 ||
				( g_miningData[ m ] [ E_ORE ] == ORE_DIAMOND && iRandom > 30 ) ||
				( g_miningData[ m ] [ E_ORE ] == ORE_RUBY && iRandom > 35 ) ||
				( g_miningData[ m ] [ E_ORE ] == ORE_SAPHHIRE && iRandom > 30 ) ||
				( g_miningData[ m ] [ E_ORE ] == ORE_EMERALD && iRandom > 52 ) ||
				( g_miningData[ m ] [ E_ORE ] == ORE_PLATINUM && iRandom > 25 ) ||
				( g_miningData[ m ] [ E_ORE ] == ORE_AMETHYST && iRandom > 75 ) )
			)	return SendError( playerid, "Yuck. You received mud instead of an ore." );

			if ( GetPVarInt( playerid, "give_ore_score" ) < g_iTime ) GivePlayerScore( playerid, 1 ), SetPVarInt( playerid, "give_ore_score", g_iTime + 15 );
			g_miningData[ m ] [ E_ORES ] --;

			format( szNormalString, 14, "%s\n%d/%d", getOreName( g_miningData[ m ] [ E_ORE ] ), g_miningData[ m ] [ E_ORES ], g_miningData[ m ] [ E_MAX_ORES ] );
			UpdateDynamic3DTextLabelText( g_miningData[ m ] [ E_LABEL ], g_miningData[ m ] [ E_COLOR ], szNormalString );
			SendServerMessage( playerid, "Great you've mined an ore, now store it in a "COL_GREY"Dune"COL_WHITE"." );

			SetPVarInt( playerid, "carrying_ore", m );
			SetPlayerSpecialAction( playerid, SPECIAL_ACTION_CARRY );
			SetPlayerAttachedObject( playerid, 4, 2936, 5, 0.000000, 0.197999, 0.133999, 113.099983, -153.799987, 57.300003, 0.631000, 0.597000, 0.659999 );
		}
		case PROGRESS_BRUTEFORCE:
		{
		   	g_houseData[ p_HouseCrackingPW[ playerid ] ] [ E_BEING_CRACKED ] = false;
			g_houseData[ p_HouseCrackingPW[ playerid ] ] [ E_CRACKED_WAIT ] = g_iTime + 30;
	        iRandom = random( 101 );
	        if ( iRandom < 75  )
	        {
				g_houseData[ p_HouseCrackingPW[ playerid ] ] [ E_CRACKED ] = true;
			   	g_houseData[ p_HouseCrackingPW[ playerid ] ] [ E_CRACKED_TS ] = g_iTime + 60;
				SendServerMessage( playerid, "You have successfully brute forced this houses' password. This lasts for one minute." );
	        }
	        else SendServerMessage( playerid, "You have failed to brute force this houses' password." );
		}
		case PROGRESS_CRACKING:
		{
		   	g_houseData[ p_HouseCrackingPW[ playerid ] ] [ E_BEING_CRACKED ] = false;
			g_houseData[ p_HouseCrackingPW[ playerid ] ] [ E_CRACKED_WAIT ] = g_iTime + 300;
	        iRandom = random( 101 );
			if ( iRandom < 75 )
			{
				g_houseData[ p_HouseCrackingPW[ playerid ] ] [ E_CRACKED ] = true;
			   	g_houseData[ p_HouseCrackingPW[ playerid ] ] [ E_CRACKED_TS ] = g_iTime + 120;
				SendServerMessage( playerid, "You have successfully cracked this houses' password. You have two minutes to do your thing." );
				GivePlayerWantedLevel( playerid, 12 );
				GivePlayerScore( playerid, 2 );
				// Achievement Data
				p_Burglaries[ playerid ] ++;
			   	switch( p_Burglaries[ playerid ] )
			   	{
			   	    case 5:     ShowAchievement( playerid, "Commited ~r~5~w~~h~~h~ burglaries!", 3 );
			   	    case 20:    ShowAchievement( playerid, "Commited ~r~20~w~~h~~h~ burglaries!", 6 );
			   	    case 50:    ShowAchievement( playerid, "Commited ~r~50~w~~h~~h~ burglaries!", 9 );
			   	    case 100:   ShowAchievement( playerid, "Commited ~r~100~w~~h~~h~ burglaries!", 12 );
			   	    case 200:   ShowAchievement( playerid, "Commited ~r~200~w~~h~~h~ burglaries!", 15 );
			   	    case 500:   ShowAchievement( playerid, "Commited ~r~500~w~~h~~h~ burglaries!", 18 );
			   	    case 1000:  ShowAchievement( playerid, "Commited ~r~1000~w~~h~~h~ burglaries!", 25 );
				}
			}
			else
			{
				new szLocation[ MAX_ZONE_NAME ];
				GetZoneFromCoordinates( szLocation, g_houseData[ p_HouseCrackingPW[ playerid ] ] [ E_EX ], g_houseData[ p_HouseCrackingPW[ playerid ] ] [ E_EY ], g_houseData[ p_HouseCrackingPW[ playerid ] ] [ E_EZ ] );
				SendClientMessageToCops( -1, ""COL_BLUE"[BURGLARY]"COL_WHITE" %s has failed to crack a houses' password near %s.", ReturnPlayerName( playerid ), szLocation );
				SendClientMessage( playerid, -1, ""COL_GREY"[SERVER]"COL_WHITE" You have failed to crack this houses' password." );
				GivePlayerWantedLevel( playerid, 6 );
				CreateCrimeReport( playerid );
			}
		}
		case PROGRESS_ROBBING:
		{
			new
				robberyid = params,//p_UsingRobberySafe[ playerid ],
				Float: distance = distanceFromSafe( playerid, robberyid )
			;

			if ( robberyid != -1 && distance < 2.5 || distance > 0.0 )
			{
				if ( IsValidDynamicObject( g_robberyData[ robberyid ] [ E_SAFE_MONEY ] ) )
				{
			        if ( g_robberyData[ robberyid ] [ E_STATE ] != STATE_ROBBED ) return SendError( playerid, "This safe can no longer be robbed." );
			        else
			        {
					    static
							szLocation[ MAX_ZONE_NAME ], szCity[ MAX_ZONE_NAME ]
						;

						ClearAnimations 	( playerid );
			        	g_robberyData 		[ robberyid ] [ E_STATE ] = STATE_NONE;
	    				p_UsingRobberySafe 	[ playerid ] = -1;

						if ( IsPlayerConnected( playerid ) && p_MoneyBag{ playerid } == true ) g_robberyData[ robberyid ] [ E_SAFE_LOOT ] *= 2;

						if ( GetPlayerInterior( playerid ) != 0 )
						{
							new id = p_LastEnteredEntrance[ playerid ];
						    if ( id == -1 )
						  	{
						    	SendServerMessage( playerid, "You've been kicked due to suspected teleport hacking." );
						    	KickPlayerTimed( playerid );
						    	return 1;
						    }

						    Get2DCity( szCity, g_entranceData[ id ] [ E_EX ], g_entranceData[ id ] [ E_EY ], g_entranceData[ id ] [ E_EZ ] );
						    GetZoneFromCoordinates( szLocation, g_entranceData[ id ] [ E_EX ], g_entranceData[ id ] [ E_EY ], g_entranceData[ id ] [ E_EZ ] );
						    if ( !strmatch( szCity, "San Fierro" ) && !strmatch( szCity, "Las Venturas" ) && !strmatch( szCity, "Los Santos" ) ) g_robberyData[ robberyid ] [ E_SAFE_LOOT ] /= 2; // Halve Profit outside SF, LV & LS
							//if ( strmatch( szCity, "Las Venturas" ) || strmatch( szCity, "Los Santos" ) ) g_robberyData[ robberyid ] [ E_SAFE_LOOT ] = floatround( g_robberyData[ robberyid ] [ E_SAFE_LOOT ] * 0.75 ); // Remove 25%
							SendGlobalMessage( -1, ""COL_GOLD"[ROBBERY]"COL_WHITE" %s(%d) has robbed "COL_GOLD"%s"COL_WHITE" from %s near %s in %s!", ReturnPlayerName( playerid ), playerid, ConvertPrice( g_robberyData[ robberyid ] [ E_SAFE_LOOT ] ), g_robberyData[ robberyid ] [ E_NAME ], szLocation, szCity );
						}
						else
						{
							GetPlayerPos( playerid, X, Y, Z );
						    Get2DCity( szCity, X, Y, Z );
						    if ( !strmatch( szCity, "San Fierro" ) && !strmatch( szCity, "Las Venturas" ) && !strmatch( szCity, "Los Santos" ) ) g_robberyData[ robberyid ] [ E_SAFE_LOOT ] /= 2; // Halve Profit outside SF, LV & LS
							//if ( strmatch( szCity, "Las Venturas" ) || strmatch( szCity, "Los Santos" ) ) g_robberyData[ robberyid ] [ E_SAFE_LOOT ] = floatround( g_robberyData[ robberyid ] [ E_SAFE_LOOT ] * 0.75 ); // Remove 25%
							SendGlobalMessage( -1, ""COL_GOLD"[ROBBERY]"COL_WHITE" %s(%d) has robbed "COL_GOLD"%s"COL_WHITE" from %s in %s!", ReturnPlayerName( playerid ), playerid, ConvertPrice( g_robberyData[ robberyid ] [ E_SAFE_LOOT ] ), g_robberyData[ robberyid ] [ E_NAME ], szCity );
						}

						GivePlayerScore( playerid, 2 );
						GivePlayerWantedLevel( playerid, 6 );
			        	SplitPlayerCashForGang( playerid, float( g_robberyData[ robberyid ] [ E_SAFE_LOOT ] ) );
						g_robberyData[ robberyid ] [ E_SAFE_LOOT ] = 0;
						DestroyDynamicObject( g_robberyData[ robberyid ] [ E_SAFE_MONEY ] );
						g_robberyData[ robberyid ] [ E_SAFE_MONEY ] = INVALID_OBJECT_ID;
						g_robberyData[ robberyid ] [ E_ROBBED ] = true;
	    				g_robberyData[ robberyid ] [ E_ROB_TIME ] = g_iTime + MAX_ROBBERY_WAIT;
	           			//SendClientMessageToAdmins(COLOR_ORANGE,"%s(%d) robbed safe %d (%d sec)", ReturnPlayerName( playerid ), playerid, robberyid, g_robberyData[ robberyid ] [ E_ROB_TIME ] - gettime());

						if ( g_Debugging )
						{
							printf("[DEBUG] [ROBBERY] [%d] Store Robbed [progress : %d, distance : %f] { open : %d, robbed : %d, c4: %d, drill : %d, dplacer : %d, deffect : %d, replenish : %d, raw ts : %d, current ts : %d, name : %s, velocity : %f, state : %d }",
								robberyid, progressid, distance,
								g_robberyData[ robberyid ] [ E_OPEN ], g_robberyData[ robberyid ] [ E_ROBBED ], g_robberyData[ robberyid ] [ E_C4 ],
								g_robberyData[ robberyid ] [ E_DRILL ], g_robberyData[ robberyid ] [ E_DRILL_PLACER ], g_robberyData[ robberyid ] [ E_DRILL_EFFECT ], g_robberyData[ robberyid ] [ E_ROB_TIME ] - g_iTime,
								g_robberyData[ robberyid ] [ E_ROB_TIME ], g_iTime, g_robberyData[ robberyid ] [ E_NAME ], g_robberyData[ robberyid ] [ E_VELOCITY ], g_robberyData[ robberyid ] [ E_STATE ] );
						}
						Achievement::HandlePlayerRobbery( playerid );
			        }
				}
			}
		}
		case PROGRESS_SAFEPICK:
		{
			new
				robberyid = p_UsingRobberySafe[ playerid ],
				Float: distance = distanceFromSafe( playerid, robberyid )
			;

			if ( robberyid != -1 && distance < 2.5 || distance > 0.0 )
			{
				if ( !g_robberyData[ robberyid ] [ E_ROBBED ] && !IsValidDynamicObject( g_robberyData[ robberyid ] [ E_SAFE_MONEY ] ) )
				{
					static
						Float: pZ, Float: sZ;

			        if ( g_robberyData[ robberyid ] [ E_STATE ] != STATE_PICKED ) return SendError( playerid, "This safe can no longer be picked." );

			        p_UsingRobberySafe[ playerid ] = -1;
					RemovePlayerAttachedObject( playerid, 0 );
			        SendServerMessage( playerid, "You've opened the safe door." );

			        g_robberyData[ robberyid ] [ E_STATE ] 	  = STATE_NONE;
			        g_robberyData[ robberyid ] [ E_ROBTIMER ] = SetTimerEx( "onSafeBust", 1000, false, "dddd", playerid, robberyid, ROBBERY_TYPE_LABOR, 0 );

					if ( g_Debugging )
					{
						printf("[DEBUG] [ROBBERY] [%d] Safe Picked [progress : %d, distance : %f] { open : %d, robbed : %d, c4: %d, drill : %d, dplacer : %d, deffect : %d, replenish : %d, raw ts : %d, current ts : %d, name : %s, velocity : %f, state : %d }",
							robberyid, progressid, distance,
							g_robberyData[ robberyid ] [ E_OPEN ], g_robberyData[ robberyid ] [ E_ROBBED ], g_robberyData[ robberyid ] [ E_C4 ],
							g_robberyData[ robberyid ] [ E_DRILL ], g_robberyData[ robberyid ] [ E_DRILL_PLACER ], g_robberyData[ robberyid ] [ E_DRILL_EFFECT ], g_robberyData[ robberyid ] [ E_ROB_TIME ] - g_iTime,
							g_robberyData[ robberyid ] [ E_ROB_TIME ], g_iTime, g_robberyData[ robberyid ] [ E_NAME ], g_robberyData[ robberyid ] [ E_VELOCITY ], g_robberyData[ robberyid ] [ E_STATE ] );
					}

	       	 		GetDynamicObjectPos( g_robberyData[ robberyid ] [ E_SAFE ], sZ, sZ, sZ );
					GetPlayerPos( playerid, pZ, pZ, pZ );

	        		if ( sZ < pZ )
						ApplyAnimation( playerid, "ROB_BANK", "CAT_Safe_Open", 4.1, 0, 0, 0, 0, 0, 0 );
				}
			}
		}
		case PROGRESS_CHEMICAL:
		{
			if ( IsPlayerInRangeOfPoint( playerid, 2.0, 1476.0264, 1463.6255, 1011.8170 ) && IsPlayerInMethlab( playerid ) )
			{
				new
					chemical = GetPVarInt( playerid, "pouring_chemical" ),
					vehicleid = GetPlayerMethLabVehicle( playerid )
				;

				DeletePVar( playerid, "pouring_chemical" );

				switch( chemical )
				{
					case CHEMICAL_MU: 	p_MuriaticAcid{ playerid } --,		SetGVarInt( "meth_acid", 0, vehicleid );
					case CHEMICAL_CS: 	p_CausticSoda{ playerid } --,		SetGVarInt( "meth_soda", 0, vehicleid );
					case CHEMICAL_HLC: 	p_HydrogenChloride{ playerid } --,	SetGVarInt( "meth_chloride", 0, vehicleid );
				}

				if ( GetGVarInt( "meth_ingredient", vehicleid ) != chemical )
				{
					DeleteGVar( "meth_ingredient", vehicleid );
					DeleteGVar( "meth_soda", vehicleid );
					DeleteGVar( "meth_acid", vehicleid );
					DeleteGVar( "meth_chloride", vehicleid );
					DeleteGVar( "meth_chef", vehicleid );
					SendServerMessage( playerid, "You have put the whole chemical. The methlab has exploded." );
					GetPlayerPos( playerid, X, Y, Z );
					CreateExplosionForPlayer( playerid, X, Y, Z - 0.75, 0, 10.0 );
					SetPlayerHealth( playerid, -1 );
				}
				else
				{
					SetGVarInt( "meth_chef", playerid, vehicleid );

					SetGVarInt( "meth_smoke", CreateDynamicObject( 18726, 0.0, 0.0, -1000.0, 0.000000, 0.000000, 0.000000 ), vehicleid );
					AttachDynamicObjectToVehicle( GetGVarInt( "meth_smoke", vehicleid ), vehicleid, -0.524999, -0.974999, -0.375000, 0.000000, 0.000000, 0.000000 );

					ShowPlayerHelpDialog( playerid, 5000, "Okay, okay, everything seems to be cooking fine. Wait till for the next chemical to be added." );
	   				if ( !IsPlayerUsingRadio( playerid ) ) PlayAudioStreamForPlayer( playerid, "http://files.irresistiblegaming.com/game_sounds/cooking.mp3", 1476.0394, 1464.3358, 1012.1190, 5.0, 1 );
					SetGVarInt( "meth_cooktimer", SetTimerEx( "OnMethamphetamineCooking", 20000, false, "ddd", playerid, vehicleid, chemical ), vehicleid );
				}
			}
		}
		case PROGRESS_GRAB_METH:
		{
			if ( IsPlayerInRangeOfPoint( playerid, 2.0, 1476.0264, 1463.6255, 1011.8170 ) && IsPlayerInMethlab( playerid ) )
			{
				new
					vehicleid = GetPlayerMethLabVehicle( playerid ),
					objectid = GetGVarInt( "meth_yield", vehicleid )
				;

				if ( !( IsValidDynamicObject( objectid ) && Streamer_GetIntData( STREAMER_TYPE_OBJECT, objectid, E_STREAMER_MODEL_ID ) == 1579 ) )
					return SendError( playerid, "Someone just took the last batch of the meth!" );

				if ( p_Methamphetamine{ playerid } >= 128 )
					return SendError( playerid, "You can only export a maximum of 128 pounds of meth." );
				p_Methamphetamine{ playerid } ++;

				DestroyDynamicObject( GetGVarInt( "meth_yield", vehicleid ) );

				// Reset meth data
				DeleteGVar( "meth_yield", vehicleid );
				DeleteGVar( "meth_ingredient", vehicleid );
				DeleteGVar( "meth_soda", vehicleid );
				DeleteGVar( "meth_acid", vehicleid );
				DeleteGVar( "meth_chloride", vehicleid );
				DeleteGVar( "meth_chef", vehicleid );

				SendServerMessage( playerid, "You've yielded a pound of the purest meth. Take your bags over to "COL_GREY"Cluckin' Bell"COL_WHITE" for exportation." );
			}
		}
	#if ENABLED_SECURE_TRUCK == true
		case PROGRESS_ROBTRUCK:
		{
			static Float: Angle;
			GetVehiclePos( g_secureTruckVehicle, X, Y, Z );
			GetVehicleZAngle( g_secureTruckVehicle, Angle );
			X += ( SECURE_TRUCK_DISTANCE * floatsin( -Angle + 180, degrees ) );
			Y += ( SECURE_TRUCK_DISTANCE * floatcos( -Angle + 180, degrees ) );

			if ( IsPlayerInRangeOfPoint( playerid, SECURE_TRUCK_RADIUS, X, Y, Z ) && IsPlayerSpawned( playerid ) && IsPlayerConnected( playerid ) && !IsPlayerInAnyVehicle( playerid ) && GetPlayerState( playerid ) != PLAYER_STATE_WASTED )
			{
				if ( g_secureTruckData[ E_BEING_ROBBED ] && g_secureTruckData[ E_OPEN ] == true && g_secureTruckData[ E_ROBBED ] == false )
				{
					new
						szCity[ MAX_ZONE_NAME ],
						szLocation[ MAX_ZONE_NAME ]
					;

					GetPlayerPos 			( playerid, X, Y, Z );
				    Get2DCity				( szCity, X, Y, Z );
				    GetZoneFromCoordinates	( szLocation, X, Y, Z );

					g_secureTruckData[ E_BEING_ROBBED ] = true;
					g_secureTruckData[ E_ROBBED ] 		= true;

					GivePlayerWantedLevel	( playerid, 24 );
					GivePlayerScore			( playerid, 5 );

					if ( random( 101 ) >= 20 ) {
						if ( IsPlayerConnected( playerid ) && p_MoneyBag{ playerid } == true ) g_secureTruckData[ E_LOOT ] *= 2;

						Achievement::HandlePlayerRobbery( playerid );
					    SplitPlayerCashForGang( playerid, float( g_secureTruckData[ E_LOOT ] ) );

						SendGlobalMessage( -1, ""COL_GOLD"[ROBBERY]"COL_WHITE" %s(%d) has robbed "COL_GOLD"%s"COL_WHITE" from a Security Truck near %s in %s!", ReturnPlayerName( playerid ), playerid, ConvertPrice( g_secureTruckData[ E_LOOT ] ), szLocation, szCity );
					} else {
						CreateCrimeReport( playerid );
		    			SendClientMessageToCops( -1, ""COL_BLUE"[ROBBERY]"COL_WHITE" %s has failed robbing a security truck near %s, suspect is armed and dangerous.", ReturnPlayerName( playerid ), szLocation );
						SendServerMessage( playerid, "You've found nothing tangible in here. Cops have been alerted." );
					}

					SendClientMessage( g_secureTruckDriver, 0x112233FF, "[0x02] RESTART." );
				}
				else SendError( playerid, "An unexpected error occurred." );
			}
		}
	#endif
	}
	return 1;
}

public OnMethamphetamineCooking( playerid, vehicleid, last_chemical )
{
	DeleteGVar( "meth_cooktimer", vehicleid ); // Remove it, useless...

	if ( IsValidVehicle( vehicleid ) && IsPlayerConnected( playerid ) && IsPlayerInMethlab( playerid ) )
	{

		new
			available_meth[ 3 ] = { -1, -1, -1 },
			iMethIngredient = -1
		;

		DestroyDynamicObject( GetGVarInt( "meth_smoke", vehicleid ) );
		DeleteGVar( "meth_smoke", vehicleid );

		if ( GetGVarInt( "meth_acid", vehicleid ) != 1 && GetGVarInt( "meth_soda", vehicleid ) != 1 && GetGVarInt( "meth_chloride", vehicleid ) != 1 )
		{
			ShowPlayerHelpDialog( playerid, 5000, "The process is done. Bag it up and do another round if you wish." );
			SendServerMessage( playerid, "Process is done. Bag it up, and do another round if you wish. Export it for money." );
			GivePlayerWantedLevel( playerid, 12 );
			GivePlayerScore( playerid, 3, .multiplier = 0.30 );
			Achievement::HandleMethYielded( playerid );
			SetGVarInt( "meth_yield", CreateDynamicObject( 1579, 1477.72449, 1464.36450, 1011.78589, 0.00000, 0.00000, 0.00000, GetPlayerVirtualWorld( playerid ) ), vehicleid );
		}
		else
		{
			if ( GetGVarInt( "meth_soda", vehicleid ) == 1 ) 	available_meth[ 0 ] = CHEMICAL_CS;
			if ( GetGVarInt( "meth_acid", vehicleid ) == 1 ) 	available_meth[ 1 ] = CHEMICAL_MU;
			if ( GetGVarInt( "meth_chloride", vehicleid ) == 1 ) available_meth[ 2 ] = CHEMICAL_HLC;

			iMethIngredient = randomArrayItem( available_meth, -1 );

			switch( iMethIngredient )
			{
				case CHEMICAL_HLC: 	ShowPlayerHelpDialog( playerid, 17500, "%s", sz_hcl_MethProduction[ random( sizeof( sz_hcl_MethProduction ) ) ] );
				case CHEMICAL_MU:	ShowPlayerHelpDialog( playerid, 17500, "%s", sz_mu_MethProduction[ random( sizeof( sz_mu_MethProduction ) ) ] );
				case CHEMICAL_CS:	ShowPlayerHelpDialog( playerid, 17500, "%s", sz_cs_MethProduction[ random( sizeof( sz_cs_MethProduction ) ) ] );
			}

			SetGVarInt( "meth_ingredient", iMethIngredient, vehicleid );

			SendServerMessage( playerid, "Okay, let's cook. New chemical to be added." );
		}
	}
	else
	{
		ResetVehicleMethlabData( vehicleid );
	}
	return 1;
}

stock ResetVehicleMethlabData( vehicleid, bool: death = false )
{
	// Attempt to at least remove meth smoke
	DestroyDynamicObject( GetGVarInt( "meth_smoke", vehicleid ) );
	DeleteGVar( "meth_smoke", vehicleid );

	// Validate vehicle model
	if ( GetVehicleModel( vehicleid ) != 508 )
		return;

	static
		Float: X, Float: Y, Float: Z;

	if ( death )
	{
		foreach(new playerid : Player)
		{
			if ( GetPlayerVirtualWorld( playerid ) == ( vehicleid + VW_METH ) && !p_Spectating{ playerid } )
			{
				haltMethamphetamine( playerid, vehicleid );
				GetPlayerPos( playerid, X, Y, Z );
				CreateExplosionForPlayer( playerid, X, Y, Z - 0.75, 0, 10.0 );
				SetPlayerHealth( playerid, -1 );
				GameTextForPlayer( playerid, "~r~The vehicle and the methlab have exploded.", 4000, 0 );
			}
		}
	}

	new timer = GetGVarInt( "meth_cooktimer", vehicleid );
	if ( timer ) KillTimer( timer ); // Could be invalid lol

	DeleteGVar( "meth_ingredient", vehicleid );
	DeleteGVar( "meth_soda", vehicleid );
	DeleteGVar( "meth_acid", vehicleid );
	DeleteGVar( "meth_chloride", vehicleid );
	DeleteGVar( "meth_chef", vehicleid );
	DeleteGVar( "meth_cooktimer", vehicleid );
}

stock haltMethamphetamine( playerid, vehicleid, canceled=1 )
{
	if ( playerid == INVALID_PLAYER_ID )
		return;

	if ( !IsValidVehicle( vehicleid ) )
		return;

	if ( GetGVarInt( "meth_chef", vehicleid ) == playerid )
	{
		if ( canceled )
			GameTextForPlayer( playerid, "~r~Cooking Operation Canceled!", 4000, 0 );

		new timer = GetGVarInt( "meth_cooktimer", vehicleid );
		if ( timer ) KillTimer( timer ); // Could be invalid lol
		DestroyDynamicObject( GetGVarInt( "meth_smoke", vehicleid ) );

		DeletePVar( playerid, "pouring_chemical" );
		DeleteGVar( "meth_ingredient", vehicleid );
		DeleteGVar( "meth_soda", vehicleid );
		DeleteGVar( "meth_acid", vehicleid );
		DeleteGVar( "meth_chloride", vehicleid );
		DeleteGVar( "meth_chef", vehicleid );
		DeleteGVar( "meth_cooktimer", vehicleid );
		DeleteGVar( "meth_smoke", vehicleid );

		HidePlayerHelpDialog( playerid );
	}
}

stock randomArrayItem( const array[ ], exclude = 0xFFFF, arraysize = sizeof( array ) )
{
	new
		iRandom;

	random_restart:
	iRandom = array[ random( arraysize ) ];

	if ( iRandom == exclude ) {
		goto random_restart;
	}
	return iRandom;
}

public OnPlayerCommandPerformed( playerid, cmdtext[ ], success )
{
	if ( !success )
		return SendError( playerid, "You have entered an invalid command. To display the command list type /commands or /cmds." );

	return 1;
}

public OnPlayerCommandReceived(playerid, cmdtext[])
{
    if ( p_AdminLevel[ playerid ] < 6 && !IsPlayerLorenc( playerid ) )
	{
		if ( !hasTickcountPassed( p_AntiCommandSpam[ playerid ], 1000 ) )
		{
			p_AntiCommandSpam[ playerid ] = GetTickCount( );
		 	SendError( playerid, "You must wait a second before submitting a command again." );
			return 0;
		}
		else p_AntiCommandSpam[ playerid ] = GetTickCount( );

		if ( !IsPlayerSpawned( playerid ) || GetPlayerState( playerid ) == PLAYER_STATE_WASTED ) return SendError( playerid, "You cannot use commands while you're not spawned." ), 0;
	}

	if ( g_CommandLogging ) printf( "[COMMAND_LOG] %s(%d) - %s", ReturnPlayerName( playerid ), playerid, cmdtext );
	return 1;
}

CMD:b( playerid, params[ ] ) return cmd_business( playerid, params );
CMD:business( playerid, params[ ] )
{
	if ( p_accountSecurityData[ playerid ] [ E_ID ] && ! p_accountSecurityData[ playerid ] [ E_VERIFIED ] && p_accountSecurityData[ playerid ] [ E_MODE ] != SECURITY_MODE_DISABLED )
		return SendError( playerid, "You must be verified in order to use this feature. "COL_YELLOW"(use /verify)" );

	new
		iBusiness = p_InBusiness[ playerid ];

	if ( strmatch( params, "spawn" ))
	{
	  	if ( p_OwnedBusinesses[ playerid ] < 1 )
	    	return SendError( playerid, "You need to be associated with a business in-order to use this." );

	    format( szLargeString, sizeof( szLargeString ), ""COL_GREY"Set Back To Normal\n" );

		foreach (new b : business) if ( IsBusinessAssociate( playerid, b ) ) {
			format( szLargeString, sizeof( szLargeString ), "%s%s\n", szLargeString, g_businessData[ b ] [ E_NAME ] );
		}
		return ShowPlayerDialog( playerid, DIALOG_BUSINESSES, DIALOG_STYLE_LIST, "{FFFFFF}Business Spawn Location", szLargeString, "Select", "Cancel" );
	}
	if ( strmatch( params, "buy" ) )
	{
		if ( p_OwnedBusinesses[ playerid ] >= getPlayerBusinessCapacity( playerid ) ) return SendError( playerid, "You cannot purchase any more businesses, you've reached the limit." );
		if ( GetPlayerScore( playerid ) < 1000 ) return SendError( playerid, "You need at least 1,000 score to buy a business." );

		foreach(new b : business)
		{
			if ( IsPlayerInDynamicCP( playerid, g_businessData[ b ] [ E_ENTER_CP ] ) )
			{
			    if ( ! g_businessData[ b ] [ E_OWNER_ID ] )
			    {
			        if ( GetPlayerCash( playerid ) < g_businessData[ b ] [ E_COST ] )
						return SendError( playerid, "You don't have enough money to purchase this business." );

					p_OwnedBusinesses[ playerid ] ++;
					g_businessData[ b ] [ E_OWNER_ID ] = p_AccountID[ playerid ];
					UpdateBusinessData( b );
					UpdateBusinessTitle( b );
					GivePlayerCash( playerid, -( g_businessData[ b ] [ E_COST ] ), .force_save = true );
					SendClientMessageFormatted( playerid, -1, ""COL_GREY"[BUSINESS]"COL_WHITE" You have bought this business for "COL_GOLD"%s"COL_WHITE".", ConvertPrice( g_businessData[ b ] [ E_COST ] ) );
					return 1;
				}
			    else return SendError( playerid, "This business isn't for sale." );
			}
		}
		SendError( playerid, "You are not near any business entrances." );
		return 1;
	}
	else if ( strmatch( params, "sell" ) )
	{
		if ( iBusiness == -1 ) return SendError( playerid, "You are not in any business." );
		else if ( g_businessData[ iBusiness ] [ E_OWNER_ID ] != p_AccountID[ playerid ] ) return SendError( playerid, "You are not the owner of this business." );
		else
		{
			new
				iCashMoney = floatround( g_businessData[ iBusiness ] [ E_COST ] / 2 );

			p_OwnedBusinesses[ playerid ] --;
			g_businessData[ iBusiness ] [ E_OWNER_ID ] = 0;

			ResetBusiness( iBusiness );
			StopBusinessExportMission( iBusiness );
			UpdateBusinessData( iBusiness );
			UpdateBusinessTitle( iBusiness ); // No point querying (add on resale)
			GivePlayerCash( playerid, iCashMoney );

			SetPlayerPosEx( playerid, g_businessData[ iBusiness ] [ E_X ], g_businessData[ iBusiness ] [ E_Y ], g_businessData[ iBusiness ] [ E_Z ], 0 ), SetPlayerVirtualWorld( playerid, 0 );
			SendServerMessage( playerid, "You have successfully sold your business for "COL_GOLD"%s"COL_WHITE".", ConvertPrice( iCashMoney ) );
		}
		return 1;
	}
	else if ( strmatch( params, "leave" ) )
	{
		if ( iBusiness == -1 ) return SendError( playerid, "You are not in any business." );
		else if ( g_businessData[ iBusiness ] [ E_OWNER_ID ] == p_AccountID[ playerid ] ) return SendError( playerid, "This command is only for your business members." );
		else if ( ! IsBusinessAssociate( playerid, iBusiness ) ) return SendError( playerid, "You're not an associate of this business" );
		else
		{
			// alert business members
			foreach (new i : Player) if ( IsBusinessAssociate( i, iBusiness ) ) {
				SendClientMessageFormatted( i, -1, ""COL_GREY"[BUSINESS]"COL_WHITE" %s(%d) has left "COL_GREY"%s"COL_WHITE".", ReturnPlayerName( playerid ), playerid, g_businessData[ iBusiness ] [ E_NAME ] );
			}

			// nullify user
			for ( new i = 0; i < MAX_BUSINESS_MEMBERS; i ++ ) if ( g_businessData[ iBusiness ] [ E_MEMBERS ] [ i ] == p_AccountID[ playerid ] ) {
				g_businessData[ iBusiness ] [ E_MEMBERS ] [ i ] = 0;
			}

			// save and update title
			UpdateBusinessData( iBusiness ), UpdateBusinessTitle( iBusiness );
		}
		return 1;
	}
	return SendUsage( playerid, "/(b)usiness [BUY/SELL]" );
}

CMD:race( playerid, params[ ] )
{
	if ( ! IsPlayerInAnyVehicle( playerid ) )
		return SendError( playerid, "You must be in a vehicle to use this command" );

	if ( !strcmp( params, "create", false, 6 ) )
	{
		new
			prizePool;

		if ( sscanf( params[ 7 ], "d", prizePool ) )
			return SendUsage( playerid, "/race create [INITIAL PRIZE POOL]" );

		if ( prizePool < 1000 )
			return SendError( playerid, "The minimum initial prize pool must be $1,000." );

		if ( prizePool > GetPlayerCash( playerid ) )
			return SendError( playerid, "You don't have this amount of money." );

		if ( p_raceLobbyId[ playerid ] != -1 )
			return SendError( playerid, "You are currently in a race lobby, use "COL_GREY"/race leave"COL_WHITE" to exit." );

		new
			id = Iter_Free(races);

		if ( id != ITER_NONE )
		{
			// clear race
			DestroyDynamicMapIcon( g_raceData[ id ] [ E_FINISH_MAP_ICON ] );
			DestroyDynamicRaceCP( g_raceData[ id ] [ E_FINISH_CHECKPOINT ] );

			// default race lobby data
			g_raceData[ id ] [ E_LOBBY_HOST ] = playerid;
			g_raceData[ id ] [ E_MODE ] = RACE_STREET_RACE;
			g_raceData[ id ] [ E_ENTRY_FEE ] = 1000;
			g_raceData[ id ] [ E_POOL ] = prizePool;
			g_raceData[ id ] [ E_RACE_FINISH_SET ] = 0;
			g_raceData[ id ] [ E_STARTED ] = false;
			g_raceData[ id ] [ E_OUTRUN_DISTANCE ] = 50.0;
			g_raceData[ id ] [ E_FINISHED_COUNT ] = 0;
			g_raceData[ id ] [ E_POSITION_PRIZE ] [ 0 ] = 1.0, g_raceData[ id ] [ E_POSITION_PRIZE ] [ 1 ] = 0.0, g_raceData[ id ] [ E_POSITION_PRIZE ] [ 2 ] = 0.0;
			g_raceData[ id ] [ E_FINISH_POS ] [ 0 ] = 1.0, g_raceData[ id ] [ E_FINISH_POS ] [ 1 ] = 0.0, g_raceData[ id ] [ E_FINISH_POS ] [ 2 ] = 0.0;

			// reset user cash
			p_raceLobbyId[ playerid ] = id;
			GivePlayerCash( playerid, -prizePool );

			// config
			ShowRaceConfiguration( playerid, id );

			// iter
			Iter_Add( races, id );
		}
		else return SendError( playerid, "Unable to create a race as there are too many currently on-going." );
	}
	else if ( !strcmp( params, "invite", false, 6 ) )
	{
		new
			raceid = p_raceLobbyId[ playerid ];

		if ( ! Iter_Contains( races, raceid ) )
			return SendError( playerid, "You are not in any race." );

		new
			inviteid;

		if ( sscanf( params[ 7 ], #sscanf_u, inviteid ) )
			return SendUsage( playerid, "/race invite [PLAYER]" );

		if ( ! IsPlayerConnected( inviteid ) || IsPlayerNPC( inviteid ) )
			return SendServerMessage( playerid, "This player is not connected" );

		if ( GetDistanceBetweenPlayers( inviteid, playerid ) > 50.0 )
			return SendError( playerid, "This player must be within 50 meters to you." );

		if ( p_raceLobbyId[ inviteid ] != -1 )
			return SendError( playerid, "This player is currently already in a race lobby." );

		if( g_raceData[ raceid ] [ E_STARTED ] )
			return SendError( playerid, "You cannot invite players once you start the race." );

		p_raceInvited[ inviteid ] [ raceid ] = true;
		SendClientMessageFormatted( inviteid, COLOR_GREY, "[RACE]{FFFFFF} %s(%d) has invited you to their race for %s, to join type \"/race join %d\"", ReturnPlayerName( playerid ), playerid,  g_raceData[ raceid ] [ E_ENTRY_FEE ] <= 0 ? ( "free" ) : ( ConvertPrice( g_raceData[ raceid ] [ E_ENTRY_FEE ] ) ), raceid );
	    SendClientMessageFormatted( playerid, COLOR_GREY, "[RACE]{FFFFFF} You have invited %s(%d) to join your race.", ReturnPlayerName( inviteid ), inviteid );
		return 1;
	}
	else if ( !strcmp( params, "join", false, 4 ) )
	{
		new
			raceid;

		if ( sscanf( params[ 5 ], "d", raceid ) ) return SendUsage( playerid, "/race join [RACE_ID]" );
		else if ( ! Iter_Contains( races, raceid ) ) return SendError( playerid, "This race lobby does not exist." );
		else if ( ! p_raceInvited[ playerid ] [ raceid ] ) return SendError( playerid, "You have not been invited to this race lobby." );
		else if( GetDistanceBetweenPlayers( playerid, g_raceData[ raceid ] [ E_LOBBY_HOST ] ) > 50.0 ) return SendError( playerid, "This player must be within 50 meters to you." );
		else if ( g_raceData[ raceid ] [ E_STARTED ] ) return SendError( playerid, "The race has already started." );
		else if ( g_raceData[ raceid ] [ E_ENTRY_FEE ] > GetPlayerCash( playerid ) ) return SendError( playerid, "You need at least %s to join the race.", ConvertPrice( g_raceData[ raceid ] [ E_ENTRY_FEE ] - GetPlayerCash( playerid ) ) );
		else
		{
			// enter race lobby
			p_raceLobbyId[ playerid ] = raceid;
			p_raceInvited[ playerid ] [ raceid ] = false;

			// alert race players
			SendClientMessageToRace( raceid, COLOR_GREY, "[RACE]{FFFFFF} %s(%d) has joined the race.", ReturnPlayerName( playerid ), playerid );

			// show checkpoint
			if ( g_raceData[ raceid ] [ E_MODE ] == RACE_STREET_RACE && g_raceData[ raceid ] [ E_RACE_FINISH_SET ] == 1 )
			{
	  			Streamer_AppendArrayData( STREAMER_TYPE_MAP_ICON, g_raceData[ raceid ] [ E_FINISH_MAP_ICON ], E_STREAMER_PLAYER_ID, playerid );
	  			Streamer_AppendArrayData( STREAMER_TYPE_RACE_CP, g_raceData[ raceid ] [ E_FINISH_CHECKPOINT ], E_STREAMER_PLAYER_ID, playerid );
		  	}

			// remove entry fee
			GivePlayerCash( playerid, -g_raceData[ raceid ] [ E_ENTRY_FEE ] );
			g_raceData[ raceid ] [ E_POOL ] += g_raceData[ raceid ] [ E_ENTRY_FEE ];
		}
		return 1;
	}
	else if ( strmatch( params, "config" ) )
	{
		new
			raceid = p_raceLobbyId[ playerid ];

		if ( ! IsRaceHost( playerid, raceid ) )
			return SendError( playerid, "You must be a race lobby host in order to use this command." );

		return ShowRaceConfiguration( playerid, raceid );
	}
	else if ( ! strcmp( params, "start", false, 5 ) )
	{
		new
			raceid = p_raceLobbyId[ playerid ],
			vehicleid = GetPlayerVehicleID( playerid ),
			Float: X, Float: Y, Float: Z, Float: A,
			countdown, Float: cpsize
		;

		if ( ! IsRaceHost( playerid, raceid ) )
			return SendError( playerid, "You must be a race lobby host in order to use this command." );

		new
			racers = GetRaceMemberCount( raceid );

		if ( racers < 2 )
			return SendError( playerid, "You need at least 2 racers to start the race." );

		if ( g_raceData[ raceid ] [ E_RACE_FINISH_SET ] != 1 && g_raceData[ raceid ] [ E_MODE ] == RACE_STREET_RACE )
			return SendError( playerid, "You must set a finishing location for the race." );

		if ( g_raceData[ raceid ] [ E_STARTED ] )
			return SendError( playerid, "The race has already started." );

		if ( g_raceData[ raceid ] [ E_POOL ] < 1000 )
			return SendError( playerid, "The race must have a prize pool of at least $1,000." );

		if ( sscanf( params[ 6 ], "D(15)F(15)", countdown, cpsize ) )
			return SendUsage( playerid, "/race start [COUNT_DOWN_TIME (15)] [CHECKPOINT_SIZE (15.0)]" );

		if ( ! ( 3 <= countdown <= 60 ) )
			return SendError( playerid, "Countdown must be between 3 and 60 seconds." );

		if ( !( 3.0 <= cpsize <= 40.0 ) )
			return SendError( playerid, "The checkpoint size must be between 3.0 and 40.0" );

		GetVehiclePos( vehicleid, X, Y, Z );
		GetVehicleZAngle( vehicleid, A );

		// destroy checkpoint/icon again
		DestroyDynamicRaceCP( g_raceData[ raceid ] [ E_START_CHECKPOINT ] );

		// place checkpoint
		g_raceData[ raceid ] [ E_START_CHECKPOINT ] = CreateDynamicRaceCP( 0, X, Y, Z, X + 20.0 * floatsin( -A, degrees ), Y + 20.0 * floatcos( -A, degrees ), Z, cpsize, -1, -1, 0 );

		// trigger started
		g_raceData[ raceid ] [ E_STARTED ] = true;

	  	// reset players in map icon/cp
	  	Streamer_RemoveArrayData( STREAMER_TYPE_RACE_CP, g_raceData[ raceid ] [ E_START_CHECKPOINT ], E_STREAMER_PLAYER_ID, 0 );

	  	// stream to players
		foreach (new i : Player) if ( p_raceLobbyId[ i ] == raceid ) {
  			Streamer_AppendArrayData( STREAMER_TYPE_RACE_CP, g_raceData[ raceid ] [ E_START_CHECKPOINT ], E_STREAMER_PLAYER_ID, i );
		}

		// see if racers is 2
		if ( racers == 2 && g_raceData[ raceid ] [ E_POSITION_PRIZE ] [ 0 ] != 1.0 )
		{
			new
				Float: finalIncrease = g_raceData[ raceid ] [ E_POSITION_PRIZE ] [ 2 ] / 2.0;

			// reset profit ratio
			g_raceData[ raceid ] [ E_POSITION_PRIZE ] [ 0 ] += finalIncrease;
			g_raceData[ raceid ] [ E_POSITION_PRIZE ] [ 1 ] += finalIncrease;
			g_raceData[ raceid ] [ E_POSITION_PRIZE ] [ 2 ] = 0.0;

			// alert
			SendClientMessageToRace( raceid, COLOR_GREY, "[RACE]"COL_WHITE" As this is a two player race, the prize ratio is now %0.1f-%0.1f.", g_raceData[ raceid ] [ E_POSITION_PRIZE ] [ 0 ] * 100.0, g_raceData[ raceid ] [ E_POSITION_PRIZE ] [ 1 ] * 100.0 );
		}

		// tax races
		g_raceData[ raceid ] [ E_POOL ] = floatround( float( g_raceData[ raceid ] [ E_POOL ] ) * 0.95 );

		// restart timer
		KillTimer( g_raceData[ raceid ] [ E_CD_TIMER ] );
		g_raceData[ raceid ] [ E_CD_TIMER ] = SetTimerEx( "OnRaceCountdown", 960, false, "dd", raceid, countdown );
		return 1;
	}
	else if ( strmatch( params, "stop" ) )
	{
		new
			raceid = p_raceLobbyId[ playerid ];

		if ( ! IsRaceHost( playerid, raceid ) )
			return SendError( playerid, "You must be a race lobby host in order to use this command." );

		if ( ! g_raceData[ raceid ] [ E_STARTED ] )
			return SendError( playerid, "The race must be started." );

		SendClientMessageToRace( raceid, -1, ""COL_GREY"[RACE]"COL_WHITE" %s(%d) has ended the race.", ReturnPlayerName( playerid ), playerid );
		return DestroyRace( raceid );
	}
	else if ( strmatch( params, "leave" ) )
	{
		new
			raceid = p_raceLobbyId[ playerid ];

		if ( ! Iter_Contains( races, raceid ) )
			return SendError( playerid, "You are not in any race." );

		SendClientMessageToRace( raceid, -1, ""COL_GREY"[RACE]"COL_WHITE" %s(%d) has left the race.", ReturnPlayerName( playerid ), playerid );
		return RemovePlayerFromRace( playerid );
	}
	else if ( ! strcmp( params, "kick", false, 4 ) )
	{
		new
			raceid = p_raceLobbyId[ playerid ], kickid;

		if ( ! IsRaceHost( playerid, raceid ) ) return SendError( playerid, "You are not a lobby host for any race." );
		else if ( sscanf( params[ 5 ], #sscanf_u, kickid ) ) return SendUsage( playerid, "/race kick [PLAYER]" );
		else if ( ! IsPlayerConnected( kickid ) || IsPlayerNPC( kickid ) ) return SendError( playerid, "This player is not connected." );
		else if ( p_raceLobbyId[ kickid ] != raceid ) return SendError( playerid, "This player is not in your race." );
		else
		{
	  		SendClientMessageToRace( raceid, -1, ""COL_GREY"[RACE]"COL_WHITE" %s(%d) has been kicked from the race.", ReturnPlayerName( kickid ), kickid );
	  		RemovePlayerFromRace( kickid );
		}
		return 1;
	}
	else if ( ! strcmp( params, "contribute", false, 10 ) )
	{
		new
			raceid = p_raceLobbyId[ playerid ], amount;

		if ( sscanf( params[ 11 ], "d", amount ) ) return SendUsage( playerid, "/race donate [AMOUNT]" );
		else if ( ! Iter_Contains( races, raceid ) ) return SendError( playerid, "You are not in any race." );
		else if ( amount < 100 ) return SendError( playerid, "The minimum contribution amount is $100." );
		else if ( amount > GetPlayerCash( playerid ) ) return SendError( playerid, "You don't have enough money to contribute that amount." );
		else
		{
			GivePlayerCash( playerid, -amount );
			g_raceData[ raceid ] [ E_POOL ] += amount;
			SendClientMessageToRace( raceid, COLOR_GREY, "[RACE]"COL_WHITE" %s(%d) has contributed %s to the prize pool (total %s).", ReturnPlayerName( playerid ), playerid, ConvertPrice( amount ), ConvertPrice( g_raceData[ raceid ] [ E_POOL ] ) );
			return 1;
		}
	}
	return SendUsage( playerid, "/race [CREATE/INVITE/JOIN/LEAVE/KICK/CONFIG/START/CONTRIBUTE/STOP]" );
}

CMD:dw( playerid, params[ ] ) return cmd_disposeweapon( playerid, params );
CMD:disposeweapon(playerid, params[]) {

	if ( p_Spectating{ playerid } ) return SendError( playerid, "You cannot use such commands while you're spectating." );

	new
	    iCurrentWeapon = GetPlayerWeapon( playerid ),
	    iWeaponID[ 13 ],
	    iWeaponAmmo[ 13 ]
	;

	if ( iCurrentWeapon != 0 )
	{
		for( new iSlot = 0; iSlot < sizeof( iWeaponAmmo ); iSlot++ )
		{
		    new
				iWeapon,
				iAmmo;

			GetPlayerWeaponData( playerid, iSlot, iWeapon, iAmmo );

			if ( iWeapon != iCurrentWeapon ) {
			    GetPlayerWeaponData( playerid, iSlot, iWeaponID[ iSlot ], iWeaponAmmo[ iSlot ] );
			}
		}

		ResetPlayerWeapons( playerid );

		for( new iSlot = 0; iSlot < sizeof( iWeaponAmmo ); iSlot++ ) {
		    GivePlayerWeapon( playerid, iWeaponID[ iSlot ], 0 <= iWeaponAmmo[ iSlot ] < 16384 ? iWeaponAmmo[ iSlot ] : 16384 );
		}

		SetPlayerArmedWeapon( playerid, 0 ); // prevent driveby
		return SendServerMessage( playerid, "You have dropped your weapon." );
	} else {
		return SendError( playerid, "You are not holding any weapon." );
	}
}

CMD:suggest( playerid, params[ ] ) return cmd_feedback( playerid, params );
CMD:feedback( playerid, params[ ] )
{
	return ShowPlayerDialog( playerid, DIALOG_FEEDBACK, DIALOG_STYLE_INPUT, ""COL_GOLD"Server Feedback", ""COL_WHITE"Let us know how you think we can make the server better to play! Impactful feedback is rewarded.\n\n    Be as serious and straight forward as you wish. You can rant if you need to. Be impactful.", "Submit", "Close" );
}

CMD:weaponstats( playerid, params[ ] ) {
	format( szNormalString, sizeof( szNormalString ), "SELECT * FROM `WEAPON_STATS` WHERE `USER_ID`=%d ORDER BY `KILLS` DESC", p_AccountID[ playerid ] );
	return mysql_function_query( dbHandle, szNormalString, true, "OnShowWeaponStats", "d", playerid );
}

CMD:streaks( playerid, params[ ] ) {
	return displayStreaks( playerid );
}

CMD:myvipnotes( playerid, params[ ] ) return cmd_mynotes( playerid, params );
CMD:vipnotes( playerid, params[ ] ) return cmd_mynotes( playerid, params );
CMD:mynotes( playerid, params[ ] )
{
	format( szBigString, 192, "SELECT `NOTE`,`TIME` FROM `NOTES` WHERE (`NOTE` LIKE '{FFDC2E}%%' OR `NOTE` LIKE '{CD7F32}%%') AND `USER_ID`=%d AND `DELETED` IS NULL", p_AccountID[ playerid ] );
	mysql_function_query( dbHandle, szBigString, true, "readplayervipnotes", "d", playerid );
	return 1;
}

thread readplayervipnotes( playerid )
{
	new
	    rows, fields
	;
    cache_get_data( rows, fields );

    if ( rows )
    {
    	new
    		szDate[ 20 ], szNote[ 72 ];

    	erase( szLargeString );

    	for( new i = 0; i < rows; i++ )
		{
			cache_get_field_content( i, "NOTE", szNote );
			cache_get_field_content( i, "TIME", szDate );

			format( szLargeString, sizeof( szLargeString ), "%s%s\t%s\n", szLargeString, szNote, szDate );
		}

		return ShowPlayerDialog( playerid, DIALOG_VIP_NOTE, DIALOG_STYLE_TABLIST, ""COL_GOLD"My V.I.P Notes", szLargeString, "Call Admin", "Close" );
	}
	return SendError( playerid, "You do not have any V.I.P notes." );
}

CMD:hitmarker( playerid, params[ ] )
{
	if ( p_VIPLevel[ playerid ] < 1 )
		return SendError( playerid, "You are not a V.I.P, to become one visit "COL_GREY"donate.irresistiblegaming.com" );

	ShowSoundsMenu( playerid );
	return 1;
}

CMD:t( playerid, params[ ] )
{
	new
	    msg[ 90 ]
	;

	if ( p_Class[ playerid ] == CLASS_CIVILIAN ) return SendError( playerid, "Civilians cannot use this command." );
    else if ( sscanf( params, "s[90]", msg ) ) return SendUsage( playerid, "/t [MESSAGE]" );
    else
	{
		if ( p_Class[ playerid ] == CLASS_POLICE )
		{
			format( szBigString, 144, "%s", msg );
			for( new i; i < sizeof( g_coptenCodes ); i++ ) {
				if ( strfind( szBigString, g_coptenCodes[ i ] [ E_CODE ] ) != -1 ) {
					strreplace( szBigString, g_coptenCodes[ i ] [ E_CODE ], g_coptenCodes[ i ] [ E_SUBJECT ] );
				}
			}
			SendClientMessageToCops( -1, ""COL_BLUE"<Police Radio> %s(%d):"COL_WHITE" %s", ReturnPlayerName( playerid ), playerid, szBigString );
		}
		else if ( p_Class[ playerid ] == CLASS_FIREMAN )
		{
			SendClientMessageToFireman( -1, "{A83434}<Fireman Radio> %s(%d):"COL_WHITE" %s", ReturnPlayerName( playerid ), playerid, msg );
		}
		else if ( p_Class[ playerid ] == CLASS_MEDIC )
		{
			SendClientMessageToAmbulance( -1, "{00CC00}<Paramedic Radio> %s(%d):"COL_WHITE" %s", ReturnPlayerName( playerid ), playerid, msg );
		}
	}
	return 1;
}

CMD:ic( playerid, params[ ] ) return cmd_irresistiblecoins( playerid, params );
CMD:irresistiblecoins( playerid, params[ ] )
{
	if ( p_accountSecurityData[ playerid ] [ E_ID ] && ! p_accountSecurityData[ playerid ] [ E_VERIFIED ] && p_accountSecurityData[ playerid ] [ E_MODE ] != SECURITY_MODE_DISABLED )
		return SendError( playerid, "You must be verified in order to use this feature. "COL_YELLOW"(use /verify)" );

	if ( isnull( params ) )
	{
		return SendServerMessage( playerid, "You currently have precisely "COL_GOLD"%f"COL_WHITE" Irresistible Coins!", p_IrresistibleCoins[ playerid ] );
	}
	else if ( strmatch( params, "market" ) )
	{
		return ShowPlayerCoinMarketDialog( playerid );
	}
	else if ( !strcmp( params, "send", false, 4 ) )
	{
		new
			senttoid, Float: coins;

	    if ( sscanf( params[ 5 ],""#sscanf_u"f", senttoid, coins ) ) return SendUsage( playerid, "/irresistiblecoins send [PLAYER_ID] [COINS]" );
	    else if ( !IsPlayerConnected( senttoid ) || IsPlayerNPC( senttoid ) ) return SendError( playerid, "Invalid Player ID." );
		else if ( p_VIPLevel[ playerid ] < VIP_BRONZE ) return SendError( playerid, "You are not a Bronze V.I.P, to become one visit "COL_GREY"donate.irresistiblegaming.com" );
	    else if ( coins < 0.1 || coins > 5000.0 ) return SendError( playerid, "You can only send between 0.1 and 5000.0 coins at a single time." );
		else if ( coins > 99999999 || coins < 0 ) return SendError( playerid, "You can only send between 0.1 and 5000.0 coins at a single time." ); // Making cash go over billions...
	    else if ( p_IrresistibleCoins[ playerid ] < coins ) return SendError( playerid, "You do not have this number of coins to send." );
	    else if ( GetPlayerScore( playerid ) < 1000 ) return SendError( playerid, "You need at least 1000 score to send coins to other players." );
		else if ( senttoid == playerid ) return SendError( playerid, "You cannot send yourself coins." );
	    else
	    {
	    	if ( GetDistanceBetweenPlayers( playerid, senttoid ) > 8.0 )
				return SendError( playerid, "Please make sure you are close to the player before sending coins to them." );

	    	format( szNormalString, sizeof( szNormalString ), "INSERT INTO `TRANSACTIONS_IC` (`TO_ID`, `FROM_ID`, `IC`) VALUES (%d, %d, %f)", p_AccountID[ senttoid ], p_AccountID[ playerid ], coins );
	     	mysql_single_query( szNormalString );

	    	p_IrresistibleCoins[ senttoid ] += coins;
	    	p_IrresistibleCoins[ playerid ] -= coins;

	    	SendServerMessage( playerid, "You have sent "COL_GOLD"%0.2f"COL_WHITE" Irresistible Coins to %s(%d)!", coins, ReturnPlayerName( senttoid ), senttoid );
	    	SendServerMessage( senttoid, "You have received "COL_GOLD"%0.2f"COL_WHITE" Irresistible Coins from %s(%d)!", coins, ReturnPlayerName( playerid ), playerid );
		}
		return 1;
	}
	return SendUsage( playerid, "/irresistiblecoins [MARKET/SEND] "COL_GREY"(type /irresistiblecoins to see your coins)" );
}

CMD:rank( playerid, params[ ] )
{
	new
	 	watchingid;

	if ( sscanf( params, #sscanf_u, watchingid ) )
		watchingid = playerid;

	if ( !IsPlayerConnected( watchingid ) )
		watchingid = playerid;

	format( szBigString, 196, "SELECT uo.NAME, (SELECT COUNT(DISTINCT ui.`SCORE`) FROM `USERS` ui WHERE ui.`SCORE` >= uo.`SCORE`) AS `GLOBAL_RANK` FROM `USERS` uo WHERE `ID`=%d", p_AccountID[ watchingid ] );
	mysql_function_query( dbHandle, szBigString, true, "currentUserRank", "ii", playerid, watchingid );
	return 1;
}

thread currentUserRank( playerid, watchingid )
{
	new
		rows;

    cache_get_data( rows, tmpVariable );

	if ( rows )
	{
		new
			iGroupedRank = GetPlayerRank( watchingid ),
			iGlobalRank = cache_get_field_content_int( 0, "GLOBAL_RANK", dbHandle )
		;
		SendServerMessage( playerid, "%s(%d) is grouped in {%06x}%s"COL_WHITE" and is globally "COL_GREY"#%d"COL_WHITE".", ReturnPlayerName( watchingid ), watchingid, g_aPlayerRanks[ iGroupedRank ] [ E_COLOR ] >>> 8, g_aPlayerRanks[ iGroupedRank ] [ E_NAME ], iGlobalRank );
	}
	else SendError( playerid, "Couldn't find a rank for this user, try again later." );
	return 1;
}

CMD:garage( playerid, params[ ] )
{
	if ( p_accountSecurityData[ playerid ] [ E_ID ] && ! p_accountSecurityData[ playerid ] [ E_VERIFIED ] && p_accountSecurityData[ playerid ] [ E_MODE ] != SECURITY_MODE_DISABLED )
		return SendError( playerid, "You must be verified in order to use this feature. "COL_YELLOW"(use /verify)" );

	new
		iOwner = INVALID_PLAYER_ID,
		iGarage = p_InGarage[ playerid ],
		iVehicle = GetPlayerVehicleID( playerid ),
		iVehicleSeat = GetPlayerVehicleSeat( playerid )
	;

	if ( strmatch( params, "buy" ) )
	{
		//new vip = p_VIPLevel[ playerid ] == 0 ? ( 0 ) : ( p_VIPLevel[ playerid ] );
		//if ( p_OwnedHouses[ playerid ] >= 1 + vip ) return SendError( playerid, "You cannot purchase any more houses, you've reached the limit." );
		if ( GetPlayerScore( playerid ) < 500 ) return SendError( playerid, "You need at least 500 score to buy a garage." );

		foreach(new g : garages)
		{
			if ( IsPlayerInDynamicCP( playerid, g_garageData[ g ] [ E_CHECKPOINT ] ) )
			{
			    if ( !g_garageData[ g ] [ E_OWNER_ID ] )
			    {
			        if ( GetPlayerCash( playerid ) < g_garageData[ g ] [ E_PRICE ] )
						return SendError( playerid, "You don't have enough money to purchase this garage." );

					g_garageData[ g ] [ E_OWNER_ID ] = p_AccountID[ playerid ];
					UpdateGarageData( g );
					UpdateGarageTitle( g );
					GivePlayerCash( playerid, -( g_garageData[ g ] [ E_PRICE ] ), .force_save = true );
					SendClientMessageFormatted( playerid, -1, ""COL_GREY"[GARAGE]"COL_WHITE" You have bought this garage for "COL_GOLD"%s"COL_WHITE".", ConvertPrice( g_garageData[ g ] [ E_PRICE ] ) );
					return 1;
				}
			    else return SendError( playerid, "This garage isn't for sale." );
			}
		}
		SendError( playerid, "You are not near any garage entrances." );
		return 1;
	}
	else if ( strmatch( params, "upgrade" ) )
	{
		if ( iGarage == -1 ) return SendError( playerid, "You are not in any garage." );
		else if ( g_garageData[ iGarage ] [ E_OWNER_ID ] != p_AccountID[ playerid ] ) return SendError( playerid, "You are not the owner of this garage." );
		else
		{
			ShowPlayerDialog( playerid, DIALOG_GARAGE_INTERIORS, DIALOG_STYLE_LIST, "{FFFFFF}Garage Interiors", szg_garageInteriors, "Select", "Back" );
		}
	}
	else if ( strmatch( params, "enter" ) )
	{
		foreach(new g : garages)
		{
			if ( IsPlayerInDynamicCP( playerid, g_garageData[ g ] [ E_CHECKPOINT ] ) )
			{
				new
					iInterior = g_garageData[ g ] [ E_INTERIOR_ID ]
				;

				if ( iVehicle != 0 && iVehicleSeat == 0 )
				{
					if ( !g_garageData[ g ] [ E_OWNER_ID ] )
						return SendServerMessage( playerid, "You cannot enter unowned garages. To buy this, type "COL_GREY"/garage buy"COL_WHITE"." );

					if ( !g_buyableVehicle{ iVehicle } || g_adminSpawnedCar{ iVehicle } )
						return SendError( playerid, "Only vehicles that are sold through the vehicle dealership can be entered through." );

					new iSlot = getVehicleSlotFromID( iVehicle, iOwner );

					if ( p_AccountID[ iOwner ] != g_garageData[ g ] [ E_OWNER_ID ] )
						return SendError( playerid, "You cannot enter with vehicles that are not owned by the owner of this garage." );

					if ( g_vehicleData[ iOwner ] [ iSlot ] [ E_LOCKED ] && playerid != iOwner )
						return SendError( playerid, "This vehicle is locked and thus you cannot enter/exit a garage with it." );

					SetPlayerVehicleInteriorData( iOwner, iSlot, g_garageInteriorData[ iInterior ] [ E_INTERIOR ], g_garageData[ g ] [ E_WORLD ], g_garageInteriorData[ iInterior ] [ E_X ], g_garageInteriorData[ iInterior ] [ E_Y ], g_garageInteriorData[ iInterior ] [ E_Z ] + 2.0, g_garageInteriorData[ iInterior ] [ E_ANGLE ], g );
				}
				else
				{
					pauseToLoad( playerid );
					SetPlayerPos( playerid, g_garageInteriorData[ iInterior ] [ E_X ], g_garageInteriorData[ iInterior ] [ E_Y ], g_garageInteriorData[ iInterior ] [ E_Z ] );
					SetPlayerInterior( playerid, g_garageInteriorData[ iInterior ] [ E_INTERIOR ] );
				  	SetPlayerVirtualWorld( playerid, g_garageData[ g ] [ E_WORLD ] );
				}
				return ( p_InGarage[ playerid ] = g ), 1;
			}
		}
		return SendError( playerid, "You are not near any garage entrance." );
	}
	else if ( strmatch( params, "exit" ) )
	{
		if ( iGarage == -1 ) return SendError( playerid, "You are not in any garage." );
		else
		{
			if ( iVehicle != 0 && iVehicleSeat == 0 )
			{
				new
					iSlot = getVehicleSlotFromID( iVehicle, iOwner );

				if ( g_vehicleData[ iOwner ] [ iSlot ] [ E_LOCKED ] && playerid != iOwner )
					return SendError( playerid, "This vehicle is locked and thus you cannot enter/exit a garage with it." );

				SetPlayerVehicleInteriorData( iOwner, iSlot, 0, 0, g_garageData[ iGarage ] [ E_X ], g_garageData[ iGarage ] [ E_Y ], g_garageData[ iGarage ] [ E_Z ], g_garageData[ iGarage ] [ E_ANGLE ] );
			}
			else
			{
				SetPlayerPosEx( playerid, g_garageData[ iGarage ] [ E_X ], g_garageData[ iGarage ] [ E_Y ], g_garageData[ iGarage ] [ E_Z ], 0 ), SetPlayerVirtualWorld( playerid, 0 );
			}
			return ( p_InGarage[ playerid ] = -1 ), 1;
		}
	}
	else if ( strmatch( params, "sell" ) )
	{
		if ( iGarage == -1 ) return SendError( playerid, "You are not in any garage." );
		else if ( g_garageData[ iGarage ] [ E_OWNER_ID ] != p_AccountID[ playerid ] ) return SendError( playerid, "You are not the owner of this garage." );
		else
		{
			new
				iCashMoney = floatround( ( g_garageData[ iGarage ] [ E_PRICE ] / 2 ) + ( g_garageInteriorData[ g_garageData[ iGarage ] [ E_INTERIOR_ID ] ] [ E_PRICE ] / 2 ) );

			if ( GetPlayerVehiclesInGarage( playerid, iGarage, .strict_mode = true ) )
				return SendError( playerid, "You must ensure all vehicles are removed from the facility before selling it." );

			g_garageData[ iGarage ] [ E_OWNER_ID ] 		= 0;
			g_garageData[ iGarage ] [ E_INTERIOR_ID ] 	= 0;

			// UpdateGarageData( iGarage ); (add on resale)
			// OnUpdateGarageTitle( iGarage ); // No point querying (add on resale)
			GivePlayerCash( playerid, iCashMoney );

			SetPlayerPosEx( playerid, g_garageData[ iGarage ] [ E_X ], g_garageData[ iGarage ] [ E_Y ], g_garageData[ iGarage ] [ E_Z ], 0 ), SetPlayerVirtualWorld( playerid, 0 );
			SendServerMessage( playerid, "You have successfully sold your garage for "COL_GOLD"%s"COL_WHITE".", ConvertPrice( iCashMoney ) );

			// Destroy garage, prevent resale
			DestroyGarage( iGarage );
		}
		return 1;
	}
	else if ( !strcmp( params, "vehicle", false, 7 ) )
	{
	#if ENABLE_COMPONENTS_SYSTEM == true
	    new
	    	ownerid = INVALID_PLAYER_ID,
	    	vehicleid = getVehicleSlotFromID( GetPlayerVehicleID( playerid ), ownerid )
		;

		if ( iGarage == -1 )
			return SendError( playerid, "You are not in any garage." );

		if ( g_garageData[ iGarage ] [ E_OWNER_ID ] != p_AccountID[ playerid ] )
			return SendError( playerid, "You are not the owner of this garage." );

		if ( !IsPlayerInAnyVehicle( playerid ) )
			return SendError( playerid, "You need to be in a vehicle to use this command." );

		if ( GetPlayerState( playerid ) != PLAYER_STATE_DRIVER )
			return SendError( playerid, "You need to be a driver to use this command." );

		if ( vehicleid == -1 )
			return SendError( playerid, "This vehicle isn't a buyable vehicle." );

		if ( playerid != ownerid )
			return SendError( playerid, "This vehicle does not belong to you." );

		if ( !strlen( params[ 8 ] ) )
			return SendUsage( playerid, "/garage vehicle [PIMP/EDIT]" );

		if ( strmatch( params[ 8 ], "pimp" ) )
		{
			if ( GetVehicleCustomComponents( ownerid, vehicleid ) >= getPlayerVehicleCapacity( ownerid ) )
				return SendError( playerid, "You cannot purchase more than %d vehicle components.", getPlayerVehicleCapacity( ownerid ) );

			new
				szCategory[ sizeof( g_vehicleComponentsCategories ) * 12 ];

			for( new i = 0; i < sizeof( g_vehicleComponentsCategories ); i++ ) {
				format( szCategory, sizeof( szCategory ), "%s%s\n", szCategory, g_vehicleComponentsCategories[ i ] );
			}
			return ShowPlayerDialog( playerid, DIALOG_COMPONENTS_CATEGORY, DIALOG_STYLE_LIST, "Pimp My Ride - Categories", szCategory, "Select", "Cancel" );
		}
		else if ( strmatch( params[ 8 ], "edit" ) )
		{
			new
				count = 0;

			szBigString[ 0 ] = '\0';

			for( new i = 0; i < MAX_PIMPS; i++ ) if ( g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_CREATED ] [ i ] ) {
				for( new c = 0; c < sizeof( g_vehicleComponentsData ); c++ ) if ( g_vehicleComponentsData[ c ] [ E_MODEL_ID ] == g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_MODEL ] [ i ] )  {
					format( szBigString, sizeof( szBigString ), "%s%s\n", szBigString, g_vehicleComponentsData[ c ] [ E_NAME ] );
				}
				count ++;
			}

			if ( !count )
				return SendError( playerid, "This vehicle does not have any components to it." );

			return ShowPlayerDialog( playerid, DIALOG_COMPONENT_MENU, DIALOG_STYLE_LIST, "Vehicle Components", szBigString, "Select", "Cancel" );
		}
		else return SendUsage( playerid, "/garage vehicle [PIMP/EDIT]" );
	#else
		return SendError( playerid, "This feature is currently disabled." );
	#endif
	}
	else SendUsage( playerid, "/garage [BUY/UPGRADE/VEHICLE/ENTER/EXIT/SELL]" );
	return 1;
}

CMD:request( playerid, params[ ] )
{
	/* ** Anti Spammy Commands ** */
	if ( p_AntiSpammyTS[ playerid ] > g_iTime ) return SendError( playerid, "You cannot use commands that are sent to players globally for %d seconds.", p_AntiSpammyTS[ playerid ] - g_iTime );
	/* ** End Anti Spammy Commands ** */

	new
		iJob;

	if ( isnull( params ) )
		return SendUsage( playerid, "/request [PART OF JOB NAME]" );

	if ( p_Class[ playerid ] == CLASS_POLICE )
		return SendError( playerid, "You must be a civilian to use this command." );

	if ( ( iJob = GetJobIDFromName( params ) ) == 0xFE )
		return SendError( playerid, "You have entered an invalid job." );

	if ( iJob == JOB_RAPIST || iJob == JOB_KIDNAPPER || iJob == JOB_BURGLAR )
		return SendServerMessage( playerid, "%s's do not do any services in exchange for money.", GetJobName( iJob ) );

	if ( JobEquals( playerid, iJob ) )
		return SendError( playerid, "You cannot request for your own job!" );

	new
		Float: X, Float: Y, Float: Z,
		szLocation[ MAX_ZONE_NAME ], szCity[ MAX_ZONE_NAME ]
	;

	GetPlayerPos( playerid, X, Y, Z );
	GetZoneFromCoordinates( szLocation, X, Y, Z );
	Get2DCity( szCity, X, Y, Z );

	foreach(new i : Player) if ( p_Class[ i ] == CLASS_CIVILIAN && JobEquals( i, iJob ) )
		SendClientMessageFormatted( i, -1, ""COL_GREY"[JOB REQUEST]"COL_WHITE" %s(%d) is in need of a %s near %s in %s!", ReturnPlayerName( playerid ), playerid, GetJobName( iJob ), szLocation, szCity );

	p_AntiSpammyTS[ playerid ] = g_iTime + 15;
	SendServerMessage( playerid, "You have requested for a %s in your area.", GetJobName( iJob ) );
	return 1;
}

CMD:work( playerid, params[ ] )
{
	new
		szDifficulty[ 7 ],
		iVehicle = GetPlayerVehicleID( playerid ),
		iModel 	 = GetVehicleModel( iVehicle ),
		iTrailer = GetVehicleModel( GetVehicleTrailer( iVehicle ) )
	;

	if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "You must be an ordinary civilian to use this command." );
	else if ( sscanf( params, "S(NORMAL)[7]", szDifficulty ) ) return SendUsage( playerid, "/work [NORMAL/HARDER]" );
	else if ( strmatch( szDifficulty, "STOP" ) )
	{
		StopPlayerTruckingCourier( playerid );
		return SendServerMessage( playerid, "Your trucking mission has been stopped." );
	}
	else if ( !strmatch( szDifficulty, "NORMAL" ) && !strmatch( szDifficulty, "HARDER" ) ) return SendUsage( playerid, "/work [NORMAL/HARDER/STOP]" );
	else if ( GetPlayerState( playerid ) != PLAYER_STATE_DRIVER ) return SendError( playerid, "You must be a driver of a vehicle to work." );
	else if ( !iModel ) return SendError( playerid, "You are not in any vehicle." );
	else
	{
		if ( iModel == 403 || iModel == 514 || iModel == 515 )
		{
			if ( !p_hasTruckingJob{ playerid } )
			{
				if ( !IsTrailerAttachedToVehicle( iVehicle ) )
					return SendError( playerid, "You can only begin to work only if you have a trailer attached to your vehicle." );

				if ( p_WorkCooldown[ playerid ] > g_iTime )
					return SendError( playerid, "You must wait %d seconds before working again.", p_WorkCooldown[ playerid ] - g_iTime );

				static aPlayer[ 1 ]; aPlayer[ 0 ] = playerid;
				DestroyDynamicMapIcon( p_TruckingMapIcon[ playerid ] );

				p_hasTruckingJob 		{ playerid } = true;
				p_WorkCooldown			[ playerid ] = g_iTime + 60;

				p_TruckingTrailerModel	{ playerid } = getTrailerType( iTrailer );
				p_TruckingTrailer 		{ playerid } = getRandomTrailerLoad( p_TruckingTrailerModel{ playerid }, strmatch( szDifficulty, "HARDER" ) ? RISK_FACTOR_HARD : RISK_FACTOR_EASY );

				p_TruckingRoute[ playerid ] { 0 } = getClosestTruckingRoute( playerid );

			random_route:
				p_TruckingRoute[ playerid ] { 1 } = random( sizeof( g_aTruckingLocations ) );

				if ( p_TruckingRoute[ playerid ] { 0 } == p_TruckingRoute[ playerid ] { 1 } )
					goto random_route;

				p_TruckingTimeElapsed[ playerid ] = g_iTime;
				p_TruckingDistance	[ playerid ] = GetDistanceBetweenPoints( g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 0 } ] [ E_X ], g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 0 } ] [ E_Y ], g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 0 } ] [ E_Z ], g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 1 } ] [ E_X ], g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 1 } ] [ E_Y ], g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 1 } ] [ E_Z ] );
				p_TruckingMapIcon	[ playerid ] = CreateDynamicMapIconEx( g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 0 } ] [ E_X ], g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 0 } ] [ E_Y ], g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 0 } ] [ E_Z ], 51, 0, MAPICON_GLOBAL, 6000.0, { -1 }, { -1 }, aPlayer );
				p_TruckingCheckPoint[ playerid ] = CreateDynamicRaceCP( 0, g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 0 } ] [ E_X ], g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 0 } ] [ E_Y ], g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 0 } ] [ E_Z ], g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 1 } ] [ E_X ], g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 1 } ] [ E_Y ], g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 1 } ] [ E_Z ], 10.0, -1, -1, playerid );

				p_TruckingPositionTimer[ playerid ] = SetTimerEx( "OnTruckPositionUpdate", 750, false, "dd", playerid, p_TruckingRoute[ playerid ] { 0 } );
	  			TextDrawShowForPlayer( playerid, p_TruckingTD[ playerid ] );

				ShowPlayerHelpDialog( playerid, 7500, "A ~g~~h~truck blip~w~~h~ has been shown on your radar. Go to where the truck blip is load your trailer with %s.", g_aTrailerData[ p_TruckingTrailerModel{ playerid } ] [ p_TruckingTrailer{ playerid } ] [ E_NAME ] );
			}
			else SendError( playerid, "You already have a trucking job started! Cancel it with "COL_GREY"/work stop"COL_WHITE"." );
		}
		else SendError( playerid, "There are currently no jobs for this particular vehicle." );
	}
	return 1;
}

CMD:cnr( playerid, params[ ] )
{
	new
		Float: iClass[ 2 ];

	for( new i = 0; i < MAX_PLAYERS; i++ )
		if ( IsPlayerConnected( i ) && i != g_secureTruckDriver )
			iClass[ ( p_Class[ i ] == CLASS_POLICE ? CLASS_POLICE : CLASS_CIVILIAN ) ] ++;

	new
		Float: iCivilians  	= ( iClass[ CLASS_CIVILIAN ] / ( iClass[ CLASS_CIVILIAN ] + iClass[ CLASS_POLICE ] ) ) * 100.0,
		Float: iPolice 		= ( iClass[ CLASS_POLICE ] / ( iClass[ CLASS_CIVILIAN ] + iClass[ CLASS_POLICE ] ) ) * 100.0
	;

	SendClientMessageFormatted( playerid, -1, ""COL_GREY"[SERVER]"COL_WHITE" The server is made up of %0.2f%s robbers and %0.2f%s cops.", iCivilians, "%%", iPolice, "%%" );
	return 1;
}

CMD:eventbank( playerid, params[ ] )
{
	new
		iAmount;

	if ( !strcmp( params, "donate", false, 6 ) )
	{
		/* ** Anti Spammy Commands ** */
		if ( p_AntiSpammyTS[ playerid ] > g_iTime ) return SendError( playerid, "You cannot use commands that are sent to players globally for %d seconds.", p_AntiSpammyTS[ playerid ] - g_iTime );
		/* ** End Anti Spammy Commands ** */

	    if ( sscanf( params[ 7 ], "d", iAmount ) ) return SendUsage( playerid, "/eventbank donate [AMOUNT]" );
	    else if ( iAmount < 5000 ) return SendError( playerid, "You cannot donate less than $5000." );
	    else if ( GetPlayerCash( playerid ) < iAmount ) return SendError( playerid, "You cannot afford to donate this much." );
	    else
	    {
	    	GivePlayerCash( playerid, -iAmount );
			p_AntiSpammyTS[ playerid ] = g_iTime + 15;
			UpdateServerVariable( "eventbank", GetGVarInt( "eventbank" ) + iAmount, 0.0, "", GLOBAL_VARTYPE_INT );
			SendGlobalMessage( playerid, ""COL_GOLD"[EVENT BANK]"COL_WHITE" Thanks for donating %s to the event bank, %s!", ConvertPrice( iAmount ), ReturnPlayerName( playerid ) );
	    }
	}
	else if ( !strcmp( params, "withdraw", false, 8 ) )
	{
	    if ( sscanf( params[ 9 ], "d", iAmount ) ) return SendUsage( playerid, "/eventbank withdraw [AMOUNT]" );
		else if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	    else if ( iAmount < 0 || iAmount > GetGVarInt( "eventbank" ) ) return SendError( playerid, "You cannot withdraw this amount." );
	    else if ( p_AccountID[ playerid ] != GetGVarInt( "eventhost" ) && p_AdminLevel[ playerid ] < 6 ) return SendError( playerid, "You are not designated to use this command." );
	    else
	    {
	    	GivePlayerCash( playerid, iAmount );
			UpdateServerVariable( "eventbank", GetGVarInt( "eventbank" ) - iAmount, 0.0, "", GLOBAL_VARTYPE_INT );
			SendGlobalMessage( -1, ""COL_GOLD"[EVENT BANK]"COL_WHITE" %s(%d) has withdrawn %s from the event bank!", ReturnPlayerName( playerid ), playerid, ConvertPrice( iAmount ) );
	    }
	}
	else if ( strmatch( params, "balance" ) )
	{
		SendServerMessage( playerid, "The event bank balance is "COL_GOLD"%s"COL_WHITE". To donate, type "COL_GREY"/eventbank donate"COL_WHITE".", ConvertPrice( GetGVarInt( "eventbank" ) ) );
	}
	else if ( strmatch( params, "host" ) )
	{
		mysql_function_query( dbHandle, "SELECT f.`NAME` FROM `USERS` f LEFT JOIN `SERVER` m ON m.`INT_VAL` = f.`ID` WHERE m.`NAME` = 'eventhost'", true, "geteventhost", "i", playerid );
	}
	else SendUsage( playerid, "/eventbank [BALANCE/DONATE/WITHDRAW/HOST]" );
	return 1;
}

thread geteventhost( playerid )
{
	new
		rows, fields;

    cache_get_data( rows, fields );
	if ( rows )
	{
		new
			szName[ MAX_PLAYER_NAME ];

		cache_get_field_content( 0, "NAME", szName );
		SendServerMessage( playerid, "The event bank host designated at the moment is "COL_GREY"%s"COL_WHITE".", szName );
	}
	else SendError( playerid, "An error has occurred, try again later." );
	return 1;
}

CMD:unbanme( playerid, params[ ] )
{
	ShowPlayerDialog( playerid, DIALOG_UNBAN_CLASS, DIALOG_STYLE_LIST, ""COL_WHITE"Unban Class", ""COL_GOLD"$750,000"COL_WHITE"\tUnban Army Class\n"COL_GOLD"$500,000"COL_WHITE"\tUnban Cop Class\n", "Select", "Close" );
	return 1;
}

CMD:packetloss( playerid, params[ ] ) return cmd_pl( playerid, params );
CMD:pl( playerid, params[ ] )
{
	SendServerMessage( playerid, "Your packet loss is %0.2f%s.", NetStats_PacketLossPercent( playerid ), "%%" );
	return 1;
}

CMD:chuffloc( playerid, params[ ] )
{
#if ENABLED_SECURE_TRUCK == true
	static
		Float: X, Float: Y, Float: Z,
		szCity[ MAX_ZONE_NAME ], szLocation[ MAX_ZONE_NAME ]
	;

	if ( IsSecurityDriverAFK( ) ) SendServerMessage( playerid, "ChuffSec is currently immobile and not making any deliveries at present." );
	else
	{
		if ( GetPlayerPos( g_secureTruckDriver, X, Y, Z ) )
		{
		  	Get2DCity( szCity, X, Y, Z );
		    GetZoneFromCoordinates( szLocation, X, Y, Z );
			SendServerMessage( playerid, "ChuffSec schedules show that the security truck is located near %s in %s.", szLocation, szCity );
		}
		else SendServerMessage( playerid, "ChuffSec is currently immobile and not making any deliveries at present." );
	}
#else
	SendServerMessage( playerid, "This feature is currently disabled." );
#endif
	return 1;
}

CMD:deathmessage( playerid, params[ ] ) return cmd_deathmsg( playerid, params );
CMD:deathmsg( playerid, params[ ] )
{
	if ( p_VIPLevel[ playerid ] < 1 )
		return SendError( playerid, "You are not a V.I.P, to become one visit "COL_GREY"donate.irresistiblegaming.com" );

	new
		szDeathMessage[ sizeof( p_DeathMessage[ ] ) ];

	if ( sscanf( params, "s[32]", szDeathMessage ) )
	{
		if ( !isnull( szDeathMessage ) )
		{
			p_DeathMessage[ playerid ] [ 0 ] = '\0';
			return SendServerMessage( playerid, "Death message has been disabled." );
		}
		return SendUsage( playerid, "/deathmessage [MESSAGE (leave blank to disable)]" );
	}

	if ( textContainsIP( szDeathMessage ) || textContainsBadTextdrawLetters( szDeathMessage ) )
		return SendError( playerid, "Invalid death message." );

	format( p_DeathMessage[ playerid ], sizeof( p_DeathMessage[ ] ), "%s", szDeathMessage );
	SendServerMessage( playerid, "You have set your death message to "COL_GREY"%s"COL_WHITE".", szDeathMessage );
	return 1;
}

CMD:calc( playerid, params[ ] ) return cmd_calculate( playerid, params );
CMD:calculate( playerid, params[ ] ) {
	new
		szExpression[ 72 ],
		e_Error: iError
	;

	if ( sscanf( params, "s[72]", szExpression ) ) return SendUsage( playerid, "/calc(ulate) [EXPRESSION]" );
	else if ( GetPlayerScore( playerid ) < 750 ) return SendError( playerid, "You cannot use this as you're beneath 750 score." );
	else
	{
		new Float: fValue = Math::ParseExpression( szExpression, iError );

		if ( iError != e_Error: ERROR_NONE )
			return SendError( playerid, "Something is wrong with your calculation!" );

		if ( fValue == Float: 0x7FFFFFFF || fValue == Float: 0x7F800000 || fValue == Float: 0xFF800000 || fValue == Float: 0x7FBFFFFF )
			return SendError( playerid, "The value returned cannot be displayed as it is breaches 32-bit integer limits." );

		SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[CALCULATOR]"COL_WHITE" %s = %.3f", szExpression, fValue );
	}
	return 1;
}

CMD:idletime( playerid, params[ ] )
{
	new
		iPlayer;

	if ( sscanf( params, ""#sscanf_u"", iPlayer ) ) return SendUsage( playerid, "/idletime [PLAYER_ID]" );
	if ( !IsPlayerConnected( iPlayer ) || IsPlayerNPC( iPlayer ) ) return SendError( playerid, "This player isn't connected." );

	new
		Float: iTime = float( GetTickCount( ) - p_AFKTime[ iPlayer ] );

	if ( iTime > 1000.0 )
	{
		iTime /= 1000.0;
		SendServerMessage( playerid, "%s(%d)'s idle time is "COL_GREY"%0.2f seconds (s)", ReturnPlayerName( iPlayer ), iPlayer, iTime );
	}
	else
	{
		SendServerMessage( playerid, "%s(%d)'s idle time is "COL_GREY"%0.0f milliseconds (ms)", ReturnPlayerName( iPlayer ), iPlayer, iTime );
	}
	return 1;
}

#if ENABLED_EASTER_EGG == true
	CMD:treasures( playerid, params[ ] )
	{
		new
			count = Iter_Count(eastereggs);

		if ( !g_EasterHunt )
			return SendError( playerid, "Treasure Hunt isn't activated thus this feature is disabled." );

	 	if ( !count )
	 		SendServerMessage( playerid, "There are no " #EASTEREGG_NAME "s currently planted." );
	 	else
	 		SendServerMessage( playerid, "There are %d " #EASTEREGG_NAME "(s) currently planted at the moment.", count );
		return 1;
	}
#endif

CMD:redeemvip( playerid, params[ ] ) return cmd_donated( playerid, params );
CMD:donated( playerid, params[ ] )
{
	ShowPlayerDialog( playerid, DIALOG_VIP, DIALOG_STYLE_INPUT, ""COL_GOLD"Irresistible Gaming Donation", ""COL_WHITE"Enter the transaction ID of your donation below.\n\n"COL_GREY"See http://forum.irresistiblegaming.com/showthread.php?10125 for details.", "Redeem", "Close" );
	return 1;
}

CMD:pb( playerid, params[ ] ) return cmd_paintball( playerid, params );
CMD:paintball( playerid, params[ ] )
{
	if ( !IsPlayerInPaintBall( playerid ) )
		return SendError( playerid, "You're not in any paintball lobby." );

	if ( !hasPaintBallArena( playerid ) )
		return SendError( playerid, "This command requires you to be the host of a lobby." );

	new
		id = p_PaintBallArena{ playerid },
		pID
	;

	if ( strmatch( params, "edit" ) )
	{
		showPaintBallLobbyData( playerid, id, "Close" );
	}
	else if ( !strcmp( params, "kick", false, 4 ) )
	{
		if ( sscanf( params[ 5 ], #sscanf_u, pID ) ) return SendUsage( playerid, "/paintball kick [PLAYER_ID]" );
		else if ( !IsPlayerConnected( pID ) ) return SendError( playerid, "This player is not connected." );
		else if ( !IsPlayerInPaintBall( pID ) ) return SendError( playerid, "This player is not in paintball." );
		else if ( p_PaintBallArena{ pID } != id ) return SendError( playerid, "This player is not in your paintball lobby." );
		else if ( pID == playerid ) return SendError( playerid, "You cannot kick yourself." );
		else
		{
			SendClientMessageToPaintball( id, -1, ""COL_GREY"[PAINTBALL]"COL_WHITE" %s(%d) has left the lobby (KICKED)", ReturnPlayerName( pID ), pID );
			LeavePlayerPaintball( pID );
			SetPlayerHealth( pID, -1 );
		}
	}
	else if ( !strcmp( params, "leader", false, 6 ) )
	{
		if ( sscanf( params[ 7 ], #sscanf_u, pID ) ) return SendUsage( playerid, "/paintball paintball [PLAYER_ID]" );
		else if ( !IsPlayerConnected( pID ) ) return SendError( playerid, "This player is not connected." );
		else if ( !IsPlayerInPaintBall( pID ) ) return SendError( playerid, "This player is not in paintball." );
		else if ( p_PaintBallArena{ pID } != id ) return SendError( playerid, "This player is not in your paintball lobby." );
		else if ( pID == playerid ) return SendError( playerid, "You cannot apply this action to yourself." );
		else
		{
			g_paintballData[ id ] [ E_HOST ] = pID;
			SendClientMessageToPaintball( id, -1, ""COL_GREY"[PAINTBALL]"COL_WHITE" %s(%d) is the new paintball leader.", ReturnPlayerName( pID ), pID );
		}
	}
	else if ( !strcmp( params, "countdown", false, 6 ) )
	{
		new
			iSeconds;

		if ( sscanf( params[ 10 ], "D(10)", iSeconds ) ) return SendUsage( playerid, "/paintball countdown [SECONDS]" );
		else if ( iSeconds < 1 || iSeconds > 30 ) return SendError( playerid, "Please specify countdown seconds between 1 and 30." );
		else
		{
			SendServerMessage( playerid, "You have started a countdown from %d in your paintball game.", iSeconds );

		 	KillTimer( g_paintballData[ id ] [ E_CD_TIMER ] );
			g_paintballData[ id ] [ E_CD_TIMER ] = SetTimerEx( "paintballCountDown", 960, false, "dd", id, iSeconds - 1 );
		}
	}
	else SendUsage( playerid, "/paintball [EDIT/KICK/COUNTDOWN/LEADER]" );
	return 1;
}


function paintballCountDown( paintballid, time )
{
	if ( paintballid == -1 )
		return;

	if ( !time )
	{
	    foreach(new playerid : Player)
	    {
	    	if ( IsPlayerInPaintBall( playerid ) && p_PaintBallArena{ playerid } == paintballid )
	    	{
	    		GameTextForPlayer( playerid, "~g~GO!", 2000, 3 );
				PlayerPlaySound( playerid, 1057, 0.0, 0.0, 0.0 );
			}
		}
		g_paintballData[ paintballid ] [ E_CD_TIMER ] = 0xFFFF;
	}
	else
	{
	    foreach(new playerid : Player)
	    {
	    	if ( IsPlayerInPaintBall( playerid ) && p_PaintBallArena{ playerid } == paintballid )
	    	{
	    		GameTextForPlayer( playerid, sprintf( "~y~%d", time ), 2000, 3 );
	    		PlayerPlaySound( playerid, 1056, 0.0, 0.0, 0.0 );
	    	}
	    }
		g_paintballData[ paintballid ] [ E_CD_TIMER ] = SetTimerEx( "paintballCountDown", 960, false, "dd", paintballid, time - 1 );
	}
}

CMD:gate( playerid, params[ ] )
{
	new
        Float: distance = 99999.99,
		gID = getClosestGate( playerid, distance )
	;

	if ( gID == INVALID_OBJECT_ID )
		return SendError( playerid, "You're not near any gates." );

	if ( strmatch( params, "edit" ) )
	{
		if ( g_gateData[ gID ] [ E_OWNER ] != p_AccountID[ playerid ] )
			return SendError( playerid, "You need to be the owner of this gate to edit it." );

		format( szNormalString, sizeof( szNormalString ), "Name\t\t\t\t"COL_GREY"%s"COL_WHITE"\nPassword\t\t\t"COL_GREY"%s"COL_WHITE"", g_gateData[ gID ] [ E_NAME ], g_gateData[ gID ] [ E_PASS ] );
		ShowPlayerDialog( playerid, DIALOG_GATE_OWNER, DIALOG_STYLE_LIST, "{FFFFFF}Edit Gate", szNormalString, "Select", "Cancel" );

		SetPVarInt( playerid, "gate_o_editing", gID );
		SendClientMessageFormatted( playerid, -1, ""COL_GREY"[GATE]"COL_WHITE" You're now editing "COL_GREY"%s"COL_WHITE".", g_gateData[ gID ] [ E_NAME ] );
	}
	else if ( !strcmp( params, "open", true, 4 ) )
	{
		new
			szPassword[ 8 ];

		strreplacechar( params, '\\', '/' );

		if ( sscanf( params[ 5 ], "s[8]", szPassword ) )
			return SendUsage( playerid, "/gate open [PASSWORD]" );

		new
			gates = 0;

		foreach(new g : gates)
		{
			if ( ( distance = GetPlayerDistanceFromPoint( playerid, g_gateData[ g ] [ E_X ], g_gateData[ g ] [ E_Y ], g_gateData[ g ] [ E_Z ] ) ) > g_gateData[ g ] [ E_RANGE ] )
				continue; // return SendError( playerid, "You're not within the gates' operation range." );

			if ( strcmp( szPassword, g_gateData[ g ] [ E_PASS ], false ) )
				continue; // return SendError( playerid, "Incorrect password. Please try again." );

			if ( g_gateData[ g ] [ E_CLOSE_TIMER ] != -1 )
				continue; // return SendError( playerid, "This gate is currently in operation. Please wait." );

			if ( !strmatch( g_gateData[ g ] [ E_NAME ], "N/A" ) )
				SendClientMessageFormatted( playerid, -1, ""COL_GREY"[GATE]"COL_WHITE" You've opened "COL_GREY"%s"COL_WHITE".", g_gateData[ g ] [ E_NAME ] );

			new
				travelInterval = MoveDynamicObject( g_gateData[ g ] [ E_OBJECT ], g_gateData[ g ] [ E_MOVE_X ], g_gateData[ g ] [ E_MOVE_Y ], g_gateData[ g ] [ E_MOVE_Z ], g_gateData[ g ] [ E_SPEED ], g_gateData[ g ] [ E_MOVE_RX ], g_gateData[ g ] [ E_MOVE_RY ], g_gateData[ g ] [ E_MOVE_RZ ] );

			g_gateData[ g ] [ E_CLOSE_TIMER ] = SetTimerEx( "StartGateClose", travelInterval + g_gateData[ g ] [ E_TIME ], false, "d", g );
			gates++;
		}
		return !gates ? SendError( playerid, "Either a gate is in operation, not in range or simply incorrect password." ) : 1;
	}
	else if ( strmatch( params, "closest" ) && p_AdminLevel[ playerid ] > 1 )
	{
		SendServerMessage( playerid, "The closest gate to you is "COL_GREY"%s"COL_WHITE". (id: %d, distance: %f)", g_gateData[ gID ] [ E_NAME ], gID, distance );
	}
	else SendUsage( playerid, "/gate [OPEN/EDIT]" );
	return 1;
}

CMD:meth( playerid, params[ ] )
{
	if ( strmatch( params, "cook" ) )
	{
		if ( !IsPlayerInMethlab( playerid ) )
			return SendError( playerid, "You need to be in a methlab to use this command." );

		new
			vehicleid = GetPlayerMethLabVehicle( playerid ),
			objectid = GetGVarInt( "meth_yield", vehicleid )
		;
		if ( IsValidVehicle( vehicleid ) && GetVehicleModel( vehicleid ) == 508 )
		{
			if ( !IsPlayerInRangeOfPoint( playerid, 2.0, 1476.0264, 1463.6255, 1011.8170 ) )
				return SendError( playerid, "You're not near the lab." );

			if ( GetGVarInt( "meth_soda", vehicleid ) != 0 || GetGVarInt( "meth_acid", vehicleid ) != 0 || GetGVarInt( "meth_chloride", vehicleid ) != 0 )
				return SendError( playerid, "This methlab is already in operation." );

			if ( GetGVarType( "meth_cooktimer", vehicleid ) != GLOBAL_VARTYPE_NONE  )
				return SendError( playerid, "This methlab is already in operation." );

			if ( IsValidDynamicObject( objectid ) && Streamer_GetIntData( STREAMER_TYPE_OBJECT, objectid, E_STREAMER_MODEL_ID ) == 1579 )
				return SendError( playerid, "You must grab the meth before you continue." );

			if ( !p_CausticSoda{ playerid } && !p_HydrogenChloride{ playerid } && !p_MuriaticAcid{ playerid } )
				return SendError( playerid, "You're light on Caustic Soda, Hydrogen Chloride and Muriatic Acid." );

			if ( p_Class[ playerid ] != CLASS_CIVILIAN )
				return SendError( playerid, "This is restricted to civilians only." );

			new
				iMethIngredient = random( 3 );

			SendServerMessage( playerid, "You're now beginning the methamphetamine production. Follow the dialog to yield a pound of meth." );

			SetGVarInt( "meth_ingredient", iMethIngredient, vehicleid );
			SetGVarInt( "meth_soda", 1, vehicleid );
			SetGVarInt( "meth_acid", 1, vehicleid );
			SetGVarInt( "meth_chloride", 1, vehicleid );
			SetGVarInt( "meth_chef", playerid, vehicleid );

			switch( iMethIngredient )
			{
				case CHEMICAL_HLC: 	ShowPlayerHelpDialog( playerid, 12500, "%s", sz_hcl_MethProduction[ random( sizeof( sz_hcl_MethProduction ) ) ] );
				case CHEMICAL_MU:	ShowPlayerHelpDialog( playerid, 12500, "%s", sz_mu_MethProduction[ random( sizeof( sz_mu_MethProduction ) ) ] );
				case CHEMICAL_CS:	ShowPlayerHelpDialog( playerid, 12500, "%s", sz_cs_MethProduction[ random( sizeof( sz_cs_MethProduction ) ) ] );
			}
		}
		else SendError( playerid, "An unexpected error has occurred, please re-enter your methlab." );
	}
	else if ( strmatch( params, "export" ) )
	{
		if ( GetPlayerInterior( playerid ) != 9 )
			return SendError( playerid, "You must be inside Cluckin' Bell to use this command." );

		if ( !IsPlayerInRangeOfPoint( playerid, 2.0, 364.9201, -5.3505, 1001.8516 ) )
			return SendError( playerid, "You need to near the kitchen door inside Cluckin' Bell." );

		if ( !p_Methamphetamine{ playerid } )
			return SendError( playerid, "You don't have any meth to export." );

		if ( p_Class[ playerid ] != CLASS_CIVILIAN )
			return SendError( playerid, "This is restricted to civilians only." );

		new
			cashEarned = p_Methamphetamine{ playerid } * ( 3500 + random( 1000 ) );

		GivePlayerCash( playerid, cashEarned );
		SendServerMessage( playerid, "You have exported %d bags of meth, earning you "COL_GOLD"%s"COL_WHITE".", p_Methamphetamine{ playerid }, ConvertPrice( cashEarned ) );
		p_Methamphetamine{ playerid } = 0;
	}
	else SendUsage( playerid, "/meth [COOK/EXPORT]" );
	return 1;
}

CMD:ore( playerid, params[ ] )
{
	new Float: X, Float: Y, Float: Z;

	if ( strmatch( params, "mine" ) )
	{
		if ( IsPlayerAttachedObjectSlotUsed( playerid, 4 ) ) return SendError( playerid, "You cannot mine while you have ore in your hands!" );
		if ( !IsWeaponInAnySlot( playerid, WEAPON_SHOVEL ) ) return SendError( playerid, "Pick up a shovel before you start mining!" );
		if ( IsPlayerAttachedObjectSlotUsed( playerid, 3 ) ) return SendError( playerid, "You have a stolen item in your hands, store that then go mine." );
		if ( p_InAnimation{ playerid } == true ) 			return SendError( playerid, "You may continue once you've stopped the animation." );

		foreach(new m : miningrock)
		{
			if ( !IsPlayerConnected( g_miningData[ m ] [ E_MINING ] ) )
			{
				GetDynamicObjectPos( g_miningData[ m ] [ E_OBJECT ], X, Y, Z );
				if ( IsPlayerInRangeOfPoint( playerid, 2.0, X, Y, Z ) )
				{
					if ( g_miningData[ m ] [ E_ORES ] <= 0 )
						return SendError( playerid, "There are no ores left in this rock." );

					SetPlayerArmedWeapon( playerid, WEAPON_SHOVEL );
					SetPlayerFacePoint( playerid, X, Y, Z );
					ApplyAnimation( playerid, "BASEBALL", "Bat_4", 2.0, 1, 0, 0, 0, 0 );
					p_isMining{ playerid } = true;
					g_miningData[ m ] [ E_MINING ] = playerid;
					p_MiningOre{ playerid } = m;
					ShowProgressBar( playerid, "Mining Rock", PROGRESS_MINING, g_oreMiningTime[ g_miningData[ m ] [ E_ORE ] ], g_miningData[ m ] [ E_COLOR ] );
					SendServerMessage( playerid, "You're now mining a rock." );
					return 1;
				}
			}
		}
		SendError( playerid, "Someone is currently mining this rock or you're not near an available rock." );
	}
	else if ( strmatch( params, "store" ) )
	{
		new
			vehicleid = GetClosestVehicle( playerid ),
			ore = GetPVarInt( playerid, "carrying_ore" ),
			Float: Angle, szID[ 15 ], szOres[ 15 ]
		;

		if ( !IsValidVehicle( vehicleid ) ) return SendError( playerid, "You're not near any vehicles." );
		if ( GetVehicleModel( vehicleid ) != 573 ) return SendError( playerid, "The vehicle you're near is not a Dune." );
		if ( !IsPlayerAttachedObjectSlotUsed( playerid, 4 ) ) return SendError( playerid, "You aren't holding anything!" );
	    GetVehiclePos( vehicleid, X, Y, Z );
	    GetVehicleZAngle( vehicleid, Angle );
	    X += ( 4.0 * floatsin( -Angle + 180, degrees ) );
	    Y += ( 4.0 * floatcos( -Angle + 180, degrees ) );
	    if ( !IsPlayerInRangeOfPoint( playerid, 1.5, X, Y, Z ) ) return SendError( playerid, "Make sure you're behind the vehicle!" );

		format( szOres, sizeof( szOres ), "mine_%d_ores", vehicleid );
		if ( GetGVarInt( szOres ) >= MAX_ORE_STORAGE ) return SendError( playerid, "You can only carry "#MAX_ORE_STORAGE" ores in this vehicle." );

		SetGVarInt( szOres, GetGVarInt( szOres ) + 1 );
		format( szID, sizeof( szID ), "mine_%d_cash", vehicleid ), SetGVarInt( szID, GetGVarInt( szID ) + g_orePrices[ g_miningData[ ore ] [ E_ORE ] ] );

		SendServerMessage( playerid, "You have stored a "COL_GREY"%s"COL_WHITE" ore in this Dune. "COL_ORANGE"[%d/"#MAX_ORE_STORAGE"]", getOreName( g_miningData[ ore ] [ E_ORE ] ), GetGVarInt( szOres ) );

		RemoveEquippedOre( playerid );
	}
	else if ( strmatch( params, "value" ) )
	{
		new
			vehicleid = GetPlayerVehicleID( playerid ),
			szOres[ 15 ], szCash[ 15 ]
		;

		if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You're not in any vehicle." );
		if ( GetVehicleModel( vehicleid ) != 573 ) return SendError( playerid, "The vehicle you're near is not a Dune." );

		format( szOres, sizeof( szOres ), "mine_%d_ores", vehicleid );
		format( szCash, sizeof( szCash ), "mine_%d_cash", vehicleid );

		SendServerMessage( playerid, "This Dune has %d ore(s) which values "COL_GOLD"%s"COL_WHITE".", GetGVarInt( szOres ), ConvertPrice( GetGVarInt( szCash ) ) );
	}
	else SendUsage( playerid, "/ore [MINE/STORE/VALUE]" );
	return 1;
}

CMD:robitems( playerid, params[ ] )
{
	/* ** ANTI ROB SPAM ** */
    if ( GetPVarInt( playerid, "robitems_timestamp" ) > g_iTime ) return SendError( playerid, "You must wait at least a minute before swindling another person." );
    /* ** END OF ANTI SPAM ** */

  	new victimid = GetClosestPlayer( playerid );
   	if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "This is restricted to civilians only." );
   	else if ( !JobEquals( playerid, JOB_PROSTITUTE ) ) return SendError( playerid, "You must be a prostitute to use this command." );
   	else if ( p_Spectating{ playerid } ) return SendError( playerid, "You cannot use such commands while you're spectating." );
	else if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "It's impossible to rob someone inside a car." );
	else if ( GetDistanceBetweenPlayers( playerid, victimid ) < 4.0 && IsPlayerConnected( victimid ) )
	{
  		if ( IsPlayerInAnyVehicle( victimid ) ) return SendError( playerid, "This player is in a vehicle." );
		if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this command since you're jailed." );
		if ( IsPlayerTazed( playerid ) ) return SendError( playerid, "You cannot use this command since you're tazed." );
		if ( IsPlayerDetained( playerid ) ) return SendError( playerid, "You cannot use this command since you're detained." );
		if ( IsPlayerCuffed( playerid ) ) return SendError( playerid, "You cannot use this command since you're cuffed." );
		if ( IsPlayerTied( playerid ) ) return SendError( playerid, "You cannot use this command since you're tied." );
		if ( IsPlayerKidnapped( playerid ) ) return SendError( playerid, "You cannot use this command since you're kidnapped." );
		if ( IsPlayerInPaintBall( playerid ) ) return SendError( playerid, "You cannot use this command since you're inside the paintball arena." );
		if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You cannot use this command inside a vehicle." );
		if ( IsPlayerGettingBlowed( playerid ) ) return SendError( playerid, "You cannot use this command since you're getting blowed." );
		if ( IsPlayerBlowingCock( playerid ) ) return SendError( playerid, "You cannot use this command since you're giving oral sex." );
		if ( IsPlayerAdminOnDuty( victimid ) ) return SendError( playerid, "You cannot use this command on admins that are on duty." );
		if ( IsPlayerJailed( victimid ) ) return SendError( playerid, "This player is jailed. He may be paused." );

		SetPVarInt( playerid, "robitems_timestamp", g_iTime + 60 );
		GivePlayerWantedLevel( playerid, 4 );
		GivePlayerScore( playerid, 1 );

		new
			available_items[ 3 ] = { -1, -1, -1 },
			iRandomItem = -1
		;

		if ( p_BobbyPins[ victimid ] > 0 && p_BobbyPins[ playerid ] < LIMIT_PINS ) 	available_items[ 0 ] = 0;
		if ( p_Scissors[ victimid ] > 0 && p_Scissors[ playerid ] < LIMIT_SCISSORS ) available_items[ 1 ] = 1;
		if ( p_Ropes[ victimid ] > 0 && p_Ropes[ playerid ] < LIMIT_ROPES ) 			available_items[ 2 ] = 2;

		if ( available_items[ 0 ] == -1 || available_items[ 1 ] == -1 || available_items[ 2 ] == -1 ) {
			SendClientMessageFormatted( victimid, -1, ""COL_GREEN"[ROB FAIL]{FFFFFF} %s(%d) has failed to rob items off you.", ReturnPlayerName( playerid ), playerid );
		    SendClientMessageFormatted( playerid, -1, ""COL_RED"[ROB FAIL]{FFFFFF} You find nothing in %s(%d)'s pocket and he noticed you after thoroughly checking.", ReturnPlayerName( victimid ), victimid );
		    return 1;
		}

		iRandomItem = randomArrayItem( available_items, -1 );

		switch( iRandomItem )
		{
			case 0: // Pins
			{
				p_BobbyPins[ victimid ] --, p_BobbyPins[ playerid ] ++;
				SendClientMessageFormatted( victimid, -1, ""COL_RED"[ROBBED]{FFFFFF} %s(%d) has pinched a bobby pin off you!", ReturnPlayerName( playerid ), playerid );
			    SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[ROBBED]{FFFFFF} You have pinched a bobby pin off %s(%d)!", ReturnPlayerName( victimid ), victimid );
			}
			case 1: // Scissors
			{
				p_Scissors[ victimid ] --, p_Scissors[ playerid ] ++;
				SendClientMessageFormatted( victimid, -1, ""COL_RED"[ROBBED]{FFFFFF} %s(%d) has pinched a pair of scissors off you!", ReturnPlayerName( playerid ), playerid );
			    SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[ROBBED]{FFFFFF} You have pinched a pair of scissors off %s(%d)!", ReturnPlayerName( victimid ), victimid );
			}
			case 2: // Ropes
			{
				p_Ropes[ victimid ] --, p_Ropes[ playerid ] ++;
				SendClientMessageFormatted( victimid, -1, ""COL_RED"[ROBBED]{FFFFFF} %s(%d) has pinched a rope off you!", ReturnPlayerName( playerid ), playerid );
			    SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[ROBBED]{FFFFFF} You have pinched a rope off %s(%d)!", ReturnPlayerName( victimid ), victimid );
			}
		}
 	}
 	else SendError( playerid, "There are no players around to rob." );
	return 1;
}

CMD:bruteforce( playerid, params[ ] )
{
	/* ** ANTI SPAM ** */
    if ( GetPVarInt( playerid, "last_bruteforce" ) > g_iTime ) return SendError( playerid, "You must wait 30 seconds before using this command again." );
    /* ** END OF ANTI SPAM ** */

	if ( p_Class[ playerid ] != CLASS_POLICE ) return SendError( playerid, "This command is restricted for F.B.I agents." );
	if ( !( p_inFBI{ playerid } == true && p_inArmy{ playerid } == false && p_inCIA{ playerid } == false ) ) return SendError( playerid, "This command is restricted for F.B.I agents." );

	for( new i; i < MAX_HOUSES; i++ )
	{
		if ( g_houseData[ i ] [ E_CREATED ] )
		{
			if ( IsPlayerInDynamicCP( playerid, g_houseData[ i ] [ E_CHECKPOINT ] [ 0 ] ) && !strmatch( g_houseData[ i ] [ E_OWNER ], ReturnPlayerName( playerid ) ) )
			{
				if ( g_iTime > g_houseData[ i ] [ E_CRACKED_TS ] && g_houseData[ i ] [ E_CRACKED ] ) g_houseData[ i ] [ E_CRACKED ] = false; // The Virus Is Disabled.

				if ( g_houseData[ i ] [ E_CRACKED_WAIT ] > g_iTime )
				    return SendError( playerid, "This house had its password recently had a cracker run through. Come back later." );

				if ( strmatch( g_houseData[ i ] [ E_PASSWORD ], "N/A" ) )
				    return SendError( playerid, "This house does not require cracking as it doesn't have a password." );

				if ( g_houseData[ i ] [ E_CRACKED ] || g_houseData[ i ] [ E_BEING_CRACKED ] )
				    return SendError( playerid, "This house is currently being cracked or is already cracked." );

		        if ( IsHouseOnFire( i ) )
			       	return SendError( playerid, "This house is on fire, you cannot bruteforce it!" ), 1;

                g_houseData[ i ] [ E_BEING_CRACKED ] = true;
                p_HouseCrackingPW[ playerid ] = i;
                SetPVarInt( playerid, "last_bruteforce", g_iTime + 30 );
				ShowProgressBar( playerid, "Brute Forcing Password", PROGRESS_BRUTEFORCE, 500, COLOR_BLUE );
	            return 1;
			}
		}
	}
	SendError( playerid, "You are not standing in any house checkpoint." );
	return 1;
}

CMD:pdjail( playerid, params[ ] )
{
	erase( szBigString );

	new
		time = g_iTime;

	for( new i = 0; i < sizeof( g_jailData ); i++ ) {
		if ( g_jailData[ i ] [ E_TIMESTAMP ] < time )
			format( szBigString, sizeof( szBigString ), "%s"COL_GREY"%s"COL_WHITE"\t"COL_GREEN"Available To Raid!\n", szBigString, returnCityName( g_jailData[ i ] [ E_CITY ] ) );
		else
			format( szBigString, sizeof( szBigString ), "%s"COL_GREY"%s"COL_WHITE"\t%s\n", szBigString, returnCityName( g_jailData[ i ] [ E_CITY ] ), secondstotime( g_jailData[ i ] [ E_TIMESTAMP ] - time ) );
	}

	if ( g_alcatrazTimestamp < time )
		strcat( szBigString, ""COL_GREY"Alcatraz"COL_WHITE"\t"COL_GREEN"Available To Raid!" );
	else
		format( szBigString, sizeof( szBigString ), "%s"COL_GREY"Alcatraz"COL_WHITE"\t%s\n", szBigString, secondstotime( g_alcatrazTimestamp - time ) );

	ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_MSGBOX, "{FFFFFF}Police Jails", szBigString, "Okay", "" );
	return 1;
}

CMD:banks( playerid, params[ ] )
{
	erase( szBigString );

	for( new i = 0, time = g_iTime; i < sizeof( g_bankvaultData ); i++ ) {
		if ( g_bankvaultData[ i ] [ E_TIMESTAMP ] < time )
			format( szBigString, sizeof( szBigString ), "%s"COL_GREY"%s"COL_WHITE"\t"COL_GREEN"Available To Rob!\n", szBigString, returnCityName( g_bankvaultData[ i ] [ E_CITY ] ) );
		else
			format( szBigString, sizeof( szBigString ), "%s"COL_GREY"%s"COL_WHITE"\t%s\n", szBigString, returnCityName( g_bankvaultData[ i ] [ E_CITY ] ), secondstotime( g_bankvaultData[ i ] [ E_TIMESTAMP ] - time ) );
	}
	ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_MSGBOX, "{FFFFFF}Banks", szBigString, "Okay", "" );
	return 1;
}

CMD:burglar( playerid, params[ ] )
{
	if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "You are not a civilian." );
	if ( !JobEquals( playerid, JOB_BURGLAR ) ) return SendError( playerid, "You are not a burglar." );

	if ( isnull( params ) ) return SendUsage( playerid, "/burglar [CRACKPW/STEAL/STORE]" );
	else if ( strmatch( params, "crackpw" ) )
	{
		if ( GetPVarInt( playerid, "crackpw_cool" ) > g_iTime ) return SendError( playerid, "You must wait 40 seconds before using this command again." );

		for( new i; i < MAX_HOUSES; i++ )
		{
			if ( g_houseData[ i ] [ E_CREATED ] )
			{
				if ( IsPlayerInDynamicCP( playerid, g_houseData[ i ] [ E_CHECKPOINT ] [ 0 ] ) && !strmatch( g_houseData[ i ] [ E_OWNER ], ReturnPlayerName( playerid ) ) )
				{
					if ( g_iTime > g_houseData[ i ] [ E_CRACKED_TS ] && g_houseData[ i ] [ E_CRACKED ] ) g_houseData[ i ] [ E_CRACKED ] = false; // The Virus Is Disabled.

					if ( g_houseData[ i ] [ E_CRACKED_WAIT ] > g_iTime )
					    return SendError( playerid, "This house had its password recently had a cracker run through. Come back later." );

					if ( strmatch( g_houseData[ i ] [ E_PASSWORD ], "N/A" ) )
					    return SendError( playerid, "This house does not require cracking as it doesn't have a password." );

					if ( g_houseData[ i ] [ E_CRACKED ] || g_houseData[ i ] [ E_BEING_CRACKED ] )
					    return SendError( playerid, "This house is currently being cracked or is already cracked." );

			        if ( IsHouseOnFire( i ) )
				       	return SendError( playerid, "This house is on fire, you cannot crack it!" ), 1;

	                g_houseData[ i ] [ E_BEING_CRACKED ] = true;
	                p_HouseCrackingPW[ playerid ] = i;
	                SetPVarInt( playerid, "crackpw_cool", g_iTime + 40 );
					ShowProgressBar( playerid, "Cracking Password", PROGRESS_CRACKING, 750, COLOR_WHITE );
		            return 1;
				}
			}
		}
		SendError( playerid, "You are not standing in any house checkpoint." );
	}
	else if ( strmatch( params, "steal" ) )
	{
	    new
	        Float: distance = 99999.99,
			furnitureID = getClosestFurniture( playerid, distance )
		;
	    if ( p_InHouse[ playerid ] == -1 ) return SendError( playerid, "You're not inside any house." );
    	if ( strmatch( g_houseData[ p_InHouse[ playerid ] ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You can't steal a piece of furniture from your house!" );
    	if ( furnitureID == INVALID_OBJECT_ID ) return SendError( playerid, "No furniture is in this house." );
		if ( distance > 3.0 ) return SendError( playerid, "You are not close to any furniture." );
		if ( g_houseFurniture[ GetGVarInt( "fur_f", furnitureID ) ] [ E_CATEGORY ] != FC_ELECTRONIC ) return SendError( playerid, "The furniture you're near is not an electronic." );
		if ( IsPlayerAttachedObjectSlotUsed( playerid, 3 ) ) return SendError( playerid, "Your hands are busy at the moment." );

		new
			houseid = p_InHouse[ playerid ];

		if ( IsPointToPoint( 150.0, g_houseData[ houseid ] [ E_EX ], g_houseData[ houseid ] [ E_EY ], g_houseData[ houseid ] [ E_EZ ], -2480.1426, 5.5302, 25.6172 ) )
			return SendError( playerid, "This house is prohibited from burglarly features as it is too close to the Pawn Store." );

		SendServerMessage( playerid, "You have stolen a "COL_GREY"%s"COL_WHITE". Store it in a Boxville to transport the item.", g_houseFurniture[ GetGVarInt( "fur_f", furnitureID ) ] [ E_NAME ] );
		SetPlayerSpecialAction( playerid, SPECIAL_ACTION_CARRY );
		SetPVarInt( playerid, "stolen_fid", GetGVarInt( "fur_f", furnitureID ) );
		SetPlayerAttachedObject( playerid, 3, 1220, 5, 0.043999, 0.222999, 0.207000, 14.400002, 15.799994, 0.000000, 0.572999, 0.662000, 0.665000 );
	}
	else if ( strmatch( params, "store" ) )
	{
		new vehicleid = GetClosestVehicle( playerid ), Float: X, Float: Y, Float: Z, Float: Angle, szID[ 18 ];
		if ( !IsValidVehicle( vehicleid ) ) return SendError( playerid, "You're not near any vehicles." );
		if ( GetVehicleModel( vehicleid ) != 498 ) return SendError( playerid, "The vehicle you're near is not a Boxville." );
		if ( !IsPlayerAttachedObjectSlotUsed( playerid, 3 ) ) return SendError( playerid, "You aren't holding anything!" );
	    GetVehiclePos( vehicleid, X, Y, Z );
	    GetVehicleZAngle( vehicleid, Angle );
	    X += ( 4.5 * floatsin( -Angle + 180, degrees ) );
	    Y += ( 4.5 * floatcos( -Angle + 180, degrees ) );
	    if ( !IsPlayerInRangeOfPoint( playerid, 1.0, X, Y, Z ) ) return SendError( playerid, "Make sure you're behind the vehicle!" );
		format( szSmallString, sizeof( szSmallString ), "vburg_%d_items", vehicleid );
		if ( GetGVarInt( szSmallString ) >= MAX_BURGLARY_SLOTS ) return SendError( playerid, "You can only carry "#MAX_BURGLARY_SLOTS" items in this vehicle." );
		SetGVarInt( szSmallString, GetGVarInt( szSmallString ) + 1 );
		format( szID, sizeof( szID ), "vburg_%d_%d", vehicleid, GetGVarInt( szSmallString ) );
		SetGVarInt( szID, GetPVarInt( playerid, "stolen_fid" ) );
		RemovePlayerAttachedObject( playerid, 3 );
		SetPlayerSpecialAction( playerid, SPECIAL_ACTION_NONE );
		SendServerMessage( playerid, "You have placed a "COL_GREY"%s"COL_WHITE" in this Boxville. "COL_ORANGE"[%d/"#MAX_BURGLARY_SLOTS"]", g_houseFurniture[ GetPVarInt( playerid, "stolen_fid" ) ] [ E_NAME ], GetGVarInt( szSmallString ) );
		DeletePVar( playerid, "stolen_fid" );
		ClearAnimations( playerid );
	}
	else SendUsage( playerid, "/burglar [CRACKPW/STEAL/STORE]" );
	return 1;
}

CMD:playerjobs( playerid, params[ ] )
{
	ShowPlayerDialog( playerid, DIALOG_ONLINE_JOB, DIALOG_STYLE_LIST, "{FFFFFF}Player Jobs", "Rapist\nKidnapper\nTerrorist\nHitman\nProstitute\nWeapon Dealer\nDrug Dealer\nDirty Mechanic\nBurglar", "Select", "Cancel" );
	return 1;
}

CMD:getmytax( playerid, params[ ] )
{
	SendServerMessage( playerid, "Your tax is "COL_GOLD"%s"COL_WHITE" per 24 minutes.", ConvertPrice( getPlayerTax( playerid ) ) );
	return 1;
}

CMD:gettotalcash( playerid, params[ ] )
{
	mysql_function_query( dbHandle, "SELECT SUM(`BANKMONEY`) + SUM(`CASH`) AS `total_cash` FROM `USERS`", true, "gettotalcash", "i", playerid );
	return 1;
}

thread gettotalcash( playerid )
{
	new
		rows, fields, Field[ 12 ];

    cache_get_data( rows, fields );
	if ( rows )
	{
		cache_get_field_content( 0, "total_cash", Field );
		SendServerMessage( playerid, "Total: "COL_GOLD"%s"COL_WHITE", Tax Rate: "COL_GOLD"%s"COL_WHITE" per 24 mins.", ConvertPrice( strval( Field ) ), ConvertPrice( floatround( strval( Field ) / 1000 * GetTaxRate( ) ) ) );
	}
	else SendError( playerid, "An error has occurred, try again later." );
	return 1;
}

CMD:gettaxrate( playerid, params[ ] )
{
	SendServerMessage( playerid, "The tax rate is currently on "COL_GREY"%0.2f"COL_WHITE".", GetTaxRate( ) );
	return 1;
}

/*CMD:policetutorial( playerid, params[ ] )
{
	if ( p_CopTutorial{ playerid } == 0 ) return SendError( playerid, "You have already enabled the law enforcement officer tutorial." );
  	ShowPlayerDialog( playerid, DIALOG_VIEW_LEO_TUT, DIALOG_STYLE_MSGBOX, "{FFFFFF}Law Enforcement Officer Tutorial", "{FFFFFF}Are you sure you would like to view the law enforcement officer tutorial again?", "Yes", "No" );
	return 1;
}*/

CMD:ransompay( playerid, params[ ] )
{
	if ( !IsPlayerConnected( p_RansomPlacer[ playerid ] ) ) return SendError( playerid, "Your ransom offerer is not connected anymore." );
	else if ( !IsPlayerTied( playerid ) ) return p_RansomPlacer[ playerid ] = INVALID_PLAYER_ID, SendError( playerid, "Only tied players can use this command." );
	else if ( GetPlayerCash( playerid ) < p_RansomAmount[ playerid ] ) return SendError( playerid, "You do not have enough money for your ransom." );
	else if ( p_PlayerSettings[ playerid ] { SETTING_RANSOMS } ) return SendError( playerid, "This feature is unavailable as you have disabled ransom offers." );
	else
	{
		TogglePlayerControllable( playerid, 1 );
		p_Tied{ playerid } = false;
	   	if ( IsPlayerKidnapped( playerid ) ) {
	     	p_Kidnapped{ playerid } = false;
	 	}
		Delete3DTextLabel( p_TiedLabel[ playerid ] );
		p_TiedLabel[ playerid ] = Text3D: INVALID_3DTEXT_ID;
		GivePlayerCash( playerid, -p_RansomAmount[ playerid ] );
		GivePlayerCash( p_RansomPlacer[ playerid ], p_RansomAmount[ playerid ] );
		SendClientMessageFormatted( p_RansomPlacer[ playerid ], -1, ""COL_GREEN"[RANSOM PAY]{FFFFFF} %s(%d) has paid his ransom ("COL_GOLD"%s"COL_WHITE").", ReturnPlayerName( playerid ), playerid, ConvertPrice( p_RansomAmount[ playerid ] ) );
		SendClientMessageFormatted( playerid, -1, ""COL_RED"[RANSOM PAY]{FFFFFF} You have paid your ransom ("COL_GOLD"%s"COL_WHITE"), you are now released.", ConvertPrice( p_RansomAmount[ playerid ] ) );
		Beep( p_RansomPlacer[ playerid ] );
		GivePlayerWantedLevel( p_RansomPlacer[ playerid ], 6 );
		p_RansomAmount[ playerid ] = 0;
		p_RansomPlacer[ playerid ] = INVALID_PLAYER_ID;
		p_KidnapImmunity[ playerid ] = g_iTime + 180;
	}
	return 1;
}

CMD:rans( playerid, params[ ] ) return cmd_ransom( playerid, params );
CMD:ransom( playerid, params[ ] )
{
	new victimid, amount;

	if ( sscanf( params, ""#sscanf_u"d", victimid, amount ) ) return SendUsage( playerid, "/ransom [PLAYER_ID] [AMOUNT]" );
	else if ( !IsPlayerConnected( victimid ) ) return SendError( playerid, "This player is not connected." );
	else if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this command since you're jailed." );
	else if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "This is restricted to civilians only." );
	else if ( !JobEquals( playerid, JOB_KIDNAPPER ) ) return SendError( playerid, "You must be a kidnapper to use this command." );
   	else if ( p_Spectating{ playerid } ) return SendError( playerid, "You cannot use such commands while you're spectating." );
	else if ( victimid == playerid ) return SendError( playerid, "You cannot create a ransom on yourself." );
	else if ( p_PlayerSettings[ victimid ] { SETTING_RANSOMS } ) return SendError( playerid, "This player has disabled ransom offers." );
	else if ( amount < 50 || amount > 20000 ) return SendError( playerid, "You may place a ransom from $50 to $20,000." );
	else if ( amount > 99999999 || amount < 0 ) return SendError( playerid, "You may place a ransom from $50 to $20,000."); // Making cash go over billions...
	else if ( amount > p_Cash[ victimid ] ) return SendError( playerid, "This person doesn't have enough money to pay this amount." );
	else if ( p_RansomTimestamp[ victimid ] > g_iTime ) return SendError( playerid, "You must wait %d seconds before offering a ransom to this person.", p_RansomTimestamp[ victimid ] - g_iTime );
 	else if ( GetDistanceBetweenPlayers( playerid, victimid ) < 4.0 && IsPlayerConnected( victimid ) )
 	{
		if ( IsPlayerTied( playerid ) ) return SendError( playerid, "You cannot use this command since you're tied." );
		if ( !IsPlayerTied( victimid ) ) return SendError( playerid, "This player must be tied in order to create a ransom." );
		if ( IsPlayerCuffed( playerid ) ) return SendError( playerid, "You cannot use this command while you're cuffed." );
		if ( IsPlayerTazed( playerid ) ) return SendError( playerid, "You cannot use this command while you're tazed." );
		if ( IsPlayerInPaintBall( playerid ) ) return SendError( playerid, "You cannot use this command since you're inside the paintball arena." );

		SendClientMessageFormatted( victimid, -1, ""COL_RED"[RANSOM]{FFFFFF} You have been offered a ransom of "COL_GOLD"%s"COL_WHITE" for your release. Use /ransompay to pay the ransom.", ConvertPrice( amount ) );
	    SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[RANSOM]{FFFFFF} You have offered a ransom to %s(%d) of "COL_GOLD"%s"COL_WHITE".", ReturnPlayerName( victimid ), victimid, ConvertPrice( amount ) );
		p_RansomAmount[ victimid ] = amount;
		p_RansomPlacer[ victimid ] = playerid;
		p_RansomTimestamp[ victimid ] = g_iTime + 15;
	}
	else return SendError( playerid, "This player is not nearby." );
	return 1;
}

CMD:flat( playerid, params[ ] )
{
	if ( isnull( params ) ) return SendUsage( playerid, "/flat [CONFIG/STOPSPAWN]" );
	else if ( strmatch( params, "config" ) )
	{
		new count = 0;
		szBigString[ 0 ] = '\0';
		for( new i; i < sizeof( g_apartmentData ); i++ ) if ( g_apartmentData[ i ] [ E_CREATED ] )
		{
			if ( strmatch( g_apartmentData[ i ] [ E_OWNER ], ReturnPlayerName( playerid ) ) )
			{
			    count++;
			    format( szBigString, sizeof( szBigString ), "%s%s\n", szBigString, g_apartmentData[ i ] [ E_NAME ] );
			}
		}
		if ( count == 0 ) return SendError( playerid, "You don't own any apartments." );

		ShowPlayerDialog( playerid, DIALOG_FLAT_CONFIG, DIALOG_STYLE_LIST, "{FFFFFF}Owned Apartments", szBigString, "Select", "Cancel" );
	}
	else if ( strmatch( params, "stopspawn" ) )
	{
		p_ApartmentSpawnLocation[ playerid ] = -1;
		SendServerMessage( playerid, "Your spawning location has been set to the default positions." );
	}
	else SendUsage( playerid, "/flat [CONFIG/STOPSPAWN]" );
	return 1;
}

CMD:cw( playerid, params[ ] ) return cmd_carwhisper( playerid, params );
CMD:carwhisper( playerid, params[ ] )
{
	new msg[ 100 ];
	if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You must be inside a vehicle to use this command." );
	else if ( sscanf( params, "s[100]", msg ) ) return SendUsage( playerid, "/carwhisper [MESSAGE]" );
	else if ( textContainsIP( msg ) ) return SendError( playerid, "Advertising is forbidden." );
	else
	{
		foreach(new i : Player)
		{
		    if ( GetPlayerVehicleID( i ) == GetPlayerVehicleID( playerid ) ) {
		        SendClientMessageFormatted( i, -1, ""COL_ORANGE"<Car Whisper> %s(%d):"COL_WHITE" %s", ReturnPlayerName( playerid ), playerid, msg );
		    }
		}
	}
	return 1;
}

CMD:w( playerid, params[ ] ) return cmd_whisper( playerid, params );
CMD:whisper( playerid, params[ ] )
{
	new msg[ 100 ];
	if ( sscanf( params, "s[100]", msg ) ) return SendUsage( playerid, "/whisper [MESSAGE]" );
	else if ( textContainsIP( msg ) ) return SendError( playerid, "Advertising is forbidden." );
	else
	{
		new Float: X, Float: Y, Float: Z;
		GetPlayerPos( playerid, X, Y, Z );
		foreach(new i : Player)
		{
		    if ( IsPlayerInRangeOfPoint( i, 5.0, X, Y, Z ) && GetPlayerVirtualWorld( i ) == GetPlayerVirtualWorld( playerid ) ) {
		        SendClientMessageFormatted( i, -1, ""COL_ORANGE"<Whisper> %s(%d):"COL_WHITE" %s", ReturnPlayerName( playerid ), playerid, msg );
		    }
		}
	}
	return 1;
}

CMD:nametags( playerid, params[ ] )
{
	if ( strmatch( params, "off" ) ) {
		foreach(new i : Player) { ShowPlayerNameTagForPlayer( playerid, i, 0 ); }
	    SendClientMessage( playerid, 0x84aa63ff, "-> Name tags disabled" );
	} else if ( strmatch( params, "on" ) ) {
		foreach(new i : Player) { ShowPlayerNameTagForPlayer( playerid, i, 1 ); }
	    SendClientMessage( playerid, 0x84aa63ff, "-> Name tags enabled" );
	}
	else SendClientMessage( playerid, 0xa9c4e4ff, "-> /nametags [ON/OFF]" );
	return 1;
}

new p_LastCuredTS[ MAX_PLAYERS ];
new p_LastHealedTS[ MAX_PLAYERS ];

CMD:cure( playerid, params[ ] )
{
  	new
  		pID,
  		time = g_iTime
  	;

   	if ( p_Class[ playerid ] != CLASS_MEDIC ) return SendError( playerid, "This is restricted to medics only." );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/cure [PLAYER_ID]" );
	else if ( p_Spectating{ playerid } ) return SendError( playerid, "You cannot use such commands while you're spectating." );
	else if ( !IsPlayerConnected( pID ) ) return SendError( playerid, "This player is not connected." );
	else if ( playerid == pID ) return SendError( playerid, "You cannot offer to cure yourself." );
	else if ( GetPlayerCash( pID ) < 4875 ) return SendError( playerid, "This player doesn't have enough money to get a cure." );
 	else if ( GetDistanceBetweenPlayers( playerid, pID ) < 4.0 )
 	{
		if ( IsPlayerInAnyVehicle( pID ) ) return SendError( playerid, "This player is in a vehicle " );
		if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You cannot do this while you're inside a vehicle." );
		if ( p_LastCuredTS[ playerid ] > time ) return SendError( playerid, "You must wait another %d seconds before curing somebody.", p_LastCuredTS[ playerid ] - time );
 		SendClientMessageFormatted( pID, -1, ""COL_ORANGE"[DISEASE CURE]{FFFFFF} %s(%d) wishes to cure you for $4,875. "COL_ORANGE"/acceptcure{FFFFFF} to accept the deal.", ReturnPlayerName( playerid ), playerid );
		SendClientMessageFormatted( playerid, -1, ""COL_ORANGE"[DISEASE CURE]{FFFFFF} You have offered %s(%d) a cure for $4875.", ReturnPlayerName( pID ), pID );
   		p_CureDealer[ pID ] = playerid;
		p_CureTick[ pID ] = time + 120;
	}
	else SendError( playerid, "This player is not nearby." );
	return 1;
}

CMD:ac( playerid, params[ ] ) return cmd_acceptcure( playerid, params );
CMD:acceptcure( playerid, params[ ] )
{
	new
		time = g_iTime;

	if ( !IsPlayerConnected( p_CureDealer[ playerid ] ) ) return SendError( playerid, "Your dealer isn't connected anymore." );
	else if ( time > p_CureTick[ playerid ]  ) return p_CureDealer[ playerid ] = INVALID_PLAYER_ID, SendError( playerid, "This deal has ended, each deal goes for 2 minutes maximum. You were late." );
	else if ( GetPlayerCash( playerid ) < 4875 ) return SendError( playerid, "You do not have enough money to get a cure." );
	else if ( p_Jailed{ playerid } ) return SendError( playerid, "You cannot buy cures while you're in jail." );
   	else if ( p_Class[ p_CureDealer[ playerid ] ] != CLASS_MEDIC ) return SendError( playerid, "The paramedic that offered you is no longer a paramedic." );
	else
	{
	    Beep( p_CureDealer[ playerid ] );
		SendClientMessageFormatted( playerid, -1, ""COL_ORANGE"[DISEASE CURE]{FFFFFF} You have been cured from all diseases by %s(%d) for $4,875. ", ReturnPlayerName( p_CureDealer[ playerid ] ), p_CureDealer[ playerid ] );
		SendClientMessageFormatted( p_CureDealer[ playerid ], -1, ""COL_ORANGE"[DISEASE CURE]{FFFFFF} %s(%d) has paid and got himself cured.", ReturnPlayerName( playerid ), playerid );		p_InfectedHIV{ playerid } = false;
		GivePlayerCash( playerid, -4875 );
		GivePlayerCash( p_CureDealer[ playerid ], 4875 );
		GivePlayerScore( p_CureDealer[ playerid ], 2 );
		p_LastCuredTS[ p_CureDealer[ playerid ] ] = time + 15;
		p_CureDealer[ playerid ] = INVALID_PLAYER_ID;
	}
	return 1;
}

CMD:heal( playerid, params[ ] )
{
  	new
  		pID;

   	if ( p_Class[ playerid ] != CLASS_MEDIC ) return SendError( playerid, "This is restricted to medics only." );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/heal [PLAYER_ID]" );
	else if ( p_Spectating{ playerid } ) return SendError( playerid, "You cannot use such commands while you're spectating." );
	else if ( !IsPlayerConnected( pID ) ) return SendError( playerid, "This player is not connected." );
	else if ( playerid == pID ) return SendError( playerid, "You cannot offer to heal yourself." );
	else if ( GetPlayerCash( pID ) < 750 ) return SendError( playerid, "This player doesn't have enough money to get a health refill." );
 	else if ( GetDistanceBetweenPlayers( playerid, pID ) < 4.0 )
 	{
		if ( IsPlayerInAnyVehicle( pID ) ) return SendError( playerid, "This player is in a vehicle " );
		if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You cannot do this while you're inside a vehicle." );
		if ( p_LastHealedTS[ playerid ] > g_iTime ) return SendError( playerid, "You must wait another %d seconds before curing somebody.", p_LastHealedTS[ playerid ] - g_iTime );
 		SendClientMessageFormatted( pID, -1, ""COL_ORANGE"[HEALTH REFILL]{FFFFFF} %s(%d) wishes to heal you for $1,200. "COL_ORANGE"/acceptheal{FFFFFF} to accept the deal.", ReturnPlayerName( playerid ), playerid );
		SendClientMessageFormatted( playerid, -1, ""COL_ORANGE"[HEALTH REFILL]{FFFFFF} You have offered %s(%d) a health refill for $1,200.", ReturnPlayerName( pID ), pID );
   		p_HealDealer[ pID ] = playerid;
		p_HealTick[ pID ] = g_iTime + 120;
	}
	else SendError( playerid, "This player is not nearby." );
	return 1;
}

CMD:ah( playerid, params[ ] ) return cmd_acceptheal( playerid, params );
CMD:acceptheal( playerid, params[ ] )
{
	new
		Float: fHealth;

	if ( !IsPlayerConnected( p_HealDealer[ playerid ] ) ) return SendError( playerid, "Your dealer isn't connected anymore." );
	else if ( g_iTime > p_HealTick[ playerid ]  ) return p_HealDealer[ playerid ] = INVALID_PLAYER_ID, SendError( playerid, "This deal has ended, each deal goes for 2 minutes maximum. You were late." );
	else if ( GetPlayerCash( playerid ) < 750 ) return SendError( playerid, "You do not have enough money to get a health refill." );
	else if ( p_Jailed{ playerid } ) return SendError( playerid, "You cannot buy heals while you're in jail." );
   	else if ( p_Class[ p_HealDealer[ playerid ] ] != CLASS_MEDIC ) return SendError( playerid, "The paramedic that offered you is no longer a paramedic." );
	else if ( IsPlayerInEvent( playerid ) ) return SendError( playerid, "You cannot use this command since you're in an event." );
	else if ( GetPlayerHealth( playerid, fHealth ) && fHealth >= 90.0 ) return SendError( playerid, "You need to have less than 90 percent of your health to be healed." );
	else
	{
	    Beep( p_HealDealer[ playerid ] );
		SendClientMessageFormatted( playerid, -1, ""COL_ORANGE"[HEALTH REFILL]{FFFFFF} You have patched up and healed by %s(%d) for $1,200. ", ReturnPlayerName( p_HealDealer[ playerid ] ), p_HealDealer[ playerid ] );
		SendClientMessageFormatted( p_HealDealer[ playerid ], -1, ""COL_ORANGE"[HEALTH REFILL]{FFFFFF} %s(%d) has paid and got his health refilled.", ReturnPlayerName( playerid ), playerid );
		SetPlayerHealth( playerid, 120.0 );
		GivePlayerCash( playerid, -1200 );
		GivePlayerCash( p_HealDealer[ playerid ], 1200 );
		GivePlayerScore( p_HealDealer[ playerid ], 2 );
		p_LastHealedTS[ p_HealDealer[ playerid ] ] = g_iTime + 15;
		p_HealDealer[ playerid ] = INVALID_PLAYER_ID;
	}
	return 1;
}

CMD:admins( playerid, params[ ] )
{
	if ( GetPlayerScore( playerid ) < 500 && !IsPlayerUnderCover( playerid ) && p_AdminLevel[ playerid ] < 1 )
	    return SendError( playerid, "You need at least 500 score to view the online adminstrators." );

	new count = 0;
	szLargeString = ""COL_WHITE"Player\t"COL_WHITE"Admin Level\n";

	foreach(new i : Player)
	{
	    if ( p_AdminLevel[ i ] ) {
	        count++;
	        format( szLargeString, sizeof( szLargeString ), "%s%s%s(%d)\tLevel %d\n", szLargeString, IsPlayerAdminOnDuty( i ) ? ( COL_PINK ) : ( COL_GREY ), ReturnPlayerName( i ), i, p_AdminLevel[ i ] );
	    }
	}
    if ( count == 0 ) return SendServerMessage( playerid, "There are no administrators online." );
	ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_TABLIST_HEADERS, "{FFFFFF}Online Admins", szLargeString, "Okay", "" );
	return 1;
}

CMD:vip( playerid, params[ ] )
{
	szLargeString = "{FFFFFF}Help support our community by donating, in return you will receive Irresistible Coins!\n\n";

	strcat( szLargeString, "Use the coins to buy all available items on "COL_GREY"/ic market"COL_WHITE" like V.I.P!\n\nDon't forget, V.I.P gives you special benefits. Most of all more money and XP!\n\n" );
	strcat( szLargeString, "Visit "COL_GOLD"donate.irresistiblegaming.com"COL_WHITE" to donate today!" );

	ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_MSGBOX, "{FFFFFF}Donate for V.I.P", szLargeString, "Okay", "" );
	return 1;
}

CMD:vsay( playerid, params[ ] )
{
    new
    	msg[ 100 ],
    	time = g_iTime
    ;

    if ( p_VIPLevel[ playerid ] < 1 ) return SendError( playerid, "You are not a V.I.P, to become one visit "COL_GREY"donate.irresistiblegaming.com" );
    else if ( sscanf( params, "s[100]", msg ) ) return SendUsage( playerid, "/vsay [MESSAGE]" );
	else if ( textContainsIP( msg ) ) return SendServerMessage( playerid, "Please do not advertise." );
    else
    {
     	if ( p_Muted{ playerid } )
		{
		 	if ( time > p_MutedTime[ playerid ] )
			 	p_Muted{ playerid } = false;
			else
		   		return SendError( playerid, "You cannot speak as you are muted for %s.", secondstotime( p_MutedTime[ playerid ] - time ) );
		}

		DCC_SendChannelMessageFormatted( discordGeneralChan, "__**(VIP) %s(%d):**__ %s", ReturnPlayerName( playerid ), playerid, msg );
		SendClientMessageToAllFormatted( 0x3eff3eff, "[VIP] %s(%d):{9ec34f} %s", ReturnPlayerName( playerid ), playerid, msg );
	}
	return 1;
}


CMD:aclist( playerid, params[ ] )
{
	new
		count = 0;

	szLargeString = ""COL_WHITE"Orange players are forced to use SA-MP AC\n";

	foreach(new i : Player) if ( IsPlayerUsingSampAC( i ) ) {
		format( szLargeString, sizeof( szLargeString ), "%s%s%s(%d)\n", szLargeString, p_forcedAnticheat[ i ] > 0 ? ( COL_ORANGE ) : ( "" ), ReturnPlayerName( i ), i );
	    count++;
	}
    if ( count == 0 ) return SendError( playerid, "There are no SA-MP AC users online." );
    if ( strlen( szLargeString ) == sizeof( szLargeString ) - 1 ) return ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_MSGBOX, "{FFFFFF}Online SA-MP AC Users", sprintf( ""COL_WHITE"There are %d SA-MP AC users online.", count ), "Okay", "" );
	ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_TABLIST_HEADERS, "{FFFFFF}Online SA-MP AC Users", szLargeString, "Okay", "" );
	return 1;
}

CMD:viplist( playerid, params[ ] )
{
	new
		count = 0;

	szLargeString = ""COL_WHITE"Player\t"COL_WHITE"V.I.P Package\n";

	foreach(new i : Player) if ( p_VIPLevel[ i ] > 0 )
	{
		// Diamond
	  	if ( p_VIPLevel[ i ] < VIP_DIAMOND )
	    	format( szLargeString, sizeof( szLargeString ), "%s%s(%d)\t"COL_GOLD"%s\n", szLargeString, ReturnPlayerName( i ), i, VIPToString( p_VIPLevel[ i ] ) );
	    else
	    	format( szLargeString, sizeof( szLargeString ), "%s%s(%d)\t"COL_DIAMOND"%s\n", szLargeString, ReturnPlayerName( i ), i, isnull( p_VipPackageName[ i ] ) ? VIPToString( p_VIPLevel[ i ] ) : p_VipPackageName[ i ] );

	    count++;
	}
    if ( count == 0 ) return SendError( playerid, "There are no V.I.P's online." );
    if ( strlen( szLargeString ) == sizeof( szLargeString ) - 1 ) return ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_MSGBOX, "{FFFFFF}Online V.I.P's", sprintf( ""COL_WHITE"There are %d V.I.P players online.", count ), "Okay", "" );
	ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_TABLIST_HEADERS, "{FFFFFF}Online V.I.P's", szLargeString, "Okay", "" );
	return 1;
}

CMD:vipcmds( playerid, params[ ] )
{
	if ( p_VIPLevel[ playerid ] < 1 ) return SendError( playerid, "You are not a V.I.P, to become one visit "COL_GREY"donate.irresistiblegaming.com" );

	erase( szLargeString );
	strcat( szLargeString,	""COL_GREY"/vipspawnwep\tConfigure your spawning weapons\n"\
							""COL_GREY"/vipskin\tConfigure your spawning skin\n"\
							""COL_GREY"/vipgun\tRedeem weapons or an armour vest from the gun locker\n"\
							""COL_GREY"/vsay\tGlobal V.I.P Chat\n" );
	strcat( szLargeString,	""COL_GREY"/vipjob\tSet your secondary VIP job\n"\
							""COL_GREY"/vippackage\tCustomize your VIP package name\n"\
							""COL_GREY"/mynotes\tAccess your VIP notes and material\n"\
							""COL_GREY"/mycustomizations\tAccess your house customization taxes" );

	ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_TABLIST, "{FFFFFF}V.I.P Commands", szLargeString, "Okay", "" );
	return 1;
}

CMD:vippackage( playerid, params[ ] )
{
	new
		packageName[ 16 ];

	if ( p_VIPLevel[ playerid ] < VIP_DIAMOND ) return SendError( playerid, "You can only use this if you are a "COL_DIAMOND"Diamond V.I.P{FFFFFF}." );
	else if ( sscanf( params, "s[16]", packageName ) ) return SendUsage( playerid, "/vippackage [PACKAGE_NAME]" );
    else if ( textContainsIP( packageName ) ) return SendError( playerid, "You cannot advertise!" );
	else
	{
		SendServerMessage( playerid, "You have rename your V.I.P package to \"%s\", check /viplist!", packageName );
		format( p_VipPackageName[ playerid ], sizeof( p_VipPackageName[ ] ), packageName );
	}
	return 1;
}

CMD:vipspawnwep( playerid, params[ ] )
{
	if ( p_VIPLevel[ playerid ] < VIP_REGULAR ) return SendError( playerid, "You are not a V.I.P, to become one visit "COL_GREY"donate.irresistiblegaming.com" );
	format( szNormalString, sizeof( szNormalString ), "%s\n"COL_GOLD"%s\n"COL_PLATINUM"%s", p_VIPWep1{ playerid } ? ReturnWeaponName( p_VIPWep1{ playerid } ) : ( "Nothing" ), p_VIPWep2{ playerid } ? ReturnWeaponName( p_VIPWep2{ playerid } ) : ( "Nothing" ), p_VIPWep3{ playerid } ? ReturnWeaponName( p_VIPWep3{ playerid } ) : ( "Nothing" ) );
    ShowPlayerDialog( playerid, DIALOG_VIP_WEP, DIALOG_STYLE_LIST, "{FFFFFF}Spawn Weapons", szNormalString, "Select", "" );
	return 1;
}

CMD:vipgun( playerid, params[ ] )
{
	if ( p_VIPLevel[ playerid ] < VIP_REGULAR )
	    return SendError( playerid, "You are not a V.I.P, to become one visit "COL_GREY"donate.irresistiblegaming.com" );

	if ( !IsPlayerInRangeOfPoint( playerid, 5.0, -1966.1591, 852.7100, 1214.2678 ) && !IsPlayerInRangeOfPoint( playerid, 5.0, -1944.1324, 830.0725, 1214.2678 ) && !IsPlayerInRangeOfPoint( playerid, 5.0, 60.3115, 121.5226, 1017.4534 ) )
		return SendError( playerid, "You must be near a gun vending machine inside the V.I.P lounge to use this." );

    ShowPlayerDialog( playerid, DIALOG_VIP_LOCKER, DIALOG_STYLE_LIST, "{FFFFFF}V.I.P Guns", ""COL_GOLD"[GOLD VIP]"COL_GREY" Armour\n9mm Pistol\nSilenced Pistol\nDesert Eagle\nShotgun\nSawn-off Shotgun\nSpas 12\nMac 10\nMP5\nAK-47\nM4\nTec 9\nRifle\nSniper\nKnuckle Duster\nGolf Club\nBaton\nKnife\nBaseball Bat\nSpade\nPool Cue\nKatana\nChainsaw\nDildo\nFlowers\nCane", "Select", "Cancel");
	return 1;
}

CMD:vipskin( playerid, params[ ] )
{
	new
	    skin
	;
	if ( p_VIPLevel[ playerid ] < VIP_REGULAR ) return SendError( playerid, "You are not a V.I.P, to become one visit "COL_GREY"donate.irresistiblegaming.com" );
	else if ( GetPlayerAnimationIndex( playerid ) == 1660 ) return SendError( playerid, "You cannot use this command since you're using a vending machine." );
	else if ( IsPlayerRobbing( playerid ) ) return SendError( playerid, "You cannot use this command since you're robbing a store." );
	/*else if ( strmatch( params, "toggle" ) )
	{
		if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You cannot use this in a vehicle. Exit it, and try again." );
	    if ( GetPlayerState( playerid ) == PLAYER_STATE_ENTER_VEHICLE_DRIVER || GetPlayerState( playerid ) == PLAYER_STATE_ENTER_VEHICLE_PASSENGER ) return SendError( playerid, "You cannot set your skin if you're entering a vehicle." );
	    if ( GetPlayerState( playerid ) == PLAYER_STATE_EXIT_VEHICLE ) return SendError( playerid, "You cannot set your skin if you're exiting a vehicle." );
		p_SkinToggled{ playerid } = true;
		SyncObject( playerid );
		ClearAnimations( playerid );
		SetPlayerSkin( playerid, p_LastSkin[ playerid ] );
		SendServerMessage( playerid, "You have toggled your V.I.P skin!" );
		return 1;
	}
	else if ( strmatch( params, "remove" ) )
	{
		p_SkinToggled{ playerid } = false;
		SendServerMessage( playerid, "Your V.I.P skin has been removed, changes will take place after your next spawn." );
		return 1;
	}*/
	else if ( sscanf( params, "d", skin ) ) return SendUsage( playerid, "/vipskin [SKIN_ID]" );
	else if ( !IsValidSkin( skin ) ) return SendError( playerid, "Invalid Skin ID." );
	else
	{
	    p_LastSkin[ playerid ] = skin;
	    if ( p_PlayerSettings[ playerid ] { SETTING_VIPSKIN } ) SetPlayerSkin( playerid, skin );
	    SendClientMessageFormatted( playerid, -1, ""COL_GOLD"[VIP]"COL_WHITE" You have changed your V.I.P skin id to %d!", skin );
	}
	return 1;
}

CMD:vipjob( playerid, params[ ] )
{
	new
	    iJob;

	if ( p_VIPLevel[ playerid ] < VIP_REGULAR )
		return SendError( playerid, "You are not a V.I.P, to become one visit "COL_GREY"donate.irresistiblegaming.com" );

	if ( p_VIPLevel[ playerid ] < VIP_PLATINUM )
		return SendError( playerid, "This command requires you to be platinum V.I.P." );

	if ( isnull( params ) )
		return SendUsage( playerid, "/vipjob [PART OF JOB NAME]" );

	if ( ( iJob = GetJobIDFromName( params ) ) == 0xFE )
		return SendError( playerid, "You have entered an invalid job." );

	if ( iJob != p_Job{ playerid } ) {
		if ( GetPlayerCash( playerid ) < 5000 )
			return SendError( playerid, "You do not have enough money to set your V.I.P job." );

		GivePlayerCash( playerid, -5000 );
    	SendClientMessageFormatted( playerid, -1, ""COL_GOLD"[VIP]"COL_WHITE" You have changed your V.I.P job to %s! To disable, set your vip job to your original job.", GetJobName( iJob ) );
	}
	else SendClientMessage( playerid, -1, ""COL_GOLD"[VIP]"COL_WHITE" You have disabled your VIP job." );

    p_VIPJob{ playerid } = iJob;
	return 1;
}

CMD:toys( playerid, params[ ] )
{
	if ( !IsPlayerSpawned( playerid ) ) return SendError( playerid, "You cannot use this command while you are not spawned." );

	new
		iToy[ 3 ] [ 24 ] = { { "None" }, { "None" }, { "None" } };

	for( new i = 0; i < sizeof( g_ToyData ); i++ ) {
 		for( new x = 0; x < sizeof( iToy ); x++ ) {
			if ( g_ToyData[ i ] [ E_MODEL ] == p_AttachedObjectsData[ playerid ] [ x ] [ E_MODELID ] )
				strcpy( iToy[ x ], g_ToyData[ i ] [ E_NAME ] );
 		}
 	}

	format( szNormalString, sizeof( szNormalString ), ""COL_GREY"Disable All Toys\nSlot 1 (%s)\nSlot 2 (%s)\nSlot 3 (%s)", iToy[ 0 ], iToy[ 1 ], iToy[ 2 ] );
	ShowPlayerDialog( playerid, DIALOG_TOYS_MAIN, DIALOG_STYLE_LIST, "{FFFFFF}Toys", szNormalString, "Select", "Close" );
	return 1;
}

CMD:changes( playerid, params[ ] ) return cmd_updates( playerid, params );
CMD:updates( playerid, params[ ] )
{
    new
    	File: handle = fopen( "updates.txt", io_read );

    if ( ! handle )
    	return SendError( playerid, "There are no updates to show." );

    erase( szNormalString );
    erase( szHugeString );

    while ( fread( handle, szNormalString ) )
    {
        new
        	find = strfind( szNormalString, "(+)" );

        // additions
        if( find != -1 )
        {
            strins( szNormalString, "{23D96F}added{FFFFFF}\t\t", find + 3 );
            strdel( szNormalString, find, find + 3);
        }

        // removals
        find = strfind( szNormalString, "(-)" );
        if( find != -1 )
        {
            strins( szNormalString, "{D92323}removed{FFFFFF}\t", find + 3 );
            strdel( szNormalString, find, find + 3 );
        }

        // fixes
        find = strfind( szNormalString, "(*)" );
        if ( find != -1 )
        {
            strins( szNormalString, "{D9A823}fixed{FFFFFF}\t\t", find + 3 );
            strdel( szNormalString, find, find + 3 );
        }

        // fixes
        find = strfind( szNormalString, "(/)" );
        if ( find != -1 )
        {
            strins( szNormalString, "{c0c0c0}changed{FFFFFF}\t", find + 3 );
            strdel( szNormalString, find, find + 3 );
        }

        // append
        strcat( szHugeString, szNormalString );
    }

    fclose( handle );
    ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_MSGBOX, "{FFFFFF}Recent Updates - " #FILE_BUILD " - {C0C0C0}Created by Cloudy & sponyy", szHugeString, "Okay", "" );
    SendServerMessage( playerid, "You're now viewing the latest changes to the gamemode (version "#FILE_BUILD")." );
	return 1;
}

CMD:tweets( playerid, params[ ] ) return cmd_twitter( playerid, params );
CMD:twitter( playerid, params[ ] )
{
    SendServerMessage( playerid, "Reading latest tweets from {00CCFF}www.twitter.com/IrresistibleDev{FFFFFF}, please wait!" );
	HTTP( playerid, HTTP_GET, "files.irresistiblegaming.com/cnr_twitter.php", "", "OnTwitterHTTPResponse" );
	return 1;
}

CMD:mechanic( playerid, params[ ] ) return cmd_mech( playerid, params );
CMD:mech( playerid, params[ ] )
{
	new
		Float: vZ,
		iVehicle = GetPlayerVehicleID( playerid )
	;

	if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "You must be a civilian to use this command." );
	if ( !JobEquals( playerid, JOB_DIRTY_MECHANIC ) ) return SendError( playerid, "You are not a dirty mechanic." );
	if ( isnull( params ) ) return SendUsage( playerid, "/(mech)anic [FIX/NOS/REMP/FLIP/FLIX/PRICE/NEARBY]" );
	else if ( strmatch( params, "fix" ) )
	{
	    if ( ( GetTickCount( ) - p_AntiMechFixSpam[ playerid ] ) < 10000 )
	    	return SendError( playerid, "You must wait 10 seconds before using this feature again." );

   		if ( !IsPlayerInAnyVehicle( playerid ) )
   			return SendError( playerid, "You are not in any vehicle." );

		new
			cost = 250;

		if ( g_isBusinessVehicle[ iVehicle ] != -1 && Iter_Contains( business, g_isBusinessVehicle[ iVehicle ] ) )
			cost = IsBusinessAerialVehicle( g_isBusinessVehicle[ iVehicle ], GetVehicleModel( iVehicle ) ) ? 2500 : 750;

   		if ( GetPlayerCash( playerid ) < cost )
   			return SendError( playerid, "You need %s to fix this vehicle.", ConvertPrice( cost ) );

		PlayerPlaySound( playerid, 1133, 0.0, 0.0, 5.0 );
		p_DamageSpamCount{ playerid } = 0;
	 	RepairVehicle( iVehicle );
	 	SendServerMessage( playerid, "You have repaired this vehicle." );
	 	p_AntiMechFixSpam[ playerid ] = GetTickCount( );
	 	GivePlayerCash( playerid, -cost );
	}
	else if ( strmatch( params, "nos" ) )
	{
	    if ( ( GetTickCount( ) - p_AntiMechNosSpam[ playerid ] ) < 10000 ) return SendError( playerid, "You must wait 10 seconds before using this feature." );
   		if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You are not in any vehicle." );
   		if ( GetPlayerCash( playerid ) < 500 ) return SendError( playerid, "You need $500 to add nitrous to this vehicle." );
		PlayerPlaySound( playerid, 1133, 0.0, 0.0, 5.0 );
	  	AddVehicleComponent( iVehicle, 1010 );
	 	SendServerMessage( playerid, "You have added nitrous to this vehicle." );
	 	p_AntiMechNosSpam[ playerid ] = GetTickCount( );
	 	GivePlayerCash( playerid, -500 );
	}
	else if ( strmatch( params, "remp" ) )
	{
	    if ( ( GetTickCount( ) - p_AntiMechEmpSpam[ playerid ] ) < 10000 ) return SendError( playerid, "You must wait 10 seconds before using this feature." );
   		if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You are not in any vehicle." );
		if ( GetPlayerCash( playerid ) < 750 ) return SendError( playerid, "You need $750 to remove EMP off this vehicle." );
		GetVehicleParamsEx( iVehicle, engine, lights, alarm, doors, bonnet, boot, objective );
		if ( engine != VEHICLE_PARAMS_OFF ) return SendError( playerid, "This has not been affected by any EMP attacks." );
		GivePlayerCash( playerid, -750 );
		PlayerPlaySound( playerid, 1133, 0.0, 0.0, 5.0 );
		SetVehicleParamsEx( iVehicle, VEHICLE_PARAMS_ON, lights, alarm, doors, bonnet, boot, objective );
	 	SendServerMessage( playerid, "You have successfully re-initialized the vehicle." );
	 	p_AntiMechEmpSpam[ playerid ] = GetTickCount( );
	}
	else if ( strmatch( params, "flip" ) )
	{
	    if ( ( GetTickCount( ) - p_AntiMechFlipSpam[ playerid ] ) < 10000 ) return SendError( playerid, "You must wait 10 seconds before using this feature." );
   		if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You are not in any vehicle." );
		if ( GetPlayerCash( playerid ) < 200 ) return SendError( playerid, "You need $200 to flip this vehicle." );
		PlayerPlaySound( playerid, 1133, 0.0, 0.0, 5.0 );
		GetVehicleZAngle( iVehicle, vZ ), SetVehicleZAngle( iVehicle, vZ );
		GivePlayerCash( playerid, -200 );
	 	SendServerMessage( playerid, "You have successfully flipped this vehicle." );
	 	p_AntiMechFlipSpam[ playerid ] = GetTickCount( );
	}
	else if ( strmatch( params, "flix" ) )
	{
	    if ( ( GetTickCount( ) - p_AntiMechFixSpam[ playerid ] ) < 10000 ) return SendError( playerid, "You must wait 10 seconds before using this feature." );
	    if ( ( GetTickCount( ) - p_AntiMechFlipSpam[ playerid ] ) < 10000 ) return SendError( playerid, "You must wait 10 seconds before using this feature." );
   		if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You are not in any vehicle." );
   		if ( GetPlayerCash( playerid ) < 500 ) return SendError( playerid, "You need $500 to flip and fix this vehicle." );

		new
			cost = 500;

		if ( g_isBusinessVehicle[ iVehicle ] != -1 && Iter_Contains( business, g_isBusinessVehicle[ iVehicle ] ) )
			cost = IsBusinessAerialVehicle( g_isBusinessVehicle[ iVehicle ], GetVehicleModel( iVehicle ) ) ? 3000 : 1250;

   		if ( GetPlayerCash( playerid ) < cost )
   			return SendError( playerid, "You need %s to fix this vehicle.", ConvertPrice( cost ) );

		PlayerPlaySound( playerid, 1133, 0.0, 0.0, 5.0 );
		p_DamageSpamCount{ playerid } = 0;
	 	RepairVehicle( iVehicle );
		GetVehicleZAngle( iVehicle, vZ ), SetVehicleZAngle( iVehicle, vZ );
	 	SendServerMessage( playerid, "You have flipped and fixed this vehicle." );
	 	p_AntiMechFixSpam[ playerid ] = GetTickCount( );
	 	p_AntiMechFlipSpam[ playerid ] = GetTickCount( );
	 	GivePlayerCash( playerid, -cost );
	}
	else if ( strmatch( params, "price" ) )
	{
   		if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You are not in any vehicle." );

   		new
   			iPrice;

   		if ( ( iPrice = calculateVehicleSellPrice( iVehicle ) ) )
			ShowPlayerHelpDialog( playerid, 3000, "You can export this vehicle at the docks for around ~g~%s~w~~h~.~n~~n~~r~Damaging the vehicle will further decrease the value.", ConvertPrice( iPrice ) );
   		else
			ShowPlayerHelpDialog( playerid, 3000, "~r~This vehicle cannot be sold." );
	}
	else if ( strmatch( params, "nearby" ) )
	{
		new
			Float: fDistance = Float: 0x7F800000,
			iClosest = GetClosestVehicle( playerid, INVALID_VEHICLE_ID, fDistance )
		;

		SendServerMessage( playerid, "The closest vehicle to you is a "COL_GREY"%s"COL_WHITE", which is %0.2fm away.", GetVehicleName( GetVehicleModel( iClosest ) ), fDistance );
	}
	else return SendUsage( playerid, "/(mech)anic [FIX/NOS/REMP/FLIP/FLIX/PRICE/NEARBY]" );
	return 1;
}

CMD:savestats( playerid, params[ ] )
{
	if ( ( GetTickCount( ) - p_AntiSaveStatsSpam[ playerid ] ) < 15000 ) return SendError( playerid, "You must wait 15 seconds before saving your statistics again." );
    SavePlayerData( playerid );
    p_AntiSaveStatsSpam[ playerid ] = GetTickCount( );
    SendServerMessage( playerid, "Your statistics have been saved." );
	return 1;
}

CMD:dance( playerid, params[ ] )
{
	new id;
	if ( sscanf( params, "d", id ) ) return SendUsage( playerid, "/dance [1-11]" );
	else
	{
	    switch( id )
		{
           	case 1: CreateLoopingAnimation(playerid, "DANCING", "dance_loop", 4.0, 1, 0, 0, 0, 0 );
          	case 2: CreateLoopingAnimation(playerid, "DANCING", "DAN_Down_A", 4.0, 1, 0, 0, 0, 0 );
           	case 3: CreateLoopingAnimation(playerid, "DANCING", "DAN_Left_A", 4.0, 1, 0, 0, 0, 0 );
           	case 4: CreateLoopingAnimation(playerid, "DANCING", "DAN_Loop_A", 4.0, 1, 0, 0, 0, 0 );
          	case 5: CreateLoopingAnimation(playerid, "DANCING", "DAN_Right_A", 4.0, 1, 0, 0, 0, 0 );
          	case 6: CreateLoopingAnimation(playerid, "DANCING", "DAN_Up_A", 4.0, 1, 0, 0, 0, 0 );
          	case 7: CreateLoopingAnimation(playerid, "DANCING", "dnce_M_a", 4.0, 1, 0, 0, 0, 0 );
          	case 8: CreateLoopingAnimation(playerid, "DANCING", "dnce_M_b", 4.0, 1, 0, 0, 0, 0 );
          	case 9: CreateLoopingAnimation(playerid, "DANCING", "dnce_M_c", 4.0, 1, 0, 0, 0, 0 );
          	case 10: CreateLoopingAnimation(playerid, "DANCING", "dnce_M_d", 4.0, 1, 0, 0, 0, 0 );
           	case 11: CreateLoopingAnimation(playerid, "DANCING", "dnce_M_e", 4.0, 1, 0, 0, 0, 0 );
         	default: SendError( playerid, "Invalid Dance ID." );
      	}
	}
	return 1;
}

CMD:piss( playerid, params[ ] )
{
    CreateLoopingAnimation( playerid, "PED", "null", 4.0, 1, 0, 0, 0, 0, 68 ); // Sit
	return 1;
}

CMD:wank( playerid, params[ ] )
{
    CreateLoopingAnimation( playerid, "PAULNMAC", "wank_loop", 4.0, 1, 0, 0, 0, 0 );
	return 1;
}

CMD:sit( playerid, params[ ] )
{
    CreateLoopingAnimation( playerid, "INT_OFFICE", "OFF_Sit_Type_Loop", 4.0, 1, 0, 0, 0, 0 );
	return 1;
}

CMD:groundsit( playerid, params[ ] )
{
	CreateLoopingAnimation( playerid, "BEACH", "ParkSit_M_loop", 4.0, 1, 0, 0, 0, 0 );
	return 1;
}

CMD:lay( playerid, params[ ] )
{
	CreateLoopingAnimation( playerid, "BEACH", "bather", 4.0, 1, 0, 0, 0, 0 );
	return 1;
}

CMD:slapass( playerid, params[ ] )
{
	CreateLoopingAnimation( playerid, "SWEET", "sweet_ass_slap", 4.0, 0, 0, 0, 0, 0 );
	return 1;
}

CMD:sex( playerid, params[ ] )
{
	CreateLoopingAnimation( playerid, "SNM", "SPANKING_ENDW", 4.0, 0, 0, 0, 0, 0 );
	return 1;
}

CMD:crossarms( playerid, params[ ] )
{
	CreateLoopingAnimation( playerid, "COP_AMBIENT", "Coplook_loop", 4.0, 1, 0, 0, 0, 0 );
	return 1;
}

CMD:wave( playerid, params[ ] )
{
	CreateLoopingAnimation( playerid, "ON_LOOKERS", "wave_loop", 4.0, 1, 0, 0, 0, 0 );
	return 1;
}

CMD:lookout( playerid, params[ ] )
{
	CreateLoopingAnimation( playerid, "SHOP", "ROB_Shifty", 4.0, 0, 0, 0, 0, 0 );
	return 1;
}

CMD:laugh( playerid, params[ ] )
{
	CreateLoopingAnimation( playerid, "RAPPING", "Laugh_01", 4.0, 0, 0, 0, 0, 0 );
	return 1;
}

CMD:deal( playerid, params[ ] )
{
	CreateLoopingAnimation( playerid, "DEALER", "DEALER_IDLE", 4.0, 1, 0, 0, 0, 0 );
	return 1;
}

CMD:strip( playerid, params[ ] )
{
	new id;
	if ( sscanf( params, "d", id ) ) return SendUsage( playerid, "/strip [1-7]" );
	else
	{
	    switch( id )
		{
           	case 1: CreateLoopingAnimation(playerid, "STRIP", "strip_A", 4.0, 1, 0, 0, 0, 0 );
           	case 2: CreateLoopingAnimation(playerid, "STRIP", "strip_B", 4.0, 1, 0, 0, 0, 0 );
           	case 3: CreateLoopingAnimation(playerid, "STRIP", "strip_C", 4.0, 1, 0, 0, 0, 0 );
           	case 4: CreateLoopingAnimation(playerid, "STRIP", "strip_D", 4.0, 1, 0, 0, 0, 0 );
           	case 5: CreateLoopingAnimation(playerid, "STRIP", "strip_E", 4.0, 1, 0, 0, 0, 0 );
           	case 6: CreateLoopingAnimation(playerid, "STRIP", "strip_F", 4.0, 1, 0, 0, 0, 0 );
           	case 7: CreateLoopingAnimation(playerid, "STRIP", "strip_G", 4.0, 1, 0, 0, 0, 0 );
         	default: SendError( playerid, "Invalid Strip ID." );
      	}
	}
	return 1;
}

CMD:aimthreat( playerid, params[ ] )
{
	CreateLoopingAnimation( playerid, "SHOP", "ROB_Loop_Threat", 4.0, 1, 0, 0, 0, 0 );
	return 1;
}

CMD:chat( playerid, params[ ] )
{
	CreateLoopingAnimation( playerid, "PED", "IDLE_CHAT", 4.0, 1, 0, 0, 0, 0 );
	return 1;
}

CMD:fuckoff( playerid, params[ ] )
{
	CreateLoopingAnimation( playerid, "PED", "fucku", 4.0, 0, 0, 0, 0, 0 );
	return 1;
}

CMD:shout( playerid, params[ ] )
{
	CreateLoopingAnimation( playerid, "RIOT", "RIOT_shout", 4.0, 1, 0, 0, 0, 0 );
	return 1;
}

CMD:chant( playerid, params[ ] )
{
	CreateLoopingAnimation( playerid, "RIOT", "RIOT_CHANT", 4.0, 1, 0, 0, 0, 0 );
	return 1;
}

CMD:handsup( playerid, params[ ] )
{
    CreateLoopingAnimation( playerid, "PED", "null", 4.0, 1, 0, 0, 0, 0, SPECIAL_ACTION_HANDSUP );
	return 1;
}

CMD:cower( playerid, params[ ] )
{
	CreateLoopingAnimation( playerid, "PED", "COWER", 4.0, 1, 0, 0, 0, 0 );
	return 1;
}

CMD:kiss( playerid, params[ ] )
{
	CreateLoopingAnimation( playerid, "KISSING", "Playa_Kiss_02", 4.0, 1, 0, 0, 0, 0 );
	return 1;
}

CMD:gangsign( playerid, params[ ] )
{
	new id;
	if ( sscanf( params, "d", id ) ) return SendUsage( playerid, "/gangsign [1-7]" );
	else
	{
	    switch( id )
		{
           	case 1: CreateLoopingAnimation(playerid, "GHANDS", "gsign1", 4.0, 1, 0, 0, 0, 0 );
           	case 2: CreateLoopingAnimation(playerid, "GHANDS", "gsign1LH", 4.0, 1, 0, 0, 0, 0 );
           	case 3: CreateLoopingAnimation(playerid, "GHANDS", "gsign2", 4.0, 1, 0, 0, 0, 0 );
           	case 4: CreateLoopingAnimation(playerid, "GHANDS", "gsign2LH", 4.0, 1, 0, 0, 0, 0 );
           	case 5: CreateLoopingAnimation(playerid, "GHANDS", "gsign3", 4.0, 1, 0, 0, 0, 0 );
           	case 6: CreateLoopingAnimation(playerid, "GHANDS", "gsign3LH", 4.0, 1, 0, 0, 0, 0 );
           	case 7: CreateLoopingAnimation(playerid, "GHANDS", "gsign4", 4.0, 1, 0, 0, 0, 0 );
         	default: SendError( playerid, "Invalid Gang Sign ID." );
      	}
	}
	return 1;
}

CMD:lean( playerid, params[ ] )
{
	CreateLoopingAnimation( playerid, "GANGS", "leanIDLE", 4.0, 1, 0, 0, 0, 0 );
	return 1;
}

CMD:sleep( playerid, params[ ] )
{
	CreateLoopingAnimation( playerid, "INT_HOUSE", "BED_Loop_L", 4.0, 1, 0, 0, 0, 0 );
	return 1;
}

CMD:fiddle( playerid, params[ ] )
{
	CreateLoopingAnimation( playerid, "INT_HOUSE", "wash_up", 4.0, 1, 0, 0, 0, 0 );
	return 1;
}

CMD:anims( playerid, params[ ] ) return cmd_animlist( playerid, params );
CMD:animlist( playerid, params[ ] )
{
	SendClientMessage( playerid, COLOR_GOLD, ".: Animation List :." );
	SendClientMessage( playerid, -1, "/dance, /piss, /wank, /sit, /groundsit, /lay, /deal, /laugh, /gangsign" );
	SendClientMessage( playerid, -1, "/slapass, /sex, /crossarms, /wave, /lookout, /strip, /aimthreat, /kiss" );
	SendClientMessage( playerid, -1, "/chat, /fuckoff, /shout, /chant, /handsup, /cower, /sleep, /lean, /fiddle" );
	return 1;
}

CMD:email( playerid, params[ ] ) {
	return ShowPlayerAccountGuard( playerid );
}

CMD:cp( playerid, params[ ] ) return cmd_controlpanel( playerid, params );
CMD:controlpanel( playerid, params[ ] )
{
	szLargeString = ""COL_WHITE"Setting\t"COL_WHITE"Status\t"COL_WHITE"Default\n"COL_GREY"Irresistible Guard\t \t"COL_GREY">>>\n";

	for( new i = 0; i < MAX_SETTINGS; i++ )
		format( szLargeString, 600, "%s%s\t%s\t"COL_GREY"%s\n", szLargeString, g_PlayerSettings[ i ] [ E_NAME ], p_PlayerSettings[ playerid ] { i } == g_PlayerSettings[ i ] [ E_DEFAULT_VAL ] ? ( ""#COL_GREEN"enabled" ) : ( ""#COL_RED"disabled" ), g_PlayerSettings[ i ] [ E_DEFAULT_VAL ] ? ( "disabled" ) : ( "enabled" ) );

	ShowPlayerDialog( playerid, DIALOG_CP_MENU, DIALOG_STYLE_TABLIST_HEADERS, "{FFFFFF}Control Panel", szLargeString, "Select", "Cancel" );
	return 1;
}

CMD:ask( playerid, params[ ] )
{
    new szMessage[ 96 ];
    if ( sscanf( params, "s[96]", szMessage ) ) return SendUsage( playerid, "/ask [QUESTION]" );
    else if ( p_CantUseAsk{ playerid } == true ) return SendError( playerid, "You have been blocked to use this command by an admin." );
    else
	{
		for( new iPos; iPos < sizeof( szQuestionsLog ) - 1; iPos++ )
			memcpy( szQuestionsLog[ iPos ], szQuestionsLog[ iPos + 1 ], 0, sizeof( szQuestionsLog[ ] ) * 4 );

		format( szNormalString, sizeof( szNormalString ), "[%s] %s: %s\n", getCurrentTime( ), ReturnPlayerName( playerid ), szMessage );
		strcpy( szQuestionsLog[ 7 ], szNormalString );

		Beep( playerid );
        SendClientMessageToAdmins( -1, "{FE5700}[QUESTION] %s(%d):{FFFFFF} %s", ReturnPlayerName( playerid ), playerid, szMessage );
		SendClientMessageFormatted( playerid, -1, "{FE5700}[QUESTION]"COL_WHITE" You've asked \"%s\".", szMessage );
	}
	return 1;
}

CMD:weed( playerid, params[ ] )
{
	new
		Float: X, Float: Y, Float: Z
	;

	if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "You are not a civilian." );

	if ( IsPlayerTied( playerid ) || IsPlayerTazed( playerid ) || IsPlayerCuffed( playerid ) || IsPlayerJailed( playerid ) || IsPlayerInPaintBall( playerid ) ) return SendError( playerid, "You cannot use this command at the moment." );

	if ( isnull( params ) ) return SendUsage( playerid, "/weed [COLLECT/SELL/BUY/USE]" );
	else if ( strmatch( params, "collect" ) )
	{
		if ( !JobEquals( playerid, JOB_DRUG_DEALER ) ) return SendError( playerid, "You are not a drug dealer." );
		if ( p_WeedGrams[ playerid ] >= MAX_WEED_STORAGE ) return SendError( playerid, "You can only carry " #MAX_WEED_STORAGE " grams of weed." );
		if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You mustn't be inside a vehicle while collecting weed." );

		new count = 0;
	    for( new i; i < MAX_WEED; i++ )
	    {
			if ( g_weedData[ i ] [ E_CREATED ] == false || g_weedData[ i ] [ E_CUT ] == true ) continue;
			GetDynamicObjectPos( g_weedData[ i ] [ E_OBJECT ], X, Y, Z );

			if ( IsPlayerInRangeOfPoint( playerid, 4.0, X, Y, Z ) && g_weedData[ i ] [ E_CUT ] == false )
			{
			    count++;
                p_WeedGrams[ playerid ]++;
                g_weedData[ i ] [ E_CUT ] = true;
                MoveDynamicObject( g_weedData[ i ] [ E_OBJECT ], X, Y, Z - 5.0, 0.50 );
                SendServerMessage( playerid, "You have collected a gram of "COL_GREEN"weed{FFFFFF}." );
			  	break;
		  	}
	    }
		if ( !count ) SendError( playerid, "You are not next to any weed plant." );
	}
	else if ( !strcmp( params, "sell", false, 4 ) )
	{
	    new pID, iAmount;

		if ( !JobEquals( playerid, JOB_DRUG_DEALER ) ) return SendError( playerid, "You are not a drug dealer." );
	    else if ( p_SellingWeedTick[ playerid ] > g_iTime ) return SendError( playerid, "You must wait a minute before selling weed again." );
		else if ( !p_WeedGrams[ playerid ] ) return SendError( playerid, "You don't have any weed with you." );
	    else if ( sscanf( params[ 5 ],""#sscanf_u"D(1)", pID, iAmount ) ) return SendUsage( playerid, "/weed sell [PLAYER_ID] [GRAMS]" );
	    else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	    else if ( pID == playerid ) return SendError( playerid, "You cannot sell yourself weed." );
		else if ( p_Class[ pID ] != CLASS_CIVILIAN ) return SendError( playerid, "This person is not a civilian." );
		else if ( iAmount > p_WeedGrams[ playerid ] ) return SendError( playerid, "You only have %d grams of weed on you.", p_WeedGrams[ playerid ] );
	    else if ( iAmount < 1 || iAmount > MAX_WEED_STORAGE ) return SendError( playerid, "You can only sell between 1 to " #MAX_WEED_STORAGE " grams of weed to a player." );
	    else if ( GetDistanceBetweenPlayers( playerid, pID ) < 5.0 )
	    {
	    	new
	    		iCost  = iAmount * 5000,
	    		iTaxed = floatround( iCost * 0.8 )
	    	;

			if ( GetPlayerCash( pID ) < iCost ) return SendError( playerid, "This person doesn't have enough money." );

			p_WeedDealer[ pID ] = playerid;
			p_WeedTick[ pID ] = GetTickCount( );
			p_WeedSellingGrams[ pID ] = iAmount;
			p_SellingWeedTick[ playerid ] = g_iTime + 60;
			SendClientMessageFormatted( pID, -1, ""COL_ORANGE"[DRUG DEAL]{FFFFFF} %s(%d) is selling you %d gram(s) of weed for %s. "COL_ORANGE"/weed buy"COL_WHITE" to buy.", ReturnPlayerName( playerid ), playerid, iAmount, ConvertPrice( iCost ) );
			SendClientMessageFormatted( playerid, -1, ""COL_ORANGE"[DRUG DEAL]{FFFFFF} You have sent an offer to %s(%d) to buy a %d gram(s) of weed for "COL_GOLD"%s.", ReturnPlayerName( pID ), pID, iAmount, ConvertPrice( iTaxed ) );
	    }
	    else SendError( playerid, "This player is not nearby." );
	}
	else if ( strmatch( params, "buy" ) )
	{
	    if ( !IsPlayerConnected( p_WeedDealer[ playerid ] ) ) return SendError( playerid, "Your dealer isn't connected anymore." );
		else if ( hasTickcountPassed( p_WeedTick[ playerid ], 120000 ) ) return p_WeedDealer[ playerid ] = INVALID_PLAYER_ID, SendError( playerid, "This deal has ended, each deal goes for 2 minutes maximum. You were late." );
		else
		{
		    new
		    	dealerid = p_WeedDealer[ playerid ],
		    	iGrams 	 = p_WeedSellingGrams[ playerid ],
		    	iCost 	 = iGrams * 5000,
		    	iTaxed 	 = floatround( iCost * 0.8 )
		    ;

			if ( GetPlayerCash( playerid ) < iCost ) return SendError( playerid, "You need %s to buy %d grams of weed.", ConvertPrice( iCost ), iGrams );
			else if ( IsPlayerInPaintBall( dealerid ) ) return SendError( playerid, "Your dealer cannot deal while he's in paintball." );
			else if ( p_Class[ dealerid ] != CLASS_CIVILIAN ) return p_WeedDealer[ playerid ] = INVALID_PLAYER_ID, SendError( playerid, "This deal has ended, the dealer is not a civilian." );
			else if ( !JobEquals( dealerid, JOB_DRUG_DEALER ) ) return SendError( playerid, "Your dealer no longer does drugs." );
			else if ( !p_WeedGrams[ dealerid ] ) return p_WeedDealer[ playerid ] = INVALID_PLAYER_ID,  SendError( playerid, "Your dealer doesn't have any more weed." );
			else if ( ( p_WeedGrams[ playerid ] + iGrams ) > MAX_WEED_STORAGE ) return SendError( playerid, "You can only carry " #MAX_WEED_STORAGE " grams of weed." );
			else
			{
	         	p_WeedGrams[ playerid ] += iGrams;
	         	p_WeedGrams[ dealerid ] -= iGrams;

				GivePlayerCash( playerid, -iCost );
				GivePlayerCash( dealerid, iTaxed );

				SendClientMessageFormatted( dealerid, -1, ""COL_ORANGE"[DRUG DEAL]{FFFFFF} %s(%d) has bought %d grams of weed off you for %s.", ReturnPlayerName( playerid ), playerid, iGrams, ConvertPrice( iTaxed ) );
				SendClientMessageFormatted( playerid, -1, ""COL_ORANGE"[DRUG DEAL]{FFFFFF} You have bought %d grams of weed for %s.", iGrams, ConvertPrice( iCost ) );

				GivePlayerWantedLevel( dealerid, 6 );
				GivePlayerWantedLevel( playerid, 6 );

				Beep( dealerid );
				p_WeedDealer[ playerid ] = INVALID_PLAYER_ID;
			}
		}
	}
	else if ( strmatch( params, "use" ) )
	{
    	if ( GetPVarInt( playerid, "weed_timestamp" ) > g_iTime ) return SendError( playerid, "You must wait at least %d seconds before using this command.", GetPVarInt( playerid, "weed_timestamp" ) - g_iTime );
		if ( p_WeedGrams[ playerid ] < 1 ) return SendError( playerid, "You don't have any weed with you." );
		if ( p_Jailed{ playerid } == true ) return SendError( playerid, "You cannot use this in jail." );
		if ( IsPlayerLoadingObjects( playerid ) ) return SendError( playerid, "You're in a object-loading state, please wait." );
		if ( IsPlayerAttachedObjectSlotUsed( playerid, 0 ) ) return SendError( playerid, "You cannot use this command since you're robbing." );
		if ( JobEquals( playerid, JOB_DRUG_DEALER ) ) return SendError( playerid, "You cannot use your own products, they are for resale only!" );
		if ( IsPlayerInEvent( playerid ) ) return SendError( playerid, "You cannot use this command since you're in an event." );
		//if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You cannot use this command in a vehicle." );
	    //if ( GetPlayerState( playerid ) == PLAYER_STATE_ENTER_VEHICLE_DRIVER || GetPlayerState( playerid ) == PLAYER_STATE_ENTER_VEHICLE_PASSENGER ) return SendError( playerid, "You cannot use this command if you're entering a vehicle." );
	    //if ( GetPlayerState( playerid ) == PLAYER_STATE_EXIT_VEHICLE ) return SendError( playerid, "You cannot use this command if you're exiting a vehicle." );
		//if ( p_InAnimation{ playerid } || GetPlayerSpecialAction( playerid ) != SPECIAL_ACTION_NONE ) return SendError( playerid, "You cannot use this command since you're in animation." );
		SetPVarInt( playerid, "weed_timestamp", g_iTime + 120 );
		p_WeedGrams[ playerid ]--;
		SetPlayerHealth( playerid, 150 );
		SetPlayerDrunkLevel( playerid, 5000 );
		SendServerMessage( playerid, "You have smoked a gram of weed." );
		DestroyDynamic3DTextLabel( p_WeedLabel[ playerid ] );
	    p_WeedLabel[ playerid ] = CreateDynamic3DTextLabel( "Blazed W33D Recently!", COLOR_GREEN, X, Y, Z + 1.0, 15, playerid );
		//ApplyAnimation( playerid, "GANGS", "smkcig_prtl", 4.1, 0, 1, 1, 0, 0, 1 );
	}
	else return SendUsage( playerid, "/weed [COLLECT/SELL/BUY/USE]" );
	return 1;
}

CMD:ach( playerid, params[ ] ) return cmd_achievements( playerid, params );
CMD:achievements( playerid, params[ ] )
{
	displayAchievements( playerid );
	return 1;
}

CMD:wood( playerid, params[ ] )
{
	new
	    Float: X, Float: Y, Float: Z
	;

	if ( isnull( params ) ) return SendUsage( playerid, "/wood [CHOP/CHIP/START/STOP]" );
	else if ( strmatch( params, "chop" ) )
	{
	    new count = 0;
	    for( new i; i < MAX_TREES; i++ )
	    {
			if ( g_treeData[ i ] [ E_CREATED ] == false || g_treeData[ i ] [ E_CUT ] == false ) continue;
			GetDynamicObjectPos( g_treeData[ i ] [ E_OBJECT ], X, Y, Z );

			if ( IsPlayerInRangeOfPoint( playerid, 4.0, X, Y, Z ) && g_treeData[ i ] [ E_CHOPPED ] == false )
			{
			    StopDynamicObject( g_treeData[ i ] [ E_OBJECT ] );
			    DestroyDynamicObject( g_treeData[ i ] [ E_OBJECT ] );
			    g_treeData[ i ] [ E_OBJECT ] = CreateDynamicObject( 831, X, Y, Z + 0.75, 0.0, 0.0, 0.0 );
			    SetPlayerPos( playerid, X, Y + 2, Z + 0.75 );
			    p_Wood[ playerid ]++;
			    g_treeData[ i ] [ E_CHOPPED ] = true;
			    count++;
			    GivePlayerCash( playerid, 250 );
				SendServerMessage( playerid, "Tree successfully chopped into smaller pieces. Go to the wood chipper and type "COL_ORANGE"/wood chip{FFFFFF}!" );
				break;
		  	}
	    }
		if ( !count ) SendError( playerid, "You are not next to any chopped tree." );
	}
	else if ( strmatch( params, "chip" ) )
	{
		if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You cannot use this feature while in a vehicle." );
	    if ( IsPlayerInRangeOfPoint( playerid, 4.0, -2338.20, -106.51, 34.00 ) )
	    {
	        if ( p_Wood[ playerid ] < 1 )
	            return SendError( playerid, "You are not carrying any chopped wood." );

		    new object = CreateDynamicObject( 14872, -2338.20, -106.51, 34.00, -27.78, 89.40, 1.92 );
		    MoveDynamicObject( object, -2338.20, -106.51, 33.5, 0.10 );
			SyncObject( playerid );
            PlayerPlaySound( playerid, 1153, -2338.20, -106.51, 33.99 );
            GivePlayerCash( playerid, 500 );
		    SetTimerEx( "lumberjack_RemoveWood", 9000, false, "d", object );
            p_Wood[ playerid ]--;
            g_LogsInStock ++;
           	UpdateWoodStockObject( );
			SendServerMessage( playerid, "You've placed a chopped log in the wood chipper. You have made a total of "COL_GOLD"$1,000!" );
		}
		else SendError( playerid, "You are not next to the wood chipper." );
	}
	else if ( strmatch( params, "start" ) )
	{
		if ( p_StartedLumberjack{ playerid } == true )
		    return SendError( playerid, "You are already doing this job." );

	    if ( !IsPlayerInAnyVehicle( playerid ) )
	        return SendError( playerid, "You are not in any vehicle." );

		if ( GetVehicleModel( GetPlayerVehicleID( playerid ) ) != 455 )
	        return SendError( playerid, "You are not inside the wood exporting truck." );

		if ( GetPlayerState( playerid ) != PLAYER_STATE_DRIVER )
		    return SendError( playerid, "You must be a driver of this vehicle to proceed." );

 		if ( g_LogsInStock < 1 )
	    	return SendError( playerid, "There is not enough logs in stock to export." );

		new id = random( sizeof( g_treeExportLocations ) );
		p_treeExportLocation[ playerid ] = id;

		static aPlayer[ 1 ]; aPlayer[ 0 ] = playerid;
		DestroyDynamicMapIcon( p_LumberjackMapIcon[ playerid ] );
		p_LumberjackMapIcon[ playerid ] = CreateDynamicMapIconEx( -2330.8535, -113.9084, 34.00, 51, 0, MAPICON_GLOBAL, 6000.0, { -1 }, { -1 }, aPlayer );

		p_LumberjackTimeElapsed[ playerid ] = g_iTime;
		p_LumberjackReturn[ playerid ] = CreateDynamicRaceCP( 0, -2330.8535, -113.9084, 34.00, g_treeExportLocations[ id ] [ 0 ], g_treeExportLocations[ id ] [ 1 ], g_treeExportLocations[ id ] [ 2 ], 4.0, -1, -1, playerid );
		p_StartedLumberjack{ playerid } = true;

		ShowPlayerHelpDialog( playerid, 7500, "A ~g~~h~truck blip~w~~h~ has been shown on your radar. Go to where the truck blip is located to export and import logs." );
	}
	else if ( strmatch( params, "stop" ) )
	{
		if ( p_StartedLumberjack{ playerid } != true )
		    return SendError( playerid, "You are not doing this job." );

		p_StartedLumberjack{ playerid } = false;
	 	GameTextForPlayer( playerid, "~r~job stopped!", 4000, 0 );
        DestroyDynamicRaceCP( p_LumberjackReturn[ playerid ] );
        p_LumberjackReturn[ playerid ] = 0xFFFF;
        DestroyDynamicRaceCP( p_LumberjackDeliver[ playerid ] );
        p_LumberjackDeliver[ playerid ] = 0xFFFF;
        p_treeExportLocation[ playerid ] = 0xFF;
		DestroyDynamicMapIcon( p_LumberjackMapIcon[ playerid ] );
		p_LumberjackMapIcon[ playerid ] = 0xFFFF;
	}
	else SendUsage( playerid, "/wood [CHOP/CHIP/START/STOP]" );
	return 1;
}

CMD:idof( playerid, params[ ] )
{
	new pID;
	if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/idof [PART_OF_NAME]" );
	if ( !IsPlayerConnected( pID ) ) return SendError( playerid, "This player isn't connected." );
	SendServerMessage( playerid, "%s: "COL_GREY"%d", ReturnPlayerName( pID ), pID );
	return 1;
}

CMD:firetracker( playerid, params[ ] )
{
	if ( p_Class[ playerid ] != CLASS_FIREMAN )
		return SendError( playerid, "You are not a fireman." );

	KillTimer( p_FireDistanceTimer[ playerid ] );
	p_FireDistanceTimer[ playerid ] = 0xFF;
	p_FireDistanceTimer[ playerid ] = SetTimerEx( "OnPlayerFireDistanceUpdate", 1000, true, "d", playerid );
	SendServerMessage( playerid, "Fire's have been tracked and have been forwarded to you in meters. Find the fires and extinguish them." );
	return 1;
}

CMD:rfiretracker( playerid, params[ ] )
{
	KillTimer( p_FireDistanceTimer[ playerid ] );
	p_FireDistanceTimer[ playerid ] = 0xFF;
	TextDrawHideForPlayer( playerid, p_FireDistance1[ playerid ] );
	TextDrawHideForPlayer( playerid, p_FireDistance2[ playerid ] );
	SendServerMessage( playerid, "You have turned off your fire tracker." );
	return 1;
}

CMD:playercolor( playerid, params[ ] ) return cmd_pc( playerid, params );
CMD:pc( playerid, params[ ] )
{
    ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_LIST, "{FFFFFF}Player Colors", "Innocent\n{FFEC41}Low Suspect\n"COL_ORANGE"Wanted\n{F83245}Most Wanted\n{3E7EFF}Police\n{0035FF}F.B.I\n{191970}C.I.A\n{954BFF}Army\n{A83434}Fireman\n{00CC00}Paramedic\n"COL_PINK"Admin On Duty\n"COL_GREY"Other Colors Are Gang Colors", "Okay", "" );
	return 1;
}

CMD:robstore( playerid, params[ ] )
{
	SendServerMessage( playerid, "This command binds your walking key, so you must be in a robbery checkpoint to get a response!" );
	CallLocalFunction( "OnPlayerKeyStateChange", "ddd", playerid, KEY_WALK, KEY_SPRINT );
	return 1;
}

CMD:myaccid( playerid, params[ ] )
{
    SendServerMessage( playerid, "Your account ID is "COL_GOLD"%d"COL_WHITE".", p_AccountID[ playerid ] );
	return 1;
}

CMD:job( playerid, params[ ] )
{
    if ( p_VIPLevel[ playerid ] >= VIP_PLATINUM && p_VIPJob{ playerid } != p_Job{ playerid } )
    	return SendServerMessage( playerid, "Your jobs are "COL_GOLD"%s"COL_WHITE" and "COL_GOLD"%s"COL_WHITE".", GetJobName( p_Job{ playerid } ), GetJobName( p_VIPJob{ playerid } ) );

    if ( p_VIPLevel[ playerid ] >= VIP_PLATINUM && p_VIPJob{ playerid } == p_Job{ playerid } )
    	return SendServerMessage( playerid, "Your jobs are "COL_GOLD"%s"COL_WHITE" and your VIP job is disabled.", GetJobName( p_Job{ playerid } ) );

   	SendServerMessage( playerid, "Your job is a "COL_GOLD"%s"COL_WHITE".", GetJobName( p_Job{ playerid } ) );
	return 1;
}

CMD:jaillist( playerid, params[ ] )
{
	new count = 0;
	SendClientMessage( playerid, COLOR_GOLD, ".: Jail List :." );
	foreach(new i : Player)
	{
	    if ( p_Jailed{ i } == true )
	    {
	        SendClientMessageFormatted( playerid, -1, "%s (%d seconds)", ReturnPlayerName( i ), p_JailTime[ i ] );
	        count++;
	    }
	}
	if ( count == 0 ) SendClientMessage( playerid, -1, "There are no players in jail." );
	return 1;
}

CMD:gps( playerid, params[ ] )
{
	if ( p_GPSToggled{ playerid } == true )
	{
		p_GPSLocation	[ playerid ] = 0;
		p_GPSToggled	{ playerid } = false;
		DestroyDynamicObject( p_GPSObject[ playerid ] );
		KillTimer( p_GPSTimer[ playerid ] );
		p_GPSTimer[ playerid ] = 0xFF;
	  	p_GPSObject[ playerid ] = INVALID_OBJECT_ID;
	  	TextDrawHideForPlayer( playerid, p_GPSInformation[ playerid ] );
		return SendServerMessage( playerid, "You have de-activated your GPS." ), 1;
	}
	else
	{
	    if ( GetPlayerState( playerid ) != PLAYER_STATE_DRIVER ) return SendError( playerid, "You have to be a driver of a vehicle to use this a command." );
        ShowPlayerDialog( playerid, DIALOG_GPS_CITY, DIALOG_STYLE_LIST, "{FFFFFF}GPS - Choose City", "San Fierro\nLas Venturas\nLos Santos", "Select", "Cancel" );
	}
	return 1;
}

CMD:lastlogged( playerid, params[ ] )
{
	static
	    player[ MAX_PLAYER_NAME ]
	;

	if ( sscanf( params, "s[24]", player ) ) return SendUsage( playerid, "/lastlogged [PLAYER_NAME]" );
	else
	{
		format( szNormalString, sizeof( szNormalString ), "SELECT `LASTLOGGED` FROM `USERS` WHERE `NAME` = '%s' LIMIT 0,1", mysql_escape( player ) );
  		mysql_function_query( dbHandle, szNormalString, true, "OnPlayerLastLogged", "iis", playerid, 0, player );
	}
	return 1;
}

thread OnPlayerLastLogged( playerid, irc, player[ ] )
{
	new
	    rows, fields, time, Field[ 50 ]
	;
    cache_get_data( rows, fields );
	if ( rows )
	{
		cache_get_field_content( 0, "LASTLOGGED", Field );

		time = g_iTime - strval( Field );
		if ( time > 86400 )
		{
		    time /= 86400;
		    format( Field, sizeof( Field ), "%d day(s) ago.", time );
		}
		else if ( time > 3600 )
		{
		    time /= 3600;
		    format( Field, sizeof( Field ), "%d hour(s) ago.", time );
		}
		else
		{
		    time /= 60;
		    format( Field, sizeof( Field ), "%d minute(s) ago.", time );
		}

		if ( !irc ) SendClientMessageFormatted( playerid, COLOR_GREY, "[SERVER]"COL_RED" %s:"COL_WHITE" Last Logged: %s", player, Field );
		else {
			format( szNormalString, sizeof( szNormalString ),"7LAST LOGGED OF '%s': %s", player, Field );
			DCC_SendChannelMessage( discordGeneralChan, szNormalString );
		}
	}
	else {
		if ( !irc ) SendError( playerid, "Player not found." );
	}
	return 1;
}

CMD:weeklytime( playerid, params[ ] )
{
	static
	    player[ MAX_PLAYER_NAME ]
	;

	if ( sscanf( params, "s[24]", player ) ) return SendUsage( playerid, "/weeklytime [PLAYER_NAME]" );
	else
	{
		format( szNormalString, sizeof( szNormalString ), "SELECT `UPTIME`,`WEEKEND_UPTIME` FROM `USERS` WHERE `NAME` = '%s' LIMIT 0,1", mysql_escape( player ) );
  		mysql_function_query( dbHandle, szNormalString, true, "OnPlayerWeeklyTime", "iis", playerid, 0, player );
	}
	return 1;
}

thread OnPlayerWeeklyTime( playerid, irc, player[ ] )
{
	new
	    rows, fields,
	    iCurrentUptime, iLastUptime
	;
    cache_get_data( rows, fields );
	if ( rows )
	{
		iCurrentUptime 	= cache_get_field_content_int( 0, "UPTIME", dbHandle );
		iLastUptime 	= cache_get_field_content_int( 0, "WEEKEND_UPTIME", dbHandle );

		if ( !irc ) SendClientMessageFormatted( playerid, COLOR_GREY, "[SERVER]"COL_GREY" %s:"COL_WHITE" %s", player, secondstotime( iCurrentUptime - iLastUptime ) );
		else
		{
			format( szNormalString, sizeof( szNormalString ),"7WEEKLY TIME OF '%s': %s", player, secondstotime( iCurrentUptime - iLastUptime ) );
			DCC_SendChannelMessage( discordGeneralChan, szNormalString );
		}
	}
	else
	{
		if ( !irc )
			SendError( playerid, "Player not found." );
	}
	return 1;
}

CMD:pleave( playerid, params[ ] )
{
	if ( !IsPlayerInPaintBall( playerid ) )
	    return SendError( playerid, "You're not inside the paintball." );

	LeavePlayerPaintball( playerid );
    SetPlayerHealth( playerid, -1 );
    SendServerMessage( playerid, "You have left the paintball arena." );
	return 1;
}

CMD:bc( playerid, params[ ] ) return cmd_breakcuff( playerid, params );
CMD:breakcuff( playerid, params[ ] )
{
	if ( p_BobbyPins[ playerid ] < 1 )
	    return SendError( playerid, "You don't have any bobby pins." );

	if ( !IsPlayerAttachedObjectSlotUsed( playerid, 2 ) ) return SendError( playerid, "You are not cuffed." );
	else if ( IsPlayerLoadingObjects( playerid ) ) return SendError( playerid, "You're in a object-loading state, please wait." );
	else
	{
	    new iRandom = random( 101 );

		if ( IsPlayerDetained( playerid ) ) // && iRandom < 66 )
			return SendError( playerid, "You cannot break your cuffs if you're detained." );
	    //	return SendError( playerid, "You snapped the bobby pin and failed to get break out of your cuffs." );

		if ( p_BobbyPins[ playerid ]-- <= 3 )
			ShowPlayerHelpDialog( playerid, 2500, "You only have %d bobby pins left!", p_BobbyPins[ playerid ] );

	    if ( iRandom < 50 )
	    	return SendError( playerid, "You snapped the bobby pin and failed to get break out of your cuffs." );

		TogglePlayerControllable( playerid, 1 );
	 	RemovePlayerAttachedObject( playerid, 2 );
		SetPlayerSpecialAction( playerid, SPECIAL_ACTION_NONE );
		if ( !IsPlayerInAnyVehicle( playerid ) ) {
			ClearAnimations( playerid );
		}
		p_Cuffed{ playerid } = false;
		p_Tazed{ playerid } = false;
		p_Detained{ playerid } = false;
		Delete3DTextLabel( p_DetainedLabel[ playerid ] );
		p_DetainedLabel[ playerid ] = Text3D: INVALID_3DTEXT_ID;
		p_DetainedBy[ playerid ] = INVALID_PLAYER_ID;
		p_QuitToAvoidTimestamp[ playerid ] = g_iTime + 3;

		SendServerMessage( playerid, "You have successfully broken your cuffs." );
	    GivePlayerWantedLevel( playerid, 6 );
	}
	return 1;
}


CMD:cuttie( playerid, params[ ] )
{
	new
		bTiedLong = g_iTime - p_TimeTiedAt[ playerid ] > MAX_TIME_TIED;

	if ( p_Scissors[ playerid ] < 1 && !bTiedLong )
	    return SendError( playerid, "You don't have any scissors" );

	if ( !p_Tied{ playerid } ) return SendError( playerid, "You are not tied." );
	else if ( IsPlayerLoadingObjects( playerid ) ) return SendError( playerid, "You're in a object-loading state, please wait." );
	else
	{
	    new iRandom = random( 101 );

	    p_Scissors[ playerid ] --;

	    if ( IsPlayerKidnapped( playerid ) )
	    	iRandom -= 75;

	    if ( bTiedLong )
	    	iRandom = 100; // Tied for too long

	    if ( iRandom > 10 )
	    {
        	TogglePlayerControllable( playerid, 1 );
			p_Tied{ playerid } = false;
		   	if ( IsPlayerKidnapped( playerid ) ) {
		     	p_Kidnapped{ playerid } = false;
		 	}
			Delete3DTextLabel( p_TiedLabel[ playerid ] );
			p_TiedLabel[ playerid ] = Text3D: INVALID_3DTEXT_ID;
			SendServerMessage( playerid, "You have cut the ties connected to your hands." );
	    }
	    else SendServerMessage( playerid, "You have failed to cut the tie connected to you." );

		if ( 0 <= p_Scissors[ playerid ] <= 3 )
			ShowPlayerHelpDialog( playerid, 2500, "You only have %d scissors left!", p_Scissors[ playerid ] );
	}
	return 1;
}

CMD:xpmarket( playerid, params[ ] )
{
	ShowPlayerDialog(playerid, DIALOG_XPMARKET, DIALOG_STYLE_INPUT, "{FFFFFF}XP Market", ""COL_WHITE"Welcome, enter inside the input box how much XP you're willing\nto trade in for.\n\nExchange Rate: "COL_GOLD"1 XP = $"#EXCHANGE_XPCASH"", "Select", "Cancel");
	return 1;
}

CMD:emp( playerid, params[ ] )
{
	new
		pID
	;
	if ( p_Class[ playerid ] != CLASS_POLICE ) return SendError( playerid, "This is restricted to Police only." );
	else if ( p_inCIA{ playerid } == false || p_inArmy{ playerid } == true ) return SendError( playerid, "This is restricted to CIA only." );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/emp [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( pID == playerid ) return SendError( playerid, "You cannot do this to yourself." );
	else if ( IsPlayerKidnapped( playerid ) ) return SendError( playerid, "You are kidnapped, you cannot do this." );
	else if ( IsPlayerTied( playerid ) ) return SendError( playerid, "You are tied, you cannot do this." );
	else if ( IsPlayerAdminOnDuty( pID ) ) return SendError( playerid, "This person is an admin on duty!" );
	else if ( p_Class[ pID ] == CLASS_POLICE ) return SendError( playerid, "This person is a apart of the Police Force." );
	else if ( !p_WantedLevel[ pID ] ) return SendError( playerid, "This person is innocent!" );
	else if ( !IsPlayerInAnyVehicle( pID ) ) return SendError( playerid, "This player isn't inside any vehicle." );
	else if ( GetPlayerState( pID ) != PLAYER_STATE_DRIVER ) return SendError( playerid, "This player is not a driver of any vehicle." );
	//else if ( g_buyableVehicle{ GetPlayerVehicleID( pID ) } == true ) return SendError( playerid, "Failed to place a Electromagnetic Pulse on this player's vehicle." );
    else if ( GetDistanceBetweenPlayers( playerid, pID ) < 30.0 )
	{
	    /* ** ANTI EMP SPAM ** */
	    if ( p_AntiEmpSpam[ pID ] > g_iTime )
	    	return SendError( playerid, "You cannot EMP this person for another minute." );
	    /* ** END OF ANTI SPAM ** */

	    new
	    	iVehicle = GetPlayerVehicleID( pID );

		if ( g_buyableVehicle{ iVehicle } )
			return SendError( playerid, "Failed to place a Electromagnetic Pulse on this player's vehicle." );

		p_AntiEmpSpam[ pID ] = g_iTime + 60;

	    if ( p_AntiEMP[ pID ] > 0 )
	    {
		    p_AntiEMP[ pID ] --;

		    new
		    	iRandom = random( 101 );

		    //if ( g_buyableVehicle{ iVehicle } )
		    	//iRandom -= 50;

	    	if ( iRandom < 90 )
	    	{
		        SendClientMessage( playerid, -1, ""COL_RED"[EMP]{FFFFFF} An Electromagnetic Pulse attempt has been repelled by an aluminum foil!" );
				SendClientMessage( pID, -1, ""COL_GREEN"[EMP]{FFFFFF} Electromagnetic Pulse had been repelled by aluminum foil set on vehicle." );
	    		return 1;
	    	}
	    }

 		SendClientMessageFormatted( pID, -1, ""COL_RED"[EMP]{FFFFFF} %s(%d) has sent an electromagnetic pulse on your vehicle causing it to crash for 30 seconds.", ReturnPlayerName( playerid ), playerid );
		SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[EMP]{FFFFFF} You have activated a electromagnetic pulse on %s(%d)'s vehicle!", ReturnPlayerName( pID ), pID );
		SetTimerEx( "emp_deactivate", 30000, false, "d", GetPlayerVehicleID( pID ) );
		GetVehicleParamsEx( iVehicle, engine, lights, alarm, doors, bonnet, boot, objective );
		SetVehicleParamsEx( iVehicle, VEHICLE_PARAMS_OFF, lights, alarm, doors, bonnet, boot, objective );
	}
	else SendError( playerid, "This player is not nearby." );
	return 1;
}

CMD:moviemode( playerid, params[ ] )
{
	switch( p_inMovieMode{ playerid } )
	{
		case true:
		{
			ShowPlayerTogglableTextdraws( playerid );
			TextDrawShowForPlayer( playerid, g_CurrentRankTD );
			TextDrawShowForPlayer( playerid, g_currentXPTD );
		    PlayerTextDrawShow( playerid, p_LocationTD[ playerid ] );
			if ( p_InAnimation{ playerid } ) TextDrawShowForPlayer( playerid, g_AnimationTD );
			PlayerTextDrawShow( playerid, p_ExperienceTD[ playerid ] );
			if ( IsDoubleXP( ) ) TextDrawShowForPlayer( playerid, g_DoubleXPTD );
			TextDrawShowForPlayer( playerid, g_WebsiteTD );
			if ( p_WantedLevel[ playerid ] ) PlayerTextDrawShow( playerid, p_WantedLevelTD[ playerid ] );
			TextDrawShowForPlayer( playerid, g_MotdTD );
			if ( g_HappyHour ) TextDrawShowForPlayer( playerid, g_NotManyPlayersTD );
			if ( p_FPSCounter{ playerid } ) TextDrawShowForPlayer( playerid, p_FPSCounterTD[ playerid ] );
			if ( p_AdminOnDuty{ playerid } ) TextDrawShowForPlayer( playerid, g_AdminOnDutyTD );
			TextDrawShowForPlayer( playerid, g_WorldDayTD );
			ShowPlayerIrresistibleRank( playerid );
			for( new i; i < sizeof( g_MovieModeTD ); i ++ ) TextDrawHideForPlayer( playerid, g_MovieModeTD[ i ] );
		    p_inMovieMode{ playerid } = false;
		    SendServerMessage( playerid, "Movie mode has been un-toggled." );
		}
		case false:
		{
			HidePlayerTogglableTextdraws( playerid );
			TextDrawHideForPlayer( playerid, g_CurrentRankTD );
			TextDrawHideForPlayer( playerid, g_currentXPTD );
			PlayerTextDrawHide( playerid, p_LocationTD[ playerid ] );
			PlayerTextDrawHide( playerid, p_ExperienceTD[ playerid ] );
			PlayerTextDrawHide( playerid, p_WantedLevelTD[ playerid ] );
			TextDrawHideForPlayer( playerid, g_WebsiteTD );
			TextDrawHideForPlayer( playerid, g_AnimationTD );
			TextDrawHideForPlayer( playerid, g_AdminOnDutyTD );
			TextDrawHideForPlayer( playerid, g_DoubleXPTD );
			PlayerTextDrawHide( playerid, p_PlayerRankTD[ playerid ] );
			PlayerTextDrawHide( playerid, p_PlayerRankTextTD[ playerid ] );
			TextDrawHideForPlayer( playerid, g_MotdTD );
			TextDrawHideForPlayer( playerid, g_NotManyPlayersTD );
			TextDrawHideForPlayer( playerid, g_WorldDayTD );
			TextDrawHideForPlayer( playerid, p_FPSCounterTD[ playerid ] );
			for( new i; i < sizeof( g_MovieModeTD ); i ++ ) TextDrawShowForPlayer( playerid, g_MovieModeTD[ i ] );
		    p_inMovieMode{ playerid } = true;
		    SendServerMessage( playerid, "Movie mode has been toggled." );
		}
	}
	return 1;
}

CMD:hidelabel( playerid, params[ ] ) return cmd_rlabel( playerid, params );
CMD:rlabel( playerid, params[ ] )
{
	if ( p_InfoLabel[ playerid ] == Text3D: INVALID_3DTEXT_ID )
		return SendError( playerid, "You do not have any label on your head to remove." );

	p_LabelColor[ playerid ] = COLOR_GREY;
	Delete3DTextLabel( p_InfoLabel[ playerid ] );
	p_InfoLabel[ playerid ] = Text3D: INVALID_3DTEXT_ID;
	SendServerMessage( playerid, "You have removed your label from your head." );
	return 1;
}

CMD:labelinfo( playerid, params[ ] )
{
    if ( p_InfoLabel[ playerid ] != Text3D: INVALID_3DTEXT_ID )
    {
        SendServerMessage( playerid, "{%06x}%s", p_LabelColor[ playerid ] >>> 8, p_InfoLabelString[ playerid ] );
    }
    else SendError( playerid, "You don't have a label attached on you." );
	return 1;
}

CMD:label( playerid, params[ ] )
{
	new
		szLabel[ 32 ]
	;

	if ( p_XP[ playerid ] < 3500 ) return SendError( playerid, "You need 3,500 XP to use this command." );
	else if ( sscanf( params, "s[32]", szLabel ) ) return SendUsage( playerid, "/label [MESSAGE]" );
	else
	{
	    Delete3DTextLabel( p_InfoLabel[ playerid ] );
	    format( p_InfoLabelString[ playerid ], sizeof( p_InfoLabelString[ ] ), "%s", szLabel );
		p_InfoLabel[ playerid ] = Text3D: INVALID_3DTEXT_ID;
	    p_InfoLabel[ playerid ] = Create3DTextLabel( szLabel, p_LabelColor[ playerid ], 0.0, 0.0, 0.0, 15.0, 0 );
	    Attach3DTextLabelToPlayer( p_InfoLabel[ playerid ], playerid, 0.0, 0.0, 0.4 );
	    SendServerMessage( playerid, "You placed a label above your head containing the text above." );
	}
	return 1;
}

CMD:labelcolor( playerid, params[ ] )
{
	new
		szLabel[ 7 ];

	if ( sscanf( params, "s[7]", szLabel ) ) return SendUsage( playerid, "/labelcolor [HEX CODE (= normal)]" );
	else if ( p_VIPLevel[ playerid ] < VIP_REGULAR ) return SendError( playerid, "You are not a V.I.P, to become one visit "COL_GREY"donate.irresistiblegaming.com" );
	else if ( strmatch( szLabel, "normal" ) )
	{
		p_LabelColor[ playerid ] = COLOR_GREY;
		Update3DTextLabelText( p_InfoLabel[ playerid ], COLOR_GREY, p_InfoLabelString[ playerid ] );
		return SendServerMessage( playerid, "You've successfully reset your label's color." );
	}
	else if ( strlen( szLabel ) != 6 ) return SendError( playerid, "Your hex code must be equal to six characters. "COL_ORANGE"Format: RRGGBB" );
	else if ( p_InfoLabel[ playerid ] == Text3D: INVALID_3DTEXT_ID ) return SendError( playerid, "You don't have a label attached on you." );
	else if ( strmatch( szLabel, "FF0770" ) ) return SendError( playerid, "This colour is strictly prohibited and can result in ban." );
	else if ( !isHex( szLabel ) ) return SendError( playerid, "Invalid Hex Code." );
	else
	{
		SendServerMessage( playerid, "You have changed your {%s}label's color to this{FFFFFF}. To reset: "COL_GREY"/labelcolor normal"COL_WHITE".", szLabel );
		format( szNormalString, 11, "0x%sFF", szLabel );
		p_LabelColor[ playerid ] = HexToInt( szNormalString );
		Update3DTextLabelText( p_InfoLabel[ playerid ], p_LabelColor[ playerid ], p_InfoLabelString[ playerid ] );
	}
	return 1;
}

CMD:stopradio( playerid, params[ ] )
{
	if ( IsPlayerUsingRadio( playerid ) ) p_UsingRadio{ playerid } = false;
    StopAudioStreamForPlayer( playerid );
	return 1;
}

CMD:changepassword( playerid, params[ ] ) return cmd_changepw( playerid, params );
CMD:changepass( playerid, params[ ] ) return cmd_changepw( playerid, params );
CMD:changepw( playerid, params[ ] )
{
	static
		szHashed[ 129 ], szSalt[ 25 ];

	if ( !p_PlayerLogged{ playerid } ) return SendError( playerid, "You are not logged in." );
	if ( isnull( params ) ) return SendUsage( playerid, "/change(pw/pass/password) [PASSWORD]" );
	if ( strlen( params ) > 24 || strlen( params ) < 3 ) return SendError( playerid, "Your password must be indexed within 3 and 24 characters." );

 	randomString( szSalt, 24 );
 	pencrypt( szHashed, sizeof( szHashed ), params, szSalt );

	format( szBigString, sizeof( szBigString ), "UPDATE `USERS` SET `PASSWORD`='%s', `SALT`='%s' WHERE `ID`=%d", szHashed, mysql_escape( szSalt ), p_AccountID[ playerid ] );
	mysql_single_query( szBigString );

	GameTextForPlayer( playerid, "~r~Password changed!", 5000, 3 );
	SendClientMessageFormatted( playerid, COLOR_GOLD, "[PASSWORD CHANGED]"COL_WHITE" You have successfully changed your password to \""COL_GREY"%s"COL_WHITE"\", make sure you remember!", params );
	return 1;
}

CMD:richlist( playerid, params[ ] )
{
    SendClientMessage( playerid, COLOR_GOLD, ".: Richest Online Players :." );
    new
        iArray[ 3 ] = { INVALID_PLAYER_ID, ... },
        Richest = 0,
        iStep = 0
	;
	Richest = 0;
	foreach(new i : Player)
	{
	    if ( p_AdminLevel[ i ] > 0 ) continue;
	    if ( GetPlayerCash( i ) > Richest && i != iArray[ 0 ] && i != iArray[ 1 ] && i != iArray[ 2 ] ) {
			iArray[ iStep ] = i;
			Richest = GetPlayerCash( i );
		}
	}
	Richest = 0;
	SendClientMessage( playerid, -1, ReturnPlayerName( iArray[ iStep ] ) );
	iStep ++;
	foreach(new i : Player)
	{
	    if ( p_AdminLevel[ i ] > 0 ) continue;
	    if ( GetPlayerCash( i ) > Richest && i != iArray[ 0 ] && i != iArray[ 1 ] && i != iArray[ 2 ] ) {
			iArray[ iStep ] = i;
			Richest = GetPlayerCash( i );
		}
	}
	Richest = 0;
	SendClientMessage( playerid, -1, ReturnPlayerName( iArray[ iStep ] ) );
	iStep ++;
	foreach(new i : Player)
	{
	    if ( p_AdminLevel[ i ] > 0 ) continue;
	    if ( GetPlayerCash( i ) > Richest && i != iArray[ 0 ] && i != iArray[ 1 ] && i != iArray[ 2 ] ) {
			iArray[ iStep ] = i;
			Richest = GetPlayerCash( i );
		}
	}
	SendClientMessage( playerid, -1, ReturnPlayerName( iArray[ iStep ] ) );
	return 1;
}

CMD:hitlist( playerid, params[ ] )
{
	if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "This is restricted to civilians only." );
	//if ( !JobEquals( playerid, JOB_HITMAN ) ) return SendError( playerid, "You have to be a hitman to use this command." );

    SendClientMessage( playerid, COLOR_GOLD, ".: List of all contracted People :." );
    new count = 0;
	foreach(new i : Player)
	{
	    if ( p_ContractedAmount[ i ] > 0 )
	    {
			format( szNormalString, sizeof( szNormalString ), "%s(%d) - "COL_GOLD"$%d", ReturnPlayerName( i ), i, p_ContractedAmount[ i ] );
			SendClientMessage( playerid, -1, szNormalString );
			count ++;
	    }
	}
	if ( count == 0 ) SendClientMessage( playerid, -1, "No-one" );
	return 1;
}

CMD:radio( playerid, params[ ] )
{
    ShowPlayerDialog(playerid, DIALOG_RADIO, DIALOG_STYLE_LIST, "{FFFFFF}Radio Stations - List", g_RadioStations, "Select", "Close");
	return 1;
}

CMD:rules( playerid, params[ ] )
{
	ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_MSGBOX, "{FFFFFF}Rules", szRules, "Okay", "" );
	return 1;
}

#if ENABLE_DISCORD == true
CMD:discordpm( playerid, params[ ] )
{
	new
		msg[ 128 ];

	if ( sscanf( params, "s[100]", msg ) ) SendUsage( playerid, "/discordpm [message]" );
	else
	{
 		Beep( playerid );
 		format( msg, sizeof( msg ), "__[Discord PM]__ **%s(%d):** %s", ReturnPlayerName( playerid ), playerid, msg );
    	DCC_SendChannelMessage( discordGeneralChan, msg );
		SendServerMessage( playerid, "Your typed message has been sent to the Discord #sfcnr channel!" );
	}
	return 1;
}
#endif

CMD:perks( playerid, params[ ] )
{
	if ( IsPlayerInEvent( playerid ) ) return SendError( playerid, "You cannot use this command since you're in an event." );
    ShowPlayerDialog( playerid, DIALOG_PERKS, DIALOG_STYLE_LIST, "{FFFFFF}Game Perks", "Player Perks\nVehicle Perks", "Select", "Cancel" );
	return 1;
}

CMD:viewguns( playerid, params[ ] )
{
	/* ** COOL DOWN ** */
    if ( GetPVarInt( playerid, "weapon_buy_cool" ) > g_iTime ) return SendError( playerid, "You must wait 40 seconds before buying a weapon from someone again." );
    /* ** END OF COOL DOWN ** */

	if ( !IsPlayerConnected( p_WeaponDealer[ playerid ] ) ) return p_WeaponDealer[ playerid ] = INVALID_PLAYER_ID, SendError( playerid, "Your weapon dealer isn't available." );
	else if ( g_iTime > p_WeaponDealTick[ playerid ] ) return SendError( playerid, "Your last weapon deal has expired." );
	else if ( IsPlayerInPaintBall( playerid ) ) return SendError( playerid, "You can't buy weapons in paintball." );
	else
	{
	    p_WeaponDealing{ playerid } = true;
		ShowAmmunationMenu( playerid, "{FFFFFF}Weapon Deal - Purchase Weapons", DIALOG_WEAPON_DEAL );
		SendClientMessageFormatted( p_WeaponDealer[ playerid ], -1, ""COL_GREY"[SERVER]"COL_WHITE" %s(%d) is now viewing your weapon selection.", ReturnPlayerName( playerid ), playerid );
	}
	return 1;
}

CMD:sellgun( playerid, params[ ] )
{
	new
	    pID
	;

	if ( !JobEquals( playerid, JOB_WEAPON_DEALER ) ) return SendError( playerid, "You aren't a weapon dealer." );
	else if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "Only civilians can use this command." );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/sellgun [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( pID == playerid ) return SendError( playerid, "You cannot sell yourself a weapon." );
	else if ( p_Class[ pID ] == CLASS_POLICE ) return SendError( playerid, "You cannot sell weapons to law enforcement officers." );
	else if ( p_WeaponDealing{ pID } == true ) return SendError( playerid, "This player is currently busy." );
	else if ( p_Jailed{ playerid } ) return SendError( playerid, "You cannot sell weapons while you're in jail." );
	else if ( p_Jailed{ pID } ) return SendError( playerid, "This player is jailed, you cannot sell weapons to him." );
	else if ( IsPlayerInPaintBall( pID ) ) return SendError( playerid, "You can't sell weapons in paintball." );
	else if ( IsPlayerInEvent( playerid ) ) return SendError( playerid, "You cannot use this command since you're in an event." );
	else if ( GetDistanceBetweenPlayers( playerid, pID ) < 5.0 )
	{
		SendClientMessageFormatted( pID, -1, ""COL_ORANGE"[WEAPON DEAL]{FFFFFF} %s(%d) wishes to sell you weapons. "COL_ORANGE"/viewguns{FFFFFF} to view the available weapons.", ReturnPlayerName( playerid ), playerid );
		SendClientMessageFormatted( playerid, -1, ""COL_ORANGE"[WEAPON DEAL]{FFFFFF} You have sent an offer to %s(%d) to buy guns.", ReturnPlayerName( pID ), pID );
		p_WeaponDealer[ pID ] = playerid;
		p_WeaponDealTick[ pID ] = g_iTime + 60;
	}
	else SendError( playerid, "This player is not nearby." );
	return 1;
}

CMD:ej( playerid, params[ ] ) return cmd_eject( playerid, params );
CMD:eject( playerid, params[ ] )
{
	new
	    pID
	;

	if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/eject [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You're not in any vehicle." );
	else if ( !IsPlayerInAnyVehicle( pID ) ) return SendError( playerid, "This player isn't in any vehicle" );
	else if ( pID == playerid ) return SendError( playerid, "This command is created for ejecting passengers only." );
	else if ( GetPlayerVehicleID( pID ) != GetPlayerVehicleID( playerid ) ) return SendError( playerid, "This player isn't inside your vehicle" );
	else if ( GetPlayerState( playerid ) != PLAYER_STATE_DRIVER ) return SendError( playerid, "You are not the driver of this vehicle." );
	//else if ( p_Detained{ pID } ) return SendError( playerid, "This player has his cuffs locked onto his seat. You can't eject him." );
	else
	{
	    if ( p_Kidnapped{ pID } == true ) p_Kidnapped{ pID } = false;
	    if ( p_Detained{ pID } == true ) p_Detained{ pID } = false;
	    RemovePlayerFromVehicle( pID );
		SyncObject( pID, 0.0, 2.0, 2.0 );
    	GameTextForPlayer( pID, "~r~EJECTED~w~!", 3500, 3 );
    	SendServerMessage( playerid, "Player has been ejected from your vehicle." );
	}
	return 1;
}

CMD:ejectall( playerid, params[ ] )
{
	new
	    iEjectCounter = 0,
		iPlayerSeat = GetPlayerVehicleSeat( playerid ),
		iPlayerVehicle = GetPlayerVehicleID( playerid )
	;

	if ( !IsPlayerInAnyVehicle( playerid ) ) {
		return SendError( playerid, "You're not in a vehicle." );
	}

	if ( iPlayerSeat != 0 ) {
		return SendError( playerid, "You're not the driver of this vehicle." );
	}

	foreach(new i : Player)
	{
		new
			iTargetVehicle = GetPlayerVehicleID( i ),
			iTargetSeat = GetPlayerVehicleSeat( i )
		;

		if ( iTargetVehicle == iPlayerVehicle && iTargetSeat >= 1 && iTargetSeat <= 3 ) {
			// change variables
		    if ( p_Kidnapped{ i } == true ) p_Kidnapped{ i } = false;
		    if ( p_Detained{ i } == true ) p_Detained{ i } = false;

		    // remove from vehicle
			RemovePlayerFromVehicle( i );
			SyncObject( i, 0.0, 2.0, 2.0 );
			GameTextForPlayer( i, "~r~EJECTED~w~!", 3500, 3 );

			// increment players ejected
			iEjectCounter++;
		}
	}

	if ( ! iEjectCounter )
		return SendError( playerid, "You do not have any passengers to eject." );

	return SendServerMessage( playerid, "You have ejected %d player%s from your vehicle.", iEjectCounter, iEjectCounter > 1 ? ( "s" ) : ( "" ) );
}

CMD:bail( playerid, params[ ] )
{
	new
	    pID,
	    equa
	;

	if ( p_Class[ playerid ] != CLASS_POLICE ) return SendError( playerid, "This is restricted to police only." );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/bail [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( pID == playerid ) return SendError( playerid, "You cannot bail yourself." );
	else if ( !IsPlayerJailed( pID ) ) return SendError( playerid, "This player isn't jailed." );
	else if ( IsPlayerAdminJailed( pID ) ) return SendError( playerid, "This player has been admin jailed." );
	else if ( p_PlayerSettings[ pID ] { SETTING_BAILOFFERS } ) return SendError( playerid, "This player has disabled bail notifications." );
	else if ( GetPVarInt( pID, "bail_antispam" ) > g_iTime ) return SendError( playerid, "You must wait 10 seconds before offering a bail to this player." );
	else
	{
	    equa = 25 * p_JailTime[ pID ];
	    p_BailOfferer[ pID ] = playerid;
	    p_BailTimestamp[ pID ] = g_iTime + 120;
	    SetPVarInt( pID, "bail_antispam", g_iTime + 1 );
	    SendServerMessage( playerid, "You have offered %s(%d) bail for "COL_GOLD"%s", ReturnPlayerName( pID ), pID, ConvertPrice( equa ) );
	    SendClientMessageFormatted( pID, -1, ""COL_GREY"[SERVER]"COL_WHITE" %s(%d) has offered to bail you out for "COL_GOLD"%s"COL_WHITE". "COL_ORANGE"/acceptbail"COL_WHITE" to accept the bail.", ReturnPlayerName( playerid ), playerid, ConvertPrice( equa ) );
	}
	return 1;
}

CMD:acceptbail( playerid, params[ ] )
{
	new
	    equa = 25 * p_JailTime[ playerid ]
	;
	if ( GetPlayerCash( playerid ) < equa ) return p_BailOfferer[ playerid ] = INVALID_PLAYER_ID, SendError( playerid, "You don't have enough to be bailed." );
	else if ( IsPlayerAdminJailed( playerid ) ) return p_BailOfferer[ playerid ] = INVALID_PLAYER_ID, SendError( playerid, "You have been admin jailed, therefore disallowing this." );
	else if ( !IsPlayerJailed( playerid ) ) return SendError( playerid, "You're not jailed!" );
	else if ( !IsPlayerConnected( p_BailOfferer[ playerid ] ) ) return p_BailOfferer[ playerid ] = INVALID_PLAYER_ID, SendError( playerid, "The person who offered you bail is not connected." );
	else if ( p_BailTimestamp[ playerid ] < g_iTime ) return p_BailOfferer[ playerid ] = INVALID_PLAYER_ID, SendError( playerid, "This offer has expired a minute ago." );
	else
	{
		new
			cashEarned = floatround( equa * 0.75 );

	    GivePlayerCash( playerid, -equa );
		GivePlayerCash( p_BailOfferer[ playerid ], cashEarned );
		SendClientMessageFormatted( p_BailOfferer[ playerid ], -1, ""COL_GREEN"[BAIL]"COL_WHITE" %s(%d) has paid bail. You have earned "COL_GOLD"%s"COL_WHITE" from his bail.", ReturnPlayerName( playerid ), playerid, ConvertPrice( cashEarned ) );
    	p_BailOfferer[ playerid ] = INVALID_PLAYER_ID;
        SendServerMessage( playerid, "You have paid for your bail. You are now free!" );
	   	CallLocalFunction( "OnPlayerUnjailed", "dd", playerid, 1 );
	}
	return 1;
}

CMD:acceptbj( playerid, params[ ] )
{
	if ( !IsPlayerConnected( p_BlowjobOfferer[ playerid ] ) ) return p_BlowjobOfferer[ playerid ] = INVALID_PLAYER_ID, SendError( playerid, "Your blowjob offerer isn't available." );
	else if ( g_iTime > p_BlowjobDealTick[ playerid ] ) return SendError( playerid, "Your blowjob offer has expired." );
	else if ( !JobEquals( p_BlowjobOfferer[ playerid ], JOB_PROSTITUTE ) ) return SendError( playerid, "Your blowjob offerer no longer offers blowjobs." );
	else if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You cannot get a blowjob inside a car." );
	else if ( IsPlayerInAnyVehicle( p_BlowjobOfferer[ playerid ] ) ) return SendError( playerid, "This player is inside a car." );
	else if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot accept blowjobs in jail." );
	else if ( IsPlayerTied( playerid ) ) return SendError( playerid, "You cannot accept blowjobs while tied." );
	else if ( IsPlayerTazed( playerid ) ) return SendError( playerid, "You cannot accept blowjobs while tazed." );
	else if ( IsPlayerCuffed( playerid ) ) return SendError( playerid, "You cannot accept blowjobs while cuffed." );
	else if ( IsPlayerRobbing( playerid ) ) return SendError( playerid, "You cannot accept blowjobs while robbing a store." );
	else if ( IsPlayerGettingBlowed( playerid ) ) return SendError( playerid, "You cannot use this command since you're getting blowed." );
	else if ( IsPlayerBlowingCock( playerid ) ) return SendError( playerid, "You cannot use this command since you're giving oral sex." );
	else if ( GetPlayerCash( playerid ) < p_BlowjobPrice[ playerid ] ) return SendError( playerid, "You cannot afford this blowjob." );
	else if ( IsPlayerAttachedObjectSlotUsed( playerid, 4 ) || IsPlayerAttachedObjectSlotUsed( playerid, 3 ) ) return SendError( playerid, "Your hands are busy at the moment." );
	else if ( GetDistanceBetweenPlayers( playerid, p_BlowjobOfferer[ playerid ] ) < 4.0 )
	{
		new
		    Float: X, Float: Y, Float: Z, Float: Angle,
		    iPrice = p_BlowjobPrice[ playerid ],
		    iEarned = floatround( iPrice * 0.90 )
		;

		SendClientMessageFormatted( p_BlowjobOfferer[ playerid ], -1, ""COL_ORANGE"[BLOWJOB]{FFFFFF} %s(%d) has accepted your blowjob offer for "COL_GOLD"%s"COL_WHITE".", ReturnPlayerName( playerid ), playerid, ConvertPrice( iPrice ) );
		SendClientMessageFormatted( playerid, -1, ""COL_ORANGE"[BLOWJOB]{FFFFFF} You are now recieving a blowjob." );
		TogglePlayerControllable( p_BlowjobOfferer[ playerid ], 0 );
		TogglePlayerControllable( playerid, 0 );
		GetPlayerFacingAngle( p_BlowjobOfferer[ playerid ], Angle );
		SetPlayerFacingAngle( playerid, Angle - 180 );
		GetXYInFrontOfPlayer( p_BlowjobOfferer[ playerid ], X, Y, Z, 1 );
		SetPlayerPos( playerid, X, Y, Z );
		ApplyAnimation( playerid, "BLOWJOBZ", "BJ_STAND_START_P", 1.0, 1, 1, 1, 0, 0, 1 );
		ApplyAnimation( p_BlowjobOfferer[ playerid ], "BLOWJOBZ", "BJ_STAND_START_W", 1.0, 1, 1, 1, 0, 0, 1 );
		SetTimerEx( "BlowJob", 1500, false, "ddd", p_BlowjobOfferer[ playerid ], playerid, 0 );
		p_GettingBlowjob{ playerid } = true;
 		p_GivingBlowjob{ p_BlowjobOfferer[ playerid ] } = true;
		GivePlayerCash( playerid, -iPrice );
		GivePlayerCash( p_BlowjobOfferer[ playerid ], iEarned );
		p_BlowjobOfferer[ playerid ] = INVALID_PLAYER_ID;
	}
	else SendError( playerid, "This prostitute is not nearby." );
	return 1;
}

CMD:blowjob( playerid, params[ ] ) return cmd_bj( playerid, params );
CMD:bj( playerid, params[ ] )
{
	new
	    pID, price
	;

	if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "This is restricted to civilians only." );
	else if ( !JobEquals( playerid, JOB_PROSTITUTE ) ) return SendError( playerid, "You must be a prostitute to use this command." );
	else if ( ( GetTickCount( ) - p_AntiBlowJobSpam[ playerid ] ) < 30000 ) return SendError( playerid, "You must wait 30 seconds before using this command again." );
	else if ( sscanf( params, ""#sscanf_u"d", pID, price ) ) return SendUsage( playerid, "/(bj)blowjob [PLAYER_ID] [PRICE]" );
	else if ( !IsPlayerConnected( pID ) ) return SendError( playerid, "This player isn't connected." );
	else if ( price < 20 || price > 3000 ) return SendError( playerid, "Please specify a price between $20 and $3,000." );
	else if ( playerid == pID ) return SendError( playerid, "You cannot give a blowjob to yourself." );
	else if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot offer blowjobs in jail." );
	else if ( IsPlayerGettingBlowed( playerid ) ) return SendError( playerid, "You cannot use this command since you're getting blowed." );
	else if ( IsPlayerBlowingCock( playerid ) ) return SendError( playerid, "You cannot use this command since you're giving oral sex." );
	else if ( IsPlayerInPaintBall( playerid ) ) return SendError( playerid, "You don't know how to give oral sex in paintball." );
	else if ( GetDistanceBetweenPlayers( playerid, pID ) < 4.0 )
	{
		if ( IsPlayerJailed( pID ) ) return SendError( playerid, "This player is jailed. He may be paused." );
	  	SendClientMessageFormatted( pID, -1, ""COL_ORANGE"[BLOWJOB]{FFFFFF} %s(%d) wishes to give you a blowjob for "COL_GOLD"%s"COL_WHITE". "COL_ORANGE"/acceptbj{FFFFFF} to accept.", ReturnPlayerName( playerid ), playerid, ConvertPrice( price ) );
		SendClientMessageFormatted( playerid, -1, ""COL_ORANGE"[BLOWJOB]{FFFFFF} You have offered a blowjob to %s(%d) for "COL_GOLD"%s"COL_WHITE".", ReturnPlayerName( pID ), pID, ConvertPrice( price ) );
		p_BlowjobOfferer[ pID ] = playerid;
	    p_BlowjobDealTick[ pID ] = g_iTime + 60;
	    p_BlowjobPrice[ pID ] = price;
 		p_AntiBlowJobSpam[ playerid ] = GetTickCount( );
	}
	else SendError( playerid, "This player is not nearby." );
	return 1;
}

CMD:dssall( playerid, params[ ] )
{
	if ( !p_inFBI{ playerid } && !p_AdminLevel[ playerid ] )
		return SendError( playerid, "You are not in the FBI." );

	if ( !Iter_Count(SpikeStrip) )
		return SendError( playerid, "There is nothing left to destroy." );

	for( new i = 0; i < MAX_SPIKESTRIPS; i++ ) if ( Iter_Contains( SpikeStrip, i ) )
 		destroySpikeStrip( i );

	SendServerMessage( playerid, "You have succesfully destroyed all spike strips." );
	SendClientMessageToCops( -1, ""COL_BLUE"[SPIKE STRIPS CLEARED]"COL_WHITE" %s(%d) has destroyed all spike strips set!", ReturnPlayerName( playerid ), playerid );
	return 1;
}

CMD:dss( playerid, params[ ] )
{
	new
	    rbID
	;

	if ( !p_inFBI{ playerid } ) return SendError( playerid, "You are not in the FBI." );
	else if ( sscanf( params, "d", rbID ) ) return SendUsage( playerid, "/dss [SPIKE_STRIP_ID]" );
	else if ( rbID < 0 || rbID >= MAX_SPIKESTRIPS ) return SendError( playerid, "Invalid Spike Strip ID." );
	else if ( !Iter_Contains( SpikeStrip, rbID ) ) return SendError( playerid, "Invalid Spike Strip ID." );
	else
	{
	    destroySpikeStrip( rbID );
	    SendServerMessage( playerid, "You have succesfully destroyed a spike strip." );
	}
	return 1;
}


CMD:spike( playerid, params[ ] ) return cmd_setspike( playerid, params );
CMD:setspike( playerid, params[ ] )
{
	if ( GetPlayerInterior( playerid ) != 0 || GetPlayerVirtualWorld( playerid ) != 0 ) return SendError( playerid, "You cannot use this command inside buildings." );
	else if ( IsPlayerKidnapped( playerid ) ) return SendError( playerid, "You are kidnapped, you cannot do this." );
	else if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You are jailed, you cannot do this." );
	else if ( IsPlayerTied( playerid ) ) return SendError( playerid, "You are tied, you cannot do this." );
	else if ( IsPlayerInWater( playerid ) ) return SendError( playerid, "You cannot use this command since you're in water." );
	else if ( !p_inFBI{ playerid } ) return SendError( playerid, "You are not in the FBI." );
	//else if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You cannot use this feature while in a vehicle." );
	else
	{
	  	new
			Float: X, Float: Y, Float: Z, Float: Angle;

		if ( !IsPlayerInAnyVehicle( playerid ) )
		{
			GetXYInFrontOfPlayer( playerid, X, Y, Z, 2.0 );
			GetPlayerFacingAngle( playerid, Angle );
		}
		else
		{
			new
				iVehicle = GetPlayerVehicleID( playerid ),
				iModel = GetVehicleModel( iVehicle )
			;

			if ( IsBoatVehicle( iModel ) || IsAirVehicle( iModel ) )
				return SendError( playerid, "You cannot place a spike strip in this type of vehicle." );

			GetVehiclePos( iVehicle, X, Y, Z );
			GetVehicleZAngle( iVehicle, Angle );

		 	X -= ( 4.1 * floatsin( -Angle, degrees ) );
			Y -= ( 4.1 * floatcos( -Angle, degrees ) );
		}

		if ( CreateSpikeStrip( playerid, X, Y, Z, Angle ) != -1 )
			SendServerMessage( playerid, "You have succesfully created a spike strip." );
		else
			SendError( playerid, "Failed to place a spike strip due to a unexpected error." );
	}
	return 1;
}

CMD:h( playerid, params[ ] )
{
	if ( p_accountSecurityData[ playerid ] [ E_ID ] && ! p_accountSecurityData[ playerid ] [ E_VERIFIED ] && p_accountSecurityData[ playerid ] [ E_MODE ] != SECURITY_MODE_DISABLED )
		return SendError( playerid, "You must be verified in order to use this feature. "COL_YELLOW"(use /verify)" );

	new
	    ID = p_InHouse[ playerid ],
	    query[ 140 ]
	;
	if ( strmatch( params, "spawn" ) )
	{
	  	if ( p_OwnedHouses[ playerid ] < 1 )
	    	return SendError( playerid, "You need to own a house in-order to use this." );

	    format( szLargeString, sizeof( szLargeString ), ""COL_GREY"Set Back To Normal\n" );
		for( new i = 0; i < MAX_HOUSES; i++ )
		{
		    if ( g_houseData[ i ] [ E_CREATED ] == true && strmatch( g_houseData[ i ][ E_OWNER ], ReturnPlayerName( playerid ) ) )
		    {
		    	format( szLargeString, sizeof( szLargeString ), "%s%s\n", szLargeString, g_houseData[ i ] [ E_HOUSE_NAME ] );
			}
		}
		return ShowPlayerDialog( playerid, DIALOG_HOUSES, DIALOG_STYLE_LIST, "{FFFFFF}Set Spawn Location", szLargeString, "Select", "Cancel" );
	}
	else if ( strmatch( params, "config" ) )
	{
		if ( ID == -1 ) return SendError( playerid, "You're not in any house." );
		else if ( !strmatch( g_houseData[ ID ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this house." );
		else
		{
		    ShowPlayerDialog( playerid, DIALOG_HOUSE_CONFIG, DIALOG_STYLE_LIST, "{FFFFFF}House Configuration", "Set House Title\nUpgrade Interior\nSet House Password\nWeapon Storage\nFurniture", "Select", "Cancel" );
		}
		return 1;
	}
	else if ( strmatch( params, "buy" ) )
	{
		if ( hasTooManyHouses( playerid ) ) return SendError( playerid, "You cannot purchase any more houses, you've reached the limit." );
		if ( GetPlayerScore( playerid ) < 200 ) return SendError( playerid, "You need at least 200 score to buy a house." );

		for( new i = 0; i < MAX_HOUSES; i++ ) if ( g_houseData[ i ] [ E_CREATED ] )
		{
			if ( IsPlayerInDynamicCP( playerid, g_houseData[ i ] [ E_CHECKPOINT ] [ 0 ] ) )
			{
			    if ( strmatch( g_houseData[ i ] [ E_OWNER ], "No-one" ) )
			    {
			        if ( GetPlayerCash( playerid ) < g_houseData[ i ] [ E_COST ] )
						return SendError( playerid, "You don't have enough money to purchase this house." );

					if ( g_houseData[ i ] [ E_COST ] == 1337 && !p_VIPLevel[ playerid ] )
						return SendError( playerid, "You are not a V.I.P, to become one visit "COL_GREY"donate.irresistiblegaming.com" );

					GivePlayerCash( playerid, -( g_houseData[ i ] [ E_COST ] ), .force_save = true );
					SendServerMessage( playerid, "You have bought this home for "COL_GOLD"%s"COL_WHITE"!", ConvertPrice( g_houseData[ i ] [ E_COST ] ) );
                    SetHouseOwner( i, ReturnPlayerName( playerid ) );

					p_OwnedHouses[ playerid ] ++;
					return 1;
				}
			    else return SendError( playerid, "This house isn't for sale." );
			}
		}
		return SendError( playerid, "You are not around any house entrances." );
	}
	else if ( strmatch( params, "sell" ) )
	{
	    if ( ID == -1 ) return SendError( playerid, "You're not in any house." );
		else if ( !strmatch( g_houseData[ ID ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this house." );
		else
		{
			format( szBigString, sizeof( szBigString ), "[SELL] [%s] %s | %s | %d\r\n", getCurrentDate( ), ReturnPlayerName( playerid ), g_houseData[ ID ][ E_OWNER ], ID );
		    AddFileLogLine( "log_houses.txt", szBigString );
			p_OwnedHouses[ playerid ] --;
			if ( p_HouseSpawnLocation[ playerid ] == ID ) p_HouseSpawnLocation[ playerid ] = -1;
			format( g_houseData[ ID ] [ E_PASSWORD ], 4, "N/A" );
			format( g_houseData[ ID ] [ E_OWNER ], 7, "No-one" );
			format( g_houseData[ ID ] [ E_HOUSE_NAME ], 5, "Home" );
			for( new i; i < MAX_HOUSE_WEAPONS; i++ ) { g_HouseWeapons[ ID ] [ i ] = 0, g_HouseWeaponAmmo[ ID ] [ i ] = -1; }
			SaveHouseWeaponStorage( ID );
			GivePlayerCash( playerid, ( g_houseData[ ID ] [ E_COST ] / 2 ) );
			destroyAllFurniture( ID );
			g_houseData[ ID ] [ E_TX ] = g_houseInteriors[ 0 ] [ E_EX ];
			g_houseData[ ID ] [ E_TY ] = g_houseInteriors[ 0 ] [ E_EY ];
			g_houseData[ ID ] [ E_TZ ] = g_houseInteriors[ 0 ] [ E_EZ ];
			g_houseData[ ID ] [ E_INTERIOR_ID ] = 2;
			format( query, sizeof( query ), "UPDATE HOUSES SET OWNER='No-one',PASSWORD='N/A',NAME='Home',TX=%f,TY=%f,TZ=%f,INTERIOR=%d WHERE ID=%d", g_houseData[ ID ] [ E_TX ], g_houseData[ ID ] [ E_TY ], g_houseData[ ID ] [ E_TZ ], g_houseData[ ID ] [ E_INTERIOR_ID ], ID );
		    mysql_single_query( query );
			format( szBigString, sizeof( szBigString ), ""COL_GOLD"House:"COL_WHITE" Home(%d)\n"COL_GOLD"Owner:"COL_WHITE" No-one\n"COL_GOLD"Price:"COL_WHITE" %s", ID, ConvertPrice( g_houseData[ ID ] [ E_COST ] ) );
			UpdateDynamic3DTextLabelText( g_houseData[ ID ] [ E_LABEL ] [ 0 ], COLOR_WHITE, szBigString );
			DestroyDynamic3DTextLabel( g_houseData[ ID ] [ E_LABEL ] [ 1 ] );
			g_houseData[ ID ] [ E_LABEL ] [ 1 ] = CreateDynamic3DTextLabel( "[EXIT]", COLOR_GOLD, g_houseData[ ID ] [ E_TX ], g_houseData[ ID ] [ E_TY ], g_houseData[ ID ] [ E_TZ ], 20.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, g_houseData[ ID ] [ E_WORLD ] );
			DestroyDynamicCP( g_houseData[ ID ] [ E_CHECKPOINT ] [ 1 ] );
			g_houseData[ ID ] [ E_CHECKPOINT ] [ 1 ] = CreateDynamicCP( g_houseData[ ID ] [ E_TX ], g_houseData[ ID ] [ E_TY ], g_houseData[ ID ] [ E_TZ ], 1.0, g_houseData[ ID ] [ E_WORLD ], g_houseData[ ID ] [ E_INTERIOR_ID ], -1, 50.0 );
			SetPlayerPos( playerid, g_houseData[ ID ] [ E_EX ], g_houseData[ ID ] [ E_EY ], g_houseData[ ID ] [ E_EZ ] );
			DestroyDynamicMapIcon( g_houseData[ ID ] [ E_MAP_ICON ] );
			SetPlayerInterior( playerid, 0 );
			SetPlayerVirtualWorld( playerid, 0 );
			SendServerMessage( playerid, "You have successfully sold your house for "COL_GOLD"%s", ConvertPrice( ( g_houseData[ ID ] [ E_COST ] / 2 ) ) );
		}
		return 1;
	}
	else if ( strmatch( params, "offer cancel" ) )
	{
		new
			bool: bResults = false;

		foreach(new i : Player)
		{
			if ( p_HouseOfferer[ i ] == playerid )
			{
				bResults = true;
				p_HouseOfferer		[ i ] = INVALID_PLAYER_ID;
				p_HouseOfferTicks	[ i ] = 0;
				p_HouseSellingID	[ i ] = 0;
				p_HouseSellingPrice	[ i ] = 0;
			}
		}

		if ( bResults )
			return SendServerMessage( playerid, "You have successfully canceled all house offers you have made to players." );

		return SendError( playerid, "You have not made any house offers to anybody." );
	}
	else if ( strmatch( params, "offer take" ) )
	{
		new
			houseid = p_HouseSellingID[ playerid ],
			sellerid = p_HouseOfferer[ playerid ],
			sellingprice = p_HouseSellingPrice[ playerid ]
		;

		if ( !IsPlayerConnected( sellerid ) ) SendError( playerid, "The person who offered you a house is no longer online." );
		else if ( p_HouseOfferTicks[ playerid ] < g_iTime ) SendError( playerid, "This house offer has expired %d seconds ago.", g_iTime - p_HouseOfferTicks[ playerid ] );
		else if ( GetPlayerCash( playerid ) < p_HouseSellingPrice[ playerid ] ) SendError( playerid, "You do not have enough money to accept this offer (%s).", ConvertPrice( p_HouseSellingPrice[ playerid ] ) );
		else if ( g_houseData[ houseid ] [ E_COST ] <= 1337 && !p_VIPLevel[ playerid ] ) SendError( playerid, "You are not a V.I.P, to become one visit "COL_GREY"donate.irresistiblegaming.com" );
		else if ( hasTooManyHouses( playerid ) ) SendError( playerid, "You cannot purchase any more houses, you've reached the limit." );
		else
		{
			format( szBigString, sizeof( szBigString ), "[SELL TO] [%s] %s | %s | %s | %d\r\n", getCurrentDate( ), ReturnPlayerName( playerid ), ReturnPlayerName( sellerid ), ConvertPrice( sellingprice ), houseid );
		    AddFileLogLine( "log_houses.txt", szBigString );

			p_OwnedHouses[ sellerid ] --;
			p_OwnedHouses[ playerid ] ++;

		    destroyAllFurniture( houseid );
			SetHouseOwner( houseid, ReturnPlayerName( playerid ) );

			GivePlayerCash( playerid, -sellingprice );
			GivePlayerCash( sellerid, sellingprice );

			if ( p_HouseSpawnLocation[ sellerid ] == houseid ) p_HouseSpawnLocation[ sellerid ] = -1;
			SendServerMessage( sellerid, "You have successfully sold your house for "COL_GOLD"%s"COL_WHITE" to %s(%d)!", ConvertPrice( p_HouseSellingPrice[ playerid ] ), ReturnPlayerName( playerid ), playerid );
			SendServerMessage( playerid, "You have successfully bought %s(%d)'s home for "COL_GOLD"%s"COL_WHITE"!", ReturnPlayerName( sellerid ), sellerid, ConvertPrice( p_HouseSellingPrice[ playerid ] ) );
		}
		return ( p_HouseOfferer[ playerid ] = INVALID_PLAYER_ID ), ( p_HouseOfferTicks[ playerid ] = 0 ), 1;
	}
	else if ( !strcmp( params, "offer", false, 5 ) )
	{
	    new offerid, price;

	    if ( ID == -1 ) return SendError( playerid, "You're not in any house." );
		else if ( !strmatch( g_houseData[ ID ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this house." );
	    else if ( sscanf( params[ 6 ],""#sscanf_u"d", offerid, price ) ) return SendUsage( playerid, "/h offer [PLAYER_ID] [PRICE]" );
	    else if ( !IsPlayerConnected( offerid ) ) return SendError( playerid, "This player is not connected." );
	    else if ( offerid == playerid ) return SendError( playerid, "You cannot make a house offer to yourself." );
	    else if ( price > 30000000 ) return SendError( playerid, "The maximum amount you can sell a house for is $30,000,000." );
	    else if ( price < g_houseData[ ID ] [ E_COST ] / 2 ) return SendError( playerid, "You cannot sell your house to somebody for less than half its cost." );
		else if ( GetDistanceBetweenPlayers( playerid, offerid ) > 4.0 ) return SendError( playerid, "You cannot send offers to players who are not near you." );
		else if ( p_HouseOfferTicks[ offerid ] > g_iTime ) return SendError( playerid, "Please wait %d seconds to make an house price offer to this player again.", p_HouseOfferTicks[ offerid ] - g_iTime );
		else if ( g_houseData[ ID ] [ E_COST ] <= 1337 && !p_VIPLevel[ offerid ] ) return SendError( playerid, "You cannot offer V.I.P homes to sell to regular players." );
		else if ( hasTooManyHouses( offerid ) ) return SendError( playerid, "This player cannot purchase any more houses, they have reached the limit." );
		else
	    {
	    	// Cannot sell to non vip vip homes k
			p_HouseOfferer[ offerid ] = playerid;
			p_HouseOfferTicks[ offerid ] = g_iTime + 15;
			p_HouseSellingID[ offerid ] = ID;
			p_HouseSellingPrice[ offerid ] = price;
			SendServerMessage( offerid, "%s(%d) wishes to offer his house (id %d) for %s to you. Use "COL_GREY"/h offer take"COL_WHITE" to take the offer.", ReturnPlayerName( playerid ), playerid, ID, ConvertPrice( price ) );
			SendServerMessage( playerid, "You have offered %s(%d) %s for your house (id %d), cancel the offer with "COL_GREY"/h offer cancel"COL_WHITE".", ReturnPlayerName( offerid ), offerid, ConvertPrice( price ), ID );
	    }
	    return 1;
	}
	return SendUsage( playerid, "/h [CONFIG/SPAWN/BUY/SELL/OFFER/OFFER TAKE/OFFER CANCEL]" );
}


stock SwitchHouseOwners( ID, playerid, buyerid )
{
	if ( IsPlayerConnected( playerid ) )
	{
		p_OwnedHouses[ playerid ] --;

		if ( p_HouseSpawnLocation[ playerid ] == ID )
			p_HouseSpawnLocation[ playerid ] = -1;

		SetPlayerInterior( playerid, 0 );
		SetPlayerVirtualWorld( playerid, 0 );
		SendServerMessage( playerid, "You have successfully sold your house for "COL_GOLD"%s", ConvertPrice( ( g_houseData[ ID ] [ E_COST ] / 2 ) ) );
		SetPlayerPos( playerid, g_houseData[ ID ] [ E_EX ], g_houseData[ ID ] [ E_EY ], g_houseData[ ID ] [ E_EZ ] );
	}

	// format( g_houseData[ ID ] [ E_PASSWORD ], 4, "N/A" );
	// format( g_houseData[ ID ] [ E_HOUSE_NAME ], 5, "Home" );
	strcpy( g_houseData[ ID ] [ E_PASSWORD ], "N/A" );
	strcpy( g_houseData[ ID ] [ E_HOUSE_NAME ], "Home" );
	format( g_houseData[ ID ] [ E_OWNER ], 7, "%s", ReturnPlayerName( buyerid ) );

	format( szBigString, sizeof( szBigString ), "UPDATE HOUSES SET OWNER='%s',PASSWORD='N/A',NAME='Home' WHERE ID=%d", mysql_escape( ReturnPlayerName( buyerid ) ) , ID );
    mysql_single_query( szBigString );

	format( szBigString, sizeof( szBigString ), ""COL_GOLD"House:"COL_WHITE" Home(%d)\n"COL_GOLD"Owner:"COL_WHITE" No-one\n"COL_GOLD"Price:"COL_WHITE" %s", ID, ConvertPrice( g_houseData[ ID ] [ E_COST ] ) );
	UpdateDynamic3DTextLabelText( g_houseData[ ID ] [ E_LABEL ] [ 0 ], COLOR_WHITE, szBigString );

	DestroyDynamic3DTextLabel( g_houseData[ ID ] [ E_LABEL ] [ 1 ] );
	g_houseData[ ID ] [ E_LABEL ] [ 1 ] = CreateDynamic3DTextLabel( "[EXIT]", COLOR_GOLD, g_houseData[ ID ] [ E_TX ], g_houseData[ ID ] [ E_TY ], g_houseData[ ID ] [ E_TZ ], 20.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, g_houseData[ ID ] [ E_WORLD ] );

	DestroyDynamicCP( g_houseData[ ID ] [ E_CHECKPOINT ] [ 1 ] );
	g_houseData[ ID ] [ E_CHECKPOINT ] [ 1 ] = CreateDynamicCP( g_houseData[ ID ] [ E_TX ], g_houseData[ ID ] [ E_TY ], g_houseData[ ID ] [ E_TZ ], 1.0, g_houseData[ ID ] [ E_WORLD ], g_houseData[ ID ] [ E_INTERIOR_ID ], -1, 50.0 );

	DestroyDynamicMapIcon( g_houseData[ ID ] [ E_MAP_ICON ] );
}

CMD:drball( playerid, params[ ] )
{
	if ( !p_inFBI{ playerid } && !p_AdminLevel[ playerid ] ) return SendError( playerid, "You are not in the FBI." );
	new count = 0;
	for( new i; i < MAX_ROADBLOCKS; i++ ) {
	    if ( g_roadblockData[ i ] [ E_CREATED ] ) count++, destroyRoadBlockStrip( i );
	}
	if ( count > 0 )
	{
		SendServerMessage( playerid, "You have succesfully destroyed all road blocks." );
		SendClientMessageToCops( -1, ""COL_BLUE"[ROAD BLOCKS CLEARED]"COL_WHITE" %s(%d) has destroyed all road blocks set!", ReturnPlayerName( playerid ), playerid );
	}
	else SendError( playerid, "There is nothing left to destroy." );
	return 1;
}

CMD:drb( playerid, params[ ] )
{
	new
	    rbID
	;

	if ( !p_inFBI{ playerid } ) return SendError( playerid, "You are not in the FBI." );
	else if ( sscanf( params, "d", rbID ) ) return SendUsage( playerid, "/drb [ROADBLOCK_ID]" );
	else if ( rbID < 0 || rbID > MAX_ROADBLOCKS ) return SendError( playerid, "Invalid road block ID." );
	else if ( g_roadblockData[ rbID ] [ E_CREATED ] == false ) return SendError( playerid, "Invalid road block ID." );
	else
	{
	    destroyRoadBlockStrip( rbID );
	    SendServerMessage( playerid, "You have succesfully destroyed a road block." );
	}
	return 1;
}

CMD:crb( playerid, params[ ] )
{
	new
		iRoadBlock;

	if ( GetPlayerInterior( playerid ) != 0 || GetPlayerVirtualWorld( playerid ) != 0 ) return SendError( playerid, "You cannot use this command inside buildings." );
	else if ( IsPlayerKidnapped( playerid ) ) return SendError( playerid, "You are kidnapped, you cannot do this." );
	else if ( IsPlayerTied( playerid ) ) return SendError( playerid, "You are tied, you cannot do this." );
	else if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You are jailed, you cannot do this." );
	else if ( !p_inFBI{ playerid } ) return SendError( playerid, "You are not in the FBI." );
	else if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You cannot use this command while in a vehicle." );
	else if ( IsPlayerInWater( playerid ) ) return SendError( playerid, "You cannot use this command since you're in water." );
	else if ( isnull( params ) ) return SendUsage( playerid, "/crb [SMALL/MEDIUM/BIG/CONE/DETOUR/WILL BE SIGN/LINE CLOSED]" );
	else
	{
		for( iRoadBlock = 0; iRoadBlock < sizeof( g_roadblockObjectData ); iRoadBlock++ )
			if ( strfind( g_roadblockObjectData[ iRoadBlock ] [ E_NAME ], params, true ) != -1 )
				break;

		if ( iRoadBlock >= sizeof( g_roadblockObjectData ) )
			return SendError( playerid, "You have typed in an invalid roadblock." );

		new
			iTmp = createRoadBlockStrip( playerid, iRoadBlock );

		if ( iTmp != -1 )
			SendServerMessage( playerid, "You have succesfully placed a "COL_GREY"%s"COL_WHITE".", g_roadblockObjectData[ iRoadBlock ] [ E_NAME ] );
		else
			SendError( playerid, "Failed to place a road block due to a unexpected error." );
	}
	return 1;
}

CMD:v( playerid, params[ ] )
{
	if ( p_accountSecurityData[ playerid ] [ E_ID ] && ! p_accountSecurityData[ playerid ] [ E_VERIFIED ] && p_accountSecurityData[ playerid ] [ E_MODE ] != SECURITY_MODE_DISABLED )
		return SendError( playerid, "You must be verified in order to use this feature. "COL_YELLOW"(use /verify)" );

	new
		vehicleid = GetPlayerVehicleID( playerid ),
		ownerid = INVALID_PLAYER_ID
	;

	if ( isnull( params ) ) return SendUsage( playerid, "/v [SELL/COLOR/LOCK/PARK/RESPAWN/BRING/DATA/PLATE/PAINTJOB/RESET]" );
	else if ( strmatch( params, "sell" ) )
	{
		new v = getVehicleSlotFromID( vehicleid, ownerid );
	    if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You need to be in a vehicle to use this command." );
		else if ( v == -1 ) return SendError( playerid, "This vehicle isn't a buyable vehicle." );
		else if ( g_buyableVehicle{ vehicleid } == false ) return SendError( playerid, "This vehicle isn't a buyable vehicle." );
		else if ( playerid != ownerid ) return SendError( playerid, "You cannot sell this vehicle." );
		else
		{
			format( szBigString, sizeof( szBigString ), "[SELL] [%s] %s | %d | %s\r\n", getCurrentDate( ), ReturnPlayerName( playerid ), v, GetVehicleName( GetVehicleModel( g_vehicleData[ playerid ] [ v ] [ E_VEHICLE_ID ] ) ) );
		    AddFileLogLine( "log_destroycar.txt", szBigString );
            GivePlayerCash( playerid, ( g_vehicleData[ playerid ] [ v ] [ E_PRICE ] / 2 ) );
			SendClientMessageFormatted( playerid, -1, ""COL_GREY"[VEHICLE]"COL_WHITE" You have sold this vehicle for half the price it was (%s).", ConvertPrice( ( g_vehicleData[ playerid ] [ v ] [ E_PRICE ] / 2 ) ) );
            DestroyBuyableVehicle( playerid, v );
		}
	}
	else if ( strmatch( params, "lock" ) )
	{
		new v = getVehicleSlotFromID( vehicleid, ownerid  );
	    if ( GetPlayerState( playerid ) != PLAYER_STATE_DRIVER ) return SendError( playerid, "You need to be in a vehicle to use this command." );
		else if ( v == -1 ) return SendError( playerid, "This vehicle isn't a buyable vehicle." );
		else if ( g_buyableVehicle{ vehicleid } == false ) return SendError( playerid, "This vehicle isn't a buyable vehicle." );
		else if ( playerid != ownerid ) return SendError( playerid, "You cannot lock this vehicle." );
		else
		{
		    g_vehicleData[ playerid ] [ v ] [ E_LOCKED ] = !g_vehicleData[ playerid ] [ v ] [ E_LOCKED ];
			SendClientMessageFormatted( playerid, -1, ""COL_GREY"[VEHICLE]"COL_WHITE" You have %s this vehicle.", g_vehicleData[ playerid ] [ v ] [ E_LOCKED ] == true ? ( "locked" ) : ( "un-locked" ) );
            SaveVehicleData( playerid, v );
		}
	}
	else if ( strmatch( params, "park" ) )
	{
		new v = getVehicleSlotFromID( vehicleid, ownerid  ), Float: X, Float: Y, Float: Z, Float: Angle;
	    if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You need to be in a vehicle to use this command." );
	    else if ( GetPlayerState( playerid ) != PLAYER_STATE_DRIVER ) return SendError( playerid, "You need to be a driver to use this command." );
		else if ( v == -1 ) return SendError( playerid, "This vehicle isn't a buyable vehicle." );
		else if ( playerid != ownerid ) return SendError( playerid, "You cannot park this vehicle." );
		else
		{
	        if ( IsVehicleUpsideDown( GetPlayerVehicleID( playerid ) ) ) return SendError( playerid, "Sorry, you're just going to have to ditch your car as soon as possible." );

	        new
	        	iBreach = PlayerBreachedGarageLimit( playerid, v );

	        if ( iBreach == -1 ) return SendError( playerid, "You cannot park vehicles that are not owned by the owner of this garage." );
	        if ( iBreach == -2 ) return SendError( playerid, "This garage has already reached its capacity of %d vehicles.", g_garageInteriorData[ g_garageData[ p_InGarage[ playerid ] ] [ E_INTERIOR_ID ] ] [ E_VEHICLE_CAPACITY ] );

			GetVehiclePos( vehicleid, X, Y, Z );
			GetVehicleZAngle( vehicleid, Angle );
			g_vehicleData[ playerid ] [ v ] [ E_X ] = X, g_vehicleData[ playerid ] [ v ] [ E_Y ] = Y, g_vehicleData[ playerid ] [ v ] [ E_Z ] = Z, g_vehicleData[ playerid ] [ v ] [ E_ANGLE ] = Angle;
			PutPlayerInVehicle( playerid, RespawnBuyableVehicle( vehicleid, playerid ), 0 );
 			SetTimerEx( "timedUpdates_RBV", 25, false, "ddf", playerid, INVALID_VEHICLE_ID, -1000.0 );
            SaveVehicleData( playerid, v );
        	SendClientMessage( playerid, -1, ""COL_GREY"[VEHICLE]"COL_WHITE" You have parked this vehicle." );
		}
	}
	else if ( strmatch( params, "respawn" ) )
	{
		if ( p_OwnedVehicles[ playerid ] > 0 )
		{
		    szLargeString = ""COL_GREY"Respawn All Vehicles\n";
			for( new i; i < p_OwnedVehicles[ playerid ]; i++ )
		    {
				if ( g_vehicleData[ playerid ] [ i ] [ E_OWNER_ID ] == p_AccountID[ playerid ] && IsValidVehicle( g_vehicleData[ playerid ] [ i ] [ E_VEHICLE_ID ] ) ) {
				    format( szLargeString, sizeof( szLargeString ), "%s%s\n", szLargeString, GetVehicleName( GetVehicleModel( g_vehicleData[ playerid ] [ i ] [ E_VEHICLE_ID ] ) ) );
				}
		    }
		    ShowPlayerDialog( playerid, DIALOG_VEHICLE_SPAWN, DIALOG_STYLE_LIST, "{FFFFFF}Spawn your vehicle", szLargeString, "Select", "Cancel" );
		}
		else SendError( playerid, "You don't own any vehicles." );
	}
	else if ( strmatch( params, "locate" ) ) return SendServerMessage( playerid, "This feature has been replaced with "COL_GREY"/v bring"COL_WHITE"." );
	else if ( strmatch( params, "bring" ) )
	{
		if ( p_VehicleBringCooldown[ playerid ] > g_iTime )
			return SendError( playerid, "You must wait %s before using this feature again.", secondstotime( p_VehicleBringCooldown[ playerid ] - g_iTime ) );

		if ( p_OwnedVehicles[ playerid ] > 0 )
		{
		    szLargeString = ""COL_WHITE"Bringing your vehicle to you will cost $10,000!\n";
			for( new i; i < p_OwnedVehicles[ playerid ]; i++ )
		    {
				if ( g_vehicleData[ playerid ] [ i ] [ E_OWNER_ID ] == p_AccountID[ playerid ] && IsValidVehicle( g_vehicleData[ playerid ] [ i ] [ E_VEHICLE_ID ] ) ) {
				    format( szLargeString, sizeof( szLargeString ), "%s%s\n", szLargeString, GetVehicleName( GetVehicleModel( g_vehicleData[ playerid ] [ i ] [ E_VEHICLE_ID ] ) ) );
				}
			}
		    ShowPlayerDialog( playerid, DIALOG_VEHICLE_LOCATE, DIALOG_STYLE_TABLIST_HEADERS, "{FFFFFF}Bring Vehicle", szLargeString, "Select", "Cancel" );
		}
		else SendError( playerid, "You don't own any vehicles." );
	}
	else if ( strmatch( params, "data" ) )
	{
		if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You are not in any vehicle." );
		else if ( g_buyableVehicle{ GetPlayerVehicleID( playerid ) } == false ) return SendError( playerid, "This vehicle isn't a buyable vehicle." );
		else
		{
			new v = getVehicleSlotFromID( vehicleid, ownerid );
	        if ( playerid != ownerid ) return SendError( playerid, "You don't own this vehicle." );

			format( szBigString, sizeof( szBigString ),	""COL_GREY"Vehicle Owner:"COL_WHITE" %s\n"\
			                            ""COL_GREY"Vehicle Type:"COL_WHITE" %s\n"\
			                            ""COL_GREY"Vehicle ID:"COL_WHITE" %d\n"\
			                            ""COL_GREY"Vehicle Price:"COL_WHITE" %s",
			                            ReturnPlayerName( ownerid ), GetVehicleName( GetVehicleModel( GetPlayerVehicleID( playerid ) ) ),
			                            g_vehicleData[ playerid ] [ v ] [ E_SQL_ID ], ConvertPrice( g_vehicleData[ playerid ] [ v ] [ E_PRICE ] ) );
			ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_MSGBOX, "{FFFFFF}Vehicle Data", szBigString, "Okay", "" );
		}
	}
	else if ( !strcmp( params, "color", false, 4 ) )
	{
		new
		    color1, color2
		;
		if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You must be inside a vehicle to use this command." );
	    else if ( GetPlayerState( playerid ) != PLAYER_STATE_DRIVER ) return SendError( playerid, "You need to be a driver to use this command." );
		else if ( sscanf( params[ 6 ], "dd", color1, color2 ) ) return SendUsage( playerid, "/v color [COLOR_1] [COLOR_2]" );
		else if ( g_buyableVehicle{ GetPlayerVehicleID( playerid ) } == false ) return SendError( playerid, "This isn't a buyable vehicle." );
		else if ( GetPlayerCash( playerid ) < 100 ) return SendError( playerid, "You don't have enough cash for this." );
		else if ( color1 > 255 || color1 < 0 || color2 > 255 || color2 < 0 ) return SendError( playerid, "Invalid vehicle color ID." );
		else
		{
	        new vID = getVehicleSlotFromID( GetPlayerVehicleID( playerid ), ownerid );
	        if ( playerid != ownerid ) return SendError( playerid, "You don't own this vehicle." );
	        if ( IsVehicleUpsideDown( GetPlayerVehicleID( playerid ) ) ) return SendError( playerid, "Sorry, you're just going to have to ditch your car as soon as possible." );
	        g_vehicleData[ playerid ] [ vID ] [ E_COLOR ] [ 0 ] = color1;
	        g_vehicleData[ playerid ] [ vID ] [ E_COLOR ] [ 1 ] = color2;
	    	GivePlayerCash( playerid, -100 );
			PutPlayerInVehicle( playerid, RespawnBuyableVehicle( vehicleid, playerid ), 0 );
	        SaveVehicleData( playerid, vID );
			SendServerMessage( playerid, "You have successfully changed your vehicle colors." );
		}
	}
	else if ( !strcmp( params, "plate", false, 4 ) )
	{
		new
		    szPlate[ 32 ]
		;
		if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You must be inside a vehicle to use this command." );
	    else if ( GetPlayerState( playerid ) != PLAYER_STATE_DRIVER ) return SendError( playerid, "You need to be a driver to use this command." );
		else if ( sscanf( params[ 6 ], "s[32]", szPlate ) ) return SendUsage( playerid, "/v plate [TEXT]" );
		else if ( g_buyableVehicle{ GetPlayerVehicleID( playerid ) } == false ) return SendError( playerid, "This isn't a buyable vehicle." );
		else
		{
	        new vID = getVehicleSlotFromID( GetPlayerVehicleID( playerid ), ownerid );
	        if ( playerid != ownerid ) return SendError( playerid, "You don't own this vehicle." );
			if ( IsBoatVehicle( GetVehicleModel( g_vehicleData[ playerid ] [ vID ] [ E_VEHICLE_ID ] ) ) || IsAirVehicle( GetVehicleModel( g_vehicleData[ playerid ] [ vID ] [ E_VEHICLE_ID ] ) ) ) return SendError( playerid, "Sorry, this feature is not available on planes and boats." );
	        if ( IsVehicleUpsideDown( GetPlayerVehicleID( playerid ) ) ) return SendError( playerid, "Sorry, you're just going to have to ditch your car as soon as possible." );
			format( g_vehicleData[ playerid ] [ vID ] [ E_PLATE ], 32, "%s", szPlate );
			PutPlayerInVehicle( playerid, RespawnBuyableVehicle( vehicleid, playerid ), 0 );
	        SaveVehicleData( playerid, vID );
			SendServerMessage( playerid, "Your have changed your vehicle's number plate to "COL_GREY"%s"COL_WHITE".", szPlate );
		}
	}
	else if ( !strcmp( params, "paintjob", false, 7 ) )
	{
		new
		    paintjobid
		;
		if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You must be inside a vehicle to use this command." );
	    else if ( GetPlayerState( playerid ) != PLAYER_STATE_DRIVER ) return SendError( playerid, "You need to be a driver to use this command." );
		else if ( sscanf( params[ 9 ], "d", paintjobid ) ) return SendUsage( playerid, "/v paintjob [PAINT_JOB_ID]" );
		else if ( g_buyableVehicle{ GetPlayerVehicleID( playerid ) } == false ) return SendError( playerid, "This isn't a buyable vehicle." );
		else if ( GetPlayerCash( playerid ) < 500 ) return SendError( playerid, "You don't have enough cash for this." );
		else if ( paintjobid < 0 || paintjobid > 3 ) return SendError( playerid, "Please specify a paintjob between 0 to 3." );
		else
		{
	        new vID = getVehicleSlotFromID( GetPlayerVehicleID( playerid ), ownerid );
	        if ( playerid != ownerid ) return SendError( playerid, "You don't own this vehicle." );
			if ( !IsPaintJobVehicle( GetVehicleModel( GetPlayerVehicleID( playerid ) ) ) ) return SendError( playerid, "This vehicle cannot have a paintjob installed." );
			if ( IsVehicleUpsideDown( GetPlayerVehicleID( playerid ) ) ) return SendError( playerid, "Sorry, you're just going to have to ditch your car as soon as possible." );
	        g_vehicleData[ playerid ] [ vID ] [ E_PAINTJOB ] = paintjobid;
		    ChangeVehiclePaintjob( GetPlayerVehicleID( playerid ), paintjobid );
		    GivePlayerCash( playerid, -500 );
			PutPlayerInVehicle( playerid, RespawnBuyableVehicle( vehicleid, playerid ), 0 );
	        SaveVehicleData( playerid, vID );
		}
	}
	else if ( !strcmp( params, "toggle", false, 5 ) )
	{
		new v = getVehicleSlotFromID( vehicleid, ownerid );
	    if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You need to be in a vehicle to use this command." );
	    else if ( GetPlayerState( playerid ) != PLAYER_STATE_DRIVER ) return SendError( playerid, "You need to be a driver to use this command." );
		else if ( v == -1 ) return SendError( playerid, "This vehicle isn't a buyable vehicle." );
		else if ( playerid != ownerid ) return SendError( playerid, "This vehicle does not belong to you." );
		else
		{
			if ( !strlen( params[ 7 ] ) )
				return SendUsage( playerid, "/v toggle [DOORS/BONNET/BOOT/LIGHTS/WINDOWS]" );

			GetVehicleParamsEx( vehicleid, engine, lights, alarm, doors, bonnet, boot, objective );

			if ( !strcmp( params[ 7 ], "doors", true, 5 ) ) {
				if ( !strlen( params[ 13 ] ) ) return SendUsage( playerid, "/v toggle doors [OPEN/CLOSE]" );
				if ( strmatch( params[ 13 ], "open" ) ) {
					SetVehicleParamsCarDoors( vehicleid, 1, 1, 1, 1 );
					return SendServerMessage( playerid, "You have opened the doors of this vehicle." );
				}
				else if ( strmatch( params[ 13 ], "close" ) ) {
					SetVehicleParamsCarDoors( vehicleid, 0, 0, 0, 0 );
					return SendServerMessage( playerid, "You have closed the doors of this vehicle." );
				}
				else {
					return SendUsage( playerid, "/v toggle doors [OPEN/CLOSE]" );
				}
			}

			else if ( !strcmp( params[ 7 ], "windows", true, 7 ) ) {
				if ( !strlen( params[ 15 ] ) ) return SendUsage( playerid, "/v toggle windows [OPEN/CLOSE]" );
				if ( strmatch( params[ 15 ], "open" ) ) {
					SetVehicleParamsCarWindows( vehicleid, 0, 0, 0, 0 );
					return SendServerMessage( playerid, "You have opened the windows of this vehicle." );
				}
				else if ( strmatch( params[ 15 ], "close" ) ) {
					SetVehicleParamsCarWindows( vehicleid, 1, 1, 1, 1 );
					return SendServerMessage( playerid, "You have closed the windows of this vehicle." );
				}
				else {
					return SendUsage( playerid, "/v toggle windows [OPEN/CLOSE]" );
				}
			}

			else if ( strmatch( params[ 7 ], "bonnet" ) ){
				SendServerMessage( playerid, "You have %s the bonnet of this vehicle.", ( bonnet = !bonnet ) ? ( "opened" ) : ( "closed" ) );
			}

			else if ( strmatch( params[ 7 ], "boot" ) ) {
				SendServerMessage( playerid, "You have %s the boot of this vehicle.", ( boot = !boot ) ? ( "opened" ) : ( "closed" ) );
			}

			else if ( strmatch( params[ 7 ], "lights" ) ) {
				SendServerMessage( playerid, "You have %s the lights of this vehicle.", ( lights = !lights ) ? ( "switched on" ) : ( "switched off" ) );
			}

			else {
				return SendUsage( playerid, "/v toggle [DOORS/BONNET/BOOT/LIGHTS/WINDOWS]" );
			}

			return SetVehicleParamsEx( vehicleid, engine, lights, alarm, doors, bonnet, boot, objective );
		}
	}
	else if ( strmatch( params, "reset" ) )
	{
		new v = getVehicleSlotFromID( vehicleid, ownerid );
	    if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You need to be in a vehicle to use this command." );
	    else if ( GetPlayerState( playerid ) != PLAYER_STATE_DRIVER ) return SendError( playerid, "You need to be a driver to use this command." );
		else if ( v == -1 ) return SendError( playerid, "This vehicle isn't a buyable vehicle." );
		else if ( playerid != ownerid ) return SendError( playerid, "This vehicle does not belong to you." );
		else
		{
			if ( IsVehicleUpsideDown( vehicleid ) ) return SendError( playerid, "Sorry, you're just going to have to ditch your car as soon as possible." );
			ResetBuyableVehicleMods( playerid, v, 0 );
		    ChangeVehiclePaintjob( vehicleid, 3 );
		    g_vehicleData[ playerid ] [ v ] [ E_PAINTJOB ] = 3;
	        g_vehicleData[ playerid ] [ v ] [ E_COLOR ] [ 0 ] = 0;
	        g_vehicleData[ playerid ] [ v ] [ E_COLOR ] [ 1 ] = 0;
			PutPlayerInVehicle( playerid, RespawnBuyableVehicle( vehicleid, playerid ), 0 );
	        SaveVehicleData( playerid, v );
			SendClientMessage( playerid, -1, ""COL_GREY"[SERVER]"COL_WHITE" You have reset your vehicle's appearance." );
		}
	}
	else SendUsage( playerid, "/v [SELL/COLOR/LOCK/PARK/RESPAWN/BRING/DATA/PLATE/PAINTJOB/TOGGLE/RESET]" );
	return 1;
}

CMD:report( playerid, params[ ] )
{
	new
		iPlayer,
		szMessage[ 64 ]
	;

    if ( sscanf( params, ""#sscanf_u"s[64]", iPlayer, szMessage ) ) return SendUsage( playerid, "/report [PLAYER_ID] [REASON]" );
    else if ( !IsPlayerConnected( iPlayer ) || IsPlayerNPC( iPlayer ) ) return SendError( playerid, "Invalid Player ID." );
    else if ( p_CantUseReport{ playerid } == true ) return SendError( playerid, "You have been blocked to use this command by an admin." );
	else if ( GetPVarInt( iPlayer, "report_antispam" ) > g_iTime ) return SendError( playerid, "You must wait 10 seconds before reporting this player." );
    else
	{
		for( new iPos; iPos < sizeof( szReportsLog ) - 1; iPos++ )
			memcpy( szReportsLog[ iPos ], szReportsLog[ iPos + 1 ], 0, sizeof( szReportsLog[ ] ) * 4 );

		format( szNormalString, sizeof( szNormalString ), "[%s] %s(%d): %s\n", getCurrentTime( ), ReturnPlayerName( iPlayer ), iPlayer, szMessage );
		strcpy( szReportsLog[ 7 ], szNormalString );

		Beep( playerid );
		SetPVarInt( iPlayer, "report_antispam", g_iTime + 10 );

        SendClientMessageToAdmins( -1, ""COL_RED"[REPORT] %s(%d) reported %s(%d):{FFFFFF} %s", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( iPlayer ), iPlayer, szMessage );
		SendClientMessageFormatted( playerid, -1, ""COL_RED"[REPORT]"COL_WHITE" You have reported %s(%d) for \"%s\".", ReturnPlayerName( iPlayer ), iPlayer, szMessage );
	}
	return 1;
}

CMD:bu( playerid, params[ ] ) return cmd_backup( playerid, params );
CMD:backup( playerid, params[ ] )
{
    if ( p_Class[ playerid ] != CLASS_POLICE ) return SendError( playerid, "The police are authorized to use this only." );
    SendClientMessageToCops( -1, ""COL_BLUE"[POLICE RADIO]"COL_WHITE" %s is requesting back up at %s.", ReturnPlayerName( playerid ), GetPlayerArea( playerid ) );
	return 1;
}

CMD:sm( playerid, params[ ] ) return cmd_sendmoney( playerid, params );
CMD:sendmoney( playerid, params[ ] )
{
    new
		pID,
		amount,
		szPayment[ 96 ],
		iTime = g_iTime
	;

	if ( p_accountSecurityData[ playerid ] [ E_ID ] && ! p_accountSecurityData[ playerid ] [ E_VERIFIED ] && p_accountSecurityData[ playerid ] [ E_MODE ] != SECURITY_MODE_DISABLED )
		return SendError( playerid, "You must be verified in order to use this feature. "COL_YELLOW"(use /verify)" );

	/* ** Anti Tie Spam ** */
	if ( GetPVarInt( playerid, "sm_antispam" ) > iTime ) return SendError( playerid, "You must wait 10 seconds before sending payments again." );
	/* ** End of Anti Tie Spam ** */

	if ( sscanf( params, ""#sscanf_u"d", pID, amount ) ) return SendUsage( playerid, "/sendmoney [PLAYER_ID] [AMOUNT]" );
	else if ( amount > GetPlayerCash( playerid ) ) return SendError( playerid, "You don't have this amount of money." );
	else if ( amount < 1 ) return SendError( playerid, "Invalid amount of money." );
    else if ( pID == playerid ) return SendError( playerid, "You cannot send money to yourself." );
    else if ( !IsPlayerConnected( pID ) ) return SendError( playerid, "This player is not connected." );
	else if ( p_PlayerLogged{ pID } == false ) return SendError( playerid, "This player is not logged in." );
	else if ( IsPlayerAFK( pID ) ) return SendError( playerid, "You cannot send money to a person who is AFK." );
	else if ( IsPlayerKidnapped( playerid ) ) return SendError( playerid, "You cannot send anybody money while you are kidnapped." );
    else
    {
    	format( szPayment, sizeof( szPayment ), "INSERT INTO `TRANSACTIONS` (`TO_ID`, `FROM_ID`, `CASH`) VALUES (%d, %d, %d)", p_AccountID[ pID ], p_AccountID[ playerid ], amount );
     	mysql_single_query( szPayment );

        if ( amount > 25000 )
        	printf("[sendmoney] %s -> %s - %s", ReturnPlayerName( playerid ), ReturnPlayerName( pID ), ConvertPrice( amount ) ); // 8hska7082bmahu

		if ( amount > 90000000 ) {
	   		printf("ISP banned %s for making a 75M transaction", ReturnPlayerName( playerid ));
	   		BanEx( playerid, "75M Transaction" );
	   		return 1;
        }

        GivePlayerCash( pID, amount );
        GivePlayerCash( playerid, -( amount ) );
    	SetPVarInt( playerid, "sm_antispam", iTime + 10 );
		SendClientMessageFormatted( pID, -1, ""COL_GREEN"[PAYMENT]"COL_WHITE" You have recieved %s from %s(%d).", ConvertPrice( amount ), ReturnPlayerName( playerid ), playerid );
        SendClientMessageFormatted( playerid, -1, ""COL_RED"[PAYMENT]"COL_WHITE" You have sent %s to %s(%d).", ConvertPrice( amount ), ReturnPlayerName(pID), pID );
        Beep( pID ), Beep( playerid );
    }
	return 1;
}

CMD:dndall( playerid, params[ ] )
{
	foreach(new i : Player)
	{
	    if ( i == playerid ) continue;
	    p_BlockedPM[ playerid ] [ i ] = true;
	}
	SendClientMessage( playerid, -1, ""COL_GOLD"[DO NOT DISTURB]"COL_WHITE" You have un-toggled everyone to send PMs to you." );
	return 1;
}

CMD:undndall( playerid, params[ ] )
{
	foreach(new i : Player)
	{
	    if ( i == playerid ) continue;
	    p_BlockedPM[ playerid ] [ i ] = false;
	}
	SendClientMessage( playerid, -1, ""COL_GOLD"[DO NOT DISTURB]"COL_WHITE" You have toggled everyone to send PMs to you." );
	return 1;
}

CMD:dnd( playerid, params[ ] )
{
	new
	    pID
	;
	if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/dnd [PLAYER_ID]" );
    else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
    else if ( pID == playerid ) return SendError( playerid, "You cannot block yourself." );
	else
	{
	    p_BlockedPM[ playerid ] [ pID ] = ( p_BlockedPM[ playerid ] [ pID ] == true ? ( false ) : ( true ) );
		SendClientMessageFormatted( playerid, -1, ""COL_GOLD"[DO NOT DISTURB]"COL_WHITE" You have %s %s to send pm's to you.", p_BlockedPM[ playerid ] [ pID ] == false ? ("toggled") : ("un-toggled"), ReturnPlayerName( pID ) );
	}
	return 1;
}

CMD:r( playerid, params[ ] )
{
	new msg[ 100 ];

	if ( sscanf( params, "s[100]", msg ) ) return SendUsage( playerid, "/r [MESSAGE]" );
	else if ( !IsPlayerConnected( p_PmResponder[ playerid ] ) ) return SendError( playerid, "This player is not connected." );
    else if ( p_BlockedPM[ p_PmResponder[ playerid ] ] [ playerid ] == true ) return SendError( playerid, "This person has blocked pm's coming from you." );
    else if ( textContainsIP( msg ) ) return SendError( playerid, "Advertising via PM is forbidden." );
	else if ( p_PlayerLogged{ p_PmResponder[ playerid ] } == false ) return SendError( playerid, "This player is not logged in." );
	else
	{
	    new pID = p_PmResponder[ playerid ];

		if ( IsPlayerLorenc( pID ) && g_VipPrivateMsging && p_VIPLevel[ playerid ] < VIP_REGULAR ) {
			return SendError( playerid, "You need to be V.I.P to PM this person, to become one visit "COL_GREY"donate.irresistiblegaming.com" );
		}

		if ( p_BlockedPM[ playerid ] [ pID ] == true ) {
			SendServerMessage( playerid, "The message you have sent was to a person you blocked so they have been unblocked." );
			p_BlockedPM[ playerid ] [ pID ] = false;
		}

		if ( IsPlayerAFK( pID ) ) {
			SendServerMessage( playerid, "You have sent a message to a person who is currently AFK. Be aware!" );
		}

		GameTextForPlayer( pID, "~n~~n~~n~~n~~n~~n~~n~~w~... ~y~New Message!~w~ ...", 4000, 3 );
		SendClientMessageFormatted( pID, -1, ""COL_YELLOW"[MESSAGE]{CCCCCC} From %s(%d): %s", ReturnPlayerName( playerid ), playerid, msg );
        SendClientMessageFormatted( playerid, -1, ""COL_YELLOW"[MESSAGE]{A3A3A3} To %s(%d): %s", ReturnPlayerName(pID), pID, msg );
		foreach(new i : Player)
		{
		    if ( ( p_AdminLevel[ i ] >= 5 || IsPlayerUnderCover( i ) ) && p_ToggledViewPM{ i } == true )
		    {
		        SendClientMessageFormatted( i, -1, ""COL_PINK"[PM VIEW]"COL_YELLOW" (%s >> %s):"COL_WHITE" %s", ReturnPlayerName( playerid ), ReturnPlayerName( pID ), msg );
		    }
		}
		p_PmResponder[ playerid ] = pID;
        Beep( pID ), Beep( playerid );
	}
	return 1;
}

CMD:pm( playerid, params[ ] )
{
	new
		pID, msg[100]
	;

	if ( sscanf( params, ""#sscanf_u"s[100]", pID, msg ) ) return SendUsage( playerid, "/pm [PLAYER_ID] [MESSAGE]" );
    else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
    else if ( pID == playerid ) return SendError( playerid, "You cannot pm yourself." );
    else if ( p_BlockedPM[ pID ] [ playerid ] == true ) return SendError( playerid, "This person has blocked pm's coming from you." );
	else if ( textContainsIP( msg ) ) return SendError( playerid, "Advertising via PM is forbidden." );
	else if ( p_PlayerLogged{ pID } == false ) return SendError( playerid, "This player is not logged in." );
	else
	{
		if ( IsPlayerLorenc( pID ) && g_VipPrivateMsging && p_VIPLevel[ playerid ] < VIP_REGULAR ) {
			return SendError( playerid, "You need to be V.I.P to PM this person, to become one visit "COL_GREY"donate.irresistiblegaming.com" );
		}

		if ( p_BlockedPM[ playerid ] [ pID ] == true ) {
			SendServerMessage( playerid, "The message you have sent was to a person you blocked so they have been unblocked." );
			p_BlockedPM[ playerid ] [ pID ] = false;
		}

		if ( IsPlayerAFK( pID ) ) {
			SendServerMessage( playerid, "You have sent a message to a person who is currently AFK. Be aware!" );
		}

		GameTextForPlayer( pID, "~n~~n~~n~~n~~n~~n~~n~~w~... ~y~New Message!~w~ ...", 4000, 3 );
		SendClientMessageFormatted( pID, -1, ""COL_YELLOW"[MESSAGE]{CCCCCC} From %s(%d): %s", ReturnPlayerName( playerid ), playerid, msg );
        SendClientMessageFormatted( playerid, -1, ""COL_YELLOW"[MESSAGE]{A3A3A3} To %s(%d): %s", ReturnPlayerName(pID), pID, msg );
		foreach(new i : Player)
		{
		    if ( ( p_AdminLevel[ i ] >= 5 || IsPlayerUnderCover( i ) ) && p_ToggledViewPM{ i } == true )
		    {
		        SendClientMessageFormatted( i, -1, ""COL_PINK"[PM VIEW]"COL_YELLOW" (%s >> %s):"COL_WHITE" %s", ReturnPlayerName( playerid ), ReturnPlayerName( pID ), msg );
		    }
		}
		p_PmResponder[ playerid ] = pID;
        Beep( pID ), Beep( playerid );
	}
	return 1;
}

CMD:statistics( playerid, params[ ] ) return cmd_stats( playerid, params );
CMD:stats( playerid, params[ ] )
{
	if ( !p_PlayerLogged{ playerid } )
		return SendError( playerid, "You are not logged in meaning you cannot access this command." );

	p_ViewingStats[ playerid ] = playerid;
	ShowPlayerDialog( playerid, DIALOG_STATS, DIALOG_STYLE_LIST, "{FFFFFF}Statistics", "General Statistics\nGame Statistics\nItem Statistics\nStreak Statistics\nAchievements", "Okay", "Cancel" );
	return 1;
}

CMD:help( playerid, params[ ] )
{
	ShowPlayerDialog( playerid, DIALOG_HELP, DIALOG_STYLE_LIST, "{FFFFFF}Help", "Server Information\nFeatures\nHelp\nF.A.Q.\nGuides\nTips n' Tricks", "Okay", "" );
	return 1;
}

CMD:features( playerid, params[ ] )
{
	SetPVarInt( playerid, "help_category", 1 );
    mysql_function_query( dbHandle, "SELECT `SUBJECT`,`ID`,`CATEGORY` FROM `HELP` WHERE `CATEGORY`=1 ORDER BY `SUBJECT` ASC", true, "OnFetchCategoryResponse", "dd", playerid, 1 );
   	return 1;
}

CMD:faq( playerid, params[ ] )
{
	SetPVarInt( playerid, "help_category", 3 );
    mysql_function_query( dbHandle, "SELECT `SUBJECT`,`ID`,`CATEGORY` FROM `HELP` WHERE `CATEGORY`=3 ORDER BY `SUBJECT` ASC", true, "OnFetchCategoryResponse", "dd", playerid, 3 );
   	return 1;
}

CMD:tips( playerid, params[ ] )
{
	SetPVarInt( playerid, "help_category", 5 );
    mysql_function_query( dbHandle, "SELECT `SUBJECT`,`ID`,`CATEGORY` FROM `HELP` WHERE `CATEGORY`=5 ORDER BY `SUBJECT` ASC", true, "OnFetchCategoryResponse", "dd", playerid, 5 );
   	return 1;
}

CMD:commands( playerid, params[ ] ) return cmd_cmds( playerid, params );
CMD:cmds( playerid, params[ ] )
{
    ShowPlayerDialog( playerid, DIALOG_CMDS, DIALOG_STYLE_LIST, "{FFFFFF}Commands", "Basic Commands\nMain Commands\nCivilian Commands\nShop/Item Commands\nPolice Commands\nFireman Commands\nParamedic Commands\nVehicle Commands\nHouse Commands\nMiscellaneous Commands\n"COL_GOLD"V.I.P Commands", "Okay", "" );
	return 1;
}

CMD:breakout( playerid, params[ ] )
{
	if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "This is restricted to civilians only." );
	if ( !IsPlayerJailed( playerid ) ) return SendError( playerid, "You can only use this while you're in jail!" );
	if ( IsPlayerAdminJailed( playerid ) ) return SendError( playerid, "You have been admin jailed, disallowing this." );
	if ( p_inAlcatraz{ playerid } ) return SendError( playerid, "You are unable to break out of Alcatraz. Ask a friend to blow you out." );
	if ( p_MetalMelter[ playerid ] > 0 )
	{
	    new
			iRandom = random( 101 );

		if ( p_MetalMelter[ playerid ]-- <= 3 )
			ShowPlayerHelpDialog( playerid, 2500, "You only have %d metal melters left!", p_MetalMelter[ playerid ] );

	    if ( iRandom < 80 ) {
		  	CallLocalFunction( "OnPlayerUnjailed", "dd", playerid, 2 );
		  	GivePlayerWantedLevel( playerid, 24 );
	    }
		else SendServerMessage( playerid, "You have failed to break out." );
	}
	else SendError( playerid, "You have no more Metal Melters available.");
	return 1;
}

CMD:shop( playerid, params[ ] )
{
    if ( ( !IsPlayerInEntrance( playerid, g_SupaSave ) && !IsPlayerInDynamicCP( playerid, g_Checkpoints[ CP_247_MENU ] ) ) || !GetPlayerInterior( playerid ) ) return SendError( playerid, "You must be within Supa Save or 24/7 to purchase items." );
	if ( IsPlayerTazed( playerid ) ) return SendError( playerid, "You cannot use this since you're tazed." );
	if ( IsPlayerDetained( playerid ) ) return SendError( playerid, "You cannot use this since you're detained." );
	if ( IsPlayerCuffed( playerid ) ) return SendError( playerid, "You cannot use this since you're cuffed." );
	if ( IsPlayerTied( playerid ) ) return SendError( playerid, "You cannot use this since you're tied." );
	if ( IsPlayerKidnapped( playerid ) ) return SendError( playerid, "You cannot use this since you're kidnapped." );

	ShowPlayerShopMenu( playerid );
	return 1;
}

CMD:placehit( playerid, params[ ] )
{
	if ( p_accountSecurityData[ playerid ] [ E_ID ] && ! p_accountSecurityData[ playerid ] [ E_VERIFIED ] && p_accountSecurityData[ playerid ] [ E_MODE ] != SECURITY_MODE_DISABLED )
		return SendError( playerid, "You must be verified in order to use this feature. "COL_YELLOW"(use /verify)" );

	/* ** Anti Spammy Commands ** */
	if ( p_AntiSpammyTS[ playerid ] > g_iTime ) return SendError( playerid, "You cannot use commands that are sent to players globally for %d seconds.", p_AntiSpammyTS[ playerid ] - g_iTime );
	/* ** End Anti Spammy Commands ** */

	new
	    pID,
	    cash
	;
	if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "This is restricted to civilians only." );
	else if ( JobEquals( playerid, JOB_HITMAN ) ) return SendError( playerid, "As a hitman you're not allowed to use this command." );
	else if ( sscanf( params, ""#sscanf_u"d", pID, cash ) ) return SendUsage( playerid, "/placehit [PLAYER_ID] [AMOUNT]" );
	else if ( cash > GetPlayerCash( playerid ) ) return SendError( playerid, "You don't have enough money to place this much." );
	else if ( cash < 1000 ) return SendError( playerid, "The minimal hit you can place is $1,000." );
	else if ( pID == playerid ) return SendError( playerid, "You cannot place a hit on your self.");
	else if ( !IsPlayerConnected( pID ) ) return SendError( playerid, "This player isn't connected!" );
	{
		// transaction
    	format( szNormalString, sizeof( szNormalString ), "INSERT INTO `TRANSACTIONS` (`TO_ID`, `FROM_ID`, `CASH`, `NATURE`) VALUES (%d, %d, %d, 'contract')", p_AccountID[ pID ], p_AccountID[ playerid ], cash );
     	mysql_single_query( szNormalString );

     	// place hit
		p_ContractedAmount[ pID ] += cash;
		GivePlayerCash( playerid, -cash );
		p_AntiSpammyTS[ playerid  ] = g_iTime + 10;
		printf("[placehit] %s -> %s - %s", ReturnPlayerName( playerid ), ReturnPlayerName( pID ), ConvertPrice( cash ) ); // 8hska7082bmahu
		SendGlobalMessage( -1, ""COL_ORANGE"[CONTRACT]"COL_WHITE" %s(%d) has put a contract on %s(%d), his bounty is now "COL_GOLD"%s{FFFFFF}.", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, ConvertPrice( p_ContractedAmount[ pID ] ) );
	}
	return 1;
}

CMD:me( playerid, params[ ] )
{
	new action[70];
	if ( p_Muted{ playerid } == true && g_iTime < p_MutedTime[ playerid ] ) return SendError( playerid, "You cannot use this feature as you are muted." );
	else if ( GetPlayerScore( playerid ) < 25 ) return SendError( playerid, "You need at least 25 score to use this feature (spamming purposes)." );
	else if ( sscanf( params, "s[70]", action ) ) return SendUsage( playerid, "/me [ACTION]" );
	else
	{
    	DCC_SendChannelMessageFormatted( discordGeneralChan, "** * * * %s(%d) %s **", ReturnPlayerName( playerid ), playerid, action );
		SendClientMessageToAllFormatted( GetPlayerColor( playerid ), "*** %s(%d) %s", ReturnPlayerName( playerid ), playerid, action );
	}
	return 1;
}

CMD:hidetracker( playerid, params[ ] )
{
	if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "This is restricted to civilians only." );
	if ( !JobEquals( playerid, JOB_HITMAN ) ) return SendError( playerid, "You have to be a hitman to use this command." );
	if ( p_TrackingTimer[ playerid ] == INVALID_TIMER_ID ) return SendError( playerid, "Your tracker is already deactivated." );
	SendServerMessage(playerid, "You have de-activated the tracker.");
	KillTimer( p_TrackingTimer[ playerid ] );
	p_TrackingTimer[ playerid ] = INVALID_TIMER_ID;
	TextDrawHideForPlayer( playerid, p_TrackPlayerTD[ playerid ] );
	return 1;
}

CMD:track( playerid, params[ ] )
{
	new
	    pID
	;

	if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "This is restricted to civilians only." );
	else if ( !JobEquals( playerid, JOB_HITMAN ) ) return SendError( playerid, "You have to be a hitman to use this command." );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/track [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "This player isn't connected!" );
	else if ( pID == playerid ) return SendError( playerid, "You cannot apply this to yourself." );
	else if ( !IsPlayerSpawned( pID ) ) return SendError( playerid, "The player selected isn't spawned." );
	else if ( p_AdminOnDuty{ pID } == true || GetPlayerState( pID ) == PLAYER_STATE_SPECTATING ) return SendError( playerid, "This is an admin on duty! You cannot track their proximity." );
	else
	{
	    KillTimer( p_TrackingTimer[ playerid ] );
	    p_TrackingTimer[ playerid ] = SetTimerEx( "TrackPlayer_timer", 1000, true, "dd", playerid, pID );
	    TextDrawShowForPlayer( playerid, p_TrackPlayerTD[ playerid ] );
	    SendServerMessage( playerid, "You have activated the tracker, you can hide it with /hidetracker." );
	}
	return 1;
}

function TrackPlayer_timer( playerid, victimid )
{
	if ( !IsPlayerConnected( victimid ) || p_AdminOnDuty{ victimid } == true || GetPlayerState( victimid ) == PLAYER_STATE_SPECTATING || !JobEquals( playerid, JOB_HITMAN ) || p_Class[ playerid ] != CLASS_CIVILIAN )
	{
		KillTimer( p_TrackingTimer[ playerid ] ), p_TrackingTimer[ playerid ] = INVALID_TIMER_ID;
		TextDrawHideForPlayer( playerid, p_TrackPlayerTD[ playerid ] );
	}
	else
	{
		new
			Float: fDistance;

		if ( GetPlayerInterior( playerid ) != GetPlayerInterior( victimid ) )
		{
			new
				iEntrance = p_LastEnteredEntrance[ victimid ],
				iHouse = p_InHouse[ victimid ],
				iGarage = p_InGarage[ victimid ]
			;

		    if ( iEntrance != -1 )
		  		fDistance = GetPlayerDistanceFromPoint( playerid, g_entranceData[ iEntrance ] [ E_EX ], g_entranceData[ iEntrance ] [ E_EY ], g_entranceData[ iEntrance ] [ E_EZ ] );

		  	else if ( iGarage != -1 )
		  		fDistance = GetPlayerDistanceFromPoint( playerid, g_garageData[ iGarage ] [ E_X ], g_garageData[ iGarage ] [ E_Y ], g_garageData[ iGarage ] [ E_Z ] );

		  	else if ( iHouse != -1 )
		  		fDistance = GetPlayerDistanceFromPoint( playerid, g_houseData[ iHouse ] [ E_EX ], g_houseData[ iHouse ] [ E_EY ], g_houseData[ iHouse ] [ E_EZ ] );

		  	else fDistance = 9999.9; // Truly unknown lol
		}
		else fDistance = GetDistanceBetweenPlayers( playerid, victimid );

		if ( !fDistance || fDistance > 9999.9 )
			fDistance = 9999.9;

		TextDrawSetString( p_TrackPlayerTD[ playerid ], fDistance != 9999.0 ? sprintf( "%s~n~~w~%0.1fm", ReturnPlayerName( victimid ), fDistance ) : sprintf( "%s~n~~w~unknown", ReturnPlayerName( victimid ) ) );
	}
}

CMD:stoprob( playerid, params[ ] )
{
	SendServerMessage( playerid, "This command binds your crouch key, so you must be robbing a store to get a response!" );
	CallLocalFunction( "OnPlayerKeyStateChange", "ddd", playerid, KEY_CROUCH, KEY_SPRINT );
	return 1;
}

CMD:exit( playerid, params[ ] ) return cmd_enter( playerid, params );
CMD:enter( playerid, params[ ] )
{
	GameTextForPlayer(playerid, "~n~~n~~r~~k~~VEHICLE_ENTER_EXIT~~n~~w~press this key in a enterable checkpoint.", 5000, 3);
	return 1;
}

CMD:kill( playerid, params[ ] )
{
	if ( !IsPlayerSpawned( playerid ) ) return SendError( playerid, "You cannot use this command since you're not spawned." );
	if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this command since you're jailed." );
	if ( IsPlayerTazed( playerid ) ) return SendError( playerid, "You cannot use this command since you're tazed." );
	if ( IsPlayerDetained( playerid ) ) return SendError( playerid, "You cannot use this command since you're detained." );
	if ( IsPlayerCuffed( playerid ) ) return SendError( playerid, "You cannot use this command since you're cuffed." );
	if ( IsPlayerTied( playerid ) ) return SendError( playerid, "You cannot use this command since you're tied." );
	if ( IsPlayerKidnapped( playerid ) ) return SendError( playerid, "You cannot use this command since you're kidnapped." );
	if ( p_WantedLevel[ playerid ] > 0 ) return SendError( playerid, "You cannot commit suicide if you have a wanted level on you." );
	if ( IsPlayerGettingBlowed( playerid ) ) return SendError( playerid, "You cannot use this command since you're getting blowed." );
	if ( IsPlayerBlowingCock( playerid ) ) return SendError( playerid, "You cannot use this command since you're giving oral sex." );
	if ( p_Spectating{ playerid } == true ) return SendError( playerid, "You cannot use this command since you're spectating." );
	if ( p_AntiSpawnKillEnabled{ playerid } ) return SendError( playerid, "You cannot use this command while anti-spawn kill is activated." );
	SetPVarInt( playerid, "used_cmd_kill", 1 );
	SetPlayerHealth( playerid, -1 );
	return 1;
}

CMD:changeclass( playerid, params[ ] )
{
	if ( !IsPlayerSpawned( playerid ) ) return SendError( playerid, "You cannot use this command since you're not spawned." );
	if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this command since you're jailed." );
	if ( IsPlayerTazed( playerid ) ) return SendError( playerid, "You cannot use this command since you're tazed." );
	if ( IsPlayerDetained( playerid ) ) return SendError( playerid, "You cannot use this command since you're detained." );
	if ( IsPlayerCuffed( playerid ) ) return SendError( playerid, "You cannot use this command since you're cuffed." );
	if ( IsPlayerTied( playerid ) ) return SendError( playerid, "You cannot use this command since you're tied." );
	if ( IsPlayerKidnapped( playerid ) ) return SendError( playerid, "You cannot use this command since you're kidnapped." );
	if ( p_WantedLevel[ playerid ] > 0 ) return SendError( playerid, "You cannot commit suicide if you have a wanted level on you." );
	if ( IsPlayerGettingBlowed( playerid ) ) return SendError( playerid, "You cannot use this command since you're getting blowed." );
	if ( IsPlayerBlowingCock( playerid ) ) return SendError( playerid, "You cannot use this command since you're giving oral sex." );
	if ( p_Spectating{ playerid } == true ) return SendError( playerid, "You cannot use this command since you're spectating." );
	if ( p_AntiSpawnKillEnabled{ playerid } ) return SendError( playerid, "You cannot use this command while anti-spawn kill is activated." );
	SetPVarInt( playerid, "used_cmd_kill", 1 );
	ForceClassSelection( playerid );
	SetPlayerHealth( playerid, -1 );
	return 1;
}

CMD:911( playerid, params[ ] )
{
	/* ** Anti Spammy Commands ** */
	if ( p_AntiSpammyTS[ playerid ] > g_iTime ) return SendError( playerid, "You cannot use commands that are sent to players globally for %d seconds.", p_AntiSpammyTS[ playerid ] - g_iTime );
	/* ** End Anti Spammy Commands ** */

	if ( p_Class[ playerid ] == CLASS_POLICE ) return SendError( playerid, "You cannot use this command as you are a law enforcement officer." );
	else if ( GetPlayerInterior( playerid ) != 0 ) return SendError( playerid, "You cannot use this command in an interior." );
	else
	{
		new
			Float: X, Float: Y, Float: Z,
			szLocation[ MAX_ZONE_NAME ], szCity[ MAX_ZONE_NAME ]
		;
		GetPlayerPos( playerid, X, Y, Z );
		GetZoneFromCoordinates( szLocation, X, Y, Z );
		Get2DCity( szCity, X, Y, Z );

		if ( strmatch( params, "LEO" ) )
	    {
	    	p_AntiSpammyTS[ playerid ] = g_iTime + 15;
	        SendClientMessageToCops( -1, ""COL_BLUE"[911]"COL_GREY" %s(%d) is asking for a law enforcement officer near %s in %s!", ReturnPlayerName( playerid ), playerid, szLocation, szCity );
			SendServerMessage( playerid, "You have asked for a leo enforcement officer at your current location." );
		}
		else if ( strmatch( params, "EFB" ) )
	    {
	    	p_AntiSpammyTS[ playerid ] = g_iTime + 15;
	        SendClientMessageToFireman( -1, "{A83434}[911]"COL_GREY" %s(%d) is asking for a fire brigade near %s in %s!", ReturnPlayerName( playerid ), playerid, szLocation, szCity );
			SendServerMessage( playerid, "You have asked for a fire brigade at your current location." );
		}
		else if ( strmatch( params, "EMS" ) )
	    {
	    	p_AntiSpammyTS[ playerid ] = g_iTime + 15;
	        SendClientMessageToAmbulance( -1, ""COL_GREEN"[911]"COL_GREY" %s(%d) is asking for a paramedic near %s in %s!", ReturnPlayerName( playerid ), playerid, szLocation, szCity );
			SendServerMessage( playerid, "You have asked for a paramedic at your current location." );
		}
		else SendUsage( playerid, "/911 [LEO/EFB/EMS]" );
	}
	return 1;
}


CMD:kidnap( playerid, params[ ] )
{
	/* ** ANTI KIDNAP SPAM ** */
    if ( p_AntiKidnapSpam[ playerid ] > g_iTime ) return SendError( playerid, "You must wait 30 seconds before kidnapping someone again." );
    /* ** END OF ANTI SPAM **/

  	new victimid = GetClosestPlayer( playerid );
   	if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this command since you're jailed." );
	else if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "This is restricted to civilians only." );
   	else if ( p_Spectating{ playerid } ) return SendError( playerid, "You cannot use such commands while you're spectating." );
   	else if ( !JobEquals( playerid, JOB_KIDNAPPER ) ) return SendError( playerid, "Kidnappers are only permitted to use this command." );
	else if ( GetDistanceBetweenPlayers( playerid, victimid ) < 4.0 && IsPlayerConnected( victimid ) )
	{
  		if ( IsPlayerInAnyVehicle( victimid ) ) return SendError( playerid, "This player is in a vehicle." );
		if ( !IsPlayerTied( victimid ) ) return SendError( playerid, "This player isn't tied!" );
		if ( IsPlayerKidnapped( victimid ) ) return SendError( playerid, "This player is already kidnapped!" );
		if ( IsPlayerGettingBlowed( playerid ) ) return SendError( playerid, "You cannot use this command since you're getting blowed." );
		if ( IsPlayerBlowingCock( playerid ) ) return SendError( playerid, "You cannot use this command since you're giving oral sex." );
		if ( IsPlayerInPaintBall( playerid ) ) return SendError( playerid, "You cannot use this command since you're inside the paintball arena." );
		if ( IsPlayerJailed( victimid ) ) return SendError( playerid, "This player is jailed. He may be paused." );
		if ( p_KidnapImmunity[ victimid ] > g_iTime ) return SendError( playerid, "This player cannot be kidnapped for another %s.", secondstotime( p_KidnapImmunity[ victimid ] - g_iTime ) );
		if ( PutPlayerInEmptyVehicleSeat( p_LastVehicle[ playerid ], victimid ) == -1 ) return SendError( playerid, "Failed to place the player inside a full of player vehicle." );
		SendClientMessageFormatted( victimid, -1, ""COL_RED"[KIDNAPPED]{FFFFFF} You have been kidnapped by %s(%d)!", ReturnPlayerName( playerid ), playerid );
	    SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[KIDNAPPED]{FFFFFF} You have kidnapped %s(%d), he has been thrown in your previous entered vehicle!", ReturnPlayerName( victimid ), victimid );
		TogglePlayerControllable( victimid, 0 );
		p_Kidnapped{ victimid } = true;
		GivePlayerWantedLevel( playerid, 12 );
     	p_AntiKidnapSpam[ playerid ] = g_iTime + 30;
		//PutPlayerInVehicle( victimid, p_LastVehicle[ playerid ], 1 );
	}
	else return SendError( playerid, "There are no players around to kidnap." );
	return 1;
}

CMD:untie( playerid, params[ ] )
{
  	new victimid = GetClosestPlayer( playerid );
   	if ( p_Spectating{ playerid } ) return SendError( playerid, "You cannot use such commands while you're spectating." );
	else if ( GetDistanceBetweenPlayers( playerid, victimid ) < 4.0 && IsPlayerConnected( victimid ) )
	{
		if ( IsPlayerTied( playerid ) ) return SendError( playerid, "You cannot use this command since you're tied." );
  		//if ( IsPlayerInAnyVehicle( victimid ) ) return SendError( playerid, "This player is in a vehicle." );
		if ( !IsPlayerTied( victimid ) ) return SendError( playerid, "This player isn't tied!" );
		SendClientMessageFormatted( victimid, -1, ""COL_GREEN"[UN-TIED]{FFFFFF} You have been un-tied by %s(%d)!", ReturnPlayerName( playerid ), playerid );
	    SendClientMessageFormatted( playerid, -1, ""COL_RED"[UN-TIED]{FFFFFF} You have un-tied %s(%d)!", ReturnPlayerName( victimid ), victimid );
		TogglePlayerControllable( victimid, 1 );
		p_Tied{ victimid } = false;
		Delete3DTextLabel( p_TiedLabel[ victimid ] );
		p_TiedLabel[ victimid ] = Text3D: INVALID_3DTEXT_ID;
		p_TimeTiedAt[ victimid ] = 0;
		p_Kidnapped{ victimid } = false;
	}
	else return SendError( playerid, "There are no players around to un-tie." );
	return 1;
}

CMD:tie( playerid, params[ ] )
{
	/* ** Anti Tie Spam ** */
	if ( p_AntiTieSpam[ playerid ] > g_iTime ) return SendError( playerid, "You must wait %d seconds before tieing someone again.", p_AntiTieSpam[ playerid ] - g_iTime );
	/* ** End of Anti Tie Spam ** */

	new victimid = GetClosestPlayer( playerid );
	//if ( sscanf( params, ""#sscanf_u"", victimid ) ) return SendUsage( playerid, "/tie [PLAYER_ID]" );
	//else if ( victimid == playerid ) return SendError( playerid, "You cannot tie yourself." );
	//else if ( !IsPlayerConnected( victimid ) ) return SendError( playerid, "This player is not connected." );
	if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this command since you're jailed." );
	else if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "This is restricted to civilians only." );
   	else if ( p_Spectating{ playerid } ) return SendError( playerid, "You cannot use such commands while you're spectating." );
	else if ( p_Ropes[ playerid ] < 1 ) return SendError( playerid, "You don't have any ropes." );
 	else if ( GetDistanceBetweenPlayers( playerid, victimid ) < 4.0 && IsPlayerConnected( victimid ) )
 	{
		if ( IsPlayerTied( playerid ) ) return SendError( playerid, "You cannot use this command since you're tied." );
  		if ( IsPlayerInAnyVehicle( victimid ) ) return SendError( playerid, "This player is in a vehicle." );
		if ( IsPlayerTied( victimid ) ) return SendError( playerid, "This player is already tied!" );
  		if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You cannot tie inside a vehicle." );
		if ( IsPlayerCuffed( playerid ) ) return SendError( playerid, "You cannot tie while you're cuffed." );
		if ( IsPlayerTazed( playerid ) ) return SendError( playerid, "You cannot tie while you're tazed." );
		if ( IsPlayerTazed( victimid ) ) return SendError( playerid, "The person you're trying to tie is tazed." );
		if ( IsPlayerOnSlotMachine( victimid ) ) return SendError( playerid, "The person you're trying to tie is using a slot machine." );
		if ( IsPlayerOnRoulette( victimid ) ) return SendError( playerid, "The person you're trying to tie is using roulette." );
		if ( IsPlayerCuffed( victimid ) ) return SendError( playerid, "The person you're trying to tie is cuffed." );
		if ( IsPlayerGettingBlowed( playerid ) ) return SendError( playerid, "You cannot use this command since you're getting blowed." );
		if ( IsPlayerBlowingCock( playerid ) ) return SendError( playerid, "You cannot use this command since you're giving oral sex." );
		if ( IsPlayerInPaintBall( playerid ) ) return SendError( playerid, "You cannot use this command since you're inside the paintball arena." );
		if ( IsPlayerAdminOnDuty( victimid ) ) return SendError( playerid, "You cannot use this command on admins that are on duty." );
		if ( IsPlayerJailed( victimid ) ) return SendError( playerid, "This player is jailed. He may be paused." );
		if ( IsPlayerLoadingObjects( victimid ) ) return SendError( playerid, "This player is in a object-loading state." );
		if ( GetPlayerState( victimid ) == PLAYER_STATE_WASTED ) return SendError( playerid, "You cannot tie wasted players." );
		if ( IsPlayerInEvent( playerid ) ) return SendError( playerid, "You cannot use this command since you're in an event." );
		if ( IsPlayerInPlayerGang( playerid, victimid ) ) return SendError( playerid, "You cannot use this command on your homies!" );
		if ( p_AntiSpawnKillEnabled{ victimid } ) return SendError( playerid, "You cannot use this command on spawn protected players." );

		if ( random( 101 ) < 90 )
		{
			SendClientMessageFormatted( victimid, -1, ""COL_RED"[TIED]{FFFFFF} You have been tied by %s(%d)!", ReturnPlayerName( playerid ), playerid );
		    SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[TIED]{FFFFFF} You have tied %s(%d)!", ReturnPlayerName( victimid ), victimid );
			TogglePlayerControllable( victimid, 0 );
			p_Tied{ victimid } = true;
			p_Ropes[ playerid ] --;
     		p_TimeTiedAt[ victimid ] = g_iTime;
			GivePlayerWantedLevel( playerid, 6 );
			p_AntiTieSpam[ playerid ] = g_iTime + 30;
			p_TiedBy[ victimid ] = playerid;
		    Delete3DTextLabel( p_TiedLabel[ victimid ] );
		    format( szNormalString, 48, "Tied by %s!", ReturnPlayerName( playerid ) );
		    p_TiedLabel[ victimid ] = Create3DTextLabel( szNormalString, 0xDAB583FF, 0.0, 0.0, 0.0, 15.0, 0 );
		    Attach3DTextLabelToPlayer( p_TiedLabel[ victimid ], victimid, 0.0, 0.0, 0.6 );
		    p_TiedAtTimestamp[ victimid ] = g_iTime;

			if ( p_Ropes[ victimid ] )
				ShowPlayerHelpDialog( victimid, 4000, "You can cut your ties with ~p~/cuttie." );
			else
				ShowPlayerHelpDialog( victimid, 4000, "You can buy sissors at Supa Save or a 24/7 store." );
		}
		else
		{
			p_AntiTieSpam[ playerid ] = g_iTime + 6; // makecopgreatagain
			SendClientMessageFormatted( victimid, -1, ""COL_GREEN"[FAIL TIE]{FFFFFF} %s(%d) has failed to tie you!", ReturnPlayerName( playerid ), playerid );
		    SendClientMessageFormatted( playerid, -1, ""COL_RED"[FAIL TIE]{FFFFFF} You have failed to tie %s(%d)!", ReturnPlayerName( victimid ), victimid );
		}
	}
	else return SendError( playerid, "There are no players around to tie." );
	return 1;
}

CMD:pu( playerid, params[ ] ) return cmd_pullover(playerid, params);
CMD:pullover( playerid, params[ ] )
{
   	new victimid = GetClosestPlayerEx( playerid, CLASS_CIVILIAN );
   	if ( p_Class[ playerid ] != CLASS_POLICE ) return SendError( playerid, "This is restricted to police only." );
   	else if ( p_Spectating{ playerid } ) return SendError( playerid, "You cannot use such commands while you're spectating." );
 	else if ( GetDistanceBetweenPlayers( playerid, victimid ) < 20.0 && IsPlayerConnected( victimid ) )
 	{
 	    if ( p_Class[ victimid ] == p_Class[ playerid ] ) return SendError( playerid, "This player you're close to is in your team." );
		if ( p_WantedLevel[ victimid ] == 0 ) return SendError( playerid, "This player is innocent!" );
		if ( GetPlayerState( victimid ) != PLAYER_STATE_DRIVER ) return SendError( playerid, "This player is not in any vehicle!" );
		SendClientMessageFormatted( victimid, -1, ""COL_RED"[PULL OVER]{FFFFFF} You have been asked to pull over by %s(%d)!", ReturnPlayerName( playerid ), playerid );
	    SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[PULL OVER]{FFFFFF} You have asked %s(%d) to pull over!", ReturnPlayerName( victimid ), victimid );
	}
 	else return SendError( playerid, "There are no players around to ask to pull over!" );
	return 1;
}

CMD:loc( playerid, params[ ] ) return cmd_location( playerid, params );
CMD:locate( playerid, params[ ] ) return cmd_location( playerid, params );
CMD:location( playerid, params[ ] )
{
   	new
   	    pID
	;

	if ( p_Class[ playerid ] == CLASS_CIVILIAN ) return SendError( playerid, "This is not accessible by civilians." );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/loc(ation) [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "This player isn't connected!" );
	else if ( !IsPlayerSpawned( pID ) ) return SendError( playerid, "The player selected isn't spawned." );
	//else if ( GetPlayerInterior( playerid ) != GetPlayerInterior( pID ) ) return SendError( playerid, "This player is inside a interior, the location is not viewable." );
	else if ( p_AdminOnDuty{ pID } == true ) return SendError( playerid, "This is an admin on duty! You cannot track their proximity." );
	else
	{
	    new
			szLocation[ MAX_ZONE_NAME ], szCity[ MAX_ZONE_NAME ];

		if ( !GetPlayerLocation( pID, szCity, szLocation ) )
			return SendError( playerid, "This player has gone completely under the radar." );

		SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[LOCATION]"COL_WHITE" %s(%d) is located near %s in %s!", ReturnPlayerName( pID ), pID, szLocation, szCity );
	}
	return 1;
}

CMD:sh( playerid, params[ ] ) return cmd_search( playerid, params );
CMD:search( playerid, params[ ] )
{
	/* ** ANTI SPAM ** */
    if ( p_SearchedCountTick[ playerid ] > g_iTime ) return SendError( playerid, "You must wait 2 minutes before using this command again." );
    /* ** END OF ANTI SPAM ** */

   	new
   	    pID
	;
	if ( p_Class[ playerid ] != CLASS_POLICE ) return SendError( playerid, "This is restricted to police only." );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/search [PLAYER_ID]" );
	else if ( GetDistanceBetweenPlayers( playerid, pID ) > 10.0 || !IsPlayerConnected( pID ) ) return SendError( playerid, "This player is not around." );
	else if ( p_Class[ pID ] == CLASS_POLICE ) return SendError( playerid, "This player is in your team!" );
	else if ( !IsPlayerCuffed( pID ) ) return SendError( playerid, "This player must be cuffed." );
	else if ( IsPlayerJailed( pID ) ) return SendError( playerid, "You cannot " );
	else
	{
	    new
	    	wantedlvl = p_WeedGrams[ pID ] * 6;

		p_SearchedCountTick[ playerid ] = g_iTime + 120;

		if ( wantedlvl <= 0 )
		{
			SendClientMessageFormatted( pID, -1, ""COL_RED"[SEARCHED]{FFFFFF} You have been searched by %s(%d), luckily no drugs were found!", ReturnPlayerName( playerid ), playerid );
		    SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[SEARCHED]{FFFFFF} You have searched %s(%d) and found no drugs!", ReturnPlayerName( pID ), pID, p_WeedGrams[ pID ] );
	    	return 1;
		}

		SendClientMessageFormatted( pID, -1, ""COL_RED"[SEARCHED]{FFFFFF} You have searched by %s(%d) and have had your drugs removed!", ReturnPlayerName( playerid ), playerid );
	    SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[SEARCHED]{FFFFFF} You have searched %s(%d) and found %d gram(s) of "COL_GREEN"weed{FFFFFF}!", ReturnPlayerName( pID ), pID, p_WeedGrams[ pID ] );

	  	p_WeedGrams[ pID ] = 0;
		GivePlayerWantedLevel( pID, wantedlvl );
	}
	return 1;
}

CMD:tk( playerid, params[ ] ) return cmd_ticket( playerid, params );
CMD:ticket( playerid, params[ ] )
{
   	new
   		pID = GetClosestPlayer( playerid );

	TicketPlayer( pID, playerid );
	SendServerMessage( playerid, "You can use your middle mouse button to easily ticket individuals that are near to you." );
	return 1;
}

stock TicketPlayer( pID, playerid )
{
	if ( p_Class[ playerid ] != CLASS_POLICE ) return SendError( playerid, "This is restricted to police only." );
	else if ( GetDistanceBetweenPlayers( playerid, pID ) > 10.0 || !IsPlayerConnected( pID ) ) return SendError( playerid, "There are no players around to ticket." );
	else if ( p_TicketIssuer[ pID ] == playerid ) return SendError( playerid, "You've already gave a ticket to this player." );
	else if ( p_Class[ pID ] == CLASS_POLICE ) return SendError( playerid, "This player is in your team!" );
	else if ( p_WantedLevel[ pID ] > 5 ) return SendError( playerid, "Wanted suspects cannot be issued a ticket." );
	else if ( p_WantedLevel[ pID ] < 1 ) return SendError( playerid, "Innocent players cannot be issued a ticket." );
	else if ( p_Jailed{ playerid } ) return SendError( playerid, "You cannot use this command in jail." );
	else if ( IsPlayerDetained( pID ) ) return SendError( playerid, "You cannot use this command on a detained player." );
	else if ( g_iTime < p_TicketTimestamp[ pID ] ) return SendError( playerid, "This player has been ticketed recently, he will be fined in %d seconds.", g_iTime - p_TicketTimestamp[ pID ] );
	else
	{
		if ( p_AdminOnDuty{ pID } == true ) return SendError( playerid, "This is an admin on duty!" );
		if ( IsPlayerJailed( pID ) ) return SendError( playerid, "This player is jailed. He may be paused." );
		if ( IsPlayerTied( pID ) ) return SendError( playerid, "This player is tied, you cannot ticket him unless he is untied." );
		if ( GetPlayerState( pID ) == PLAYER_STATE_WASTED ) return SendError( playerid, "You cannot ticket wasted players." );

	    p_TicketTimestamp[ pID ] = g_iTime + 15;
	    p_TicketIssuer[ pID ] = playerid;

		GameTextForPlayer( pID, "~n~~r~Ticketed!~n~~w~/payticket", 2000, 4 );
		SendClientMessageFormatted( pID, -1, ""COL_RED"[TICKET]{FFFFFF} You have been issued a "COL_GOLD"$2,000{FFFFFF} ticket by %s(%d) for your recent criminal activity!", ReturnPlayerName( playerid ), playerid );
		SendClientMessageFormatted( pID, -1, ""COL_RED"[TICKET]{FFFFFF} You have 15 seconds to "COL_GREY"/payticket"COL_WHITE" before you are wanted for resisting law enforcement." );
		SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[TICKET]{FFFFFF} You issued a ticket of "COL_GOLD"$2,000{FFFFFF} to %s(%d)!", ReturnPlayerName( pID ), pID );
	}
	return 1;
}

CMD:payticket( playerid, params[] )
{
	if ( !p_WantedLevel[ playerid ] )
		return SendError( playerid, "There's no point paying off a ticket when you don't have a wanted level." );

	if ( p_WantedLevel[ playerid ] > 5 )
		return SendError( playerid, "Your wanted level is excessive to pay a ticket." );

	if ( !p_TicketTimestamp[ playerid ] )
		return SendError( playerid, "You have not been ticketed!" );

	if ( GetPlayerCash( playerid ) < 2000 )
		return SendError( playerid, "You don't have money to pay for your ticket." );

	new
		copid = p_TicketIssuer[ playerid ];

	// remove ticket
	p_TicketTimestamp[ playerid ] = 0;
	p_TicketIssuer[ playerid ] = INVALID_PLAYER_ID;

	// remove wanted level
	GivePlayerCash( playerid, -2000 );
	GivePlayerWantedLevel( playerid, -6 );
	SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[TICKET]{FFFFFF} You have paid "COL_GOLD"$2,000{FFFFFF} dollars into paying your ticket." );

	// pay cop
	if ( IsPlayerConnected( copid ) ) {
		GivePlayerScore( copid, 2 );
		GivePlayerCash( copid, 1500 );
		GameTextForPlayer( copid, "~n~~g~~h~Ticket paid!", 2000, 4 );
		SendClientMessageFormatted( copid, -1, ""COL_GREEN"[TICKET]{FFFFFF} %s(%d) has paid his ticket issues, you have earned "COL_GOLD"$1,500{FFFFFF}!", ReturnPlayerName( playerid ), playerid );
	}
	return 1;
}

CMD:ar( playerid, params[ ] ) return cmd_arrest(playerid, params);
CMD:arrest( playerid, params[ ] )
{
   	new victimid; // = GetClosestPlayer( playerid );
   	if ( p_Class[ playerid ] != CLASS_POLICE ) return SendError( playerid, "This is restricted to police only." );
	else if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this command since you're jailed." );
	//else if ( GetPlayerScore( playerid ) > 200 ) return SendError( playerid, "This feature is no longer available to you. Please use /detain." );
	else if ( sscanf( params, ""#sscanf_u"", victimid ) ) return SendUsage( playerid, "/ar(rest) [PLAYER_ID]" );
	else if ( victimid == playerid ) return SendError( playerid, "You cannot arrest yourself." );
	else if ( !IsPlayerConnected( victimid ) ) return SendError( playerid, "This player is not connected." );
	else if ( p_Spectating{ playerid } ) return SendError( playerid, "You cannot use such commands while you're spectating." );
 	else if ( GetDistanceBetweenPlayers( playerid, victimid ) < 4.0 && IsPlayerConnected( victimid ) )
 	{
 	    if ( p_Class[ victimid ] == p_Class[ playerid ] ) return SendError( playerid, "This player is in your team." );
		if ( p_WantedLevel[ victimid ] == 0 ) return SendError( playerid, "This player is innocent!" );
		if ( !IsPlayerCuffed( victimid ) ) return SendError( playerid, "This player is not cuffed." );
		if ( IsPlayerKidnapped( playerid ) ) return SendError( playerid, "You are kidnapped, you cannot do this." );
		if ( IsPlayerDetained( victimid ) ) return SendError( playerid, "This player is detained, you cannot arrest them." );
		if ( IsPlayerTied( playerid ) ) return SendError( playerid, "You are tied, you cannot do this." );
		if ( IsPlayerJailed( victimid ) ) return SendError( playerid, "This player is jailed. He may be paused." );
		if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You cannot arrest this person inside a vehicle." );
		if ( IsPlayerInAnyVehicle( victimid ) ) return SendError( playerid, "You cannot arrest a person that is inside a vehicle." );
		if ( IsPlayerAdminOnDuty( victimid ) ) return SendError( playerid, "You cannot use this command on admins that are on duty." );
		if ( GetPlayerState( playerid ) == PLAYER_STATE_WASTED ) return SendError( playerid, "You cannot use this command since you are dead." );
		new totalCash = ( p_WantedLevel[ victimid ] < MAX_WANTED_LVL ? p_WantedLevel[ victimid ] : MAX_WANTED_LVL ) * ( 300 );
		new totalSeconds = p_WantedLevel[ victimid ] * ( JAIL_SECONDS_MULTIPLIER );
		GivePlayerScore( playerid, 2, .multiplier = 1.5 );
		GivePlayerCash( playerid, totalCash );
		if ( totalCash > 20000 ) printf("[police arrest] %s -> %s - %s", ReturnPlayerName( playerid ), ReturnPlayerName( victimid ), ConvertPrice( totalCash ) ); // 8hska7082bmahu
		SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[ACHIEVE]{FFFFFF} You have earned "COL_GOLD"%s{FFFFFF} dollars and 2 score for arresting %s(%d)!", ConvertPrice( totalCash ), ReturnPlayerName( victimid ), victimid );
		GameTextForPlayer( victimid, "~r~Busted!", 4000, 0 );
		CallLocalFunction( "OnPlayerArrest", "dddd", playerid, victimid, p_Arrests[ playerid ], 1 );
		Untaze( victimid );
		GivePlayerIrresistiblePoints( victimid, -2 );
		SendGlobalMessage( -1, ""COL_GOLD"[JAIL]{FFFFFF} %s(%d) has sent %s(%d) to jail for %d seconds!", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( victimid ), victimid, totalSeconds );
		JailPlayer( victimid, totalSeconds );
 	}
 	else return SendError( playerid, "There are no players around to arrest." );
	return 1;
}

CMD:getwanted( playerid, params[ ] )
{
	new pID;
	if ( p_Class[ playerid ] != CLASS_POLICE && !p_AdminLevel[ playerid ] ) return SendError( playerid, "This is restricted to police only." );
   	else if ( sscanf( params, #sscanf_u, pID ) ) return SendUsage( playerid, "/getwanted [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "This player is not connected." );
   	else
   	{
   		if ( p_WantedLevel[ pID ] )
   			SendServerMessage( playerid, "%s(%d)'s wanted level is %d. Be advised, suspect is armed and dangerous.", ReturnPlayerName( pID ), pID, p_WantedLevel[ pID ] );
   		else
   			SendServerMessage( playerid, "%s(%d) is an innocent civilian.", ReturnPlayerName( pID ), pID );
   	}
	return 1;
}

CMD:cuff( playerid, params[ ] )
{
   	new victimid; // = GetClosestPlayer( playerid );
   	if ( p_Class[ playerid ] != CLASS_POLICE ) return SendError( playerid, "This is restricted to police only." );
	else if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this command since you're jailed." );
	else if ( sscanf( params, ""#sscanf_u"", victimid ) ) return SendUsage( playerid, "/cuff [PLAYER_ID]" );
	else if ( victimid == playerid ) return SendError( playerid, "You cannot cuff yourself." );
	else if ( !IsPlayerConnected( victimid ) || IsPlayerNPC( victimid ) ) return SendError( playerid, "This player is not connected." );
	else if ( p_Spectating{ playerid } ) return SendError( playerid, "You cannot use such commands while you're spectating." );
 	else if ( GetDistanceBetweenPlayers( playerid, victimid ) < 4.0 && IsPlayerConnected( victimid ) )
 	{
 	    if ( p_Class[ victimid ] == p_Class[ playerid ] ) return SendError( playerid, "This player is in your team." );
		if ( p_WantedLevel[ victimid ] == 0 ) return SendError( playerid, "This player is innocent!" );
		if ( p_WantedLevel[ victimid ] < 6 ) return SendError( playerid, "This person isn't worth cuffing, ticket them." );
		if ( IsPlayerInAnyVehicle( victimid ) ) return SendError( playerid, "This player is in a vehicle " );
		if ( IsPlayerDetained( victimid ) ) return SendError( playerid, "This player is already detained." );
		if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You cannot do this while you're inside a vehicle." );
		if ( IsPlayerCuffed( victimid ) ) return SendError( playerid, "This player is already cuffed." );
		if ( IsPlayerJailed( victimid ) ) return SendError( playerid, "This player is jailed. He may be paused." );
		if ( !IsPlayerTazed( victimid ) ) return SendError( playerid, "You must taze this player before cuffing them." );
		if ( IsPlayerGettingBlowed( playerid ) ) return SendError( playerid, "You cannot use this command since you're getting blowed." );
		if ( IsPlayerBlowingCock( playerid ) ) return SendError( playerid, "You cannot use this command since you're giving oral sex." );
		if ( IsPlayerKidnapped( playerid ) ) return SendError( playerid, "You are kidnapped, you cannot do this." );
		if ( IsPlayerTied( playerid ) ) return SendError( playerid, "You are tied, you cannot do this." );
		if ( IsPlayerAdminOnDuty( victimid ) ) return SendError( playerid, "You cannot use this command on admins that are on duty." );
		if ( IsPlayerJailed( victimid ) ) return SendError( playerid, "This player is jailed. He may be paused." );
		if ( IsPlayerLoadingObjects( victimid ) ) return SendError( playerid, "This player is in a object-loading state." );
		if ( GetPlayerState( playerid ) == PLAYER_STATE_WASTED ) return SendError( playerid, "You cannot use this command since you are dead." );
		if ( !IsPlayerSpawned( victimid ) ) return SendError( playerid, "The player must be spawned." );
		GameTextForPlayer( victimid, "~n~~r~CUFFED!", 2000, 4 );
		GameTextForPlayer( playerid, sprintf( "~n~~y~~h~/arrest %d", victimid ), 2000, 4 );
		SendClientMessageFormatted( victimid, -1, ""COL_RED"[CUFFED]{FFFFFF} You have been cuffed by %s(%d)!", ReturnPlayerName( playerid ), playerid );
	    SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[CUFFED]{FFFFFF} You have cuffed %s(%d)!", ReturnPlayerName( victimid ), victimid );
		KillTimer( p_CuffAbuseTimer[ victimid ] );
   		p_CuffAbuseTimer[ victimid ] = SetTimerEx( "Uncuff", ( 60 * 1000 ), false, "d", victimid );
		//ApplyAnimation( victimid, "ped", "cower", 5.0, 1, 1, 1, 0, 0 );
		//TogglePlayerControllable( victimid, 0 );
		p_Cuffed{ victimid } = true;
		SetPlayerAttachedObject( victimid, 2, 19418, 6, -0.011000, 0.028000, -0.022000, -15.600012, -33.699977, -81.700035, 0.891999, 1.000000, 1.168000 );
      	SetPlayerSpecialAction( victimid, SPECIAL_ACTION_CUFFED );

		if ( p_BobbyPins[ victimid ] )
			ShowPlayerHelpDialog( victimid, 4000, "You can uncuff yourself with ~p~/breakcuff." );
		else
			ShowPlayerHelpDialog( victimid, 4000, "You can buy bobby pins at Supa Save or a 24/7 store to break cuffs." );
 	}
 	else return SendError( playerid, "There are no players around to cuff." );
	return 1;
}

CMD:uncuff( playerid, params[ ] )
{
   	new victimid = GetClosestPlayer( playerid );
   	//if ( p_Class[ playerid ] != CLASS_POLICE ) return SendError( playerid, "This is restricted to police only." );
   	if ( p_Spectating{ playerid } ) return SendError( playerid, "You cannot use such commands while you're spectating." );
 	else if ( GetDistanceBetweenPlayers( playerid, victimid ) < 4.0 && IsPlayerConnected( victimid ) )
 	{
 	    //if ( p_Class[ victimid ] == p_Class[ playerid ] ) return SendError( playerid, "This player you're close to is in your team." );
		if ( p_WantedLevel[ victimid ] == 0 ) return SendError( playerid, "This player is innocent!" );
		if ( !IsPlayerCuffed( victimid ) ) return SendError( playerid, "This player is not cuffed." );
		if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You cannot do this while you're inside a vehicle." );
		if ( IsPlayerLoadingObjects( victimid ) ) return SendError( playerid, "This player is in a object-loading state." );
		if ( IsPlayerTied( playerid ) ) return SendError( playerid, "You cannot use this command since you're tied." );
		if ( IsPlayerTazed( playerid ) ) return SendError( playerid, "You cannot use this command since you're tazed." );
		if ( IsPlayerCuffed( playerid ) ) return SendError( playerid, "You cannot use this command since you're cuffed." );
		if ( IsPlayerKidnapped( playerid ) ) return SendError( playerid, "You cannot use this command since you're kidnapped." );
		if ( IsPlayerDetained( playerid ) ) return SendError( playerid, "You cannot use this command since you're detained." );
		SendClientMessageFormatted( victimid, -1, ""COL_RED"[UNCUFFED]{FFFFFF} You have been uncuffed by %s(%d)!", ReturnPlayerName( playerid ), playerid );
	    SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[UNCUFFED]{FFFFFF} You have uncuffed %s(%d)!", ReturnPlayerName( victimid ), victimid );
        ClearAnimations( victimid );
		TogglePlayerControllable( victimid, 1 );
		p_Cuffed{ victimid } = false;
		p_Detained{ victimid } = false;
		Delete3DTextLabel( p_DetainedLabel[ victimid ] );
		p_DetainedLabel[ victimid ] = Text3D: INVALID_3DTEXT_ID;
		p_DetainedBy[ victimid ] = INVALID_PLAYER_ID;
		KillTimer( p_CuffAbuseTimer[ victimid ] );
        SetPlayerSpecialAction( victimid, SPECIAL_ACTION_NONE );
        RemovePlayerAttachedObject( victimid, 2 );
 	}
 	else return SendError( playerid, "There are no players around to uncuff." );
	return 1;
}

CMD:detain( playerid, params[ ] )
{
   	new victimid = GetClosestPlayer( playerid );
  	if ( p_Class[ playerid ] != CLASS_POLICE ) return SendError( playerid, "This is restricted to police only." );
	else if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this command since you're jailed." );
   	else if ( p_Spectating{ playerid } ) return SendError( playerid, "You cannot use such commands while you're spectating." );
 	else if ( GetDistanceBetweenPlayers( playerid, victimid ) < 4.0 && IsPlayerConnected( victimid ) )
 	{
	    if ( p_Class[ victimid ] == p_Class[ playerid ] ) return SendError( playerid, "This player you're close to is in your team." );
		if ( p_WantedLevel[ victimid ] == 0 ) return SendError( playerid, "This player is innocent!" );
		if ( IsPlayerInAnyVehicle( victimid ) ) return SendError( playerid, "This player is in a vehicle " );
		if ( IsPlayerDetained( victimid ) ) return SendError( playerid, "This player is already detained." );
		if ( !IsPlayerCuffed( victimid ) ) return SendError( playerid, "This player is not cuffed." );
		if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You cannot do this while you're inside a vehicle." );
		if ( IsPlayerLoadingObjects( victimid ) ) return SendError( playerid, "This player is in a object-loading state." );
		if ( !IsValidVehicle( p_LastVehicle[ playerid ] ) ) return SendError( playerid, "Your last vehicle is either destroyed or not spawned." );
		if ( PutPlayerInEmptyVehicleSeat( p_LastVehicle[ playerid ], victimid ) == -1 ) return SendError( playerid, "Failed to place the player inside a full of player vehicle." );
		if ( GetPlayerState( playerid ) == PLAYER_STATE_WASTED ) return SendError( playerid, "You cannot use this command since you are dead." );
		SendClientMessageFormatted( victimid, -1, ""COL_RED"[DETAIN]{FFFFFF} You have been detained by %s(%d)!", ReturnPlayerName( playerid ), playerid );
	    SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[DETAIN]{FFFFFF} You have detained %s(%d), he's been put in your last vehicle!", ReturnPlayerName( victimid ), victimid );
		KillTimer( p_CuffAbuseTimer[ victimid ] );
		p_CuffAbuseTimer[ victimid ] = SetTimerEx( "Uncuff", ( 300 * 1000 ), false, "d", victimid );
		p_Detained{ victimid } = true;
		p_Tazed{ victimid } = false;
		p_DetainedBy[ victimid ] = playerid;
		p_TiedAtTimestamp[ victimid ] = g_iTime;
	    Delete3DTextLabel( p_DetainedLabel[ victimid ] );
	    p_DetainedLabel[ victimid ] = Create3DTextLabel( "Detained Criminal", COLOR_BLUE, 0.0, 0.0, 0.0, 15.0, 0 );
	    Attach3DTextLabelToPlayer( p_DetainedLabel[ victimid ], victimid, 0.0, 0.0, 0.6 );
		TogglePlayerControllable( victimid, 0 );
 	}
 	else return SendError( playerid, "There are no players around to detain." );
	return 1;
}

CMD:taze( playerid, params[ ] )
{
	/* ** ANTI TAZE SPAM ** */
    if ( p_AntiTazeSpam[ playerid ] > g_iTime ) return SendError( playerid, "You must wait %d seconds before tazing someone again.", p_AntiTazeSpam[ playerid ] - g_iTime );
    /* ** END OF ANTI SPAM ** */

   	new victimid; // = GetClosestPlayer( playerid );
   	if ( p_Class[ playerid ] != CLASS_POLICE ) return SendError( playerid, "This is restricted to police only." );
	else if ( sscanf( params, ""#sscanf_u"", victimid ) ) return SendUsage( playerid, "/taze [PLAYER_ID]" );
	else if ( victimid == playerid ) return SendError( playerid, "You cannot taze yourself." );
	else if ( !IsPlayerConnected( victimid ) ) return SendError( playerid, "There are no players around to taze." );
	else if ( p_Spectating{ playerid } ) return SendError( playerid, "You cannot use such commands while you're spectating." );
 	else if ( GetDistanceBetweenPlayers( playerid, victimid ) < 5.0 && IsPlayerConnected( victimid ) )
 	{
 	    if ( p_Class[ victimid ] == p_Class[ playerid ] ) return SendError( playerid, "This player is in your team." );
		if ( p_WantedLevel[ victimid ] == 0 ) return SendError( playerid, "This player is innocent!" );
		if ( IsPlayerInAnyVehicle( victimid ) ) return SendError( playerid, "This player is in a vehicle " );
		if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You cannot do this while you're inside a vehicle." );
		if ( IsPlayerTazed( victimid ) ) return SendError( playerid, "This player is already tazed." );
		//if ( IsPlayerCuffed( victimid ) ) return SendError( playerid, "This player is already cuffed." );
		if ( IsPlayerDetained( victimid ) ) return SendError( playerid, "This player is already detained." );
		if ( IsPlayerGettingBlowed( playerid ) ) return SendError( playerid, "You cannot use this command since you're getting blowed." );
		if ( IsPlayerBlowingCock( playerid ) ) return SendError( playerid, "You cannot use this command since you're giving oral sex." );
		if ( IsPlayerKidnapped( playerid ) ) return SendError( playerid, "You are kidnapped, you cannot do this." );
		if ( IsPlayerTied( playerid ) ) return SendError( playerid, "You are tied, you cannot do this." );
		if ( IsPlayerAdminOnDuty( victimid ) ) return SendError( playerid, "You cannot use this command on admins that are on duty." );
		if ( IsPlayerJailed( victimid ) ) return SendError( playerid, "This player is jailed. He may be paused." );
		if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this command while in jail." );
		if ( IsPlayerTied( victimid ) ) return SendError( playerid, "Tazing a tied player is pretty useless, though you can use /untie for a harder job!" );
		if ( IsPlayerLoadingObjects( victimid ) ) return SendError( playerid, "This player is in a object-loading state." );
		if ( IsPlayerInEvent( playerid ) ) return SendError( playerid, "You cannot use this command since you're in an event." );
		if ( GetPlayerState( playerid ) == PLAYER_STATE_WASTED ) return SendError( playerid, "You cannot use this command since you are dead." );
		if ( random( 101 ) < 90 )
		{
			GameTextForPlayer( victimid, "~n~~r~TAZED!", 2000, 4 );
			GameTextForPlayer( playerid, sprintf( "~n~~y~~h~/cuff %d", victimid ), 2000, 4 );
			SendClientMessageFormatted( victimid, -1, ""COL_RED"[TAZED]{FFFFFF} You have been tazed by %s(%d) for 3 seconds!", ReturnPlayerName( playerid ), playerid );
		    SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[TAZED]{FFFFFF} You have tazed %s(%d) for 3 seconds!", ReturnPlayerName( victimid ), victimid );
	        SetTimerEx( "Untaze", 3000, false, "d", victimid );
			TogglePlayerControllable( victimid, 0 );
			ApplyAnimation( victimid, "CRACK", "crckdeth2", 5.0, 1, 1, 1, 0, 0 );
			p_Tazed{ victimid } = true;
		}
		else
		{
			SendClientMessageFormatted( playerid, -1, ""COL_RED"[TAZE FAIL]{FFFFFF} You have failed to taze %s(%d)!", ReturnPlayerName( victimid ), victimid );
		  	SendClientMessageFormatted( victimid, -1, ""COL_GREEN"[TAZE FAIL]{FFFFFF} %s(%d) has failed to taze you!", ReturnPlayerName( playerid ), playerid );
		}
		p_AntiTazeSpam[ playerid ] = g_iTime + 6;
 	} else {
		return SendError( playerid, "There are no players around to taze." );
	}
 	return 1;
}

CMD:rob( playerid, params[ ] )
{
	/* ** ANTI ROB SPAM ** */
    if ( ( GetTickCount( ) - p_AntiRobSpam[ playerid ] ) < 90000 ) return SendError( playerid, "You're too tired from the last time you've robbed someone..." );
    /* ** END OF ANTI SPAM ** */

  	new victimid = GetClosestPlayer( playerid );
   	if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "This is restricted to civilians only." );
   	else if ( p_Spectating{ playerid } ) return SendError( playerid, "You cannot use such commands while you're spectating." );
	//else if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "It's impossible to rob someone inside a car." );
	else if ( GetDistanceBetweenPlayers( playerid, victimid ) < 4.0 && IsPlayerConnected( victimid ) )
	{

  		//if ( IsPlayerInAnyVehicle( victimid ) && !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "This player is in a vehicle and you're not." );
		//if ( IsPlayerInAnyVehicle( playerid ) && !IsPlayerInAnyVehicle( victimid ) ) return SendError( playerid, "You cannot rob someone while you're a vehicle and they're not." );
		//if ( IsPlayerInAnyVehicle( playerid ) && IsPlayerInAnyVehicle( victimid ) && !IsPlayerKidnapped( victimid ) ) return SendError( playerid, "The person in your vehicle must be kidnapped to rob them." );
  		if ( IsPlayerInAnyVehicle( victimid ) ) return SendError( playerid, "This player is in a vehicle." );
		if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You cannot use this command inside a vehicle." );
		if ( GetPlayerCash( victimid ) < 10 ) return SendError( playerid, "This player cannot be robbed since he has a low amount of money." );
		if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this command since you're jailed." );
		if ( IsPlayerTazed( playerid ) ) return SendError( playerid, "You cannot use this command since you're tazed." );
		if ( IsPlayerDetained( playerid ) ) return SendError( playerid, "You cannot use this command since you're detained." );
		if ( IsPlayerCuffed( playerid ) ) return SendError( playerid, "You cannot use this command since you're cuffed." );
		if ( IsPlayerTied( playerid ) ) return SendError( playerid, "You cannot use this command since you're tied." );
		if ( IsPlayerKidnapped( playerid ) ) return SendError( playerid, "You cannot use this command since you're kidnapped." );
		if ( IsPlayerInPaintBall( playerid ) ) return SendError( playerid, "You cannot use this command since you're inside the paintball arena." );
		if ( IsPlayerGettingBlowed( playerid ) ) return SendError( playerid, "You cannot use this command since you're getting blowed." );
		if ( IsPlayerBlowingCock( playerid ) ) return SendError( playerid, "You cannot use this command since you're giving oral sex." );
		if ( IsPlayerAdminOnDuty( victimid ) ) return SendError( playerid, "You cannot use this command on admins that are on duty." );
		if ( IsPlayerJailed( victimid ) ) return SendError( playerid, "This player is jailed. He may be paused." );
		if ( IsPlayerInCasino( victimid ) && ! p_WantedLevel[ victimid ] ) return SendError( playerid, "The innocent person you're trying to rob is in a casino." );
		if ( p_ClassSelection{ victimid } ) return SendError( playerid, "This player is currently in class selection." );
		if ( IsPlayerInEvent( playerid ) ) return SendError( playerid, "You cannot use this command since you're in an event." );
		if ( IsPlayerInPlayerGang( playerid, victimid ) ) return SendError( playerid, "You cannot use this command on your homies!" );
		new iRandom = random( 101 );
		if ( p_SecureWallet{ victimid } == true ) iRandom -= 90;
		if ( iRandom < 75 || IsPlayerTied( victimid ) || IsPlayerKidnapped( victimid ) )
		{
		    new
				iMoney,
				cashRobbed,
		    	iLimit = 2500
			;

			if ( IsPlayerKidnapped( victimid ) )
				iLimit += 3500;

			iMoney = GetPlayerCash( victimid ) > iLimit ? iLimit : GetPlayerCash( victimid );

			cashRobbed = random( iMoney ) + 10;

			SendClientMessageFormatted( victimid, -1, ""COL_RED"[ROBBED]{FFFFFF} You have been robbed "COL_GOLD"%s{FFFFFF} by %s(%d)!", ConvertPrice( cashRobbed ), ReturnPlayerName( playerid ), playerid );
		    SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[ROBBED]{FFFFFF} You have robbed "COL_GOLD"%s{FFFFFF} off %s(%d)!", ConvertPrice( cashRobbed ), ReturnPlayerName( victimid ), victimid );

			SplitPlayerCashForGang( playerid, float( cashRobbed ) );
			GivePlayerWantedLevel( playerid, 4 );
			GivePlayerCash( victimid, -( cashRobbed ) );
			GivePlayerScore( playerid, 1 );
		}
		else
		{
			SendClientMessageFormatted( playerid, -1, ""COL_RED"[ROB FAIL]{FFFFFF} You have failed to rob %s(%d)!", ReturnPlayerName( victimid ), victimid );
		  	SendClientMessageFormatted( victimid, -1, ""COL_GREEN"[ROB FAIL]{FFFFFF} %s(%d) has failed to rob you!", ReturnPlayerName( playerid ), playerid );
			GivePlayerWantedLevel( playerid, 6 );
		}
		p_AntiRobSpam[ playerid ] = GetTickCount( );
 	}
 	else return SendError( playerid, "There are no players around to rob." );
	return 1;
}

CMD:rape( playerid, params[ ] )
{
	/* ** ANTI ROB SPAM ** */
    if ( p_AntiRapeSpam[ playerid ] > g_iTime ) return SendError( playerid, "Your cock hurts from the last time you raped somebody..." );
    /* ** END OF ANTI SPAM ** */

  	new victimid = GetClosestPlayer( playerid ), Float: Health;
   	if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "This is restricted to civilians only." );
   	else if ( p_Spectating{ playerid } ) return SendError( playerid, "You cannot use such commands while you're spectating." );
	//else if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "It's impossible to rape someone inside a car." );
	else if ( GetDistanceBetweenPlayers( playerid, victimid ) < 4.0 && IsPlayerConnected( victimid ) )
	{
  		//if ( IsPlayerInAnyVehicle( victimid ) && !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "This player is in a vehicle and you're not." );
		//if ( IsPlayerInAnyVehicle( playerid ) && !IsPlayerInAnyVehicle( victimid ) ) return SendError( playerid, "You cannot rape someone while you're a vehicle and they're not." );
		//if ( IsPlayerInAnyVehicle( playerid ) && IsPlayerInAnyVehicle( victimid ) && !IsPlayerKidnapped( victimid ) ) return SendError( playerid, "The person in your vehicle must be kidnapped to rape them." );
  		if ( IsPlayerInAnyVehicle( victimid ) ) return SendError( playerid, "This player is in a vehicle." );
		if ( IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You cannot use this command inside a vehicle." );
		if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this command since you're jailed." );
		if ( IsPlayerTazed( playerid ) ) return SendError( playerid, "You cannot use this command since you're tazed." );
		if ( IsPlayerDetained( playerid ) ) return SendError( playerid, "You cannot use this command since you're detained." );
		if ( IsPlayerCuffed( playerid ) ) return SendError( playerid, "You cannot use this command since you're cuffed." );
		if ( IsPlayerTied( playerid ) ) return SendError( playerid, "You cannot use this command since you're tied." );
		if ( IsPlayerKidnapped( playerid ) ) return SendError( playerid, "You cannot use this command since you're kidnapped." );
		if ( IsPlayerInPaintBall( playerid ) ) return SendError( playerid, "You cannot use this command since you're inside the paintball arena." );
		if ( p_Jailed{ playerid } == true ) return SendError( playerid, "You cannot rape in jail." );
		if ( IsPlayerGettingBlowed( playerid ) ) return SendError( playerid, "You cannot use this command since you're getting blowed." );
		if ( IsPlayerBlowingCock( playerid ) ) return SendError( playerid, "You cannot use this command since you're giving oral sex." );
		if ( IsPlayerAdminOnDuty( victimid ) ) return SendError( playerid, "You cannot use this command on admins that are on duty." );
		if ( IsPlayerJailed( victimid ) ) return SendError( playerid, "This player is jailed. He may be paused." );
		if ( IsPlayerInCasino( victimid ) && ! p_WantedLevel[ victimid ] ) return SendError( playerid, "The innocent person you're trying to rape is in a casino." );
		if ( IsPlayerLoadingObjects( victimid ) ) return SendError( playerid, "This player is in a object-loading state." );
		if ( p_AntiSpawnKillEnabled{ victimid } ) return SendError( playerid, "This player is in a anti-spawn-kill state." );
		if ( p_ClassSelection{ victimid } ) return SendError( playerid, "This player is currently in class selection." );
		if ( IsPlayerInEvent( playerid ) ) return SendError( playerid, "You cannot use this command since you're in an event." );
		if ( IsPlayerAFK( victimid ) && GetPlayerState( playerid ) != PLAYER_STATE_WASTED ) return SendError( playerid, "This player is in an AFK state." );
		if ( IsPlayerInPlayerGang( playerid, victimid ) ) return SendError( playerid, "You cannot use this command on your homies!" );

  		new iRandom = random( 101 );
        if ( JobEquals( playerid, JOB_RAPIST ) ) { iRandom += 10; } // Adds more success to rapists.
  		if ( iRandom < 75 || IsPlayerTied( victimid ) )
  		{
			if ( JobEquals( playerid, JOB_RAPIST ) && p_AidsVaccine{ victimid } == false && !JobEquals( victimid, JOB_PROSTITUTE ) )
			{
				infect_cunt:
				{
				    SendClientMessageFormatted( victimid, -1, ""COL_RED"[RAPED]{FFFFFF} You have been raped and infected with "COL_RED"HIV{FFFFFF} by %s(%d)!", ReturnPlayerName( playerid ), playerid );
			    	SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[RAPED]{FFFFFF} You have raped %s(%d) and infected them with "COL_RED"HIV{FFFFFF}!", ReturnPlayerName( victimid ), victimid );
				    GivePlayerScore( playerid, 2 );
				    GivePlayerWantedLevel( playerid, 5 );
				    GetPlayerHealth( victimid, Health );
				  	SetPlayerHealth( victimid,  ( Health - 25.0 ) );

				    p_InfectedHIV{ victimid } = true;
					SetTimerEx( "RapeDamage", 5000, false, "d", victimid );
				}
			}
			else
			{
				if ( p_InfectedHIV{ playerid } ) goto infect_cunt;

			    SendClientMessageFormatted( victimid, -1, ""COL_RED"[RAPED]{FFFFFF} You have been raped by %s(%d)!", ReturnPlayerName( playerid ), playerid );
		    	SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[RAPED]{FFFFFF} You have raped %s(%d)!", ReturnPlayerName( victimid ), victimid );
			    GivePlayerScore( playerid, 1 );
			    GivePlayerWantedLevel( playerid, 4 );
			    GetPlayerHealth( victimid, Health );
			  	SetPlayerHealth( victimid,  ( Health - 25.0 ) );
			}
		}
		else
		{
			SendClientMessageFormatted( playerid, -1, ""COL_RED"[RAPE FAIL]{FFFFFF} You have failed to rape %s(%d)!", ReturnPlayerName( victimid ), victimid );
		  	SendClientMessageFormatted( victimid, -1, ""COL_GREEN"[RAPE FAIL]{FFFFFF} %s(%d) has failed to rape you!", ReturnPlayerName( playerid ), playerid );
	    	GivePlayerWantedLevel( playerid, 6 );
		}
		p_AntiRapeSpam[ playerid ] = g_iTime + 60;
 	}
 	else return SendError( playerid, "There are no players around to rape." );
	return 1;
}

CMD:c4( playerid, params[ ] )
{
	if ( IsPlayerInEvent( playerid ) ) return SendError( playerid, "You cannot use this command since you're in an event." );

	if ( !strcmp( params, "plant", true, 5 ) )
	{
		new
		    ID = -1
		;

		if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this command since you're jailed." );
		if ( p_Spectating{ playerid } ) return SendError( playerid, "You cannot use such commands while you're spectating." );
		if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "This is restricted to civilians only." );
		if ( !JobEquals( playerid, JOB_TERRORIST ) ) return SendError( playerid, "This is restricted to terrorists." );
		if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this command since you're jailed." );
		if ( IsPlayerTazed( playerid ) ) return SendError( playerid, "You cannot use this command since you're tazed." );
		if ( IsPlayerDetained( playerid ) ) return SendError( playerid, "You cannot use this command since you're detained." );
		if ( IsPlayerCuffed( playerid ) ) return SendError( playerid, "You cannot use this command since you're cuffed." );
		if ( IsPlayerTied( playerid ) ) return SendError( playerid, "You cannot use this command since you're tied." );
		if ( IsPlayerKidnapped( playerid ) ) return SendError( playerid, "You cannot use this command since you're kidnapped." );
		if ( IsPlayerInPaintBall( playerid ) ) return SendError( playerid, "You cannot use this command since you're in paintball." );
		if ( p_C4Amount[ playerid ] < 1 ) return SendError( playerid, "You don't have any C4's" );

		#if ENABLED_SECURE_TRUCK == true
			if ( IsPlayerInVehicle( playerid, g_secureTruckVehicle ) ) return SendError( playerid, "You cannot be in this vehicle while planting C4." );
		#endif

		for( new i; i < MAX_C4; i++ ) {
		    if ( !g_C4Data[ playerid ] [ i ] [ E_SET ] ) {
		        ID = i;
		        break;
			}
		}

		if ( ID != -1 )
		{
			new
		        Float: distance = 99999.99,
				robberyid = getClosestRobberySafe( playerid, distance )
			;

			if ( robberyid != INVALID_OBJECT_ID && distance < 1.50 && !g_robberyData[ robberyid ] [ E_STATE ] && AttachToRobberySafe( robberyid, playerid, ROBBERY_TYPE_C4 ) )
			{
				SendServerMessage( playerid, "You have planted a C4 on this "COL_ORANGE"safe"COL_WHITE", detonation is automatic." );

				if ( g_Debugging )
				{
					printf("[DEBUG] [ROBBERY] [%d] Planted C4 { open : %d, robbed : %d, c4: %d, drill : %d, dplacer : %d, deffect : %d, replenish : %d, raw ts : %d, current ts : %d, name : %s, velocity : %f, state : %d }",
								robberyid,
								g_robberyData[ robberyid ] [ E_OPEN ], g_robberyData[ robberyid ] [ E_ROBBED ], g_robberyData[ robberyid ] [ E_C4 ],
								g_robberyData[ robberyid ] [ E_DRILL ], g_robberyData[ robberyid ] [ E_DRILL_PLACER ], g_robberyData[ robberyid ] [ E_DRILL_EFFECT ], g_robberyData[ robberyid ] [ E_ROB_TIME ] - g_iTime,
								g_robberyData[ robberyid ] [ E_ROB_TIME ], g_iTime, g_robberyData[ robberyid ] [ E_NAME ], g_robberyData[ robberyid ] [ E_VELOCITY ], g_robberyData[ robberyid ] [ E_STATE ] );
				}
			}
			else
			{
				new
				    Float: X, Float: Y, Float: Z,
					iVehicle = GetPlayerVehicleID( playerid )
				;

				GetPlayerPos( playerid, X, Y, Z );

				format( szNormalString, 64, "C4 %d\nPlanted By %s!", ID, ReturnPlayerName( playerid ) );
				g_C4Data[ playerid ] [ ID ] [ E_LABEL ] = Create3DTextLabel( szNormalString, setAlpha( COLOR_GREY, 0x50 ), X, Y, Z - 1.0, 15.0, GetPlayerVirtualWorld( playerid ) );
				g_C4Data[ playerid ] [ ID ] [ E_OBJECT ] = CreateDynamicObject( 19602, X, Y, Z - 0.92, 0, 0, 0, GetPlayerVirtualWorld( playerid ), GetPlayerInterior( playerid ), -1, 50.0 ); // 363 prev, Rx -90.0
				g_C4Data[ playerid ] [ ID ] [ E_WORLD ] = GetPlayerVirtualWorld( playerid );
				g_C4Data[ playerid ] [ ID ] [ E_INTERIOR ] = GetPlayerInterior( playerid );
				g_C4Data[ playerid ] [ ID ] [ E_SET ] = true;

				if ( !iVehicle )
					iVehicle = GetPlayerSurfingVehicleID( playerid );

				if ( IsValidVehicle( iVehicle ) && iVehicle != g_secureTruckVehicle )
				{
					GetVehiclePos( iVehicle, X, Y, Z );

		            g_C4Data[ playerid ] [ ID ] [ E_VEHICLE ] = iVehicle + 100; // Plus 100 just for verification

					//if ( GetOffsetFromPosition( iVehicle, X, Y, Z, vX, vY, vZ ) )
			   		//	g_C4Data[ playerid ] [ ID ] [ E_X ] = X + vX, g_C4Data[ playerid ] [ ID ] [ E_Y ] = Y + vY, g_C4Data[ playerid ] [ ID ] [ E_Z ] = Z + vY - vOffset;

					SendServerMessage( playerid, "You have planted a C4 on a "COL_GREY"vehicle"COL_WHITE", you can detonate it by pressing your "COL_GREY"Y key"COL_WHITE"." );
				    AttachDynamicObjectToVehicle( g_C4Data[ playerid ] [ ID ] [ E_OBJECT ], iVehicle, 0.0, 0.0, 6000.0, 0.0, 0.0, 0.0 );
				    Attach3DTextLabelToVehicle( g_C4Data[ playerid ] [ ID ] [ E_LABEL ], iVehicle, 0.0, 0.0, 0.0 );
				}
				else SendServerMessage( playerid, "You have planted a C4, you can detonate it by pressing your "COL_GREY"Y key"COL_WHITE"." );
			}
		}
		else return SendError( playerid, "You have planted the maximum C4 limit." );

		p_C4Amount[ playerid ] --;
		return 1;
	}
	else if ( !strcmp( params, "detonate", true, 8 ) )
	{
		new cID;

		if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this command since you're jailed." );
		else if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "This is restricted to civilians only." );
		else if ( !JobEquals( playerid, JOB_TERRORIST ) ) return SendError( playerid, "This is restricted to terrorists." );
		else if ( sscanf( params[ 9 ], "d", cID ) ) return SendUsage( playerid, "/c4 detonate [C4_ID] "COL_GREY"- Use detonator to blow all." );
		else if ( cID < 0 || cID >= MAX_C4 ) return SendError( playerid, "Invalid C4 ID specified." );
		else if ( g_C4Data[ playerid ] [ cID ] [ E_SET ] == false ) return SendError( playerid, "This C4 ID is not planted." );
		else
		{
			if ( ExplodePlayerC4s( playerid, cID, cID + 1 ) )
				SendServerMessage( playerid, "You have successfully detonated C4 ID %d.", cID );
			else
				SendError( playerid, "You cannot plant C4 at the moment, please try again later." );
		}
		return 1;
	}
	return SendUsage( playerid, "/c4 [PLANT/DETONATE]" );
}

/* ** Gang Commands ** */
CMD:takeover( playerid, params[ ] )
{
	if ( p_GangID[ playerid ] == INVALID_GANG_ID )
		return SendError( playerid, "You are not in any gang." );

	if ( p_Class[ playerid ] != CLASS_CIVILIAN )
		return SendError( playerid, "This is restricted to civilians only." );

	if ( GetPlayerInterior( playerid ) != 0 || IsPlayerInBank( playerid ) )
	    return SendError( playerid, "You cannot do this inside interiors." );

	new
		count = 0,
		oCount = 0,
		gmCount = 0,

		g_isAFK = 0,
		g_inAir = 0
	;

    for( new z; z < sizeof( g_gangzoneData ); z++ )
	{
	    if ( IsPlayerInArea( playerid, g_gangzoneData[ z ] [ E_MIN_X ], g_gangzoneData[ z ] [ E_MAX_X ], g_gangzoneData[ z ] [ E_MIN_Y ], g_gangzoneData[ z ] [ E_MAX_Y ] ) )
     	{
	        count = 1;
	        if ( g_gangzoneData[ z ] [ E_GANG_OWNER ] == p_GangID[ playerid ] ) return SendError( playerid, "This turf is already captured by your gang." );
			if ( g_gangzoneAttacker[ z ] != INVALID_GANG_ID ) return SendError( playerid, "This turf is currently being attacked." );

			if ( g_gangzoneData[ z ] [ E_GANG_OWNER ] != INVALID_GANG_ID ) {
				oCount = GetPlayersInGangZone( z, g_gangzoneData[ z ] [ E_GANG_OWNER ] ); // Opposing check
	        }

	        new dCount = GetPlayersInGangZone( z, p_GangID[ playerid ], g_isAFK, g_inAir );
	        if ( dCount < TAKEOVER_NEEDED_PEOPLE && ( dCount + g_isAFK + g_inAir ) >= TAKEOVER_NEEDED_PEOPLE )
		   		return SendError( playerid, "You cannot start a turf war if gangmembers are AFK or extremely high above ground." );

			if ( dCount >= TAKEOVER_NEEDED_PEOPLE && !oCount )
	        {
	            gmCount = 1;
				g_gangzoneAttacker[ z ] = p_GangID[ playerid ];
	            g_gangzoneAttackCount[ z ] = 0;
              	GangZoneFlashForAll( g_gangzoneID[ z ], 0xFF000080 );
              	SendClientMessage( playerid, g_gangData[ p_GangID[ playerid ] ] [ E_COLOR ], "[TURF]{FFFFFF} You are now beginning to take over the turf. Stay inside the area with your crew for 60 seconds. Don't die." );
	            if ( g_gangzoneData[ z ] [ E_GANG_OWNER ] != INVALID_GANG_ID ) SendClientMessageToGang( g_gangzoneData[ z ] [ E_GANG_OWNER ], g_gangData[ g_gangzoneData[ z ] [ E_GANG_OWNER ] ] [ E_COLOR ], "[GANG]{FFFFFF} Our territory is being attacked by "COL_GREY"%s"COL_WHITE", defend it!", g_gangData[ g_gangzoneAttacker[ z ] ] [ E_NAME ] );
              	break;
	        }
	    }
	}
	if ( oCount != 0 ) return SendError( playerid, "There are gang members within this turf, kill them!" );
	if ( count == 0 ) return SendError( playerid, "You are not in any gangzone." );
	if ( gmCount == 0 ) return SendError( playerid, "You need at least 3 people to take over this turf." );
	return 1;
}

CMD:clans( playerid, params[ ] )
{
	mysql_function_query( dbHandle, "SELECT * FROM `GANGS` WHERE `CLAN_TAG` IS NOT NULL ORDER BY `SCORE` DESC", true, "readclans", "d", playerid );
	return 1;
}

thread readclans( playerid )
{
	new
	    rows, fields
	;
    cache_get_data( rows, fields );

    if ( rows )
    {
    	new
    		szTag[ 8 ],
    		szName[ 30 ],
    		iScore, iColor
    	;

    	szLargeString = ""COL_WHITE"Tag\t"COL_WHITE"Name\t"COL_WHITE"Score\n";

    	for( new i = 0; i < rows; i++ )
		{
			cache_get_field_content( i, "CLAN_TAG", szTag );
			cache_get_field_content( i, "NAME", szName );
			iScore = cache_get_field_content_int( i, "SCORE", dbHandle );
			iColor = cache_get_field_content_int( i, "COLOR", dbHandle );

			format( szLargeString, sizeof( szLargeString ), "%s[%s]\t{%06x}%s\t%d\n", szLargeString, szTag, iColor >>> 8, szName, iScore );
		}

		return ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_TABLIST_HEADERS, "Clan List", szLargeString, "Close", "" ), 1;
	}
	SendError( playerid, "There are no clans to show." );
	return 1;
}


CMD:gangs( playerid, params[ ] )
{
	if ( !Iter_Count(gangs) )
		return SendError( playerid, "There are no gangs to list." );

	szHugeString = ""COL_WHITE"Gang\t"COL_WHITE"Score\n";

	foreach(new g : gangs) {
		format( szHugeString, sizeof( szHugeString ), "%s{%06x}%s\t%d\n", szHugeString, g_gangData[ g ] [ E_COLOR ] >>> 8, g_gangData[ g ] [ E_NAME ], g_gangData[ g ] [ E_SCORE ] );
	}

	return ShowPlayerDialog( playerid, DIALOG_GANG_LIST, DIALOG_STYLE_TABLIST_HEADERS, "Gangs List", szHugeString, "Select", "Cancel" );
}

CMD:gang( playerid, params[ ] )
{
	if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "This is restricted to civilians only." );

	if ( !strcmp( params, "leader", false, 6 ) )
	{
		new
		    pID
		;
	    if ( p_GangID[ playerid ] == INVALID_GANG_ID ) return SendError( playerid, "You are not inside a gang." );
		else if ( !IsPlayerGangLeader( playerid, p_GangID[ playerid ], .only_leader = 1 ) ) return SendError( playerid, "You are not the gang leader." );
		else if ( sscanf( params[ 7 ], ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/gang leader [PLAYER_ID]" );
		else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
		else if ( pID == playerid ) return SendError( playerid, "You cannot apply this action to yourself." );
		else if ( p_GangID[ pID ] != p_GangID[ playerid ] ) return SendError( playerid, "This player isn't in your gang." );
		else
		{
	        g_gangData[ p_GangID[ playerid ] ] [ E_LEADER ] = p_AccountID[ pID ];
			SendClientMessageToGang( p_GangID[ playerid ], g_gangData[ p_GangID[ playerid ] ] [ E_COLOR ], "[GANG]{FFFFFF} %s(%d) is the new gang leader.", ReturnPlayerName( pID ), pID );
            SaveGangData( p_GangID[ playerid ] );
		}
		return 1;
	}
	else if ( !strcmp( params, "coleader", false, 8 ) )
	{
		new
			gangid = p_GangID[ playerid ], pID;

	    if ( p_GangID[ playerid ] == INVALID_GANG_ID ) return SendError( playerid, "You are not inside a gang." );
		else if ( !IsPlayerGangLeader( playerid, p_GangID[ playerid ], .only_leader = 1 ) ) return SendError( playerid, "You are not the gang leader." );
		else if ( sscanf( params[ 9 ], ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/gang coleader [PLAYER_ID]" );
		else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
		else if ( pID == playerid ) return SendError( playerid, "You cannot apply this action to yourself." );
		else if ( p_GangID[ pID ] != p_GangID[ playerid ] ) return SendError( playerid, "This player isn't in your gang." );
		else
		{
			new
				slotid = -1;

			for ( new i = 0; i < MAX_COLEADERS; i ++ )
			{
				// check for dupes
				if ( g_gangData[ gangid ] [ E_COLEADER ] [ i ] == p_AccountID[ pID ] )
					return SendError( playerid, "This player is already a coleader of your gang." );

				// find slot
				if ( ! g_gangData[ gangid ] [ E_COLEADER ] [ i ] ) {
					slotid = i;
					break;
				}
			}

			if ( slotid != -1 )
			{
		        g_gangData[ gangid ] [ E_COLEADER ] [ slotid ] = p_AccountID[ pID ];
				SendClientMessageToGang( gangid, g_gangData[ gangid ] [ E_COLOR ], "[GANG]{FFFFFF} %s(%d) is the #%d co-leader.", ReturnPlayerName( pID ), pID, slotid + 1 );
				mysql_single_query( sprintf( "INSERT INTO `GANG_COLEADERS` (`GANG_ID`,`USER_ID`) VALUES (%d, %d)", g_gangData[ gangid ] [ E_SQL_ID ], p_AccountID[ pID ] ) );
			}
			else SendError( playerid, "There can only be a maximum of %d gang co-leaders. Kick one of them first.", MAX_COLEADERS );
		}
		return 1;
	}
	else if ( !strcmp( params, "kick", false, 4 ) )
	{
		new
		    pID
		;

		if ( p_GangID[ playerid ] == INVALID_GANG_ID ) return SendError( playerid, "You are not inside a gang." );
		else if ( !IsPlayerGangLeader( playerid, p_GangID[ playerid ] ) ) return SendError( playerid, "You are not the gang leader." );
		else if ( sscanf( params[ 5 ], ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/gang kick [PLAYER_ID]" );
		else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
		else if ( p_GangID[ pID ] != p_GangID[ playerid ] ) return SendError( playerid, "This player isn't in your gang." );
		else if ( IsPlayerGangLeader( pID, p_GangID[ playerid ], .only_leader = 1 ) ) return SendError( playerid, "This person is the gang leader." );
		else
		{
			RemovePlayerFromGang( pID, GANG_LEAVE_KICK, playerid );
		}
		return 1;
	}
	else if ( !strcmp( params, "name", false, 4 ) )
	{
		new
		    szName[ 30 ]
		;

		if ( p_GangID[ playerid ] == INVALID_GANG_ID ) return SendError( playerid, "You are not inside a gang." );
		else if ( !IsPlayerGangLeader( playerid, p_GangID[ playerid ] ) ) return SendError( playerid, "You are not the gang leader." );
		else if ( sscanf( params[ 5 ], "s[30]", szName ) ) return SendUsage( playerid, "/gang name [GANG_NAME]" );
		else if ( textContainsIP( szName ) || textContainsBadTextdrawLetters( szName ) ) return SendError( playerid, "Invalid Gang Name." );
		else if ( gangNameExists( szName ) ) return SendError( playerid, "This gang already exists, try another name." );
		else
		{
			format( g_gangData[ p_GangID[ playerid ] ] [ E_NAME ], 30, "%s", szName );
			SendClientMessageToGang( p_GangID[ playerid ], g_gangData[ p_GangID[ playerid ] ] [ E_COLOR ], "[GANG]{FFFFFF} %s(%d) has changed the gang's name to {%06x}%s"COL_WHITE".", ReturnPlayerName( playerid ), playerid, g_gangData[ p_GangID[ playerid ] ] [ E_COLOR ] >>> 8, szName );
            SaveGangData( p_GangID[ playerid ] );
		}
		return 1;
	}
	else if ( !strcmp( params, "color", false, 5 ) )
	{
		if ( p_GangID[ playerid ] == INVALID_GANG_ID ) return SendError( playerid, "You are not inside a gang." );
		if ( !IsPlayerGangLeader( playerid, p_GangID[ playerid ] ) ) return SendError( playerid, "You are not the gang leader." );

		return ShowPlayerDialog( playerid, DIALOG_GANG_COLOR, DIALOG_STYLE_LIST, "Gang Colors", ""COL_GREY"Custom Hex Code "COL_GOLD"[V.I.P]\n{99FF00}Yellow Green\n{00CC00}Green\n{009999}Blue Green\n{0033CC}Blue\n{330099}Blue Violet\n{660099}Violet\n{CC0099}Red Violet", "Select", "Cancel" );
	}
	else if ( !strcmp( params, "create", false, 5 ) )
	{
		new
		    szName[ 30 ]
		;

		if ( sscanf( params[ 6 ], "s[30]", szName ) ) return SendUsage( playerid, "/gang create [GANG_NAME]" );
		else if ( p_GangID[ playerid ] != INVALID_GANG_ID ) return SendError( playerid, "To make a gang, you must leave your current gang with /gang leave" );
		else if ( textContainsIP( szName ) || textContainsBadTextdrawLetters( szName ) ) return SendError( playerid, "Invalid Gang Name." );
		else if ( gangNameExists( szName ) ) return SendError( playerid, "This gang already exists, try another name." );
		else
		{
			if ( CreateGang( szName, playerid ) == INVALID_GANG_ID )
				return SendError( playerid, "There are no available slots to create a gang." );
		}
		return 1;
	}
	else if ( !strcmp( params, "joinmsg", false, 7 ) )
	{
		new
			gangid = p_GangID[ playerid ];

		if ( gangid == INVALID_GANG_ID ) return SendError( playerid, "You are not inside any gang." );
		if ( !IsPlayerGangLeader( playerid, gangid ) ) return SendError( playerid, "You are not the gang leader." );

		if ( sscanf( params[ 8 ], "s[96]", g_gangData[ gangid ] [ E_JOIN_MSG ] ) )
		{
			mysql_single_query( sprintf( "UPDATE `GANGS` SET `JOIN_MSG`=NULL WHERE `ID`=%d", g_gangData[ gangid ] [ E_SQL_ID ] ) );
			SendClientMessageToGang( gangid, g_gangData[ gangid ] [ E_COLOR ], "[GANG]{FFFFFF} %s(%d) removed the gang's join message.", ReturnPlayerName( playerid ), playerid );
		}
		else
		{
			format( szBigString, sizeof( szBigString ), "UPDATE `GANGS` SET `JOIN_MSG`='%s' WHERE `ID`=%d", mysql_escape( g_gangData[ gangid ] [ E_JOIN_MSG ] ), g_gangData[ gangid ] [ E_SQL_ID ] );
			mysql_single_query( szBigString );

			SendClientMessageToGang( gangid, g_gangData[ gangid ] [ E_COLOR ], "[GANG]{FFFFFF} %s(%d) set the gang's join message:", ReturnPlayerName( playerid ), playerid );
			SendClientMessageToGang( gangid, g_gangData[ gangid ] [ E_COLOR ], "[GANG]"COL_GREY" %s", g_gangData[ gangid ] [ E_JOIN_MSG ] );
		}
		return 1;
	}
	else if ( !strcmp( params, "join", false, 4 ) )
	{
		new
		    gID
		;
		if ( sscanf( params[ 5 ], "d", gID ) ) return SendUsage( playerid, "/gang join [GANG_ID]" );
		else if ( gID < 0 || gID >= MAX_GANGS ) return SendError( playerid, "Invalid Gang ID." );
		else if ( !Iter_Contains( gangs, gID ) ) return SendError( playerid, "Invalid Gang ID." );
		else if ( p_gangInvited[ playerid ] [ gID ] == false ) return SendError( playerid, "You haven't been invited to this gang." );
		else if ( hasTickcountPassed( p_gangInviteTick[ playerid ], 120000 ) ) return p_gangInvited[ playerid ] [ gID ] = false, SendError( playerid, "This invite has expired, each invite only lasts for 2 minutes." );
		else if ( p_GangID[ playerid ] != INVALID_GANG_ID ) return SendError( playerid, "You are already inside a gang." );
		else
		{
		    p_GangID[ playerid ] = gID;
		    p_gangInvited[ playerid ] [ gID ] = false;
		    if ( p_WantedLevel[ playerid ] < 1 ) SetPlayerColor( playerid, g_gangData[ gID ] [ E_COLOR ] );
            SaveGangData( p_GangID[ playerid ] );
			SendClientMessageToGang( gID, g_gangData[ p_GangID[ playerid ] ] [ E_COLOR ], "[GANG]{FFFFFF} %s(%d) has joined the gang.", ReturnPlayerName( playerid ), playerid );
		}
		return 1;
	}
	else if ( !strcmp( params, "invite", false, 6 ) )
	{
		new
		    pID
		;

		if ( sscanf( params[ 7 ], ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/gang invite [PLAYER_ID]" );
		else if ( !IsPlayerConnected( pID ) ) return SendError( playerid, "This player is not connected." );
		else if ( p_Class[ pID ] != CLASS_CIVILIAN ) return SendError( playerid, "You cannot invite people from non-civilian classes." );
		else if ( p_PlayerSettings[ pID ] { SETTING_GANG_INVITES } ) return SendError( playerid, "This player has disabled gang invites." );
		else if ( pID == playerid ) return SendError( playerid, "You cannot use this on yourself." );
		else if ( p_GangID[ pID ] != INVALID_GANG_ID ) return SendError( playerid, "This player is already inside a gang." );
		else if ( p_GangID[ playerid ] == INVALID_GANG_ID ) return SendError( playerid, "You are not inside any gang." );
		else if ( p_GangID[ pID ] == p_GangID[ playerid ] ) return SendError( playerid, "This player is in your gang." );
		else
		{
			if ( g_gangData[ p_GangID[ playerid ] ] [ E_INVITE_ONLY ] && !IsPlayerGangLeader( playerid, p_GangID[ playerid ] ) )
				return SendError( playerid, "You are not the gang leader." );

		    p_gangInvited[ pID ] [ p_GangID[ playerid ] ] = true;
		    p_gangInviteTick[ pID ] = GetTickCount( );
		    format( szNormalString, sizeof( szNormalString ), "[GANG]{FFFFFF} %s(%d) has invited you to join %s, to join type \"/gang join %d\"", ReturnPlayerName( playerid ), playerid, g_gangData[ p_GangID[ playerid ] ] [ E_NAME ], p_GangID[ playerid ] );
			SendClientMessage( pID, g_gangData[ p_GangID[ playerid ] ] [ E_COLOR ], szNormalString );
			format( szNormalString, sizeof( szNormalString ), "[GANG]{FFFFFF} You have invited %s(%d) to join your gang.", ReturnPlayerName( pID ), pID );
			SendClientMessage( playerid, g_gangData[ p_GangID[ playerid ] ] [ E_COLOR ], szNormalString );
		}
		return 1;
	}
	else if ( !strcmp( params, "leave", false, 5 ) )
	{
		if ( p_GangID[ playerid ] == INVALID_GANG_ID ) return SendError( playerid, "You are not in any gang." );
		RemovePlayerFromGang( playerid, GANG_LEAVE_QUIT );
		return SendServerMessage( playerid, "You have left your previous gang." );
	}
	else if ( !strcmp( params, "splitprofit", false, 11 ) )
	{
		new
			fProfitSplit;

		if ( sscanf( params[ 12 ], "d", fProfitSplit ) ) SendUsage( playerid, "/gang splitprofit [PERCENTAGE]" );
		else if ( p_GangID[ playerid ] == INVALID_GANG_ID ) SendError( playerid, "You are not inside any gang." );
		else if ( fProfitSplit == 0 && p_GangSplitProfits[ playerid ] == 0 ) SendError( playerid, "You are already not splitting any profit among your gang bank." );
		else if ( fProfitSplit == 0 )
		{
			p_GangSplitProfits[ playerid ] = 0;
			SendClientMessageToGang( p_GangID[ playerid ], g_gangData[ p_GangID[ playerid ] ] [ E_COLOR ], "[GANG]{FFFFFF} %s(%d) has decided to no longer split his profits to the gang.", ReturnPlayerName( playerid ), playerid );
		}
		else if ( fProfitSplit == p_GangSplitProfits[ playerid ] && fProfitSplit != 0 ) SendError( playerid, "Your current profit split is the same as the percentage you specified." );
		else if ( 0 < fProfitSplit > 100 ) SendError( playerid, "Choose a percentage between 0 and 100." );
		else if ( fProfitSplit > 99999999 || fProfitSplit < 0 ) SendError( playerid, "Choose a percentage between 0 and 100." ); // Going over billions
		else
		{
			p_GangSplitProfits[ playerid ] = fProfitSplit;
			SendClientMessageToGang( p_GangID[ playerid ], g_gangData[ p_GangID[ playerid ] ] [ E_COLOR ], "[GANG]{FFFFFF} %s(%d) has decided to split %d%s of his profit into the gang bank.", ReturnPlayerName( playerid ), playerid, fProfitSplit, "%%" );
		}
		return 1;
	}
	else if ( !strcmp( params, "private", false, 6 ) )
	{
		new
			gangid = p_GangID[ playerid ];

		if ( gangid == INVALID_GANG_ID ) return SendError( playerid, "You are not inside any gang." );
		else if ( !IsPlayerGangLeader( playerid, gangid ) ) return SendError( playerid, "You are not the gang leader." );
		else
		{
			// Reset all gang invites
			for( new i = 0; i < MAX_PLAYERS; i++ ) {
				p_gangInvited[ i ] [ gangid ] = false;
			}

			// Update private status
			mysql_single_query( sprintf( "UPDATE `GANGS` SET `INVITE_ONLY`=%d WHERE `ID`=%d", ( g_gangData[ gangid ] [ E_INVITE_ONLY ] = !g_gangData[ gangid ] [ E_INVITE_ONLY ] ), g_gangData[ gangid ] [ E_SQL_ID ] ) );
			SendClientMessageToGang( gangid, g_gangData[ gangid ] [ E_COLOR ], "[GANG]{FFFFFF} %s(%d) %s made the gang private.", ReturnPlayerName( playerid ), playerid, g_gangData[ gangid ] [ E_INVITE_ONLY ] ? ( "has" ) : ( "has not" ) );
		}
		return 1;
	}
	return SendUsage( playerid, "/gang [CREATE/LEAVE/INVITE/JOIN/KICK/NAME/LEADER/COLEADER/COLOR/SPLITPROFIT/PRIVATE/JOINMSG]" );
}

CMD:g( playerid, params[ ] )
{
	new
	    msg[ 90 ]
	;

	if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "Civilians can use this command only." );
	else if ( p_GangID[ playerid ] == INVALID_GANG_ID ) return SendError( playerid, "You are not in any gang." );
    else if ( sscanf( params, "s[90]", msg ) ) return SendUsage( playerid, "/g [MESSAGE]" );
    else
	{
		SendClientMessageToGang( p_GangID[ playerid ], g_gangData[ p_GangID[ playerid ] ] [ E_COLOR ], "<Gang Chat> %s(%d):{FFFFFF} %s", ReturnPlayerName( playerid ), playerid, msg );
	}
	return 1;
}

/*                                 ________    ___      ___   ________      ___________
	/--------------\             /         \  |   \    /   | |   ___  \    /           |
	|    ______    |             |   ______/  |    \  /    | |  |   |  \   |    _______|
	|   |      |   |             |   |        |     \/     | |  |   |  |   |    \_______
	|   |______|   |   ________  |   |        |            | |  |   |  |   \_______     |
	|    ______    |  |________| |   |        |   |\__/|   | |  |   |  |           /    |
	|   |      |   |             |   |______  |   |    |   | |  |   |  |   _______/    /
	|   |      |   |             |          \     |    |   | |  |___|  /  |           /
	\___/      \___/             \__________/ |___|    |___| |________/   |__________/
*/

/* Level 1 */
CMD:acommands( playerid, params[ ] ) return cmd_acmds( playerid, params );
CMD:acmds( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    SendClientMessage( playerid, COLOR_GREY, "|______________________________________| Admin Commands |_____________________________________|" );
    SendClientMessage( playerid, COLOR_WHITE, " " );
    SendClientMessage( playerid, COLOR_WHITE, "    LEVEL 1: /goto, /spec(off), /(un)jail, /asay, /slap, /a, /getstats, /stpfr, /setskin, /frules, /fpc, /ticketlog" );
    SendClientMessage( playerid, COLOR_WHITE, "    LEVEL 1: /pinfo, /warn, /spawn, /ans, /stpfa, /alog, /(un)freeze, /aod, /respawnalluv, /reports, /questions" );
    SendClientMessage( playerid, COLOR_WHITE, "    LEVEL 1: /respond, /mutelist, /aka, /arepair" );
    SendClientMessage( playerid, COLOR_WHITE, "    LEVEL 2: /kick, /vdestroy, /(un)mute, /explode, /vrespawn, /arenas, /suspend, /viewnotes, /slay" );
    SendClientMessage( playerid, COLOR_WHITE, "    LEVEL 3: /ban, /bring, /clearchat, /(ann)ounce, /giveweapon, /vadminpark, /vcreate, /healall, /getip, /smlog, /iclog" );
    SendClientMessage( playerid, COLOR_WHITE, "    LEVEL 3: /vadminstats, /pingimmune, /vbring, /countdown, /forcecoptutorial, /vgoto, /copwarn, /armywarn, /resetwep" );
    SendClientMessage( playerid, COLOR_WHITE, "    LEVEL 3: /venter, /geolocate" );
    SendClientMessage( playerid, COLOR_WHITE, "    LEVEL 4: /circleall, /giveweaponall, /resetwepall, /motd, /uncopban, /unarmyban, /setworld, /destroyallav, /gotopos" );
    SendClientMessage( playerid, COLOR_WHITE, "    LEVEL 4: /addnote, /removenote" );
    SendClientMessage( playerid, COLOR_WHITE, "    LEVEL 5: /createhouse, /destroyhouse, /respawnallv, /changename, /toggleviewpm, /unban(ip)" );
    SendClientMessage( playerid, COLOR_WHITE, "    LEVEL 5: /createcar, /destroycar, /stripcarmods, /createbribe, /destroybribe, /doublexp, /(h/v)adminsell" );
    SendClientMessage( playerid, COLOR_WHITE, "    LEVEL 5: /autovehrespawn, /megaban, /acunban, /creategate, /editgate, /connectsong" );
    SendClientMessage( playerid, COLOR_WHITE, "    LEVEL 5: /creategarage, /destroygarage, /check" );

    if ( p_AdminLevel[ playerid ] > 5 ) {
		SendClientMessage( playerid, COLOR_WHITE, "    LEVEL 6: /setirc, /seteventhost, /setlevel, /setleveloffline, /svrstats, /playaction, /playanimation" );
		SendClientMessage( playerid, COLOR_WHITE, "    LEVEL 6: /updaterules, /truncate, /broadcast, /setgangleader, /viewgangtalk, /createentrance, /destroyentrance" );
    }

    SendClientMessage( playerid, COLOR_GREY, "|_____________________________________________________________________________________________|" );
	return 1;
}

CMD:arepair( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 1 )
		return SendError( playerid, ADMIN_COMMAND_REJECT );

 	if ( !IsPlayerInEvent( playerid ) )
 		return SendError( playerid, "You cannot use this command since you're not in an event world." );

	new
		iVehicle = GetPlayerVehicleID( playerid );

	if ( IsValidVehicle( iVehicle ) )
	{
		if ( !g_adminSpawnedCar{ iVehicle } )
			return SendError( playerid, "This is not an admin spawned vehicle." );

		p_DamageSpamCount{ playerid } = 0;
	 	RepairVehicle( iVehicle );
		PlayerPlaySound( playerid, 1133, 0.0, 0.0, 5.0 );

 		AddAdminLogLineFormatted( "%s(%d) has repaired their vehicle", ReturnPlayerName( playerid ), playerid );
		return SendClientMessage( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have repaired this vehicle." );
	}
	return SendError( playerid, "You are not in any vehicle." );
}

CMD:aka( playerid, params[ ] )
{
	new
		pID
	;

	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, #sscanf_u, pID ) ) return SendUsage( playerid, "/aka [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else
	{
		format( szNormalString, 96, "SELECT `NAME`,`TIME` FROM `NAME_CHANGES` WHERE `USER_ID`=%d ORDER BY `TIME` DESC", p_AccountID[ pID ] );
		mysql_function_query( dbHandle, szNormalString, true, "readnamechanges", "dd", playerid, pID );
	}
	return 1;
}

CMD:pinfo( playerid, params[ ] )
{
	new
		pID
	;
	if ( p_AdminLevel[ playerid ] < 1 && !IsPlayerUnderCover( playerid ) ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/pinfo [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else
	{
		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" %s(%d): "COL_GREY"%0.2f%s packetloss, %d FPS, %d ping, from %s, SA-MP AC %s", ReturnPlayerName( pID ), pID, NetStats_PacketLossPercent( pID ), "%%", GetPlayerFPS( pID ), GetPlayerPing( pID ), GetPlayerCountryName( pID ), IsPlayerUsingSampAC( pID ) ? ( COL_GREEN # "ENABLED" ) : ( COL_RED # "DISABLED" ) );
	}
	return 1;
}

CMD:reports( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );

	if ( !strlen( szReportsLog[ 7 ] ) )
		szLargeString = "None at the moment.";
	else
		format( szLargeString, sizeof( szLargeString ), "%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s", szReportsLog[ 0 ], szReportsLog[ 1 ], szReportsLog[ 2 ], szReportsLog[ 3 ], szReportsLog[ 4 ], szReportsLog[ 5 ], szReportsLog[ 6 ], szReportsLog[ 7 ] );

	ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_LIST, "{FFFFFF}Report Log", szLargeString, "Okay", "" );
	return 1;
}

CMD:questions( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );

	if ( !strlen( szQuestionsLog[ 7 ] ) )
		szLargeString = "None at the moment.";
	else
		format( szLargeString, sizeof( szLargeString ), "%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s", szQuestionsLog[ 0 ], szQuestionsLog[ 1 ], szQuestionsLog[ 2 ], szQuestionsLog[ 3 ], szQuestionsLog[ 4 ], szQuestionsLog[ 5 ], szQuestionsLog[ 6 ], szQuestionsLog[ 7 ] );

	ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_LIST, "{FFFFFF}Question Log", szLargeString, "Okay", "" );
	return 1;
}

CMD:respawnalluv( playerid, params[ ] )
{
 	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else
	{
	    for( new i = 0; i < MAX_VEHICLES; i++ ) if ( IsValidVehicle( i ) ) {
	    	#if ENABLED_SECURE_TRUCK
	    	if ( g_secureTruckVehicle == i ) continue;
	    	#endif
	    	if ( IsTrailerVehicle( GetVehicleModel( i ) ) ) continue;
			if ( !IsVehicleOccupied( i, .include_vehicle_interior = true ) ) SetVehicleToRespawn( i );
		}
		AddAdminLogLineFormatted( "%s(%d) has respawned all unoccupied vehicles", ReturnPlayerName( playerid ), playerid );
		SendServerMessage( playerid, "You have respawned all unoccupied vehicles." );
	}
	return 1;
}

CMD:aod( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
 	if ( !p_AdminOnDuty{ playerid } )
	{
		TextDrawShowForPlayer( playerid, g_AdminOnDutyTD );
	    Delete3DTextLabel( p_AdminLabel[ playerid ] );
	    p_AdminLabel[ playerid ] = Create3DTextLabel( "Admin on Duty!", COLOR_PINK, 0.0, 0.0, 0.0, 15.0, 0 );
	    Attach3DTextLabelToPlayer( p_AdminLabel[ playerid ], playerid, 0.0, 0.0, 0.5 );
	    SetPlayerHealth( playerid, INVALID_PLAYER_ID );
	    DisableRemoteVehicleCollisions( playerid, 1 );
	    p_AdminOnDuty{ playerid } = true;
	    SendClientMessage( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have enabled administration mode." );
	}
	else
	{
		TextDrawHideForPlayer( playerid, g_AdminOnDutyTD );
	    Delete3DTextLabel( p_AdminLabel[ playerid ] );
	    p_AdminLabel[ playerid ] = Text3D: INVALID_3DTEXT_ID;
	    p_AdminOnDuty{ playerid } = false;
	    SetPlayerHealth( playerid, 100 );
	    DisableRemoteVehicleCollisions( playerid, 0 );
	    SendClientMessage( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have disabled administration mode." );
	}
	SetPlayerColorToTeam( playerid );
	return 1;
}

CMD:asay( playerid, params[ ] )
{
	new
	    string[ 100 ]
	;
	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "s[100]", string ) ) return SendUsage( playerid, "/asay [MESSAGE]" );
	else
	{
		AddAdminLogLineFormatted( "%s(%d) has used /asay", ReturnPlayerName( playerid ), playerid );
        SendGlobalMessage( -1, ""COL_PINK"[ADMIN]"COL_WHITE" %s", string );
	}
	return 1;
}

CMD:frules( playerid, params[ ] )
{
	new
		pID
	;
	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/frules [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( !IsPlayerSpawned( pID ) ) return SendError( playerid, "This player isn't spawned." );
	else
	{
		cmd_rules( pID, "" );
		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have shown %s(%d) the /rules", ReturnPlayerName( pID ), pID );
		AddAdminLogLineFormatted( "%s(%d) has shown the rules to %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
	}
	return 1;
}

CMD:fpc( playerid, params[ ] )
{
	new
		pID
	;
	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/fpc [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( !IsPlayerSpawned( pID ) ) return SendError( playerid, "This player isn't spawned." );
	else
	{
		cmd_pc( pID, "" );
		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have shown %s(%d) the player colors (/pc)", ReturnPlayerName( pID ), pID );
		AddAdminLogLineFormatted( "%s(%d) has shown the player colors to %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
	}
	return 1;
}

CMD:freeze( playerid, params[ ] )
{
	new
		pID
	;
	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/freeze [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( !IsPlayerSpawned( pID ) ) return SendError( playerid, "This player isn't spawned." );
	else
	{
	    AddAdminLogLineFormatted( "%s(%d) has frozen %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
		SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have been frozen by %s(%d)!", ReturnPlayerName( playerid ), playerid );
	   	SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have frozen %s(%d)!", ReturnPlayerName( pID ), pID );
	   	TogglePlayerControllable( pID, 0 );
	}
	return 1;
}


CMD:unfreeze( playerid, params[ ] )
{
	new
		pID
	;
	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/unfreeze [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( !IsPlayerSpawned( pID ) ) return SendError( playerid, "This player isn't spawned." );
	else
	{
	    AddAdminLogLineFormatted( "%s(%d) has unfrozen %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
		SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have been unfrozen by %s(%d)!", ReturnPlayerName( playerid ), playerid );
	   	SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have unfrozen %s(%d)!", ReturnPlayerName( pID ), pID );
	   	TogglePlayerControllable( pID, 1 );
	}
	return 1;
}

CMD:awep( playerid, params[ ] )
{
	static
		iAmmo,
		pID
	;
	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/awep [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( !IsPlayerSpawned( pID ) ) return SendError( playerid, "This player isn't spawned." );
	else
	{
        szLargeString[ 0 ] = '\0';
        SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You are now viewing "COL_GREY"%s(%d){FFFFFF}'s weapons.", ReturnPlayerName( pID ), pID );
		for(new i; i < MAX_WEAPONS; i++)
		{
		    if ( IsWeaponInAnySlot( pID, i ) )
		    {
				GetPlayerWeaponData( pID, GetWeaponSlot( i ), iAmmo, iAmmo );
				if ( iAmmo > 0x7FFF || iAmmo < -100 ) iAmmo = 0x7FFF;
				if ( iAmmo == 0 || i == 0 ) continue;

		        format( szLargeString, sizeof( szLargeString ), "%s%s(%d)\n", szLargeString, ReturnWeaponName( i ), iAmmo );
		        ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_LIST, "{FFFFFF}Weapon Data", szLargeString, "Okay", "" );
		    }
		}
	}
	return 1;
}

CMD:alog( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 1 && !IsPlayerUnderCover( playerid ) ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else
	{
        if ( p_AdminLog{ playerid } )
        {
            p_AdminLog{ playerid } = false;
	    	TextDrawHideForPlayer( playerid, g_AdminLogTD );
	    	SendServerMessage( playerid, "You have un-toggled the administration log." );
		}
		else
		{
            p_AdminLog{ playerid } = true;
	    	TextDrawShowForPlayer( playerid, g_AdminLogTD );
	    	SendServerMessage( playerid, "You have toggled the administration log." );
		}
	}
	return 1;
}

CMD:stpfa( playerid, params[ ] )
{
    new
		pID
	;
	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, ""#sscanf_u"", pID ) ) SendUsage(playerid, "/stpfa [PLAYER_ID]");
    else if ( !IsPlayerConnected(pID) ) return SendError(playerid, "Invalid Player ID.");
    else if ( pID == playerid ) return SendError( playerid, "You cannot apply this to yourself." );
    else if ( p_AdminLevel[ pID ] > p_AdminLevel[ playerid ] ) return SendError( playerid, "This player has a higher administration level than you." );
    else
    {
        p_CantUseAsk{ pID } = ( p_CantUseAsk{ pID } == true ? false : true );
		AddAdminLogLineFormatted( "%s(%d) has been %s from using /ask by %s(%d)", ReturnPlayerName( pID ), pID, p_CantUseAsk{ pID } == true ? ( "blocked" ) : ( "unblocked" ), ReturnPlayerName( playerid ), playerid );
        SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have %s %s(%d) from using the ask command.", p_CantUseAsk{ pID } == true ? ( "blocked" ) : ( "unblocked" ), ReturnPlayerName( pID ), pID );
    }
    return 1;
}

CMD:ans( playerid, params[ ] )
{
	new
		pID, msg[ 90 ], iTime = g_iTime
	;

	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, ""#sscanf_u"s[90]", pID, msg ) ) return SendUsage( playerid, "/ans [PLAYER_ID] [ANSWER]" );
    else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
    else if ( pID == playerid ) return SendError( playerid, "You cannot answer yourself." );
    else if ( iTime < p_AnswerDelay[ pID ] ) return SendError( playerid, "Please wait another %d seconds to answer this person.", p_AnswerDelay[ pID ] - iTime );
	else
	{
		SendClientMessageToAdmins( -1, ""COL_PINK"[ANSWER]"COL_GREY" (%s >> %s):"COL_WHITE" %s", ReturnPlayerName( playerid ), ReturnPlayerName( pID ), msg );
		AddAdminLogLineFormatted( "%s(%d) has answered %s(%d)'s question", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
        SendClientMessageFormatted( pID, -1, "{FE5700}[ANSWER] From %s(%d):{FFFFFF} %s", ReturnPlayerName( playerid ), playerid, msg );
        p_AnswerDelay[ pID ] = iTime + 4;
        Beep( pID ), Beep( playerid );
	}
	return 1;
}

CMD:respond( playerid, params[ ] )
{
	new
		pID;

	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/respond [PLAYER_ID]" );
    else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
    else if ( pID == playerid ) return SendError( playerid, "You cannot respond to yourself." );
    else if ( g_iTime < p_RespondDelay[ pID ] ) return SendError( playerid, "Please wait another %d seconds to respond to this person.", p_RespondDelay[ pID ] - g_iTime );
	else
	{
		AddAdminLogLineFormatted( "%s(%d) is responding to %s(%d)'s report", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
		SendClientMessageToAdmins( -1, ""COL_PINK"[REPORT]"COL_GREY" %s(%d) responded to %s(%d)'s report!", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
        SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]"COL_GREY" %s(%d) is now looking into your report. Please wait!", ReturnPlayerName( playerid ), playerid );
        p_RespondDelay[ pID ] = g_iTime + 4;
        Beep( pID ), Beep( playerid );
	}
	return 1;
}

CMD:spawn( playerid, params[ ] )
{
	new
		pID
	;
	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/spawn [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( p_PlayerLogged{ pID } == false ) return SendError( playerid, "This player is not logged in." );
	else
	{
		SyncObject( pID );
		SpawnPlayer( pID );
		AddAdminLogLineFormatted( "%s(%d) has spawned %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
        SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have spawned %s(%d)!", ReturnPlayerName( pID ), pID );
		SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have been spawned by %s(%d)!", ReturnPlayerName( playerid ), playerid );
	}
	return 1;
}

CMD:warn( playerid, params[ ] )
{
	new
	    pID,
	    reason[ 32 ]
	;
	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"S(No Reason)[32]", pID, reason ) ) return SendUsage( playerid, "/warn [PLAYER_ID] [REASON]" );
    else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
    else if ( pID == playerid ) return SendError( playerid, "You can't warn your self." );
	else if ( p_AdminLevel[ playerid ] < p_AdminLevel[ pID ] ) return SendError( playerid, "This player has a higher administration level than you." );
	else
	{
		if ( p_AdminCommandPause[ pID ] > g_iTime )
			return SendError( playerid, "You must wait %d seconds before using this admin command on the player.", p_AdminCommandPause[ pID ] - g_iTime );

		p_AdminCommandPause[ pID ] = g_iTime + ADMIN_COMMAND_TIME;

	    p_Warns[ pID ] ++;
		GameTextForPlayer( pID, "~r~WARNED!", 4000, 4 );
	    AddAdminLogLineFormatted( "%s(%d) has warned %s(%d) [%d/3]", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, p_Warns[ pID ] );
        SendGlobalMessage( -1, ""COL_PINK"[ADMIN]"COL_WHITE" %s(%d) has been warned by %s(%d) "COL_GREEN"[REASON: %s]", ReturnPlayerName( pID ), pID, ReturnPlayerName( playerid ), playerid, reason );
		if ( p_Warns[ pID ] >= 3 )
	    {
	        p_Warns[ pID ] = 0;
	        SendGlobalMessage( -1, ""COL_PINK"[ADMIN]"COL_WHITE" %s(%d) has been kicked from the server. "COL_GREEN"[REASON: Excessive Warns]", ReturnPlayerName( pID ), pID );
	        KickPlayerTimed( pID );
	        return 1;
	    }
 	}
	return 1;
}

CMD:setskin( playerid, params[ ] )
{
    new
		pID,
		skin
	;
	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, ""#sscanf_u"d", pID, skin ) ) SendUsage(playerid, "/setskin [PLAYER_ID] [SKIN_ID]");
    else if ( !IsPlayerConnected(pID) ) return SendError(playerid, "Invalid Player ID.");
    else if ( p_AdminLevel[ pID ] > p_AdminLevel[ playerid ] ) return SendError( playerid, "This player has a higher administration level than you." );
	else if ( !IsValidSkin( skin ) ) return SendError( playerid, "Invalid Skin ID." );
	else
	{
	    if ( GetPlayerState( pID ) == PLAYER_STATE_ENTER_VEHICLE_DRIVER || GetPlayerState( pID ) == PLAYER_STATE_ENTER_VEHICLE_PASSENGER ) return SendError( playerid, "You cannot set your skin if you're entering a vehicle." );
	    if ( GetPlayerState( pID ) == PLAYER_STATE_EXIT_VEHICLE ) return SendError( playerid, "You cannot set your skin if you're exiting a vehicle." );
		if ( GetPlayerAnimationIndex( pID ) == 1660 ) return SendError( playerid, "The player specified is currently using a vending machine." );
	    AddAdminLogLineFormatted( "%s(%d) has changed %s(%d)'s skin id to %d", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, skin );
	    SyncObject( pID );
        SetPlayerSkin( pID, skin );
	    if ( pID != playerid ) {
		    SendClientMessageFormatted( pID, COLOR_PINK, "[ADMIN]"COL_WHITE" %s(%d) has changed your skin ID to %d.", ReturnPlayerName( playerid ), playerid, skin );
		    SendClientMessageFormatted( playerid, COLOR_PINK, "[ADMIN]"COL_WHITE" You have changed %s(%d)'s skin to ID %d.", ReturnPlayerName( pID ), pID, skin );
		}
		else SendClientMessageFormatted( playerid, COLOR_PINK, "[ADMIN]"COL_WHITE" You have changed your skin to ID %d.", skin );

	}
	return 1;
}

CMD:stpfr( playerid, params[ ] )
{
    new
		pID
	;
	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, ""#sscanf_u"", pID ) ) SendUsage(playerid, "/stpfr [PLAYER_ID]");
    else if ( !IsPlayerConnected(pID) ) return SendError(playerid, "Invalid Player ID.");
    else if ( pID == playerid ) return SendError( playerid, "You cannot apply this to yourself." );
    else if ( p_AdminLevel[ pID ] > p_AdminLevel[ playerid ] ) return SendError( playerid, "This player has a higher administration level than you." );
    else
    {
		p_CantUseReport{ pID } = ( p_CantUseReport{ pID } == true ? false : true );
        AddAdminLogLineFormatted( "%s(%d) has been %s from using /report by %s(%d)", ReturnPlayerName( pID ), pID, p_CantUseReport{ pID } == true ? ( "blocked" ) : ( "unblocked" ), ReturnPlayerName( playerid ), playerid );
        SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have %s %s(%d) from using the report command.", p_CantUseReport{ pID } == true ? ( "blocked" ) : ( "unblocked" ), ReturnPlayerName( pID ), pID );
	}
    return 1;
}

CMD:getstats( playerid, params[ ] )
{
    new
		pID
	;

	if ( p_AdminLevel[ playerid ] < 1 && !IsPlayerUnderCover( playerid ) ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, ""#sscanf_u"", pID ) ) SendUsage(playerid, "/getstats [PLAYER_ID]");
    else if ( !IsPlayerConnected(pID) ) return SendError(playerid, "Invalid Player ID.");
	else if ( !p_PlayerLogged{ pID } ) return SendError( playerid, "This player is not logged in." );
	else
	{
	    p_ViewingStats[ playerid ] = pID;
		ShowPlayerDialog( playerid, DIALOG_STATS, DIALOG_STYLE_LIST, "{FFFFFF}Statistics", "General Statistics\nGame Statistics\nItem Statistics\nStreak Statistics\nAchievements", "Okay", "Cancel" );
	}
   	return 1;
}

CMD:a( playerid, params[ ] )
{
	new
	    msg[ 90 ]
	;

    if ( p_AdminLevel[ playerid ] < 1 ) return 0;
    else if ( sscanf( params, "s[90]", msg ) ) return SendUsage( playerid, "/a [MESSAGE]" );
	else if ( textContainsIP( msg ) ) return SendServerMessage( playerid, "Please do not advertise." );
    else
	{
		SendClientMessageToAdmins( -1, ""COL_PINK"<Admin Chat> %s(%d):"COL_GREY" %s", ReturnPlayerName( playerid ), playerid, msg );
	}
	return 1;
}

CMD:adminmanual( playerid, params[ ] )
{
    if ( p_AdminLevel[ playerid ] < 1 )
    	return 0;

	AddAdminLogLineFormatted( "%s(%d) used /adminmanual", ReturnPlayerName( playerid ), playerid );
    SendClientMessageToAdmins( -1, ""COL_PINK"[ADMIN]"COL_GREY" Read the admin manual on the forum or you might be demoted (%s)!", "Help and Information > Administration Manual" );
	return 1;
}

CMD:slap( playerid, params[ ] )
{
    new
		pID,
		Float: offset,
		Float: X,
		Float: Y,
		Float: Z
	;

	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, ""#sscanf_u"F(10.0)", pID, offset ) ) return SendUsage(playerid, "/slap [PLAYER_ID] [OFFSET (= 10.0)]");
    else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError(playerid, "Invalid Player ID.");
    else if ( p_AdminLevel[ pID ] > p_AdminLevel[ playerid ] ) return SendError(playerid, "You cannot use this command on admins higher than your level.");
    else
	{
        AddAdminLogLineFormatted( "%s(%d) has slapped %s(%d) %0.1f units", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, offset );
        SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have slapped %s(%d) %0.1f units", ReturnPlayerName( pID ), pID, offset );
        GetPlayerPos( pID, X, Y, Z );
        SetPlayerPos( pID, X, Y, Z + offset );
    }
    return 1;
}

CMD:jail( playerid, params [ ] )
{
    new
	    pID,
		Seconds,
		reason[ 50 ]
	;
	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"dS(No Reason)[50]", pID, Seconds, reason ) ) return SendUsage( playerid, "/jail [PLAYER_ID] [SECONDS] [REASON]");
	else if ( Seconds > 20000 || Seconds < 1 ) return SendError( playerid, "You're misleading the seconds limit ( 0 - 20000 )");
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else
	{
		if ( p_AdminCommandPause[ pID ] > g_iTime )
			return SendError( playerid, "You must wait %d seconds before using this admin command on the player.", p_AdminCommandPause[ pID ] - g_iTime );

		p_AdminCommandPause[ pID ] = g_iTime + ADMIN_COMMAND_TIME;
	    AddAdminLogLineFormatted( "%s(%d) has jailed %s(%d) for %d seconds", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, Seconds );
        JailPlayer( pID, Seconds, 1 );
	    if ( Seconds > 60 ) cmd_rules( pID, "" ); // Force rules
	    SendGlobalMessage( -1, ""COL_GOLD"[JAIL]{FFFFFF} %s(%d) has been sent to jail for %d seconds by %s "COL_GREEN"[REASON: %s]", ReturnPlayerName( pID ), pID, Seconds, ReturnPlayerName( playerid ), reason );
	}
	return 1;
}

CMD:unjail( playerid, params [ ] )
{
    new
	    pID
	;
	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/unjail [PLAYER_ID]");
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( !IsPlayerJailed( pID ) ) return SendError( playerid, "This player is not jailed." );
	else
	{
	   	CallLocalFunction( "OnPlayerUnjailed", "dd", pID, 3 );
	    AddAdminLogLineFormatted( "%s(%d) has unjailed %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
	    SendGlobalMessage( -1, ""COL_GOLD"[JAIL]{FFFFFF} %s(%d) has been unjailed by %s(%d).", ReturnPlayerName( pID ), pID, ReturnPlayerName( playerid ), playerid );
	}
	return 1;
}

CMD:spec( playerid, params[ ] )
{
	new
		pID
	;

	if ( p_AdminLevel[ playerid ] < 1 && !IsPlayerUnderCover( playerid ) ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, ""#sscanf_u"", pID ) ) SendUsage(playerid, "/spec [PLAYER_ID]");
    else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError(playerid, "Invalid Player ID.");
    else if ( pID == playerid ) return SendError(playerid, "You cannot spectate yourself.");
    else
    {
        if ( p_Spectating{ playerid } == true )
        {
			if ( IsPlayerConnected( p_whomSpectating[ playerid ] ) ) {
            	p_beingSpectated[ p_whomSpectating[ playerid ] ] = false;
            	p_whomSpectating[ playerid ] = INVALID_PLAYER_ID;
			}
        }

        for( new i; i < sizeof( p_SpectateWeapons[ ] ); i++ )
        {
        	GetPlayerWeaponData( playerid, i, p_SpectateWeapons[ playerid ] [ i ] [ 0 ], p_SpectateWeapons[ playerid ] [ i ] [ 1 ] );
        	if ( p_SpectateWeapons[ playerid ] [ i ] [ 1 ] > 10000 ) p_SpectateWeapons[ playerid ] [ i ] [ 1 ] = 15000;
        }

        SetPlayerInterior( playerid, GetPlayerInterior( pID ) );
        SetPlayerVirtualWorld( playerid, GetPlayerVirtualWorld( pID ) );

  		if ( !IsPlayerUnderCover( playerid ) ) {
			AddAdminLogLineFormatted( "%s(%d) is spectating %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
		}

        p_Spectating{ playerid } = true;
        p_whomSpectating[ playerid ] = pID;
        p_beingSpectated[ pID ] = true;
		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You are now spectating %s(%d).", ReturnPlayerName( pID ), pID );
		if ( IsPlayerInAnyVehicle( pID ) )
		{
			TogglePlayerSpectating(playerid, 1),
			PlayerSpectateVehicle( playerid, GetPlayerVehicleID( pID ) );
		}
		else
		{
			TogglePlayerSpectating( playerid, 1 ),
			PlayerSpectatePlayer( playerid, pID );
		}
    }
    return 1;
}

CMD:specoff( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 1 && !IsPlayerUnderCover( playerid ) ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    if ( p_Spectating{ playerid } == true )
	{
		TogglePlayerSpectating( playerid, 0 );
		if ( IsPlayerConnected( p_whomSpectating[ playerid ] ) ) {
       		p_beingSpectated[ p_whomSpectating[ playerid ] ] = false;
           	p_whomSpectating[ playerid ] = INVALID_PLAYER_ID;
		}
		p_Spectating{ playerid } = false;
		SendServerMessage( playerid, "Spectation has been closed." );
	}
	else SendError(playerid, "You're not spectating!");
	return 1;
}


CMD:goto( playerid, params[ ] )
{
    new
		pID, veh,
		Float: X,
		Float: Y,
		Float: Z
	;

	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, ""#sscanf_u"D(1)", pID, veh ) ) return SendUsage( playerid, "/goto [PLAYER_ID] [IN_VEHICLE]" );
    else if ( !IsPlayerConnected(pID) ) return SendError(playerid, "Invalid Player ID.");
    else if ( !( 0 <= veh <= 1 ) ) return SendError( playerid, "The no vehicle parameter must be set between 0 and 1." );
    else if ( pID == playerid ) return SendError(playerid, "You cannot go to yourself.");
    else
    {
        GetPlayerPos( pID, X, Y, Z );
		SetPlayerPosition( playerid, X, Y + 2, Z, GetPlayerInterior( pID ), GetPlayerVirtualWorld( pID ), veh );
        AddAdminLogLineFormatted( "%s(%d) has teleported to %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
        if ( p_InHouse[ playerid ] != -1 ) p_InHouse[ playerid ] = -1;
        if ( p_InGarage[ playerid ] != -1 ) p_InGarage[ playerid ] = -1;
        if ( p_inPaintBall{ playerid } ) LeavePlayerPaintball( playerid );
    }
    return 1;
}

CMD:mutelist( playerid, params[ ] )
{
	new
		count = 0, time = g_iTime;

	if ( p_AdminLevel[ playerid ] < 1 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	SendClientMessage( playerid, COLOR_PINK, ".: Mute List :." );
	foreach(new i : Player)
	{
	    if ( p_Muted{ i } == true && time < p_MutedTime[ i ] )
	    {
	        SendClientMessageFormatted( playerid, COLOR_GREY, "%s (%s)", ReturnPlayerName( i ), secondstotime( p_MutedTime[ i ] - time ) );
	        count++;
	    }
	}
	if ( count == 0 ) SendClientMessage( playerid, COLOR_GREY, "There are no muted players online." );
	return 1;
}

/* Level 2 */
CMD:slay( playerid, params[ ] )
{
	new
		pID
	;
	if ( p_AdminLevel[ playerid ] < 2 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/slay [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( p_PlayerLogged{ pID } == false ) return SendError( playerid, "This player is not logged in." );
	else
	{
		SetPlayerHealth( pID, -1 );
		AddAdminLogLineFormatted( "%s(%d) has slain %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have slain %s(%d)!", ReturnPlayerName( pID ), pID );
		SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have been slain by %s(%d)!", ReturnPlayerName( playerid ), playerid );
	}
	return 1;
}

CMD:viewnotes( playerid, params[ ] )
{
	new
		pID
	;

	if ( p_AdminLevel[ playerid ] < 2 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, #sscanf_u, pID ) ) return SendUsage( playerid, "/viewnotes [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else
	{
		format( szNormalString, 96, "SELECT `ID`,`TIME`,`NOTE`,`DELETED` FROM `NOTES` WHERE `USER_ID`=%d AND DELETED IS NULL", p_AccountID[ pID ] );
		mysql_function_query( dbHandle, szNormalString, true, "readplayernotes", "d", playerid );
	}
	return 1;
}

CMD:suspend( playerid, params [ ] )
{
    new
	    pID,
		reason[ 50 ],
		hours, days
	;
	if ( p_AdminLevel[ playerid ] < 2 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"ddS(No Reason)[50]", pID, hours, days, reason ) ) SendUsage( playerid, "/suspend [PLAYER_ID] [HOURS] [DAYS] [REASON]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( hours < 0 || hours > 24 ) return SendError( playerid, "Please specify an hour between 0 and 24." );
	else if ( days < 0 || days > 60 ) return SendError( playerid, "Please specifiy the amount of days between 0 and 60." );
	else if ( days == 0 && hours == 0 ) return SendError( playerid, "Invalid time specified." );
	else if ( pID == playerid ) return SendError( playerid, "You cannot suspend yourself." );
    else if ( p_AdminLevel[ playerid ] < p_AdminLevel[ pID ] ) return SendError( playerid, "This player has a higher administration level than you." );
	else
	{
		adhereBanCodes( reason );
        AddAdminLogLineFormatted( "%s(%d) has suspended %s(%d) for %d h %d d", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, hours, days );
	    SendGlobalMessage( -1, ""COL_PINK"[ADMIN]{FFFFFF} %s has suspended %s(%d) for %d hour(s) and %d day(s) "COL_GREEN"[REASON: %s]", ReturnPlayerName( playerid ), ReturnPlayerName( pID ), pID, hours, days, reason );
		//GetPlayerIp( pID, ip, sizeof( ip ) );
		new time = g_iTime + ( hours * 3600 ) + ( days * 86400 );
		AdvancedBan( pID, ReturnPlayerName( playerid ), reason, ReturnPlayerIP( pID ), time );
	}
	return 1;
}

CMD:arenas( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 2 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    ShowPlayerDialog( playerid, DIALOG_ARENAS, DIALOG_STYLE_LIST, "{FFFFFF}Arena Selection", "Warehouse 1\nWarehouse 2\nBloodbowl\n8-Track\nRC Battlefield\nBar\nCrack Factory\nLiberty City Inside\nLV Warehouse\nKickstart\nDirt Track\nDodge The Plane", "Select", "Cancel" );
	return 1;
}

CMD:explode( playerid, params[ ] )
{
    new pID, Float: offset;
	if ( p_AdminLevel[ playerid ] < 2 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if (sscanf( params, ""#sscanf_u"F(0.0)", pID, offset)) SendUsage(playerid, "/explode [PLAYER_ID] [VEHICLE OFFSET (= 0.0)]");
    else if ( !IsPlayerConnected(pID) ) return SendError(playerid, "Invalid Player ID.");
    else if ( p_AdminLevel[ pID ] > p_AdminLevel[ playerid ] ) return SendError(playerid, "You cannot use this command on admins higher than your level.");
    else {
        new Float: X, Float: Y, Float: Z;
        GetPlayerPos( pID, X, Y, Z );
		AddAdminLogLineFormatted( "%s(%d) has exploded %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
        SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have exploded %s(%d)", ReturnPlayerName( pID ), pID );

        if ( IsPlayerInAnyVehicle( pID ) )
        {
        	new Float: Angle;
        	GetVehicleZAngle( GetPlayerVehicleID( pID ), Angle );
		    X += ( offset * floatsin( -Angle, degrees ) );
		    Y += ( offset * floatcos( -Angle, degrees ) );
        }

        CreateExplosion( X, Y, Z, 12, 10.0 );
    }
    return 1;
}

CMD:vrespawn( playerid, params[ ] )
{
	new
		vID
	;

	if ( p_AdminLevel[ playerid ] < 2 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d", vID ) )
	{
		if ( ( vID = GetPlayerVehicleID( playerid ) ) != 0 ) {
			SetVehicleToRespawn( vID );
			return SendServerMessage( playerid, "You have respawned your vehicle." );
		}
		return SendUsage( playerid, "/vrespawn [VEHICLE_ID]" );
	}
	else if ( !IsValidVehicle( vID ) ) return SendError( playerid, "Invalid Vehicle ID" );
	else if ( IsVehicleSecurityVehicle( vID ) ) return SendError( playerid, "This vehicle is prohibited." );
	else
	{
	    SetVehicleToRespawn( vID );
		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have set the vehicle ID %d to respawn.", vID );
	}
	return 1;
}

CMD:vdestroy( playerid, params[ ] )
{
	new
		vID
	;

	if ( p_AdminLevel[ playerid ] < 2 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d", vID ) )
	{
		if ( GetPlayerSpecialAction( playerid ) == SPECIAL_ACTION_USEJETPACK )
		{
			SetPlayerSpecialAction( playerid, SPECIAL_ACTION_NONE );
			return SendServerMessage( playerid, "You have destroyed the jetpack you were using." );
		}

		if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You're not in any vehicle." );
		vID = GetPlayerVehicleID( playerid );
		if ( g_buyableVehicle{ vID } == true ) return SendError( playerid, "You cannot use this command to destroy buyable vehicles." );
		if ( IsVehicleSecurityVehicle( vID ) ) return SendError( playerid, "This vehicle is prohibited." );
		if ( g_TrolleyVehicles[ 0 ] == vID || g_TrolleyVehicles[ 1 ] == vID || g_TrolleyVehicles[ 2 ] == vID || g_TrolleyVehicles[ 3 ] == vID || g_TrolleyVehicles[ 4 ] == vID ) return SendError( playerid, "This vehicle is prohibited." );
	    DestroyVehicle( vID );
	    if ( g_adminSpawnedCar{ vID } ) g_adminSpawnedCar{ vID } = false;
		SendClientMessage( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have destroyed the vehicle you were using." );
		printf( "[DESTROY VEHICLE] %s has destroyed a %d (id %d) - ADMIN: %s", ReturnPlayerName( playerid ), GetVehicleModel( vID ), vID, g_adminSpawnedCar{ vID } == true ? ( "true" ) : ( "false" ) );
	}
	else if ( !IsValidVehicle( vID ) ) return SendError( playerid, "Invalid Vehicle ID" );
	else if ( g_buyableVehicle{ vID } == true ) return SendError( playerid, "You cannot use this command to destroy buyable vehicles." );
	else if ( IsVehicleSecurityVehicle( vID ) ) return SendError( playerid, "This vehicle is prohibited." );
	else if ( g_TrolleyVehicles[ 0 ] == vID || g_TrolleyVehicles[ 1 ] == vID || g_TrolleyVehicles[ 2 ] == vID || g_TrolleyVehicles[ 3 ] == vID || g_TrolleyVehicles[ 4 ] == vID ) return SendError( playerid, "This vehicle is prohibited." );
	else
	{
		DestroyVehicle( vID );
		if ( g_adminSpawnedCar{ vID } ) g_adminSpawnedCar{ vID } = false;
		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have destroyed the vehicle ID %d.", vID );
	    printf( "[DESTROY VEHICLE] %s has destroyed a %d (id %d) - ADMIN: %s", ReturnPlayerName( playerid ), GetVehicleModel( vID ), vID, g_adminSpawnedCar{ vID } == true ? ( "true" ) : ( "false" ) );
	}
	return 1;
}

CMD:mute( playerid, params[ ] )
{
    new pID, seconds, reason[ 32 ];

	if ( p_AdminLevel[ playerid ] < 2 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, ""#sscanf_u"dS(No Reason)[32]", pID, seconds, reason ) ) return SendUsage(playerid, "/mute [PLAYER_ID] [SECONDS] [REASON]");
    else if ( !IsPlayerConnected( pID ) ) return SendError(playerid, "Invalid Player ID.");
    else if ( pID == playerid ) return SendError(playerid, "You cannot mute yourself.");
   	else if ( p_AdminLevel[ pID ] > p_AdminLevel[ playerid ] ) return SendError(playerid, "You cannot use this command on admins higher than your level.");
    else if ( seconds < 0 || seconds > 10000000 ) return SendError( playerid, "Specify the amount of seconds from 1 - 10000000." );
    else
	{
		if ( p_AdminCommandPause[ pID ] > g_iTime )
			return SendError( playerid, "You must wait %d seconds before using this admin command on the player.", p_AdminCommandPause[ pID ] - g_iTime );

		p_AdminCommandPause[ pID ] = g_iTime + ADMIN_COMMAND_TIME;
		AddAdminLogLineFormatted( "%s(%d) has muted %s(%d) for %d seconds", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, seconds );
        SendGlobalMessage( -1, ""COL_PINK"[ADMIN]{FFFFFF} %s has been muted by %s for %d seconds "COL_GREEN"[REASON: %s]", ReturnPlayerName( pID ), ReturnPlayerName( playerid ), seconds, reason );
		GameTextForPlayer( pID, "~r~Muted!", 4000, 4 );
        p_Muted{ pID } = true;
        p_MutedTime[ pID ] = g_iTime + seconds;
    }
    return 1;
}

CMD:unmute( playerid, params[ ] )
{
    new pID;

	if ( p_AdminLevel[ playerid ] < 2 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, ""#sscanf_u"", pID )) SendUsage(playerid, "/mute [PLAYER_ID]");
    else if ( !IsPlayerConnected( pID ) ) return SendError(playerid, "Invalid Player ID.");
    else if ( pID == playerid ) return SendError( playerid, "You cannot un-mute yourself." );
    else if ( !p_Muted{ pID } ) return SendError( playerid, "This player isn't muted" );
    else
	{
		AddAdminLogLineFormatted( "%s(%d) has un-muted %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
        SendGlobalMessage( -1, ""COL_PINK"[ADMIN]{FFFFFF} %s has been un-muted by %s.", ReturnPlayerName(pID), ReturnPlayerName( playerid ));
		GameTextForPlayer( pID, "~g~Un-Muted!", 4000, 4 );
        p_Muted{ pID } = false;
        p_MutedTime[ pID ] = 0;
    }
    return 1;
}

CMD:kick( playerid, params[ ] )
{
    new
        pID,
        reason[ 70 ]
	;

	if ( p_AdminLevel[ playerid ] < 2 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, ""#sscanf_u"S(No reason)[70]", pID, reason ) ) SendUsage( playerid, "/kick [PLAYER_ID] [REASON]" );
    else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
    else if ( pID == playerid ) return SendError( playerid, "You cant kick yourself." );
    else if ( p_AdminLevel[ pID ] > p_AdminLevel[ playerid ] ) return SendError( playerid, "You cannot use this command on admins higher than your level." );
    else
	{
		adhereBanCodes( reason );
		AddAdminLogLineFormatted( "%s(%d) has kicked %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
        SendGlobalMessage( -1, ""COL_PINK"[ADMIN]{FFFFFF} %s has been kicked by %s. "COL_GREEN"[REASON: %s]", ReturnPlayerName(pID), ReturnPlayerName( playerid ), reason);
        KickPlayerTimed( pID );
    }
    return 1;
}

/* Level 3 */
CMD:smlog( playerid, params[ ] )
{
	new
		pID
	;

	if ( p_AdminLevel[ playerid ] < 2 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, #sscanf_u, pID ) ) return SendUsage( playerid, "/smlog [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else
	{
		format( szBigString, 160, "SELECT u.`NAME`,t.`CASH`,t.`DATE` FROM `TRANSACTIONS` t INNER JOIN `USERS` u ON t.`TO_ID`=u.`ID` WHERE FROM_ID=%d ORDER BY DATE DESC LIMIT 10", p_AccountID[ pID ] );
		mysql_function_query( dbHandle, szBigString, true, "readmoneylog", "dd", playerid, pID );
	}
	return 1;
}

CMD:iclog( playerid, params[ ] )
{
	new
		pID
	;

	if ( p_AdminLevel[ playerid ] < 2 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, #sscanf_u, pID ) ) return SendUsage( playerid, "/iclog [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else
	{
		format( szBigString, 160, "SELECT u.`NAME`,t.`IC`,t.`DATE` FROM `TRANSACTIONS_IC` t INNER JOIN `USERS` u ON t.`TO_ID`=u.`ID` WHERE FROM_ID=%d ORDER BY DATE DESC LIMIT 10", p_AccountID[ pID ] );
		mysql_function_query( dbHandle, szBigString, true, "readiclog", "dd", playerid, pID );
	}
	return 1;
}

CMD:resetwep( playerid, params[ ] )
{
	new
		pID
	;
	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/resetwep [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else
	{
		ResetPlayerWeapons( pID );
        AddAdminLogLineFormatted( "%s(%d) has reset %s(%d)'s weapons", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have reset %s(%d)'s weapons.", ReturnPlayerName( pID ), pID );
		SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]"COL_WHITE" Your weapons have been reset by %s(%d).", ReturnPlayerName( playerid ), playerid );
	}
	return 1;
}

CMD:getip( playerid, params[ ] )
{
	new
		pID
	;
	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/getip [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( p_AdminLevel[ pID ] >= 5 || strmatch( ReturnPlayerName( pID ), "Lorenc" ) ) return SendError( playerid, "I love this person so much that I wont give you his IP :)");
	else
	{
		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" %s(%d): "COL_GREY"%s", ReturnPlayerName( pID ), pID, ReturnPlayerIP( pID ) );
	}
	return 1;
}

CMD:geolocate( playerid, params[ ] )
{
	new pID;
 	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
 	else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/geolocate [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( !IsProxyEnabledForPlayer( pID ) ) return SendError( playerid, "The server has failed to fetch geographical data. Please use a 3rd party." );
	else if ( p_AdminLevel[ pID ] >= 5 || strmatch( ReturnPlayerName( pID ), "Lorenc" ) ) return SendError( playerid, "I love this person so much that I wont give you his geographical data! :)");
 	else
 	{
 		if ( IsPlayerUnderCover( pID ) )
 		{
			SendClientMessageFormatted( playerid, COLOR_PINK, "[ADMIN]"COL_WHITE" %s(%d) is from America (US) [%s]", ReturnPlayerName( pID ), pID, GetPlayerCountryName( pID ), GetPlayerCountryCode( pID ), ReturnPlayerIP( pID ) );
		}
		else
		{
	 		SendClientMessageFormatted( playerid, COLOR_PINK, "[ADMIN]"COL_WHITE" %s(%d) is from %s (%s) [%s]", ReturnPlayerName( pID ), pID, GetPlayerCountryName( pID ), GetPlayerCountryCode( pID ), ReturnPlayerIP( pID ) );
 		}
	}
	return 1;
}

CMD:copwarn( playerid, params [ ] )
{
    new
	    pID,
	    reason[ 32 ]
	;
	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"S(No Reason)[32]", pID, reason ) ) return SendUsage( playerid, "/copwarn [PLAYER_ID] [REASON]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( p_CopBanned{ pID } >= MAX_CLASS_BAN_WARNS ) return SendError( playerid, "This player is cop-banned." );
    else if ( p_AdminLevel[ playerid ] < p_AdminLevel[ pID ] ) return SendError( playerid, "This player has a higher administration level than you." );
	else
	{
		if ( p_AdminCommandPause[ pID ] > g_iTime )
			return SendError( playerid, "You must wait %d seconds before using this admin command on the player.", p_AdminCommandPause[ pID ] - g_iTime );

		p_AdminCommandPause[ pID ] = g_iTime + ADMIN_COMMAND_TIME;

		new
			iWarns = WarnPlayerClass( pID, .bArmy = false );

		if ( iWarns >= MAX_CLASS_BAN_WARNS )
		{
	        AddAdminLogLineFormatted( "%s(%d) has cop-banned %s(%d) [%d/" #MAX_CLASS_BAN_WARNS "]", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, iWarns );
		    SendGlobalMessage( -1, ""COL_PINK"[ADMIN]{FFFFFF} %s has cop-banned %s(%d) due to excessive cop-warnings "COL_GREEN"[REASON: %s]", ReturnPlayerName( playerid ), ReturnPlayerName( pID ), pID, reason );
		}
		else
		{
	        AddAdminLogLineFormatted( "%s(%d) has cop-warned %s(%d) [%d/" #MAX_CLASS_BAN_WARNS "]", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, iWarns );
		    SendGlobalMessage( -1, ""COL_PINK"[ADMIN]{FFFFFF} %s has cop-warned %s(%d) "COL_GREEN"[REASON: %s]", ReturnPlayerName( playerid ), ReturnPlayerName( pID ), pID, reason );
		}
	}
	return 1;
}

CMD:armywarn( playerid, params [ ] )
{
    new
	    pID,
	    reason[ 32 ]
	;
	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"S(No Reason)[32]", pID, reason ) ) return SendUsage( playerid, "/armywarn [PLAYER_ID] [REASON]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( p_ArmyBanned{ pID } >= MAX_CLASS_BAN_WARNS ) return SendError( playerid, "This player is army-banned." );
    else if ( p_AdminLevel[ playerid ] < p_AdminLevel[ pID ] ) return SendError( playerid, "This player has a higher administration level than you." );
	else
	{
		if ( p_AdminCommandPause[ pID ] > g_iTime )
			return SendError( playerid, "You must wait %d seconds before using this admin command on the player.", p_AdminCommandPause[ pID ] - g_iTime );

		p_AdminCommandPause[ pID ] = g_iTime + ADMIN_COMMAND_TIME;

		new
			iWarns = WarnPlayerClass( pID, .bArmy = true );

		if ( iWarns >= MAX_CLASS_BAN_WARNS )
		{
	        AddAdminLogLineFormatted( "%s(%d) has army-banned %s(%d) [%d/" #MAX_CLASS_BAN_WARNS "]", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, iWarns );
		    SendGlobalMessage( -1, ""COL_PINK"[ADMIN]{FFFFFF} %s has army-banned %s(%d) due to excessive army-warnings "COL_GREEN"[REASON: %s]", ReturnPlayerName( playerid ), ReturnPlayerName( pID ), pID, reason );
		}
		else
		{
	        AddAdminLogLineFormatted( "%s(%d) has army-warned %s(%d) [%d/" #MAX_CLASS_BAN_WARNS "]", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, iWarns );
		    SendGlobalMessage( -1, ""COL_PINK"[ADMIN]{FFFFFF} %s has army-warned %s(%d) "COL_GREEN"[REASON: %s]", ReturnPlayerName( playerid ), ReturnPlayerName( pID ), pID, reason );
		}
	}
	return 1;
}

CMD:rcopwarn( playerid, params [ ] )
{
    new
	    pID;

	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, #sscanf_u, pID ) ) return SendUsage( playerid, "/rcopwarn [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( !p_CopBanned{ pID } ) return SendError( playerid, "This player does not have any cop warns." );
    else if ( p_AdminLevel[ playerid ] < p_AdminLevel[ pID ] ) return SendError( playerid, "This player has a higher administration level than you." );
	else
	{
		new
			iWarns = WarnPlayerClass( pID, .bArmy = false, .iPoints = -1 );

        AddAdminLogLineFormatted( "%s(%d) has removed a cop-warn from %s(%d) [%d/" #MAX_CLASS_BAN_WARNS "]", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, iWarns );
	    SendGlobalMessage( -1, ""COL_PINK"[ADMIN]{FFFFFF} %s has removed a cop-warn from %s(%d)!", ReturnPlayerName( playerid ), ReturnPlayerName( pID ), pID );
	}
	return 1;
}

CMD:rarmywarn( playerid, params [ ] )
{
    new
	    pID;

	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, #sscanf_u, pID ) ) return SendUsage( playerid, "/rarmywarn [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( !p_ArmyBanned{ pID } ) return SendError( playerid, "This player does not have any army warns." );
    else if ( p_AdminLevel[ playerid ] < p_AdminLevel[ pID ] ) return SendError( playerid, "This player has a higher administration level than you." );
	else
	{
		new
			iWarns = WarnPlayerClass( pID, .bArmy = true, .iPoints = -1 );

        AddAdminLogLineFormatted( "%s(%d) has removed an army-warn from %s(%d) [%d/" #MAX_CLASS_BAN_WARNS "]", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, iWarns );
	    SendGlobalMessage( -1, ""COL_PINK"[ADMIN]{FFFFFF} %s has removed an army-warn from %s(%d)!", ReturnPlayerName( playerid ), ReturnPlayerName( pID ), pID );
	}
	return 1;
}

/*CMD:forcecoptutorial( playerid, params[ ] )
{
	new pID;
	if ( p_AdminLevel[ playerid ] < 2 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, ""#sscanf_u"", pID ) ) SendUsage( playerid, "/forcecoptutorial [PLAYER_ID]" );
    else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
    else if ( p_AdminLevel[ pID ] > p_AdminLevel[ playerid ] ) return SendError( playerid, "You cannot use this command on admins higher than your level." );
    else
	{
	    SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]"COL_WHITE" %s(%d) has forced you to view the law enforcement officer tutorial.", ReturnPlayerName( playerid ), playerid );
		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have forced the law enforcement officer tutorial on %s(%d).", ReturnPlayerName( pID ), pID );
		p_CopTutorial{ pID } = 0;
		if ( p_Class[ pID ] == CLASS_POLICE ) SpawnPlayer( pID );
	}
	return 1;
}*/

CMD:ann( playerid, params[ ] ) return cmd_announce( playerid, params );
CMD:announce( playerid, params[ ] )
{
    new Message[60];
	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, "s[60]", Message ) ) SendUsage(playerid, "/announce [MESSAGE]");
    else if ( !IsSafeGameText( Message ) ) return SendError( playerid, "Your message is not safe for players to view." );
    else
	{
        GameTextForAll( sprintf( "~w~%s", Message ), 6000, 3 );
        printf( "[ANNOUNCEMENT]: %s(%d) has announced \"%s\"", ReturnPlayerName( playerid ), playerid, Message );

		strreplacechar	( Message, '~', ']' );
        AddAdminLogLineFormatted( "%s(%d) has announced \"%s\"", ReturnPlayerName( playerid ), playerid, Message );
    }
    return 1;
}

CMD:aheal( playerid, params[ ] )
{
	new pID;
	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, #sscanf_u, pID ) ) SendUsage( playerid, "/aheal [PLAYER_ID]" );
    else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
    else if ( IsPlayerJailed( pID ) ) return SendError( playerid, "This player is jailed, you cannot do this." );
    else if ( IsPlayerAdminOnDuty( pID ) ) return SendError( playerid, "This player is an admin on duty, you cannot do this." );
    else
	{
	    SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]"COL_WHITE" %s(%d) healed you.", ReturnPlayerName( playerid ), playerid );
		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have healed %s(%d).", ReturnPlayerName( pID ), pID );
        AddAdminLogLineFormatted( "%s(%d) has healed %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
		SetPlayerHealth( pID, 100.0 );
	}
	return 1;
}

CMD:healall( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 3 )
		return SendError( playerid, ADMIN_COMMAND_REJECT );

	AddAdminLogLineFormatted( "%s(%d) has healed everybody", ReturnPlayerName( playerid ), playerid );
	foreach(new i : Player) {
	    if ( !p_Jailed{ i } ) SetPlayerHealth( i, p_AdminOnDuty{ i } == true ? float( INVALID_PLAYER_ID ) : 100.0 );
	}
	SendGlobalMessage( -1, ""COL_PINK"[ADMIN]"COL_WHITE" Everyone has been healed by %s(%d)!", ReturnPlayerName( playerid ), playerid );
	return 1;
}

CMD:vadminstats( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 3 )
		return SendError( playerid, ADMIN_COMMAND_REJECT );

	if ( !IsPlayerInAnyVehicle( playerid ) )
	    return SendError( playerid, "You are not in any vehicle." );

	if ( g_buyableVehicle{ GetPlayerVehicleID( playerid ) } == false )
		return SendError( playerid, "This vehicle isn't a buyable vehicle." );

	new
		ownerid, slotid,
		v = getVehicleSlotFromID( GetPlayerVehicleID( playerid ), ownerid, slotid )
	;

	if ( v == -1 ) return SendError( playerid, "This vehicle doesn't look like it can be examined. (0xAA)" );
	if ( g_vehicleData[ ownerid ] [ slotid ] [ E_CREATED ] == false ) return SendError( playerid, "This vehicle doesn't look like it can be examined. (0xAF)" );

	format( szBigString, sizeof( szBigString ), 	""COL_GREY"Vehicle Owner:"COL_WHITE" %s\n"\
	                            ""COL_GREY"Vehicle Type:"COL_WHITE" %s\n"\
	                            ""COL_GREY"Vehicle ID:"COL_WHITE" %d\n"\
	                            ""COL_GREY"Vehicle Price:"COL_WHITE" %s",
	                            ReturnPlayerName( ownerid ), GetVehicleName( GetVehicleModel( GetPlayerVehicleID( playerid ) ) ),
	                            g_vehicleData[ ownerid ] [ slotid ] [ E_SQL_ID ], ConvertPrice( g_vehicleData[ ownerid ] [ slotid ] [ E_PRICE ] ) );

	ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_MSGBOX, "{FFFFFF}Vehicle Data", szBigString, "Okay", "" );
	return 1;
}

CMD:vadminpark( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 3 )
		return SendError( playerid, ADMIN_COMMAND_REJECT );

	if ( !IsPlayerInAnyVehicle( playerid ) )
	    return SendError( playerid, "You are not in any vehicle." );

	if ( g_buyableVehicle{ GetPlayerVehicleID( playerid ) } == false )
		return SendError( playerid, "This vehicle isn't a buyable vehicle." );

	new
		ownerid, slotid, vehicleid = GetPlayerVehicleID( playerid ),
		v = getVehicleSlotFromID( vehicleid, ownerid, slotid ),
		Float: X, Float: Y, Float: Z, Float: Angle
	;

	if ( v == -1 ) return SendError( playerid, "This vehicle doesn't look like it can be parked. (0xAA)" );
	if ( g_vehicleData[ ownerid ] [ slotid ] [ E_CREATED ] == false ) return SendError( playerid, "This vehicle doesn't look like it can be parked. (0xAF)" );

    new
    	iBreach = PlayerBreachedGarageLimit( playerid, v, .admin_place = true );

	if ( iBreach == -1 ) return SendError( playerid, "You cannot park vehicles that are not owned by the owner of this garage." );
	if ( iBreach == -2 ) return SendError( playerid, "This garage has already reached its capacity of %d vehicles.", g_garageInteriorData[ g_garageData[ p_InGarage[ playerid ] ] [ E_INTERIOR_ID ] ] [ E_VEHICLE_CAPACITY ] );

	GetVehiclePos( vehicleid, X, Y, Z );
	GetVehicleZAngle( vehicleid, Angle );

	g_vehicleData[ ownerid ] [ slotid ] [ E_X ] = X, g_vehicleData[ ownerid ] [ slotid ] [ E_Y ] = Y, g_vehicleData[ ownerid ] [ slotid ] [ E_Z ] = Z, g_vehicleData[ ownerid ] [ slotid ] [ E_ANGLE ] = Angle;

	PutPlayerInVehicle( playerid, RespawnBuyableVehicle( vehicleid, playerid ), 0 );
	SaveVehicleData( ownerid, slotid );

	SendClientMessage( playerid, -1, ""COL_GREY"[VEHICLE]"COL_WHITE" You have parked this vehicle via administration." );
	return 1;
}

CMD:givewep( playerid, params[ ] ) return cmd_giveweapon( playerid, params );
CMD:giveweapon( playerid, params[ ] )
{
    new
		pID,
		wep,
		ammo,
		gunname[ 32 ]
	;

	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, ""#sscanf_u"dd", pID, wep, ammo ) ) return SendUsage(playerid, "/giveweapon [PLAYER_ID] [WEAPON_ID] [AMMO]");
    else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
    else if ( !( 0 <= wep < MAX_WEAPONS ) || wep == 47 ) return SendError(playerid, "Invalid weapon id");
    else if ( IsWeaponBanned( wep ) && p_AdminLevel[ pID ] < 5 ) return SendError( playerid, "This weapon is a banned weapon, you cannot spawn this." );
    else
	{
		printf("%s banned wep %d - admin level %d", ReturnPlayerName( pID ), wep, p_AdminLevel[ playerid ]);
        GetWeaponName( wep, gunname, sizeof( gunname ) );
        AddAdminLogLineFormatted( "%s(%d) has given %s(%d) a %s", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, gunname );
		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have given %s(%d) a %s(%d)", ReturnPlayerName( pID ), pID, gunname, wep );
        SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have been given a %s from %s(%d)", gunname, ReturnPlayerName( playerid ), playerid );
        GivePlayerWeapon( pID, wep, ammo );
    }
    return 1;
}

CMD:cc( playerid, params[ ] ) return cmd_clearchat( playerid, params );
CMD:clearchat( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	for( new i = 0; i < 50; i++ ) {
	    SendClientMessageToAll( -1, " " );
	}
    SendGlobalMessage( -1, ""COL_PINK"[ADMIN]{FFFFFF} %s cleared the chat.", ReturnPlayerName( playerid ) );
	AddAdminLogLineFormatted( "%s(%d) has cleared the chat", ReturnPlayerName( playerid ), playerid );
	return 1;
}

CMD:vbring( playerid, params[ ] )
{
	new vID;
	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d", vID ) ) return SendUsage( playerid, "/vbring [VEHICLE_ID]" );
	else if ( !IsValidVehicle( vID ) ) return SendError( playerid, "Invalid Vehicle ID." );
	else
	{
	    new Float: X, Float: Y, Float: Z;
	    GetPlayerPos( playerid, X, Y, Z );
	    LinkVehicleToInterior( vID, GetPlayerInterior( playerid ) );
	    SetVehicleVirtualWorld( vID, GetPlayerVirtualWorld( playerid ) );
	    SetVehiclePos( vID, X + 1, Y + 1, Z );
	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have brought vehicle id %d to you.", vID );
	  	AddAdminLogLineFormatted( "%s(%d) has brought vehicle id %d to them", ReturnPlayerName( playerid ), playerid, vID );
    }
	return 1;
}

CMD:vgoto( playerid, params[ ] )
{
	new vID;
	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d", vID ) ) return SendUsage( playerid, "/vgoto [VEHICLE_ID]" );
	else if ( !IsValidVehicle( vID ) ) return SendError( playerid, "Invalid Vehicle ID." );
	else
	{
	    new Float: X, Float: Y, Float: Z;
	    GetVehiclePos( vID, X, Y, Z );
	    SetPlayerPos( playerid, X + 1, Y + 1, Z );
	    SetPlayerInterior( playerid, 0 );
	    SetPlayerVirtualWorld( playerid, 0 );
	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have gone to vehicle id %d.", vID );
	  	AddAdminLogLineFormatted( "%s(%d) has gone to vehicle id %d", ReturnPlayerName( playerid ), playerid, vID );
    }
	return 1;
}

CMD:venter( playerid, params[ ] )
{
	new vID;
	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d", vID ) ) return SendUsage( playerid, "/venter [VEHICLE_ID]" );
	else if ( !IsValidVehicle( vID ) ) return SendError( playerid, "Invalid Vehicle ID." );
	else
	{
		// Maybe virtual world support
	    SetPlayerVirtualWorld( playerid, GetVehicleVirtualWorld( vID ) );
	    PutPlayerInVehicle( playerid, vID, 0 );

	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have entered the vehicle id %d.", vID );
	  	AddAdminLogLineFormatted( "%s(%d) has entered the vehicle id %d", ReturnPlayerName( playerid ), playerid, vID );
    }
	return 1;
}

CMD:vforce( playerid, params[ ] )
{
	new pID, vID;
	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"d", pID, vID ) ) return SendUsage( playerid, "/vforce [PLAYER_ID] [VEHICLE_ID]" );
    else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( !IsValidVehicle( vID ) ) return SendError( playerid, "Invalid Vehicle ID." );
	else
	{
		// Maybe virtual world support
	    SetPlayerVirtualWorld( pID, GetVehicleVirtualWorld( vID ) );
	    PutPlayerInVehicle( pID, vID, 0 );

	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have forced %s(%d) to enter the vehicle id %d.", ReturnPlayerName( pID ), pID, vID );
	  	AddAdminLogLineFormatted( "%s(%d) has forced %s to enter the vehicle id %d.", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), vID );
    }
	return 1;
}

CMD:hgoto( playerid, params[ ] )
{
	new hID;
	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d", hID ) ) return SendUsage( playerid, "/hgoto [HOUSE_ID]" );
	else if ( hID < 0 || hID >= MAX_HOUSES ) return SendError( playerid, "Invalid House ID." );
	else if ( !g_houseData[ hID ] [ E_CREATED ] ) return SendError( playerid, "Invalid House ID." );
	else
	{
	    SetPlayerPos( playerid, g_houseData[ hID ] [ E_EX ], g_houseData[ hID ] [ E_EY ], g_houseData[ hID ] [ E_EZ ] );
	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have went to house id %d.", hID );
	  	AddAdminLogLineFormatted( "%s(%d) has went to house id %d", ReturnPlayerName( playerid ), playerid, hID );
    }
	return 1;
}

CMD:bgoto( playerid, params[ ] )
{
	new bID;
	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d", bID ) ) return SendUsage( playerid, "/bgoto [BUSINESS_ID]" );
	else if ( bID < 0 || bID >= MAX_BUSINESSES ) return SendError( playerid, "Invalid Business ID." );
	else if ( ! Iter_Contains( business, bID ) ) return SendError( playerid, "Invalid Business ID." );
	else
	{
	    SetPlayerPos( playerid, g_businessData[ bID ] [ E_X ], g_businessData[ bID ] [ E_Y ], g_businessData[ bID ] [ E_Z ] );
	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have went to business id %d.", bID );
	  	AddAdminLogLineFormatted( "%s(%d) has went to business id %d", ReturnPlayerName( playerid ), playerid, bID );
    }
	return 1;
}

CMD:cd( playerid, params[ ] ) return cmd_countdown( playerid, params );
CMD:countdown( playerid, params[ ] )
{
	new seconds;
	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d", seconds ) ) return SendUsage( playerid, "/countdown [SECONDS]" );
	else if ( seconds < 0 || seconds > 30 ) return SendError( playerid, "Please specify a time between 0 and 30 seconds." );
	else if ( g_circleall_CD ) return SendError( playerid, "Countdown is already in progress." );
	else
	{
        g_circleall_CD = true;
	    SetTimerEx( "circleall_Countdown", 960, false, "dd", seconds, 1 );
	    SendGlobalMessage( -1, ""COL_PINK"[ADMIN]"COL_WHITE" %s(%d) has initiated a countdown starting from %d.", ReturnPlayerName( playerid ), playerid, seconds );
		AddAdminLogLineFormatted( "%s(%d) has initiated a countdown from %d", ReturnPlayerName( playerid ), playerid, seconds );
    }
	return 1;
}

CMD:pingimmune( playerid, params[ ] )
{
    new pID;
	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/pingimmune [PLAYER_ID]" );
    else if ( !IsPlayerConnected(pID) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
    else if ( p_AdminLevel[ pID ] > 0 ) return SendError( playerid, "Admins already have immunity." );
    else
	{
 		p_PingImmunity{ pID } = ( p_PingImmunity{ pID } == 0 ? 1 : 0 );
		SendGlobalMessage( -1, ""COL_PINK"[ADMIN]"COL_WHITE" %s(%d) has made %s(%d) %s to the ping kicker.", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, p_PingImmunity{ pID } == 0 ? ("prone") : ("immune") );
        AddAdminLogLineFormatted( "%s(%d) has made %s(%d) %s to the ping kicker", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, p_PingImmunity{ pID } == 0 ? ("prone") : ("immune") );
    }
    return 1;
}

CMD:ban( playerid, params [ ] )
{
    new
	    pID,
		reason[ 50 ]
	;
	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"S(No Reason)[50]", pID, reason ) ) return SendUsage( playerid, "/ban [PLAYER_ID] [REASON]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	// else if ( pID == playerid ) return SendError( playerid, "You cannot ban yourself." );
  	else if ( p_AdminLevel[ playerid ] < p_AdminLevel[ pID ] ) return SendError( playerid, "This player has a higher administration level than you." );
	else
	{
		adhereBanCodes( reason );
        AddAdminLogLineFormatted( "%s(%d) has banned %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
	    SendGlobalMessage( -1, ""COL_PINK"[ADMIN]{FFFFFF} %s has banned %s(%d) "COL_GREEN"[REASON: %s]", ReturnPlayerName( playerid ), ReturnPlayerName( pID ), pID, reason );
		AdvancedBan( pID, ReturnPlayerName( playerid ), reason, ReturnPlayerIP( pID ) );
	}
	return 1;
}

CMD:bring( playerid, params[ ] )
{
    new
		pID,
		Float: X,
		Float: Y,
		Float: Z
	;

	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, ""#sscanf_u"", pID ) ) return SendUsage( playerid, "/bring [PLAYER_ID]" );
    else if ( !IsPlayerConnected(pID) ) return SendError(playerid, "Invalid Player ID.");
    else if ( pID == playerid ) return SendError(playerid, "You cannot bring your self.");
    else
	{
    	/*if ( IsPlayerInAnyVehicle( playerid ) ) {
			if ( PutPlayerInEmptyVehicleSeat( GetPlayerVehicleID( playerid ), pID ) )
				return 1;
    	}*/
        GetPlayerPos( playerid, X, Y, Z );
        SetPlayerPos( pID, X, Y + 2, Z );
        SetPlayerInterior( pID, GetPlayerInterior( playerid ) );
        SetPlayerVirtualWorld( pID, GetPlayerVirtualWorld( playerid ) );
        AddAdminLogLineFormatted( "%s(%d) has brought %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
        if ( p_InHouse[ pID ] != -1 ) p_InHouse[ pID ] = -1;
        if ( p_InGarage[ pID ] != -1 ) p_InGarage[ pID ] = -1;
        if ( p_inPaintBall{ pID } ) LeavePlayerPaintball( pID );
    }
    return 1;
}

/* Level 4 */
CMD:destroyallav( playerid, params[ ] )
{
    if ( p_AdminLevel[ playerid ] < 4 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else
	{
	    for( new i; i < MAX_VEHICLES; i++ )
	    {
			if ( IsValidVehicle( i ) && g_adminSpawnedCar{ i } == true ) {
			    g_adminSpawnedCar{ i } = false;
				DestroyVehicle( i );
			}
	    }
		SendServerMessage( playerid, "You have succesfully destroyed all admin spawned vehicles." );
		AddAdminLogLineFormatted( "%s(%d) has destroyed all spawned vehicles", ReturnPlayerName( playerid ), playerid );
	}
	return 1;
}

CMD:event( playerid, params[ ] )
{
 	if ( p_AdminLevel[ playerid ] < 4 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	AddAdminLogLineFormatted( "%s(%d) has changed his world to 69", ReturnPlayerName( playerid ), playerid );
	SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have your world to 69." );
	return SetPlayerVirtualWorld( playerid, 69 );
}

CMD:setworld( playerid, params[ ] )
{
	new pID, worldid;
 	if ( p_AdminLevel[ playerid ] < 4 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
 	else if ( sscanf( params, ""#sscanf_u"d", pID, worldid ) ) return SendUsage( playerid, "/setworld [PLAYER_ID] [WORLD_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
 	else
 	{
 	    SetPlayerVirtualWorld( pID, worldid );

 	    if ( pID != playerid )
		{
	 	    SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]"COL_WHITE" Your world has been set to %d by %s(%d)!", worldid, ReturnPlayerName( playerid ), playerid );
	 		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have changed %s(%d)'s world to %d!", ReturnPlayerName( pID ), pID, worldid );
	 		AddAdminLogLineFormatted( "%s(%d) has changed %s(%d)'s world to %d", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, worldid );
		}
		else
		{
			SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have your world to %d.", worldid );
	 		AddAdminLogLineFormatted( "%s(%d) has changed his world to %d", ReturnPlayerName( pID ), pID, worldid );
		}
	}
	return 1;
}

CMD:setinterior( playerid, params[ ] )
{
	new pID, worldid;
 	if ( p_AdminLevel[ playerid ] < 4 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
 	else if ( sscanf( params, ""#sscanf_u"d", pID, worldid ) ) return SendUsage( playerid, "/setinterior [PLAYER_ID] [INTERIOR_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
 	else
 	{
 	    SetPlayerInterior( pID, worldid );

 	    if ( pID != playerid )
		{
	 	    SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]"COL_WHITE" Your interior has been set to %d by %s(%d)!", worldid, ReturnPlayerName( playerid ), playerid );
	 		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have changed %s(%d)'s interior to %d!", ReturnPlayerName( pID ), pID, worldid );
	 		AddAdminLogLineFormatted( "%s(%d) has changed %s(%d)'s interior to %d", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, worldid );
		}
		else
		{
			SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have your interior to %d.", worldid );
	 		AddAdminLogLineFormatted( "%s(%d) has changed his interior to %d", ReturnPlayerName( pID ), pID, worldid );
		}
	}
	return 1;
}

CMD:uncopban( playerid, params [ ] )
{
    new
	    pID
	;
	if ( p_AdminLevel[ playerid ] < 4 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) SendUsage( playerid, "/uncopban [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( p_CopBanned{ pID } == 0 ) return SendError( playerid, "This player is not cop-banned." );
    else
	{
        AddAdminLogLineFormatted( "%s(%d) has un-cop-banned %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
	    SendGlobalMessage( -1, ""COL_PINK"[ADMIN]{FFFFFF} %s has un-cop-banned %s(%d).", ReturnPlayerName( playerid ), ReturnPlayerName( pID ), pID );
		p_CopBanned{ pID } = 0;
		format( szNormalString, sizeof( szNormalString ), "UPDATE `USERS` SET `COP_BAN`=0 WHERE ID=%d", p_AccountID[ pID ] ), mysql_single_query( szNormalString );
	}
	return 1;
}

CMD:unarmyban( playerid, params [ ] )
{
    new
	    pID
	;
	if ( p_AdminLevel[ playerid ] < 4 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"", pID ) ) SendUsage( playerid, "/unarmyban [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( p_ArmyBanned{ pID } == 0 ) return SendError( playerid, "This player is not army-banned." );
    else
	{
        AddAdminLogLineFormatted( "%s(%d) has un-army-banned %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
	    SendGlobalMessage( -1, ""COL_PINK"[ADMIN]{FFFFFF} %s has un-army-banned %s(%d).", ReturnPlayerName( playerid ), ReturnPlayerName( pID ), pID );
		p_ArmyBanned{ pID } = 0;
		format( szNormalString, sizeof( szNormalString ), "UPDATE `USERS` SET `ARMY_BAN`=0 WHERE ID=%d", p_AccountID[ pID ] ), mysql_single_query( szNormalString );
	}
	return 1;
}

CMD:motd( playerid, params[ ] )
{
	new
	    string[ 90 ]
	;
	if ( p_AdminLevel[ playerid ] < 4 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "s[90]", string ) ) return SendUsage( playerid, "/motd [MESSAGE]" );
	else
	{
		//strreplacechar	( string, '~', ']' );
        AddAdminLogLineFormatted( "%s(%d) has set the motd", ReturnPlayerName( playerid ), playerid );
	    SendServerMessage( playerid, "The MOTD has been changed." );
		TextDrawSetString( g_MotdTD, string );
	}
	return 1;
}

CMD:resetwepall( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 4 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else
	{
		new
			iWorld = GetPlayerVirtualWorld( playerid );

		foreach(new pID : Player)
		{
		   	if ( !IsPlayerSpawned( pID ) || p_PlayerSettings[ pID ] { SETTING_EVENT_TP } )
		   		continue;

		   	if ( IsPlayerAFK( playerid ) )
		   		continue;

		   	if ( iWorld != GetPlayerVirtualWorld( pID ) )
		   		continue;

			ResetPlayerWeapons( pID );
		}

		AddAdminLogLineFormatted( "%s(%d) has reset all player weapons", ReturnPlayerName( playerid ), playerid );
		SendGlobalMessage( -1, ""COL_PINK"[ADMIN]"COL_WHITE" All player weapons have been reset in %s's world.", ReturnPlayerName( playerid ) );
	}
	return 1;
}

CMD:giveweaponall( playerid, params[ ] )
{
    new
		wep,
		ammo,
		gunname[ 32 ]
	;

	if ( p_AdminLevel[ playerid ] < 4 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, "dd", wep, ammo ) ) return SendUsage(playerid, "/giveweaponall [WEAPON_ID] [AMMO]");
    else if ( wep > MAX_WEAPONS || wep <= 0 || wep == 47 ) return SendError(playerid, "Invalid weapon id");
    else if ( IsWeaponBanned( wep ) ) return SendError( playerid, "This weapon is a banned weapon, you cannot spawn this." );
    else
	{
		new
			iWorld = GetPlayerVirtualWorld( playerid );

	    foreach(new pID : Player)
	    {
		   	if ( !IsPlayerSpawned( pID ) || IsPlayerJailed( pID ) || p_PlayerSettings[ pID ] { SETTING_EVENT_TP } )
		   		continue;

		   	if ( IsPlayerAFK( playerid ) )
		   		continue;

		   	if ( iWorld != 0 && iWorld != GetPlayerVirtualWorld( pID ) )
		   		continue;

			GivePlayerWeapon( pID, wep, ammo );
		}

		GetWeaponName( wep, gunname, sizeof( gunname ) );
        AddAdminLogLineFormatted( "%s(%d) has given everyone a %s", ReturnPlayerName( playerid ), playerid, gunname );
		SendGlobalMessage( -1, ""COL_PINK"[ADMIN]"COL_WHITE" Everyone has been given a %s in %s(%d)'s world.", gunname, ReturnPlayerName( playerid ), playerid );
    }
    return 1;
}

CMD:circleall( playerid, params[ ] )
{
	new seconds = 3, allowcop, noarmour;
	if ( p_AdminLevel[ playerid ] < 4 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, "D(3)D(0)D(1)", seconds, allowcop, noarmour ) ) return SendUsage(playerid, "/circleall [SECONDS] [ALLOW_COPS 0|1] [REMOVE ARMOUR 0|1]" );
    else if ( g_circleall_CD ) return SendError( playerid, "There is already a countdown on-going." );
    else if ( seconds > 60 ) return SendError( playerid, "You must specifiy the amount of seconds from 0 to 60." );
    else if ( allowcop < 0 || allowcop > 1 ) return SendError( playerid, "0 or 1 can only be the cop allowance parameter value!" );
    else if ( noarmour < 0 || noarmour > 1 ) return SendError( playerid, "0 or 1 can only be the remove armour parameter value!" );
    else
	{
		g_circleall_CD = true;

		new
		    Float: nX, Float: nY, Float: nZ,
		    Float: Armour, Float: deg// = 360.0 / float(Iter_Count(Player))
		;
		GetPlayerPos( playerid, nX, nY, nZ );
	    foreach(new i : Player)
	    {
	        if ( IsPlayerSpawned( i ) && i != playerid && !IsPlayerJailed( i ) && !p_PlayerSettings[ i ] { SETTING_EVENT_TP } )
	        {
	        	if ( !allowcop && p_Class[ i ] == CLASS_POLICE )
	        		continue;

	        	if ( IsPlayerAFK( i ) ) {
	        		SendServerMessage( i, "As you're AFK, you have not been teleported to the event/mass teleportation." );
	        		continue;
	        	}

	        	if ( IsPlayerInPaintBall( i ) ) {
	        		SendServerMessage( i, "As you're in paintball, you have not been teleported to the event/mass teleportation." );
	        		continue;
	        	}

	        	if ( noarmour ) {
	        		GetPlayerArmour( i, Armour );
	        		if ( Armour > 0.0 ) SetPlayerArmour( i, 0.0 );
	        	}

	            deg += 3.6;
	            nX += 10 * floatsin( deg, degrees );
	            nY += 10 * floatcos( deg, degrees );
	            SetPlayerPos( i, nX, nY, nZ );
				GetPlayerPos( playerid, nX, nY, nZ );
				SetPlayerInterior( i, GetPlayerInterior( playerid ) );
				SetPlayerVirtualWorld( i, GetPlayerVirtualWorld( playerid ) );
				TogglePlayerControllable( i, 0 );
	        }
	    }
	    SetTimerEx( "circleall_Countdown", 960, false, "dd", seconds, 0 );
		AddAdminLogLineFormatted( "%s(%d) has circled everybody", ReturnPlayerName( playerid ), playerid );
	}
	return 1;
}

CMD:vc( playerid, params [ ] ) return cmd_vcreate( playerid, params );
CMD:vcreate( playerid, params [ ] )
{
    new
		vName[ 24 ],
		vCar,
	    Float: X,
	    Float: Y,
	    Float: Z,
	    Float: Angle
	;
	GetPlayerPos( playerid, X, Y, Z );
    GetPlayerFacingAngle(playerid, Angle);

	if ( p_AdminLevel[ playerid ] < 3 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "s[24]", vName ) ) SendUsage( playerid, "/(vc)reate [VEHICLE_NAME]" );
	else
	{
		if ( strmatch( vName, "jetpack" ) && p_AdminLevel[ playerid ] >= 4 )
			return SetPlayerSpecialAction( playerid, SPECIAL_ACTION_USEJETPACK );

	    new iCarModel = GetVehicleModelFromName( vName );
	    if ( p_AdminLevel[ playerid ] < 5 )
	    {
		    if ( iCarModel == 435 || iCarModel == 450 || iCarModel == 584 || iCarModel == 591 || iCarModel == 606 || iCarModel == 607 || iCarModel == 608 || iCarModel == 610 || iCarModel == 611 ) return SendError( playerid, "You cannot spawn trailers." );
			if ( iCarModel == 449 || iCarModel == 537 || iCarModel == 538 || iCarModel == 569 || iCarModel == 570 ) return SendError( playerid, "You cannot spawn trains." );
		}

		if ( iCarModel != -1 ) {
			if ( ( vCar = CreateVehicle( iCarModel, X, Y, Z, Angle, -1, -1, 9999999999999999 ) ) ) {
	            g_adminSpawnedCar{ vCar } = true;
				LinkVehicleToInterior( vCar, GetPlayerInterior( playerid ) );
				SetVehicleVirtualWorld( vCar, GetPlayerVirtualWorld( playerid ) );
				PutPlayerInVehicle( playerid, vCar, 0 );
 				SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have spawned an "COL_GREY"%s"COL_WHITE".", GetVehicleName( iCarModel ) );
			}
		}
		else SendError( playerid, "Invalid vehicle name written." );
	}
	return 1;
}

CMD:gotopos( playerid, params[ ] )
{
	new
		Float: X, Float: Y, Float: Z, interior;

 	if ( p_AdminLevel[ playerid ] < 4 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
 	else if ( sscanf( params, "fffD(0)", X, Y, Z, interior ) ) return SendUsage( playerid, "/gotopos [POS_X] [POS_Y] [POS_Z] [INTERIOR (= 0)]" );
 	else
 	{
		SetPlayerPosition( playerid, X, Y, Z, interior );
 		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have teleported to "COL_GREY"%f, %f, %f"COL_WHITE" Interior: "COL_GREY"%d", X, Y, Z, interior );
 	}
	return 1;
}

CMD:addnote( playerid, params[ ] )
{
	new
		pID,
		note[ 72 ]
	;

	if ( p_AdminLevel[ playerid ] < 4 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"s[72]", pID, note ) ) return SendUsage( playerid, "/addnote [PLAYER_ID] [NOTE]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( strlen( note ) < 3 ) return SendError( playerid, "Keep your note's character count within the range of 3 - 72." );
	else
	{
		AddPlayerNote( pID, playerid, note );
 		SendServerMessage( playerid, "You have added a note to %s (Account ID %d)."COL_RED" Do understand that what you add is logged.", ReturnPlayerName( pID ), pID, p_AccountID[ pID ] );
		AddAdminLogLineFormatted( "%s(%d) has added a note to %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
	}
	return 1;
}

CMD:removenote( playerid, params[ ] )
{
	new
		note
	;

	if ( p_AdminLevel[ playerid ] < 4 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d", note ) ) return SendUsage( playerid, "/removenote [NOTE_ID]" );
	else if ( note < 0 ) return SendError( playerid, "Invalid note ID." );
	else
	{
		if ( p_AdminLevel[ playerid ] > 4 )
		{
	 		format( szNormalString, 64, "SELECT `ID` FROM `NOTES` WHERE `ID`=%d AND `DELETED` IS NULL", note );
			mysql_function_query( dbHandle, szNormalString, true, "deleteplayernote", "dd", playerid, note );
		}
		else
		{
	 		format( szNormalString, 96, "SELECT `ID` FROM `NOTES` WHERE `ID`=%d AND `ADDED_BY`=%d AND `DELETED` IS NULL", note, p_AccountID[ playerid ] );
			mysql_function_query( dbHandle, szNormalString, true, "deleteplayernote", "dd", playerid, note );
		}
	}
	return 1;
}

/* Level 5 */
CMD:check( playerid, params[ ] )
{
	new
		pID
	;

    if ( p_AdminLevel[ playerid ] < 5 ) return 0;
	else if ( sscanf( params, #sscanf_u, pID ) ) return SendUsage( playerid, "/check [PLAYER_ID]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else
	{
		new
			playerserial[ 45 ];

		gpci( pID, playerserial, sizeof( playerserial ) ); // playerserial

		format( szNormalString, sizeof( szNormalString ), "SELECT `NAME`,`IP`,`COUNTRY` FROM `BANS` WHERE `SERIAL`='%s' LIMIT 32", mysql_escape( playerserial ) );
		mysql_function_query( dbHandle, szNormalString, true, "readgpcibans", "dd", playerid, pID );
	}
	return 1;
}

thread readgpcibans( playerid, searchid )
{
	new
	    rows, fields
	;
    cache_get_data( rows, fields );

    if ( rows )
    {
    	new
    		szName[ MAX_PLAYER_NAME ],
    		szIP[ 16 ],
    		szCountry[ 3 ]
    	;

    	szLargeString = ""COL_GREY"Username\t"COL_GREY"IP Address\t"COL_GREY"Country (XX)\n";

    	for( new i = 0; i < rows; i++ )
		{
			cache_get_field_content( i, "COUNTRY", szCountry );
			cache_get_field_content( i, "NAME", szName );
			cache_get_field_content( i, "IP", szIP );

			if ( isnull( szCountry ) )
				szCountry = "-";

			format( szLargeString, sizeof( szLargeString ), "%s%s\t%s\t%s\n", szLargeString, szName, szIP, szCountry );
		}

		ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_TABLIST_HEADERS, sprintf( "{FFFFFF}Serial check on %s(%d)", ReturnPlayerName( searchid ), searchid ), szLargeString, "Okay", "" );
		return 1;
	}
	SendError( playerid, "This user looks clean!" );
	return 1;
}

CMD:c( playerid, params[ ] )
{
	new
	    msg[ 90 ]
	;

    if ( p_AdminLevel[ playerid ] < 5 ) return 0;
    else if ( sscanf( params, "s[90]", msg ) ) return SendUsage( playerid, "/c [MESSAGE]" );
	else if ( textContainsIP( msg ) ) return SendServerMessage( playerid, "Please do not advertise." );
    else
	{
		foreach(new councilid : Player)
			if ( p_AdminLevel[ councilid ] >= 5 || IsPlayerUnderCover( councilid ) )
				SendClientMessageFormatted( councilid, -1, "{00CCFF}<Council Chat> %s(%d):"COL_GREY" %s", ReturnPlayerName( playerid ), playerid, msg );
	}
	return 1;
}

CMD:creategarage( playerid, params[ ] )
{
    new
		cost, iTmp, iVehicle,
		Float: X, Float: Y, Float: Z, Float: Angle
	;

	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d", cost ) ) return SendUsage( playerid, "/creategarage [COST]" );
	else if ( cost < 100 ) return SendError( playerid, "The price must be located above 100 dollars." );
	else if ( !( iVehicle = GetPlayerVehicleID( playerid ) ) ) return SendError( playerid, "You are not in any vehicle." );
	else
	{
		AddAdminLogLineFormatted( "%s(%d) has created a garage", ReturnPlayerName( playerid ), playerid );

		if ( GetVehiclePos( iVehicle, X, Y, Z ) && GetVehicleZAngle( iVehicle, Angle ) )
		{
		    if ( ( iTmp = CreateGarage( 0, cost, 0, X, Y, Z, Angle ) ) != -1 )
		    {
				SaveToAdminLog( playerid, iTmp, "created garage" );
		    	SendClientMessageFormatted( playerid, -1, ""COL_PINK"[GARAGE]"COL_WHITE" You have created a %s garage taking up garage id %d.", ConvertPrice( cost ), iTmp );
		    }
			else
				SendClientMessage( playerid, -1, ""COL_PINK"[GARAGE]"COL_WHITE" Unable to create a garage due to a unexpected error." );
		}
	}
	return 1;
}

CMD:destroygarage( playerid, params[ ] )
{
	new
	    iGarage
	;

	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d", iGarage ) ) return SendUsage( playerid, "/destroygarage [GARAGE_ID]" );
	else if ( iGarage < 0 || iGarage >= MAX_GARAGES ) return SendError( playerid, "Invalid Garage ID." );
	else if ( !Iter_Contains( garages, iGarage ) ) return SendError( playerid, "Invalid Garage ID." );
	else
	{
		SaveToAdminLog( playerid, iGarage, "destroy garage" );
		format( szBigString, sizeof( szBigString ), "[DG] [%s] %s | %d | %d\r\n", getCurrentDate( ), ReturnPlayerName( playerid ), g_garageData[ iGarage ] [ E_OWNER_ID ], iGarage );
	    AddFileLogLine( "log_garages.txt", szBigString );
		AddAdminLogLineFormatted( "%s(%d) has deleted a garage", ReturnPlayerName( playerid ), playerid );
	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[GARAGE]"COL_WHITE" You have destroyed the garage ID %d.", iGarage );
	    DestroyGarage( iGarage );
	}
	return 1;
}

CMD:connectsong( playerid, params[ ] )
{
	new
		szURL[ 128 ];

	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "s[128]", szURL ) ) return SendUsage( playerid, "/connectsong [SONG_URL]" );
	else
	{
		SaveToAdminLogFormatted( playerid, 0, "updated connection song to %s", szURL );
		SendGlobalMessage( -1, ""COL_PINK"[ADMIN]"COL_WHITE" %s(%d) has set the connection song to: "COL_GREY"%s", ReturnPlayerName( playerid ), playerid, szURL );
		UpdateServerVariable( "connectsong", 0, 0.0, szURL, GLOBAL_VARTYPE_STRING );
	}
	return 1;
}

CMD:creategate( playerid, params[ ] )
{
	new
		pID, password[ 8 ], model, Float: speed, Float: range,
		Float: X, Float: Y, Float: Z
	;

	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"dffs[8]", pID, model, speed, range, password ) ) return SendUsage( playerid, "/creategate [PLAYER_ID] [MODEL_ID] [SPEED] [RANGE] [PASSWORD]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( model < 0 || model > 20000 ) return SendError( playerid, "Invalid Object Model." );
	else if ( speed < 1.0 || speed > 100.0 ) return SendError( playerid, "Please specify a speed between 1.0 and 100.0." );
	else if ( range < 2.5 || speed > 500.0 ) return SendError( playerid, "Please specify a range between 2.5 and 500.0." );
	else if ( strlen( password ) > 4 ) return SendError( playerid, "Password length can be only a maximum of four characters." );
	else
	{
		GetXYInFrontOfPlayer( playerid, X, Y, Z, 5.0 );
		new iTmp = CreateGate( pID, password, model, speed, range, X, Y, Z, 0.0, 0.0, 0.0 );
	    if ( iTmp != -1 ) {
			SaveToAdminLog( playerid, iTmp, "created gate" );
	    	SendClientMessageFormatted( playerid, -1, ""COL_PINK"[GATE]"COL_WHITE" You have created a gate taking place of ID: %d", iTmp );
	    }
		else SendClientMessage( playerid, -1, ""COL_PINK"[GATE]"COL_WHITE" Unable to create a gate due to a unexpected error." );
	}
	return 1;
}

CMD:editgate( playerid, params[ ] )
{
	new
		gID;

	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d", gID ) ) return SendUsage( playerid, "/editgate [GATE_ID]" );
	else if ( !Iter_Contains( gates, gID ) ) return SendError( playerid, "Invalid Gate ID" );
	else
	{
		format( szLargeString, sizeof( szLargeString ),
			""COL_RED"Remove This Gate?\t \nOwner ID\t"COL_GREY"%d\nName\t"COL_GREY"%s\nPassword\t"COL_GREY"%s\nModel\t"COL_GREY"%d\nSpeed\t"COL_GREY"%f\nRange\t"COL_GREY"%f\nPause\t"COL_GREY"%d MS\nChange Closed Positioning\t \nChange Opened Positioning\t ",
			g_gateData[ gID ] [ E_OWNER ], g_gateData[ gID ] [ E_NAME ], g_gateData[ gID ] [ E_PASS ], g_gateData[ gID ] [ E_MODEL ], g_gateData[ gID ] [ E_SPEED ], g_gateData[ gID ] [ E_RANGE ], g_gateData[ gID ] [ E_TIME ]
		);

		SetPVarInt( playerid, "gate_editing", gID );
		SaveToAdminLog( playerid, gID, "editing gate" );
		ShowPlayerDialog( playerid, DIALOG_GATE, DIALOG_STYLE_TABLIST, "{FFFFFF}Edit Gate", szLargeString, "Select", "Cancel" );
	}
	return 1;
}

CMD:acunban( playerid, params[ ] )
{
	new
		address[ 16 ];

	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf(params, "s[16]", address ) ) SendUsage( playerid, "/acunban [IP_ADDRESS]" );
	else if ( !textContainsIP( params ) ) return SendError( playerid, "This is not an IP address." );
	else
	{
 		UnBlockIpAddress( address );
		SetServerRule( "unbanip", address );
		SetServerRule( "reloadbans", "" );
		SaveToAdminLogFormatted( playerid, 0, "acunban %s", address );
	 	SendClientMessageFormatted( playerid, -1, ""COL_PINK"[AC UNBAN]{FFFFFF} You've unbanned %s from the anti-cheat.", address );
	 	AddAdminLogLineFormatted( "%s(%d) has un-banned %s", ReturnPlayerName( playerid ), playerid, address );
	}
	return 1;
}

CMD:safeisbugged( playerid, params[ ] )
{
 	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	new
        Float: distance = 99999.99,
		robberyid = getClosestRobberySafe( playerid, distance )
	;

	if ( robberyid != INVALID_OBJECT_ID )
	{
		SendClientMessage( playerid, COLOR_GOLD, "___ SAFE DATA ___");
		SendClientMessageFormatted( playerid, -1, "OPEN : %d | ROBBED : %d | C4 : %d | DRILL : %d | DRILL PLACER : %d | DRILL EFFECT : %d",
			g_robberyData[ robberyid ] [ E_OPEN ], g_robberyData[ robberyid ] [ E_ROBBED ], g_robberyData[ robberyid ] [ E_C4 ],
			g_robberyData[ robberyid ] [ E_DRILL ], g_robberyData[ robberyid ] [ E_DRILL_PLACER ], g_robberyData[ robberyid ] [ E_DRILL_EFFECT ] );

		SendClientMessageFormatted( playerid, -1, "REPLENISH : %d | RAW TIMESTAMP : %d | CURRENT TIME: %d | ID : %d | NAME : %s | VELOCITY: %f",
			g_robberyData[ robberyid ] [ E_ROB_TIME ] - g_iTime, g_robberyData[ robberyid ] [ E_ROB_TIME ], g_iTime, robberyid, g_robberyData[ robberyid ] [ E_NAME ], g_robberyData[ robberyid ] [ E_VELOCITY ] );
	}
	else return SendError( playerid, "You're not near any safe." );
	return 1;
}

CMD:autovehrespawn( playerid, params[ ] )
{
	#if defined _vsync_included
	    #pragma unused rl_AutoVehicleRespawner
		SendError( playerid, "This feature is disabled as protection for car warping is enabled (VehicleSync)." );
	#else
		new tick;
		if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
		else if ( sscanf( params, "d", tick ) ) return SendUsage( playerid, "/autovehrespawn [MILLISECONDS (0 = DISABLE)]" );
		else if ( tick != 0 && tick < 2500 ) return SendError( playerid, "The respawn tick cannot be less than 2500ms." );
		else
		{
	        if ( tick == 0 ) {
				KillTimer( rl_AutoVehicleRespawner );
				rl_AutoVehicleRespawner = 0xFF;
				SendServerMessage( playerid, "Auto vehicle spawner disabled." );
				return 1;
			}

			KillTimer( rl_AutoVehicleRespawner );
			rl_AutoVehicleRespawner = SetTimer( "autoVehicleSpawn", tick, true );

			SaveToAdminLogFormatted( playerid, 0, "autovehrespawn %d", tick );
	        SendClientMessageFormatted( playerid, COLOR_WHITE, ""COL_GREY"[SERVER]"COL_WHITE" The auto vehicle spawner has been set to %dms.", tick );
		}
	#endif
	return 1;
}

function autoVehicleSpawn( )
{
    for( new i; i < MAX_VEHICLES; i++ ) if ( IsValidVehicle( i ) )
   	{
		if ( !IsVehicleOccupied( i, .include_vehicle_interior = true ) )
		{
			if ( g_buyableVehicle{ i } == true )
				RespawnBuyableVehicle( i );
			else
				SetVehicleToRespawn( i );
    	}
	}
	return 1;
}

/*CMD:megaban( playerid, params [ ] )
{
    new
	    pID,
		reason[ 50 ]
	;
	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"S(No Reason)[50]", pID, reason ) ) SendUsage( playerid, "/megaban [PLAYER_ID] [REASON]" );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	//else if ( pID == playerid ) return SendError( playerid, "You cannot ban yourself." );
    //else if ( p_AdminLevel[ playerid ] < p_AdminLevel[ pID ] ) return SendError( playerid, "This player has a higher administration level than you." );
	else
	{
		SaveToAdminLogFormatted( playerid, 0, "megaban %s (reason: %s)", ReturnPlayerName( pID ), reason );
        AddAdminLogLineFormatted( "%s(%d) has mega-banned %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
	    SendGlobalMessage( -1, ""COL_PINK"[ADMIN]{FFFFFF} %s has mega-banned %s(%d) "COL_GREEN"[REASON: %s]", ReturnPlayerName( playerid ), ReturnPlayerName( pID ), pID, reason );
		BanPlayerISP( pID );
	}
	return 1;
}*/

CMD:changename( playerid, params[ ] )
{
	new
	    pID,
	    nName[ 24 ],
	    szQuery[ 100 ]
	;
	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"s[24]", pID, nName ) ) return SendUsage( playerid, "/changename [PLAYER_ID] [NEW_NAME]" );
	else if ( !IsPlayerConnected( pID ) ) SendError( playerid, "Invalid Player ID." );
	else if ( !isValidPlayerName( nName ) ) return SendError( playerid, "Invalid Name Character." );
	else if ( p_OwnedHouses[ pID ] > 0 || GetPlayerOwnedApartments( pID ) > 0 ) return SendError( playerid, "This player has a house and/or apartment." ), SendError( pID, ""COL_ORANGE"In order to change your name, you must sell your houses and/or apartment.");
	else
	{
	    format( szQuery, sizeof( szQuery ), "SELECT `NAME` FROM `USERS` WHERE `NAME` = '%s'", mysql_escape( nName ) );
	  	mysql_function_query( dbHandle, szQuery, true, "OnAdminChangePlayerName", "dds", playerid, pID, nName );
	}
	return 1;
}

thread OnAdminChangePlayerName( playerid, pID, nName[ ] )
{
	new
	    rows, fields
	;
	cache_get_data( rows, fields );

	if ( !rows )
	{
	 	mysql_single_query( sprintf( "UPDATE `USERS` SET `NAME` = '%s' WHERE `NAME` = '%s'", mysql_escape( nName ), mysql_escape( ReturnPlayerName( pID ) ) ) );
	 	mysql_single_query( sprintf( "INSERT INTO `NAME_CHANGES`(`USER_ID`,`ADMIN_ID`,`NAME`) VALUES (%d,%d,'%s')", p_AccountID[ pID ], p_AccountID[ playerid ], mysql_escape( ReturnPlayerName( pID ) ) ) );

		SaveToAdminLogFormatted( playerid, 0, "changename %s to %s", ReturnPlayerName( pID ), nName );
		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have changed %s(%d)'s name to %s!", ReturnPlayerName( pID ), pID, nName );
		SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]"COL_WHITE" Your name has been changed to %s by %s(%d)!", nName, ReturnPlayerName( playerid ), playerid );
        AddAdminLogLineFormatted( "%s(%d) has changed %s(%d)'s name to %s", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, nName );

		SetPlayerName( pID, nName );
    	GetPlayerName( pID, p_PlayerName[ pID ], sizeof( p_PlayerName[ ] ) );

    	// Update New Things
    	foreach(new g : garages)
    		if ( g_garageData[ g ] [ E_OWNER_ID ] == p_AccountID[ playerid ] )
    			UpdateGarageTitle( g );
	}
	else SendError( playerid, "This name is taken already." );
	return 1;
}

CMD:unbanip( playerid, params[ ] )
{
	new
		address[16],
		Query[70]
	;

	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if (sscanf(params, "s[16]", address)) SendUsage(playerid, "/unbanip [IP_ADDRESS]");
	else
	{
		format( Query, sizeof( Query ), "SELECT `IP` FROM `BANS` WHERE `IP` = '%s'", mysql_escape( address ) );
		mysql_function_query( dbHandle, Query, true, "OnPlayerUnbanIP", "dds", playerid, 0, address );
	}
	return 1;
}

thread OnPlayerUnbanIP( playerid, irc, address[ ] )
{
	new
	    rows, fields
	;
	cache_get_data( rows, fields );
	if ( rows )
	{
    	if ( !irc )
    	{
			SaveToAdminLogFormatted( playerid, 0, "unbanip %s", address );
    		AddAdminLogLineFormatted( "%s(%d) has un-banned IP %s", ReturnPlayerName( playerid ), playerid, address );
	 		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]{FFFFFF} IP %s has been un-banned from the server.", address );
		}
		else
		{
    		DCC_SendChannelMessageFormatted( discordGeneralChan, "**(UNBANNED)** IP %s has been un-banned from the server.", address );
		}
		format( szNormalString, sizeof( szNormalString ), "DELETE FROM `BANS` WHERE `IP` = '%s'", mysql_escape( address ) );
		mysql_single_query( szNormalString );
	}
	else {
		if ( !irc ) SendError(playerid, "This IP Address is not recognised!");
	}
	return 1;
}

CMD:unban( playerid, params[ ] )
{
	new
		player[24],
		Query[70]
	;

	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "s[24]", player ) ) SendUsage( playerid, "/unban [NAME]" );
	else
	{
		format( Query, sizeof( Query ), "SELECT `NAME` FROM `BANS` WHERE `NAME` = '%s'", mysql_escape( player ) );
		mysql_function_query( dbHandle, Query, true, "OnPlayerUnbanPlayer", "dds", playerid, 0, player );
	}
	return 1;
}

thread OnPlayerUnbanPlayer( playerid, irc, player[ ] )
{
	new
	    rows, fields
	;
	cache_get_data( rows, fields );
	if ( rows )
	{
   	 	if ( !irc ) AddAdminLogLineFormatted( "%s(%d) has un-banned %s", ReturnPlayerName( playerid ), playerid, player );
		else
		{
			format(szNormalString, sizeof(szNormalString),"**(UNBANNED)** %s has been un-banned from the server.", player);
    		DCC_SendChannelMessage( discordGeneralChan, szNormalString );
		}
		format(szNormalString, sizeof(szNormalString), "DELETE FROM `BANS` WHERE `NAME` = '%s'", mysql_escape( player ) );
		mysql_single_query( szNormalString );

		SaveToAdminLogFormatted( playerid, 0, "unban %s", player );
	 	SendClientMessageToAllFormatted(-1, ""COL_PINK"[ADMIN]{FFFFFF} \"%s\" has been un-banned from the server.", player);
	}
	else {
		if ( !irc ) SendError(playerid, "This player is not recognised!");
	}
	return 1;
}

CMD:doublexp( playerid, params[ ] )
{
	//g_doubleXP
	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );

	UpdateServerVariable( "doublexp", IsDoubleXP( ) ? 0 : 1, 0.0, "", GLOBAL_VARTYPE_INT );

	if ( IsDoubleXP( ) )
	{
		TextDrawShowForAll( g_DoubleXPTD );
		GameTextForAll( "~w~DOUBLE ~y~~h~XP~g~~h~~h~ ACTIVATED!", 6000, 3 );
	}
	else
	{
		TextDrawHideForAll( g_DoubleXPTD );
		GameTextForAll( "~w~DOUBLE ~y~~h~XP~r~~h~~h~ DEACTIVATED!", 6000, 3 );
	}

	SaveToAdminLogFormatted( playerid, 0, "doublexp %s", IsDoubleXP( ) ? ("toggled") : ("un-toggled") );
    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have %s double XP!", IsDoubleXP( ) ? ("toggled") : ("un-toggled") );
	AddAdminLogLineFormatted( "%s(%d) has %s double xp", ReturnPlayerName( playerid ), playerid, IsDoubleXP( ) ? ("toggled") : ("un-toggled") );
	return 1;
}

CMD:toggleviewpm( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 5 && !IsPlayerUnderCover( playerid ) ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    p_ToggledViewPM{ playerid } = !p_ToggledViewPM{ playerid };
    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have %s viewing peoples private messages.", p_ToggledViewPM{ playerid } == true ? ("toggled") : ("un-toggled") );
    if ( !IsPlayerUnderCover( playerid ) ) {
		AddAdminLogLineFormatted( "%s(%d) has %s viewing pm's", ReturnPlayerName( playerid ), playerid, p_ToggledViewPM{ playerid } == true ? ("toggled") : ("un-toggled") );
    }
 	return 1;
}

CMD:respawnallv( playerid, params[ ] )
{
 	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else
	{
	    for( new i; i < MAX_VEHICLES; i++ ) if ( IsValidVehicle( i ) ) {
	    	#if ENABLED_SECURE_TRUCK
	    	if ( g_secureTruckVehicle == i ) continue;
	    	#endif
			SetVehicleToRespawn( i );
		}
		AddAdminLogLineFormatted( "%s(%d) has respawned all vehicles", ReturnPlayerName( playerid ), playerid );
		SendServerMessage( playerid, "You have respawned all vehicles." );
	}
	return 1;
}

CMD:createbribe( playerid, params[ ] )
{
    new
		Float: X, Float: Y, Float: Z
	;

	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else
	{
		GetPlayerPos( playerid, X, Y, Z );
	    new iTmp = CreateBribe( X, Y, Z );
		AddAdminLogLineFormatted( "%s(%d) has created a bribe", ReturnPlayerName( playerid ), playerid );
	    if ( iTmp != -1 ) {
			SaveToAdminLog( playerid, iTmp, "created bribe" );
	    	SendClientMessageFormatted( playerid, -1, ""COL_PINK"[BRIBE]"COL_WHITE" You have created a bribe taking place of ID: %d.", iTmp );
	    }
		else SendClientMessage( playerid, -1, ""COL_PINK"[BRIBE]"COL_WHITE" Unable to create a bribe due to a unexpected error." );
	}
	return 1;
}

CMD:destroybribe( playerid, params[ ] )
{
	new
	    bID
	;

	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d", bID ) ) return SendUsage( playerid, "/destroybribe [BRIBE_ID]" );
	else if ( bID < 0 || bID > MAX_BRIBES ) return SendError( playerid, "Invalid Bribe ID." );
	else if ( !Iter_Contains( BribeCount, bID ) ) return SendError( playerid, "Invalid Bribe ID." );
	else
	{
		SaveToAdminLog( playerid, bID, "destroyed bribe" );
		AddAdminLogLineFormatted( "%s(%d) has deleted a bribe", ReturnPlayerName( playerid ), playerid );
	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[BRIBE]"COL_WHITE" You have destroyed a bribe pickup which was the ID of %d.", bID);
	    DestroyBribe( bID );
	}
	return 1;
}

CMD:createcar( playerid, params[ ] )
{
    new
		vName[ 24 ], pID,
		Float: X, Float: Y, Float: Z, Float: Angle
	;

	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"s[24]", pID, vName ) ) return SendUsage( playerid, "/createcar [PLAYER_ID] [VEHICLE_NAME]" );
	else if ( !IsPlayerConnected( pID ) ) SendError( playerid, "Invalid Player ID." );
	else if ( hasTooManyVehicles( pID ) ) return SendError( playerid, "This player has too many vehicles." );
	else
	{
	    new
	    	iModel, iTmp;

	    if ( ( iModel = GetVehicleModelFromName( vName ) ) != -1 ) {

			AddAdminLogLineFormatted( "%s(%d) has created a vehicle for %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
			GetPlayerPos( playerid, X, Y, Z );
			GetPlayerFacingAngle( playerid, Angle );

		    if ( ( iTmp = CreateBuyableVehicle( pID, iModel, 0, 0, X, Y, Z, Angle, 1337 ) ) != -1 ) {
				SaveToAdminLogFormatted( playerid, iTmp, "created car (model id %d) for %s (acc id %d)", iModel, ReturnPlayerName( pID ), p_AccountID[ pID ] );
		    	SendClientMessageFormatted( playerid, -1, ""COL_PINK"[VEHICLE]"COL_WHITE" You have created a vehicle in the name of %s(%d).", ReturnPlayerName( pID ), pID );
		    	PutPlayerInVehicle( playerid, g_vehicleData[ pID ] [ iTmp ] [ E_VEHICLE_ID ], 0 );
		    }
			else SendClientMessage( playerid, -1, ""COL_PINK"[VEHICLE]"COL_WHITE" Unable to create a vehicle due to a unexpected error." );
	    }
		else SendError( playerid, "Invalid Vehicle Model." );
	}
	return 1;
}

CMD:destroycar( playerid, params[ ] )
{
	new
	   	ownerid, slotid
	;

	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You must be in a vehicle to use this command." );
	else
	{
		new v = getVehicleSlotFromID( GetPlayerVehicleID( playerid ), ownerid, slotid );

		if ( v == -1 ) return SendError( playerid, "This vehicle doesn't look like it can be destroyed. (0xAA)" );
		if ( g_vehicleData[ ownerid ] [ slotid ] [ E_CREATED ] == false ) return SendError( playerid, "This vehicle doesn't look like it can be destroyed. (0xAF)" );

		SaveToAdminLogFormatted( playerid, slotid, "destroycar (model id %d) for %s (acc id %d)", g_vehicleData[ slotid ] [ slotid ] [ E_MODEL ], ReturnPlayerName( ownerid ), p_AccountID[ ownerid ] );
		AddAdminLogLineFormatted( "%s(%d) has deleted a car", ReturnPlayerName( playerid ), playerid );
		format( szBigString, sizeof( szBigString ), "[DC] [%s] %s | %s | %s\r\n", getCurrentDate( ), ReturnPlayerName( playerid ), ReturnPlayerName( ownerid ), GetVehicleName( GetVehicleModel( g_vehicleData[ ownerid ] [ slotid ] [ E_VEHICLE_ID ] ) ) );
        AddFileLogLine( "log_destroycar.txt", szBigString );

		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[VEHICLE]"COL_WHITE" You have destroyed a "COL_GREY"%s"COL_WHITE" owned by "COL_GREY"%s"COL_WHITE".", GetVehicleName( GetVehicleModel( g_vehicleData[ ownerid ] [ slotid ] [ E_VEHICLE_ID ] ) ), ReturnPlayerName( ownerid ) );
	   	DestroyBuyableVehicle( ownerid, slotid );
	}
	return 1;
}

CMD:stripcarmods( playerid, params[ ] )
{
	new
	   	ownerid, slotid
	;

	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You must be in a vehicle to use this command." );
	else
	{
		new v = getVehicleSlotFromID( GetPlayerVehicleID( playerid ), ownerid, slotid );

		if ( v == -1 ) return SendError( playerid, "This vehicle doesn't look like it can be stripped of its components. (0xAA)" );
		if ( g_vehicleData[ ownerid ] [ slotid ] [ E_CREATED ] == false ) return SendError( playerid, "This vehicle doesn't look like it can be destroyed. (0xAF)" );

		SaveToAdminLogFormatted( playerid, slotid, "stripcarmods on %s (acc id %d, model id %d)", ReturnPlayerName( ownerid ), p_AccountID[ ownerid ], g_vehicleData[ ownerid ] [ slotid ] [ E_MODEL ] );
		AddAdminLogLineFormatted( "%s(%d) has deleted a car's mods", ReturnPlayerName( playerid ), playerid );
		format( szBigString, sizeof( szBigString ), "[DC_MODS] [%s] %s | %s | %s\r\n", getCurrentDate( ), ReturnPlayerName( playerid ), ReturnPlayerName( ownerid ), GetVehicleName( GetVehicleModel( g_vehicleData[ ownerid ] [ slotid ] [ E_VEHICLE_ID ] ) ) );
        AddFileLogLine( "log_destroycar.txt", szBigString );

		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[VEHICLE]"COL_WHITE" You have removed the mods of %s's "COL_GREY"%s"COL_WHITE".", ReturnPlayerName( ownerid ), GetVehicleName( GetVehicleModel( g_vehicleData[ ownerid ] [ slotid ] [ E_VEHICLE_ID ] ) ) );
		DestroyVehicleCustomComponents( ownerid, slotid, .destroy_db = true );
	}
	return 1;
}

CMD:createhouse( playerid, params[ ] )
{
    new
		cost, iTmp,
		Float: X, Float: Y, Float: Z
	;

	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d", cost ) ) return SendUsage( playerid, "/createhouse [COST]" );
	else if ( cost < 100 ) return SendError( playerid, "The price must be located above 100 dollars." );
	else
	{
		AddAdminLogLineFormatted( "%s(%d) has created a house", ReturnPlayerName( playerid ), playerid );
		if ( GetPlayerPos( playerid, X, Y, Z ) ) {
		    if ( ( iTmp = CreateHouse( cost, X, Y, Z ) ) != -1 ) {
				SaveToAdminLogFormatted( playerid, iTmp, "created house for %s", ConvertPrice( cost ) );
		    	SendClientMessageFormatted( playerid, -1, ""COL_PINK"[HOUSE]"COL_WHITE" You have created a %s house taking up house id %d.", ConvertPrice( cost ), iTmp );
		    }
			else
				SendClientMessage( playerid, -1, ""COL_PINK"[HOUSE]"COL_WHITE" Unable to create a house due to a unexpected error." );
		}
	}
	return 1;
}

CMD:destroyhouse( playerid, params[ ] )
{
	new
	    hID
	;

	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d", hID ) ) return SendUsage( playerid, "/destroyhouse [HOUSE_ID]" );
	else if ( hID < 0 || hID > MAX_HOUSES ) return SendError( playerid, "Invalid house ID." );
	else if ( g_houseData[ hID ] [ E_CREATED ] == false ) return SendError( playerid, "Invalid house ID." );
	else
	{
		SaveToAdminLog( playerid, hID, "destroy house" );
		format( szBigString, sizeof( szBigString ), "[DH] [%s] %s | %s | %d\r\n", getCurrentDate( ), ReturnPlayerName( playerid ), g_houseData[ hID ][ E_OWNER ], hID );
	    AddFileLogLine( "log_houses.txt", szBigString );
		AddAdminLogLineFormatted( "%s(%d) has deleted a house", ReturnPlayerName( playerid ), playerid );
	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[HOUSE]"COL_WHITE" You have destroyed \"%s\" which was the ID of %d.", g_houseData[ hID ] [ E_HOUSE_NAME ], hID );
	    DestroyHouse( hID );
	}
	return 1;
}

CMD:hadminsell( playerid, params[ ] )
{
	new
	    hID
	;

	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d", hID ) ) return SendUsage( playerid, "/hadminsell [HOUSE_ID]" );
	else if ( hID < 0 || hID > MAX_HOUSES ) return SendError( playerid, "Invalid house ID." );
	else if ( g_houseData[ hID ] [ E_CREATED ] == false ) return SendError( playerid, "Invalid house ID." );
	else if ( strmatch( g_houseData[ hID ] [ E_OWNER ], "No-one" ) ) return SendError( playerid, "This house is not owned by anyone." );
	else
	{
	    SetHouseForAuction( hID );
		SaveToAdminLog( playerid, hID, "hadminsell" );
		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[HOUSE]"COL_WHITE" You made "COL_GREY"House ID %d"COL_WHITE" go for sale.", hID );
	}
	return 1;
}

CMD:forceac( playerid, params[ ] )
{
    new
        pID;

	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
    else if ( sscanf( params, #sscanf_u, pID ) ) SendUsage( playerid, "/forceac [PLAYER_ID]" );
    else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
    else if ( pID == playerid ) return SendError( playerid, "You cant kick yourself." );
    else if ( p_AdminLevel[ pID ] > p_AdminLevel[ playerid ] ) return SendError( playerid, "You cannot use this command on admins higher than your level." );
    else
	{
		if ( p_forcedAnticheat[ pID ] <= 0 )
		{
			p_forcedAnticheat[ pID ] = p_AccountID[ playerid ];
			mysql_single_query( sprintf( "UPDATE `USERS` SET `FORCE_AC`=%d WHERE `ID`=%d", p_AccountID[ playerid ], p_AccountID[ pID ] ) );
			AddAdminLogLineFormatted( "%s(%d) has forced ac on %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
	        SendGlobalMessage( -1, ""COL_PINK"[ADMIN]"COL_GREY" %s is required to use an anticheat to play by %s. "COL_YELLOW"(www.samp-ac.com)", ReturnPlayerName( pID ), ReturnPlayerName( playerid ) );
	        if ( ! IsPlayerUsingSampAC( pID ) ) KickPlayerTimed( pID );
		}
		else
		{
			p_forcedAnticheat[ pID ] = 0;
			mysql_single_query( sprintf( "UPDATE `USERS` SET `FORCE_AC`=0 WHERE `ID`=%d", p_AccountID[ pID ] ) );
			AddAdminLogLineFormatted( "%s(%d) has removed forced ac on %s(%d)", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
	        SendGlobalMessage( -1, ""COL_PINK"[ADMIN]"COL_GREY" %s has removed the anticheat requirement on %s.", ReturnPlayerName( playerid ), ReturnPlayerName( pID ) );
		}
    }
    return 1;
}

/* Level 6 */
CMD:createbusiness( playerid, params[ ] )
{
    new
		Float: X, Float: Y, Float: Z, cost, type
	;

	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "dd", cost, type ) ) return SendUsage( playerid, "/createbusiness [COST] [TYPE]" );
	else if ( cost < 100 ) return SendError( playerid, "The price must be located above 100 dollars." );
	else if ( ! ( 0 <= type <= 3 ) ) return SendError( playerid, "Invalid business type (Weed=0, Meth=1, Coke=2, Weapons=3)." );
	else
	{
		GetPlayerPos( playerid, X, Y, Z );
		AddAdminLogLineFormatted( "%s(%d) has created a business", ReturnPlayerName( playerid ), playerid );

		new
			iTmp = CreateBusiness( 0, "Business", cost, type, X, Y, Z );

	    if ( iTmp != -1 ) {
			SaveToAdminLog( playerid, iTmp, "created business" );
	    	SendClientMessageFormatted( playerid, -1, ""COL_PINK"[BUSINESS]"COL_WHITE" You have created a %s business taking up business id %d.", ConvertPrice( cost ), iTmp );
	    } else {
			SendClientMessage( playerid, -1, ""COL_PINK"[BUSINESS]"COL_WHITE" Unable to create a business due to a unexpected error." );
		}
	}
	return 1;
}

CMD:destroybusiness( playerid, params[ ] )
{
	new
	    iBusiness;

	if ( p_AdminLevel[ playerid ] < 5 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d", iBusiness ) ) return SendUsage( playerid, "/destroybusiness [BUSINESS_ID]" );
	else if ( iBusiness < 0 || iBusiness >= MAX_BUSINESSES ) return SendError( playerid, "Invalid Business ID." );
	else if ( !Iter_Contains( business, iBusiness ) ) return SendError( playerid, "Invalid Business ID." );
	else
	{
		SaveToAdminLog( playerid, iBusiness, "destroy business" );
		format( szBigString, sizeof( szBigString ), "[DG] [%s] %s | %d | %d\r\n", getCurrentDate( ), ReturnPlayerName( playerid ), g_businessData[ iBusiness ] [ E_OWNER_ID ], iBusiness );
	    AddFileLogLine( "log_business.txt", szBigString );
		AddAdminLogLineFormatted( "%s(%d) has deleted a business", ReturnPlayerName( playerid ), playerid );
	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[BUSINESS]"COL_WHITE" You have destroyed the business ID %d.", iBusiness );
	    DestroyBusiness( iBusiness );
	}
	return 1;
}

CMD:reloadeditor( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 6 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	SetServerRule( "reloadfs", "objecteditor" );
	SendClientMessage( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have successfully reloaded the object editor." );
	return 1;
}

CMD:createentrance( playerid, params[ ] )
{
    new
		Float: X, Float: Y, Float: Z,
		Float: toX, Float: toY, Float: toZ,
		ownerid, interior, world, customInterior, vipOnly, label[32]
	;

	if ( p_AdminLevel[ playerid ] < 6 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, sscanf_u # "fffdddds[32]", ownerid, toX, toY, toZ, interior, world, customInterior, vipOnly, label ) ) return SendUsage( playerid, "/createhouse [OWNER] [TO_X] [TO_Y] [TO_Z] [INTERIOR] [WORLD] [CUSTOM_INTERIOR] [VIP_ONLY] [LABEL]" );
	else if ( !IsPlayerConnected( ownerid ) || IsPlayerNPC( ownerid ) ) return SendError( playerid, "Invalid Player ID." );
	else
	{
		AddAdminLogLineFormatted( "%s(%d) has created an entrance", ReturnPlayerName( playerid ), playerid );

		if ( GetPlayerPos( playerid, X, Y, Z ) ) {
			new
				entranceid = CreateEntrance( label, X, Y, Z, toX, toY, toZ, interior, world, customInterior > 0, vipOnly > 0 );

		    if ( entranceid == -1 )
				return SendClientMessage( playerid, -1, ""COL_PINK"[HOUSE]"COL_WHITE" Unable to create a entrance due to a unexpected error." );

			SaveToAdminLog( playerid, entranceid, "created entrance" );
			g_entranceData[ entranceid ] [ E_SAVED ] = true;

			format( szBigString, 256, "INSERT INTO `ENTRANCES` (`OWNER`, `LABEL`, `X`, `Y`, `Z`, `EX`, `EY`, `EZ`, `INTERIOR`, `WORLD`, `CUSTOM`, `VIP_ONLY`) VALUES ('%s','%s',%f,%f,%f,%f,%f,%f,%d,%d,%d,%d)", mysql_escape( ReturnPlayerName( ownerid ) ), mysql_escape( label ), X, Y, Z, toX, toY, toZ, interior, world, customInterior, vipOnly );
			mysql_single_query( szBigString );

	    	SendClientMessageFormatted( playerid, -1, ""COL_PINK"[HOUSE]"COL_WHITE" You have created a entrance using id %d.", entranceid );
		}
	}
	return 1;
}

CMD:destroyentrance( playerid, params[ ] )
{
	new
		Float: distance = FLOAT_INFINITY, confirm,
	    entranceid = GetClosestEntrance( playerid, distance );

	if ( p_AdminLevel[ playerid ] < 6 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d", confirm ) ) return SendUsage( playerid, "/destroyentrance [ARE_YOU_SURE (0 or 1)]" );
	else if ( confirm < 1 ) return SendError( playerid, "Must confirm by typing a number above 0." );
	else if ( entranceid < 0 || entranceid > MAX_ENTERS ) return SendError( playerid, "Invalid entrance ID." );
	else if ( !Iter_Contains( entrances, entranceid ) ) return SendError( playerid, "Invalid entrance ID." );
	else if ( !g_entranceData[ entranceid ] [ E_SAVED ] ) return SendError( playerid, "Must be a saved entrance." );
	else if ( distance > 100.0 ) return SendError( playerid, "Must be within 10m of the nearest entrance." );
	else
	{
		// log deletions
		format( szBigString, sizeof( szBigString ), "[DE] [%s] %s | %f,%f,%f | %d\r\n", getCurrentDate( ), ReturnPlayerName( playerid ), g_entranceData[ entranceid ] [ E_EX ], g_entranceData[ entranceid ] [ E_EY ], g_entranceData[ entranceid ] [ E_EZ ], entranceid );
	    AddFileLogLine( "log_entrances.txt", szBigString );

	    // delete and log
		SaveToAdminLog( playerid, entranceid, "destroy entrance" );
		AddAdminLogLineFormatted( "%s(%d) has deleted an entrance", ReturnPlayerName( playerid ), playerid );
	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ENTRANCE]"COL_WHITE" You have destroyed entrance id %d", entranceid );
	    DestroyEntrance( entranceid );
	}
	return 1;
}

CMD:setgangleader( playerid, params[ ] )
{
	new
	    gID, pID;

	if ( p_AdminLevel[ playerid ] < 6 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d" #sscanf_u, gID, pID ) ) return SendUsage( playerid, "/setgangleader [GANG_ID] [PLAYER_ID]" );
	else if ( gID < 0 || gID > MAX_GANGS ) return SendError( playerid, "Invalid Gang ID." );
	else if ( !Iter_Contains( gangs, gID ) ) return SendError( playerid, "Invalid Gang ID." );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	// else if ( p_GangID[ pID ] != gID ) return SendError( playerid, "This player isn't in this gang." );
	else
	{
		p_GangID[ pID ] = gID;
        g_gangData[ gID ] [ E_LEADER ] = p_AccountID[ pID ];

		SaveToAdminLogFormatted( playerid, gID, "setgangleader to %s (acc id %d)", ReturnPlayerName( pID ), p_AccountID[ pID ] );
	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[GANG]"COL_WHITE" %s(%d) is now the leader of %s.", ReturnPlayerName( pID ), pID, g_gangData[ gID ] [ E_NAME ] );
		SendClientMessageToGang( gID, g_gangData[ gID ] [ E_COLOR ], "[GANG]{FFFFFF} %s(%d) is the new gang leader, forcefully by %s.", ReturnPlayerName( pID ), pID, ReturnPlayerName( playerid ) );
        SaveGangData( gID );
	}
	return 1;
}

CMD:viewgangtalk( playerid, params[ ] )
{
	new
	    gID;

	if ( p_AdminLevel[ playerid ] < 6 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "d", gID ) )
	{
		if ( p_ViewingGangTalk[ playerid ] != -1 )
		{
			p_ViewingGangTalk[ playerid ] = -1;
			return SendServerMessage( playerid, "You have stopped viewing other gang messages." );
		}
		return SendUsage( playerid, "/viewgangtalk [GANG_ID]" );
	}
	else if ( gID < 0 || gID > MAX_GANGS ) return SendError( playerid, "Invalid Gang ID." );
	else if ( !Iter_Contains( gangs, gID ) ) return SendError( playerid, "Invalid Gang ID." );
	else
	{
		p_ViewingGangTalk[ playerid ] = gID;
	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[GANG]"COL_WHITE" You are now viewing gang messages of %s.", g_gangData[ gID ] [ E_NAME ] );
	}
	return 1;
}

CMD:broadcast( playerid, params[ ] )
{
	new
		szURL[ 128 ]
	;

	if ( p_AdminLevel[ playerid ] < 6 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "s[128]", szURL ) ) return SendUsage( playerid, "/broadcast [MP3_URL]");
	else
	{
		new
			bStopped = strmatch( szURL, "stop" );

		foreach(new i : Player)
		{
			if ( !IsPlayerUsingRadio( i ) )
			{
				if ( bStopped )
				{
	   				StopAudioStreamForPlayer( i );
				}
	   			else
	   			{
	   				PlayAudioStreamForPlayer( i, szURL );
	   			}
			}
		}

		if ( bStopped )
		{
			SendClientMessage( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have stopped broadcasting your audio to players." );
		}
		else
		{
			SaveToAdminLogFormatted( playerid, 0, "broadcast %s", szURL );
			SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" Broadcasting "COL_GREY"%s"COL_WHITE".", szURL );
		}
	}
	return 1;
}

CMD:seteventhost( playerid, params[ ] )
{
	new
	    pID;

	if ( p_AdminLevel[ playerid ] < 5 && p_AccountID[ playerid ] != GetGVarInt( "eventhost" ) ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, #sscanf_u, pID ) ) SendUsage( playerid, "/seteventhost [PLAYER_ID]");
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else if ( p_AdminLevel[ pID ] < 4 ) return SendError( playerid, "The user you specify must have an administration level 4 or above." );
	else
	{
		UpdateServerVariable( "eventhost", p_AccountID[ pID ], 0.0, "", GLOBAL_VARTYPE_INT );
		SaveToAdminLogFormatted( playerid, 0, "seteventhost to %s (acc id %d)", ReturnPlayerName( pID ), p_AccountID[ pID ] );

		if ( playerid != pID )
		{
			AddAdminLogLineFormatted( "%s(%d) has set %s(%d) as event host", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
			SendGlobalMessage( -1, ""COL_PINK"[ADMIN]"COL_WHITE" %s(%d) has designated %s(%d) as the event host!", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID );
		}
		else
		{
			AddAdminLogLineFormatted( "%s(%d) has set himself as event host", ReturnPlayerName( playerid ), playerid );
			SendGlobalMessage( -1, ""COL_PINK"[ADMIN]"COL_WHITE" %s(%d) has designated himself as the event host!", ReturnPlayerName( playerid ), playerid );
		}
	}
	return 1;
}

CMD:setlevel( playerid, params[ ] )
{
	new
	    pID,
	    iLevel
	;
	if ( !IsPlayerAdmin( playerid ) && p_AdminLevel[ playerid ] < 6 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, ""#sscanf_u"d", pID, iLevel ) ) SendUsage( playerid, "/setlevel [PLAYER_ID] [LEVEL]");
	else if ( iLevel < 0 || iLevel > 6 ) return SendError( playerid, "Please specify an administration level between 0 and 6." );
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else
	{
		if ( !IsPlayerLorenc( playerid ) && p_AdminLevel[ playerid ] >= 6 && iLevel > 5 )
			return SendError( playerid, "You maximum level you are able to promote a person to is 5." );

		// Log level
		mysql_single_query( sprintf( "INSERT INTO `ADMIN_LEVELS`(`USER_ID`,`EXEC_ID`,`LEVEL`) VALUES (%d,%d,%d)", p_AccountID[ pID ], p_AccountID[ playerid ], iLevel ) );

		// Set level
		p_AdminLevel[ pID ] = iLevel;
		AddAdminLogLineFormatted( "%s(%d) has set %s(%d)'s admin level to %d", ReturnPlayerName( playerid ), playerid,  ReturnPlayerName( pID ), pID, iLevel );
		SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]{FFFFFF} %s(%d) has set your admin level to %d!", ReturnPlayerName( playerid ), playerid, iLevel );
	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]{FFFFFF} You've set %s(%d)'s admin level to %d!", ReturnPlayerName( pID ), pID, iLevel );
	}
	return 1;
}

CMD:setleveloffline( playerid, params[ ] )
{
	new
		iLevel, szName[ 24 ];

	if ( !IsPlayerAdmin( playerid ) && p_AdminLevel[ playerid ] < 6 ) return SendError( playerid, ADMIN_COMMAND_REJECT );
	else if ( sscanf( params, "ds[24]", iLevel, szName ) ) SendUsage( playerid, "/setleveloffline [LEVEL] [PLAYER_NAME]");
	else if ( iLevel < 0 || iLevel > 6 ) return SendError( playerid, "Please specify an administration level between 0 and 6." );
	else
	{
		if ( !IsPlayerLorenc( playerid ) && p_AdminLevel[ playerid ] >= 6 && iLevel > 4 )
			return SendError( playerid, "You maximum level you are able to promote a person to is 4." );

		mysql_function_query( dbHandle, sprintf( "UPDATE `USERS` SET `ADMINLEVEL`=%d WHERE `NAME`='%s'", iLevel, mysql_escape( szName ) ), true, "OnPlayerUpdateAdminLevel", "iis", playerid, iLevel, szName );
	}
	return 1;
}

thread OnPlayerUpdateAdminLevel( playerid, level, name[ ] )
{
	if ( cache_affected_rows( ) )
	{
		// Log level
		format( szBigString, sizeof( szBigString ), "INSERT INTO `ADMIN_LEVELS`(`USER_ID`,`EXEC_ID`,`LEVEL`) VALUES ((SELECT `ID` FROM `USERS` WHERE `NAME`='%s'),%d,%d)", name, p_AccountID[ playerid ], level );
		mysql_single_query( szBigString );

		// Set level
		AddAdminLogLineFormatted( "%s(%d) has set %s's admin level to %d", ReturnPlayerName( playerid ), playerid, name, level );
	    return SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]{FFFFFF} You've set %s's admin level to %d!", name, level );
	}

	return SendError( playerid, "This user does not exist." );
}

CMD:svrstats( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 6 )
		return SendError( playerid, ADMIN_COMMAND_REJECT );

	if ( strmatch( params, "version" ) )
		return SendServerMessage( playerid, "Current version is "COL_GREY"%s", FILE_BUILD ), 1;

	if ( strmatch( params, "ticks" ) )
		return SendServerMessage( playerid, "Current tick rate of server is: %d", GetServerTickRate( ) ), 1;

	if ( strmatch( params, "uptime" ) )
		return SendServerMessage( playerid, "Server online for "COL_GREY"%s", secondstotime( g_iTime - g_ServerUptime ) ), 1;

	return SendUsage( playerid, "/svrstats [VERSION/TICKS/UPTIME]" ), 1;
}

CMD:playaction( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 6 )
		return SendError( playerid, ADMIN_COMMAND_REJECT );

	new
		pID, action;

	if ( sscanf(params, ""#sscanf_u"d", pID, action ) )
		return SendUsage( playerid, "/playaction [PLAYER_ID] [SPECIAL_ACTION]");

	SetPlayerSpecialAction( pID, action );
	return 1;
}

CMD:playanimation( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 6 )
		return SendError( playerid, ADMIN_COMMAND_REJECT );

	new
		pID,
		szAnimation[ 2 ][ 64 ];

	if ( sscanf(params, ""#sscanf_u"s[64]s[64]", pID, szAnimation[ 0 ], szAnimation[ 1 ] ) )
		return SendUsage( playerid, "/playanimation [PLAYER_ID] [LIBRARY] [ANIM_NAME]");

	ApplyAnimation( pID, szAnimation[0], szAnimation[1], 4.1, 0, 0, 0, 0, 0, 0 );
	return 1;
}

CMD:updaterules( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 6 )
		return SendError( playerid, ADMIN_COMMAND_REJECT );

	HTTP( 0, HTTP_GET, "files.irresistiblegaming.com/en_rules.txt", "", "OnRulesHTTPResponse" );
	SendServerMessage( playerid, "Rules should be updated now." );
	return 1;
}

CMD:truncate( playerid, params[ ] )
{
	new
		bDebt,
		szName[ 24 ];

	if ( p_AdminLevel[ playerid ] < 6 )
		return SendError( playerid, ADMIN_COMMAND_REJECT );

	if ( sscanf( params, "ds[24]", bDebt, szName ) )
		return SendUsage( playerid, "/truncate [DEBT (=1 OR 0)] [PLAYER_NAME]");

	if ( bDebt != 0 && bDebt != 1 )
		return SendError( playerid, "Debt value must be either 1 or 0." );

	mysql_function_query( dbHandle, sprintf( "UPDATE `USERS` SET `CASH`=%d,`BANKMONEY`=0 WHERE `NAME`='%s' AND `ADMINLEVEL` < %d", bDebt ? -250000 : 0, mysql_escape( szName ), p_AdminLevel[ playerid ] ), true, "OnPlayerTruncateUser", "isi", playerid, szName, bDebt );
	return 1;
}

thread OnPlayerTruncateUser( playerid, name[ ], debt )
{
	if ( cache_affected_rows( ) )
	{
	    AddFileLogLine( "log_admin.txt", sprintf( "[TRUNCATE] [%s] %s -> %s\r\n", getCurrentDate( ), ReturnPlayerName( playerid ), name ) );
		AddAdminLogLineFormatted( "%s(%d) has truncated %s's money", ReturnPlayerName( playerid ), playerid, name );

		if ( debt ) {
			SaveToAdminLogFormatted( playerid, 0, "truncate %s (with debt)", name );
	    	return SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]{FFFFFF} You've truncated %s and issued them a 250K debt.", name );
		} else {
			SaveToAdminLogFormatted( playerid, 0, "truncate %s", name );
	    	return SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]{FFFFFF} You've truncated %s.", name );
		}
	}
	return SendError( playerid, "This user does not exist." );
}

CMD:weather( playerid, params[ ] )
{
	if ( p_AdminLevel[ playerid ] < 5 )
		return SendError( playerid, ADMIN_COMMAND_REJECT );

	new
		weatherid;

	if ( sscanf( params, "d", weatherid ) )
		return SendUsage( playerid, "/weather [WEATHER_ID]" );

	g_WorldWeather = weatherid;

	SaveToAdminLogFormatted( playerid, 0, "weather %d", weatherid );
	AddAdminLogLineFormatted( "%s(%d) has changed the weather to %d", ReturnPlayerName( playerid ), playerid, weatherid );
	SendGlobalMessage( -1, ""COL_PINK"[ADMIN]"COL_WHITE" %s(%d) has changed the weather to %d!", ReturnPlayerName( playerid ), playerid, weatherid );
	return 1;
}

/* Level RCON */
CMD:updatepool( playerid, params[ ] )
{
	new
		poolid, pool, win, gamble;

	if ( ! IsPlayerAdmin( playerid ) ) return 0;
	else if ( sscanf( params, "ddD(0)D(0)", poolid, pool, win, gamble ) ) return SendError( playerid, "/updatepool [POOL_ID] [POOL_INCREMENT] [TOTAL_WON] [TOTAL_GAMBLED]" );
	else if ( !Iter_Contains( CasinoPool, poolid ) ) return SendError( playerid, "This Pool ID does not exist!" );
	else
	{
		UpdateCasinoPoolData( poolid, pool, win, gamble );
		SendServerMessage( playerid, "You have updated pool id %d", poolid );
	}
	return 1;
}

CMD:updatedonortd( playerid, params[ ] )
{
	new
		targetid, Float: amount, reset;

	if ( !IsPlayerAdmin( playerid ) ) return 0;
	else if ( sscanf( params, "D(0)D(65535)F(0.0)", reset, targetid, amount ) ) return SendUsage( playerid, "/updatedonortd [RESET] [PLAYER_ID] [AMOUNT]" );
	else
	{
		// Reset the top donor
		if ( reset ) {
			TextDrawSetString( g_TopDonorTD, "Nobody Donated :(" );
		}

		// Update it incase
		UpdateGlobalDonated( targetid, amount );
		SendServerMessage( playerid, "Updating latest donor now (player id %d, amount %f)", targetid, amount );
	}
	return 1;
}

CMD:destroygang( playerid, params[ ] )
{
	new
	    gID
	;

	if ( !IsPlayerAdmin( playerid ) ) return 0;
	else if ( sscanf( params, "d", gID ) ) return SendUsage( playerid, "/destroygang [GANG_ID]" );
	else if ( gID < 0 || gID > MAX_GANGS ) return SendError( playerid, "Invalid gang ID." );
	else if ( !Iter_Contains( gangs, gID ) ) return SendError( playerid, "Invalid gang ID." );
	else
	{
		AddAdminLogLineFormatted( "%s(%d) has deleted a gang", ReturnPlayerName( playerid ), playerid );
	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[GANG]"COL_WHITE" You have destroyed \"%s\" which was the ID of %d.", g_gangData[ gID ] [ E_NAME ], gID );
	    DestroyGang( gID );
	}
	return 1;
}

CMD:time( playerid, params[ ] )
{
	if ( !IsPlayerAdmin( playerid ) )
		return 0;

	new
		timeid;

	if ( sscanf( params, "d", timeid ) )
		return SendUsage( playerid, "/time [SECONDS]" );

	return ( g_WorldClockSeconds = timeid );
}

CMD:playsound( playerid, params[ ] )
{
	if ( !IsPlayerAdmin( playerid ) )
		return 0;

	new
		pID,
		sound;

	if ( sscanf( params, ""#sscanf_u"d", pID, sound ) )
		return SendUsage( playerid, "/playsound [PLAYER_ID] [SOUND]" );

	PlayerPlaySound( pID, sound, 0.0, 0.0, 0.0 );
	return 1;
}

CMD:addgpci( playerid, params[ ] )
{
	new
	    pID;

	if ( !IsPlayerAdmin( playerid ) ) return 0;
	else if ( sscanf( params, #sscanf_u, pID ) ) SendUsage( playerid, "/addgpci [PLAYER_ID]");
	else if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return SendError( playerid, "Invalid Player ID." );
	else
	{
		new
			playerserial[ 45 ];

		gpci( pID, playerserial, sizeof( playerserial ) );
	  	AddFileLogLine( "gpci.txt", sprintf( "USER : %s , GPCI : %s\r\n", ReturnPlayerName( pID ), playerserial ) );
	}
	return 1;
}

CMD:vipdiscount( playerid, params[ ] )
{
	new Float: percent;
	if ( !IsPlayerAdmin( playerid ) ) return 0;
	else if ( sscanf( params, "f", percent ) ) return SendUsage( playerid, "/vipdiscount [PERCENTAGE]" );
	// else if ( percent < 50.0 || percent > 100.0 ) return SendError( playerid, "The percentage must be over 50 and less than 100." );
	else
	{
	    SendServerMessage( playerid, "V.I.P discount percentage set to %f! (old = %f)", percent, GetGVarFloat( "vip_discount" ) );
		UpdateServerVariable( "vip_discount", 0, ( 1 - ( percent / 100 ) ), "", GLOBAL_VARTYPE_FLOAT );
    }
	return 1;
}

CMD:vipbonus( playerid, params[ ] )
{
	new Float: percent;
	if ( !IsPlayerAdmin( playerid ) ) return 0;
	else if ( sscanf( params, "f", percent ) ) return SendUsage( playerid, "/vipbonus [PERCENTAGE]" );
	else if ( percent < 0.0 || percent > 100.0 ) return SendError( playerid, "The percentage must be over 0 and less than 100." );
	else
	{
	    SendServerMessage( playerid, "V.I.P bonus percentage set to %f! (old = %f)", percent, GetGVarFloat( "vip_bonus" ) );
		UpdateServerVariable( "vip_bonus", 0, ( percent / 100 ), "", GLOBAL_VARTYPE_FLOAT );
    }
	return 1;
}

CMD:blockip( playerid, params[ ] )
{
	new address[16], timems;
	if ( !IsPlayerAdmin( playerid ) ) return 0;
	else if (sscanf(params, "ds[16]", timems, address)) SendUsage(playerid, "/blockip [TIME_MS] [IP_ADDRESS]");
	else
	{
		SendClientMessageFormatted( playerid, -1, ""COL_GREY"[BLOCKED]"COL_WHITE" IP %s has been blocked (%d timems).", address, timems );
		BlockIpAddress( address, timems );
	}
	return 1;
}

CMD:unblockip( playerid, params[ ] )
{
	new address[16];
	if ( !IsPlayerAdmin( playerid ) ) return 0;
	else if (sscanf(params, "s[16]", address)) SendUsage(playerid, "/unblockip [IP_ADDRESS]");
	else
	{
		SendClientMessageFormatted( playerid, -1, ""COL_GREY"[BLOCKED]"COL_WHITE" IP %s has been unblocked.", address );
 		UnBlockIpAddress( address );
	}
	return 1;
}

CMD:svrquery( playerid, params[ ] )
{
	new
		szQuery[ 144 ];

	if ( !IsPlayerAdmin( playerid ) ) return 0;
	else if ( sscanf( params, "s[144]", szQuery ) ) return SendUsage( playerid, "/svrquery [QUERY]" );
	else if ( p_AccountID[ playerid ] != 1 ) return SendError( playerid, "No." );
	else
	{
		SendServerMessage( playerid, "%s", szQuery );
  		mysql_function_query( dbHandle, szQuery, true, "OnQueryServerViaRCON", "i", playerid );
	}
	return 1;
}

thread OnQueryServerViaRCON( playerid )
{
	new
		rows, fields, affected = cache_affected_rows( );

    cache_get_data( rows, fields );
	SendClientMessageFormatted( playerid, COLOR_YELLOW, "Query Sent. (Rows: %d, Fields: %d, Affected: %d)", rows, fields, affected );
	return 1;
}

#if ENABLED_SECURE_TRUCK == true
	CMD:connectnpc( playerid, params[ ] )
	{
		if ( !IsPlayerAdmin( playerid ) ) return 0;
		ConnectNPC( SECURE_TRUCK_DRIVER_NAME, "secureguard" );
		SendServerMessage( playerid, "Connecting NPC now." );
		return 1;
	}
#endif

#if ENABLED_EASTER_EGG == true
	CMD:setegg( playerid, params[ ] )
	{
		if ( !IsPlayerAdmin( playerid ) ) return 0;
		if ( g_EasterHunt ) return SendError( playerid, "The " #EASTEREGG_NAME " hunt has already started." );

		new
		    Float: X, Float: Y, Float: Z;

		if ( GetPlayerPos( playerid, X, Y, Z ) ) {
			if ( CreateEasterEgg( X, Y, Z ) != -1 ) {
				SendServerMessage( playerid, "Planted " #EASTEREGG_NAME " at your current position." );
				AddAdminLogLineFormatted( "%s(%d) has set a " #EASTEREGG_NAME "", ReturnPlayerName( playerid ), playerid );
			}
			else SendError( playerid, "There isn't enough room for another " #EASTEREGG_NAME "." );
		}
		return 1;
	}

	CMD:treasurehunt( playerid, params[ ] )
	{
		if ( !IsPlayerAdmin( playerid ) )
			return 0;

		if ( Iter_Count(eastereggs) < 1 )
			return SendError( playerid, "There are not enough " #EASTEREGG_NAME "s planted to start the treasure hunt." );

		// if its false, destroy all egs
		if ( ( g_EasterHunt = ! g_EasterHunt ) == false )
	    {
			for ( new i = 0; i < MAX_EGGS; i ++)
				DestroyEasterEgg( i );
	    }

	    // alert admin log
		AddAdminLogLineFormatted( "%s(%d) has started a treasurehunt", ReturnPlayerName( playerid ), playerid );
	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_GOLD" Treasure Hunt has been %s", g_EasterHunt == true ? ("activated, look around for " #EASTEREGG_NAME "s and get a free gift.") : ("de-activated.") );
		return 1;
	}
#endif

CMD:addcomponent( playerid, params[ ] )
{
	new
		componentid;

	if ( !IsPlayerAdmin( playerid ) ) return 0;
	else if ( sscanf( params, "d", componentid ) ) return SendUsage( playerid, "/addcomponent [COMPONENT_ID]" );
	else if ( !IsPlayerInAnyVehicle( playerid ) ) return SendError( playerid, "You need to be in a vehicle." );
	else
	{
		new vehicleid = GetPlayerVehicleID( playerid );
     	AddVehicleComponent( vehicleid, componentid );
     	SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" Added componentid id %d to this vehicle.", componentid );
	}
	return 1;
}

CMD:replenishsafe( playerid, params[ ] )
{
	new
		rID;

	if ( !IsPlayerAdmin( playerid ) ) return 0;
	else if ( sscanf( params, "d", rID ) ) return SendUsage( playerid, "/replenishsafe [SAFE_ID]" );
	else if (!Iter_Contains(RobberyCount, rID)) return SendError( playerid, "This is an invalid Safe ID." );
	else
	{
		printf( "[GM:ADMIN] %s has replenished %d! (Success: %d)", ReturnPlayerName( playerid ), rID, setSafeReplenished( rID ) );

		SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You've replenished Safe ID %d: "COL_GREY"%s"COL_WHITE".", rID, g_robberyData[ rID ] [ E_NAME ] );
	}
	return 1;
}

CMD:proxies( playerid, params[ ] )
{
	if ( !IsPlayerAdmin( playerid ) ) return 0;
	UpdateServerVariable( "proxyban", GetGVarInt( "proxyban" ) != 0 ? 0 : 1, 0.0, "", GLOBAL_VARTYPE_INT );
	SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You are have %s proxies.", IsProxiesBanned( ) ? ("enabled") : ("disabled"));
	return 1;
}

CMD:driveby( playerid, params[ ] )
{
	if ( !IsPlayerAdmin( playerid ) ) return 0;
	g_Driveby = !g_Driveby;
	SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have %s driveby.", g_Driveby == false ? ("enabled") : ("disabled"));
	return 1;
}

CMD:debug( playerid, params[ ] )
{
	if ( !IsPlayerAdmin( playerid ) ) return 0;
	g_Debugging = !g_Debugging;
	SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have %s debugging.", g_Debugging == true ? ("enabled") : ("disabled"));
	return 1;
}

CMD:vippm( playerid, params[ ] )
{
	if ( !IsPlayerAdmin( playerid ) ) return 0;
	g_VipPrivateMsging = !g_VipPrivateMsging;
	SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have %s vip only messaging.", g_VipPrivateMsging == true ? ("enabled") : ("disabled"));
	return 1;
}

CMD:logcmd( playerid, params[ ] )
{
	if ( !IsPlayerAdmin( playerid ) ) return 0;
	g_CommandLogging = !g_CommandLogging;
	SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You are %s commands.", g_CommandLogging == true ? ("logging") : ("not logging"));
	return 1;
}

CMD:logdialog( playerid, params[ ] )
{
	if ( !IsPlayerAdmin( playerid ) ) return 0;
	g_DialogLogging = !g_DialogLogging;
	SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You are %s dialogs.", g_CommandLogging == true ? ("logging") : ("not logging"));
	return 1;
}

CMD:settaxrate( playerid, params[ ] )
{
	new Float: rate;
	if ( !IsPlayerAdmin( playerid ) ) return 0;
	else if ( sscanf( params, "f", rate ) ) return SendUsage( playerid, "/settaxrate [PERCENTAGE]" );
	else if ( rate < 0 || rate > 50.0 ) return SendError( playerid, "The rate must be over 0 and less than 50." );
	else
	{
	    SendServerMessage( playerid, "You have changed the tax rate from "COL_GREY"%0.2f"COL_WHITE" to "COL_GREY"%0.2f"COL_WHITE".", GetTaxRate( ), rate );
		UpdateServerVariable( "taxrate", 0, rate, "", GLOBAL_VARTYPE_FLOAT );
    }
	return 1;
}

CMD:givewanted( playerid, params[ ] )
{
	new
	    pID, wantedlvl
	;
	if ( !IsPlayerAdmin( playerid ) ) return 0;
	else if ( sscanf( params, ""#sscanf_u"d", pID, wantedlvl ) ) SendUsage( playerid, "/givewanted [PLAYER_ID] [WANTED_LVL]" );
	else if ( !IsPlayerConnected( pID ) ) SendError( playerid, "Invalid Player ID." );
	else
	{
        AddAdminLogLineFormatted( "%s(%d) has gave %s(%d) %d wanted level", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, wantedlvl );
	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have modified %s(%d)'s wanted level by %d.", ReturnPlayerName( pID ), pID, wantedlvl );
        SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]"COL_WHITE" Your wanted level has been modified by %s(%d).", ReturnPlayerName( playerid ), playerid );
		GivePlayerWantedLevel( pID, wantedlvl );
	}
	return 1;
}

CMD:givescore( playerid, params[ ] )
{
	new
	    pID, score
	;
	if ( !IsPlayerAdmin( playerid ) ) return 0;
	else if ( sscanf( params, ""#sscanf_u"d", pID, score ) ) SendUsage( playerid, "/givescore [PLAYER_ID] [SCORE]" );
	else if ( !IsPlayerConnected( pID ) ) SendError( playerid, "Invalid Player ID." );
	else
	{
        AddAdminLogLineFormatted( "%s(%d) has given %s(%d)'s %d score", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, score );
	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have given %s(%d) %d score!", ReturnPlayerName( pID ), pID, score );
        SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You have been given %d score from %s(%d)!", score, ReturnPlayerName( playerid ), playerid );
		SetPlayerScore( pID, GetPlayerScore( pID ) + score );
	}
	return 1;
}

CMD:ping( playerid, params[ ] )
{
	new ping;

	if ( !IsPlayerAdmin( playerid ) ) return 0;
	else if ( sscanf( params, "d", ping ) ) return SendUsage( playerid, "/ping [PING]" );
	else if ( ping < 200 ) return SendError( playerid, "The ping cannot be under 200." );
	else
	{
	    g_PingLimit = ping;
		AddAdminLogLineFormatted( "%s(%d) set the ping limit to %d", ReturnPlayerName( playerid ), playerid, ping );
		SendGlobalMessage( -1, ""COL_PINK"[ADMIN]"COL_WHITE" %s(%d) set the ping limit to %d", ReturnPlayerName( playerid ), playerid, ping );
	}
	return 1;
}

CMD:givexp( playerid, params [ ] )
{
	new
	    pID,
	    xp
	;
	if ( !IsPlayerAdmin( playerid ) || !IsPlayerLorenc( playerid ) ) return 0;
	else if ( sscanf( params, ""#sscanf_u"d", pID, xp ) ) SendUsage( playerid, "/givexp [PLAYER_ID] [XP_AMOUNT]" );
	else if ( !IsPlayerConnected( pID ) ) SendError( playerid, "Invalid Player ID." );
	else
	{
	    GivePlayerXP( pID, xp );
        AddAdminLogLineFormatted( "%s(%d) has given %s(%d) %d XP", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, xp );
	    SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]{FFFFFF} %s(%d) has given you %d XP.", ReturnPlayerName( playerid ), playerid, xp );
	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]{FFFFFF} You've given %s(%d) %d XP.", ReturnPlayerName( pID ), pID, xp );
	}
	return 1;
}

CMD:giveip( playerid, params [ ] )
{
	new
	    pID,
	    ip
	;
	if ( !IsPlayerAdmin( playerid ) || !IsPlayerLorenc( playerid ) ) return 0;
	else if ( sscanf( params, ""#sscanf_u"d", pID, ip ) ) SendUsage( playerid, "/giveip [PLAYER_ID] [IP_AMOUNT]" );
	else if ( !IsPlayerConnected( pID ) ) SendError( playerid, "Invalid Player ID." );
	else
	{
	    GivePlayerIrresistiblePoints( pID, ip );
        //AddAdminLogLineFormatted( "%s(%d) has given %s(%d) %d IP", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, ip );
	   	//SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]{FFFFFF} %s(%d) has given you %d IP.", ReturnPlayerName( playerid ), playerid, ip );
	    //SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]{FFFFFF} You've given %s(%d) %d IP.", ReturnPlayerName( pID ), pID, ip );
	}
	return 1;
}

CMD:givecoins( playerid, params [ ] )
{
	new
	    sendtoid,
	    Float: coins
	;
	if ( !IsPlayerAdmin( playerid ) || !IsPlayerLorenc( playerid ) ) return 0;
	else if ( sscanf( params, ""#sscanf_u"f", sendtoid, coins ) ) SendUsage( playerid, "/givecoins [PLAYER_ID] [COINS]" );
	else if ( !IsPlayerConnected( sendtoid ) ) SendError( playerid, "Invalid Player ID." );
	else
	{
	    p_IrresistibleCoins[ sendtoid ] += coins;
        AddAdminLogLineFormatted( "%s(%d) has given %s(%d) %0.2f IC", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( sendtoid ), sendtoid, coins );
	    SendClientMessageFormatted( sendtoid, -1, ""COL_PINK"[ADMIN]{FFFFFF} %s(%d) has given you %0.2f IC.", ReturnPlayerName( playerid ), playerid, coins );
	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]{FFFFFF} You've given %s(%d) %0.2f IC.", ReturnPlayerName( sendtoid ), sendtoid, coins );
	}
	return 1;
}

CMD:givecash( playerid, params [ ] )
{
	new
	    pID,
	    cash
	;
	if ( !IsPlayerAdmin( playerid ) || !IsPlayerLorenc( playerid ) ) return 0;
	else if ( sscanf( params, ""#sscanf_u"d", pID, cash ) ) SendUsage( playerid, "/givecash [PLAYER_ID] [CASH]" );
	else if ( !IsPlayerConnected( pID ) ) SendError( playerid, "Invalid Player ID." );
	else
	{
	    GivePlayerCash( pID, cash );
		AddAdminLogLineFormatted( "%s(%d) has given %s(%d) %d dollars", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( pID ), pID, cash );
	    SendClientMessageFormatted( pID, -1, ""COL_PINK"[ADMIN]{FFFFFF} %s(%d) has given you "COL_GOLD"%s", ReturnPlayerName( playerid ), playerid, ConvertPrice( cash ) );
	    SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]{FFFFFF} You've given %s(%d) "COL_GOLD"%s", ReturnPlayerName( pID ), pID, ConvertPrice( cash ) );
	}
	return 1;
}

CMD:setviplevel( playerid, params[ ] )
{
	new
	    pID,
	    level
	;

	if ( !IsPlayerAdmin( playerid ) || !IsPlayerLorenc( playerid ) ) return 0;
    else if ( sscanf( params, ""#sscanf_u"d", pID, level ) ) return SendUsage( playerid, "/setviplevel [PLAYER_ID] [VIP_LEVEL]" );
	else if ( !IsPlayerConnected( pID ) ) SendError( playerid, "Invalid Player ID." );
	else if ( p_PlayerLogged{ pID } == false ) return SendError( playerid, "This player is not logged in." );
	else if ( level > VIP_DIAMOND || level < 0 ) return SendError( playerid, "Specify a level between 0 - 5 please!" );
    else
    {
	    SetPlayerVipLevel( pID, level );
        SendClientMessageFormatted( playerid, -1, ""COL_GOLD"[VIP LEVEL]"COL_WHITE" You have set %s(%d)'s VIP package to %s.", ReturnPlayerName( pID ), pID, VIPToString( level ) );
		SendClientMessageFormatted( pID, -1, ""COL_GOLD"[VIP LEVEL]"COL_WHITE" Your VIP package has been set to %s by %s(%d)", VIPToString( level ), ReturnPlayerName( playerid ), playerid );
    }
	return 1;
}

CMD:extendvip( playerid, params[ ] )
{
	new
	    pID,
	    days
	;

	if ( !IsPlayerAdmin( playerid ) ) return 0;
    else if ( sscanf( params, ""#sscanf_u"d", pID, days ) ) return SendUsage( playerid, "/extendvip [PLAYER_ID] [DAYS]" );
	else if ( !IsPlayerConnected( pID ) ) SendError( playerid, "Invalid Player ID." );
	else if ( p_VIPLevel[ pID ] < VIP_REGULAR ) return SendError( playerid, "This player doesn't have a V.I.P level." );
	else if ( days < -365 || days > 365 ) return SendError( playerid, "Extension can only vary from -365 to 365 days." );
	else
	{
	    p_VIPExpiretime[ pID ] += ( days ) * 86400;
	    if ( days >= 0 )
	    {
			SendClientMessageFormatted( pID, -1, ""COL_GOLD"[VIP EXTENSION]"COL_WHITE" You have had your V.I.P extended for "COL_GREEN"%d days"COL_WHITE" by %s(%d).", days, ReturnPlayerName( playerid ), playerid );
			SendClientMessageFormatted( playerid, -1, ""COL_GOLD"[VIP EXTENSION]"COL_WHITE" You have extended %s(%d)'s V.I.P for "COL_GREEN"%d days"COL_WHITE".", ReturnPlayerName( pID ), pID, days );
		}
		else
		{
            days = days * -1; // conversion to whole number
			SendClientMessageFormatted( pID, -1, ""COL_GOLD"[VIP EXTENSION]"COL_WHITE" You have had your V.I.P decremented for "COL_RED"%d days"COL_WHITE" by %s(%d).", days, ReturnPlayerName( playerid ), playerid );
			SendClientMessageFormatted( playerid, -1, ""COL_GOLD"[VIP EXTENSION]"COL_WHITE" You have decremented %s(%d)'s V.I.P for "COL_RED"%d days"COL_WHITE".", ReturnPlayerName( pID ), pID, days );
		}
    }
	return 1;
}

CMD:kickall( playerid, params[ ] )
{
	if ( !IsPlayerAdmin( playerid ) ) return 0;
	SetServerRule( "password", "updating" );
	SendClientMessageToAll( -1, ""COL_PINK"[ADMIN]"COL_WHITE" Everyone has been kicked from the server due to a server update." );
	for( new i; i < MAX_PLAYERS; i++ ) if ( IsPlayerConnected( i ) && ! IsPlayerNPC( i ) && p_AccountID[ i ] != 1 ) {
		Kick( i );
	}
	return 1;
}

/* End of admin commands */
#if ENABLE_DISCORD == true
/* ** IRC ** */
DQCMD:lastlogged( DCC_Channel: channel, DCC_User: user, params[ ] )
{
	new
		bool: hasPermission;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleVoice, hasPermission );

	if ( hasPermission )
	{
		static
		    player[ MAX_PLAYER_NAME ];

		if ( sscanf( params, "s[24]", player ) ) return 0;
		else
		{
			format( szNormalString, sizeof( szNormalString ), "SELECT `LASTLOGGED` FROM `USERS` WHERE `NAME` = '%s' LIMIT 0,1", mysql_escape( player ) );
	  		mysql_function_query( dbHandle, szNormalString, true, "OnPlayerLastLogged", "iis", INVALID_PLAYER_ID, 1, player );
		}
	}
	else DCC_SendUserMessage( user, "**Error:** This command requires voice." );
	return 1;
}

DQCMD:weeklytime( DCC_Channel: channel, DCC_User: user, params[ ] )
{
	new
		bool: hasPermission;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleVoice, hasPermission );

	if ( hasPermission )
	{
		static
		    player[ MAX_PLAYER_NAME ]
		;

		if ( sscanf( params, "s[24]", player ) ) return 0;
		else
		{
			format( szNormalString, sizeof( szNormalString ), "SELECT `UPTIME`,`WEEKEND_UPTIME` FROM `USERS` WHERE `NAME` = '%s' LIMIT 0,1", mysql_escape( player ) );
	  		mysql_function_query( dbHandle, szNormalString, true, "OnPlayerWeeklyTime", "iis", INVALID_PLAYER_ID, 1, player );
		}
	}
	else DCC_SendUserMessage( user, "**Error:** This command requires voice." );
	return 1;
}

DQCMD:idof( DCC_Channel: channel, DCC_User: user, params[ ] )
{
	new
		bool: hasPermission;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleVoice, hasPermission );

	if ( hasPermission )
	{
		new pID;
		if ( sscanf( params, ""#sscanf_u"", pID ) ) return 0;
		if ( !IsPlayerConnected( pID ) || IsPlayerNPC( pID ) ) return 0;
		format( szNormalString, sizeof( szNormalString ), "**In-game ID of %s:** %d", ReturnPlayerName( pID ), pID );
		DCC_SendChannelMessage( discordGeneralChan, szNormalString );
	}
	else DCC_SendUserMessage( user, "**Error:** This command requires voice." );
	return 1;
}

DQCMD:say( DCC_Channel: channel, DCC_User: user, params[ ] )
{
	new
		bool: hasPermission;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleVoice, hasPermission );

	if ( hasPermission )
	{
		new
			szAntispam[ 64 ];
		printf("SAY %s", params);
		if ( !isnull( params ) && !textContainsIP( params ) )
		{
			format( szAntispam, 64, "!say_%s", ReturnDiscordName( user ) );
			if ( GetGVarInt( szAntispam ) < g_iTime )
			{
				new
					bool: hasAdmin;

				DCC_HasGuildMemberRole( discordGuild, user, discordRoleLead, hasAdmin );

				if ( hasAdmin )
					SetGVarInt( szAntispam, g_iTime + 2 );

				// send message
				SendClientMessageToAllFormatted( -1, "{4DFF88}(Discord %s) {00CD45}%s:{FFFFFF} %s", discordLevelToString( user ), ReturnDiscordName( user ), params );
				DCC_SendChannelMessageFormatted( discordGeneralChan, "**(Discord %s) %s:** %s", discordLevelToString( user ), ReturnDiscordName( user ), params );
			}
			else DCC_SendUserMessage( user, "You must wait 2 seconds before speaking again." );
		}
	}
	else DCC_SendUserMessage( user, "**Error:** This command requires voice." );
	return 1;
}

DQCMD:players( DCC_Channel: channel, DCC_User: user, params[ ] )
{
	new
		bool: hasPermission;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleVoice, hasPermission );

	print("Called players");
	if ( hasPermission )
	{
		print("Has permission");
		new
			iPlayers = Iter_Count(Player);

		szLargeString[ 0 ] = '\0';
		if ( iPlayers <= 25 )
		{
			foreach(new i : Player) {
			    if ( IsPlayerConnected( i ) ) {
			        format( szLargeString, sizeof( szLargeString ), "%s%s(%d), ", szLargeString, ReturnPlayerName( i ), i );
			    }
			}
		}
		format( szLargeString, sizeof( szLargeString ), "%sThere are %d player(s) online.", szLargeString, iPlayers );
		DCC_SendChannelMessage( discordGeneralChan, szLargeString );
	}
	else DCC_SendUserMessage( user, "**Error:** This command requires voice." );
	return 1;
}

DQCMD:admins( DCC_Channel: channel, DCC_User: user, params[ ] )
{
	new
		bool: hasPermission;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleVoice, hasPermission );

	if ( hasPermission )
	{
		new count = 0;
		szBigString[ 0 ] = '\0';

		foreach(new i : Player) {
		    if ( IsPlayerConnected( i ) && p_AdminLevel[ i ] > 0 ) {
		        format( szBigString, sizeof( szBigString ), "%s%s(%d), ", szBigString, ReturnPlayerName( i ), i );
		        count++;
		    }
		}

		format( szBigString, sizeof( szBigString ), "%sThere are %d admin(s) online.", szBigString, count );
		DCC_SendChannelMessage( discordGeneralChan, szBigString );
	}
	else DCC_SendUserMessage( user, "**Error:** This command requires voice." );
	return 1;
}

/* HALF OP */
DQCMD:acmds( DCC_Channel: channel, DCC_User: user, params[ ] )
{
	new
		bool: hasPermission;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleLead, hasPermission );
	if ( hasPermission )
	{
 		DCC_SendUserMessage( user, 	"__**Lead Admin:**__ !kick, !ban, !suspend, !warn, !jail, !getip, !(un)mute\n"\
 							 		"__**Admin:**__ !unban, !unbanip" );
	}
	return 1;
}

DQCMD:kick( DCC_Channel: channel, DCC_User: user, params[ ] )
{
	new
		bool: hasPermission;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleLead, hasPermission );
	if ( hasPermission )
	{
		new pID, reason[64];
		if (sscanf( params, ""#sscanf_u"S(No reason)[64]", pID, reason)) return DCC_SendUserMessage( user, "**Usage:** !kick [PLAYER_ID] [REASON]" );
		if (IsPlayerConnected(pID))
		{
			DCC_SendChannelMessageFormatted( discordAdminChan, "**Command Success:** %s(%d) has been kicked.", ReturnPlayerName( pID ), pID );
		    SendGlobalMessage( -1, ""COL_PINK"[DISCORD ADMIN]{FFFFFF} %s(%d) has been kicked by %s "COL_GREEN"[REASON: %s]", ReturnPlayerName(pID), pID, ReturnDiscordName( user ), reason);
			KickPlayerTimed( pID );
		}
		else DCC_SendUserMessage( user, "**Command Error:** Player is not connected!" );
	}
	return 1;
}

DQCMD:ban( DCC_Channel: channel, DCC_User: user, params[ ] )
{
	new
		bool: hasPermission;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleLead, hasPermission );
	if ( hasPermission )
	{
		new pID, reason[64];
		if (sscanf( params, ""#sscanf_u"S(No reason)[64]", pID, reason)) return DCC_SendUserMessage( user, "**Usage:** !ban [PLAYER_ID] [REASON]" );
		if (IsPlayerConnected(pID))
		{
			DCC_SendChannelMessageFormatted( discordAdminChan, "**Command Success:** %s(%d) has been banned.", ReturnPlayerName( pID ), pID );
		    SendGlobalMessage( -1, ""COL_PINK"[DISCORD ADMIN]{FFFFFF} %s has banned %s(%d) "COL_GREEN"[REASON: %s]", ReturnDiscordName( user ), ReturnPlayerName( pID ), pID, reason );
			AdvancedBan( pID, "Discord Administrator", reason, ReturnPlayerIP( pID ) );
		}
		else DCC_SendUserMessage( user, "**Command Error:** Player is not connected!" );
	}
	return 1;
}

DQCMD:suspend( DCC_Channel: channel, DCC_User: user, params[ ] )
{
	new
		bool: hasPermission;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleLead, hasPermission );
	if ( hasPermission )
	{
		new pID, reason[50], hours, days;
		if ( sscanf( params, ""#sscanf_u"ddS(No Reason)[50]", pID, hours, days, reason ) ) return DCC_SendUserMessage( user, "**Usage:** !suspend [PLAYER_ID] [HOURS] [DAYS] [REASON]" );
		if ( hours < 0 || hours > 24 ) return DCC_SendUserMessage( user, "**Command Error:** Please specify an hour between 0 and 24." );
		if ( days < 0 || days > 60 ) return DCC_SendUserMessage( user, "**Command Error:** Please specifiy the amount of days between 0 and 60." );
		if ( days == 0 && hours == 0 ) return DCC_SendUserMessage( user, "**Command Error:** Invalid time specified." );
		if ( IsPlayerConnected( pID ) )
		{
			DCC_SendChannelMessageFormatted( discordAdminChan, "**Command Success:** %s(%d) has been suspended for %d hour(s) and %d day(s).", ReturnPlayerName( pID ), pID, hours, days );
			SendGlobalMessage( -1, ""COL_PINK"[DISCORD ADMIN]{FFFFFF} %s has suspended %s(%d) for %d hour(s) and %d day(s) "COL_GREEN"[REASON: %s]", ReturnDiscordName( user ), ReturnPlayerName( pID ), pID, hours, days, reason );
			new time = g_iTime + ( hours * 3600 ) + ( days * 86400 );
			AdvancedBan( pID, "Discord Administrator", reason, ReturnPlayerIP( pID ), time );
		}
		else DCC_SendUserMessage( user, "**Command Error:** Player is not connected!" );
	}
	return 1;
}

DQCMD:warn( DCC_Channel: channel, DCC_User: user, params[ ] )
{
	new
		bool: hasPermission;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleLead, hasPermission );
	if ( hasPermission )
	{
		new pID, reason[50];
		if ( sscanf( params, ""#sscanf_u"S(No Reason)[32]", pID, reason ) ) return DCC_SendUserMessage( user, "**Usage:** !warn [PLAYER_ID] [REASON]" );
		if ( IsPlayerConnected( pID ) )
		{
	    	p_Warns[ pID ] ++;
			DCC_SendChannelMessageFormatted( discordAdminChan, "**Command Success:** %s(%d) has been warned [%d/3].", ReturnPlayerName( pID ), pID, p_Warns[ pID ] );
        	SendGlobalMessage( -1, ""COL_PINK"[ADMIN]"COL_WHITE" %s(%d) has been warned by %s "COL_GREEN"[REASON: %s]", ReturnPlayerName( pID ), pID, ReturnDiscordName( user ), reason );

			if ( p_Warns[ pID ] >= 3 )
		    {
		        p_Warns[ pID ] = 0;
		        SendGlobalMessage( -1, ""COL_PINK"[ADMIN]"COL_WHITE" %s(%d) has been kicked from the server. "COL_GREEN"[REASON: Excessive Warns]", ReturnPlayerName( pID ), pID );
		        KickPlayerTimed( pID );
		        return 1;
		    }
		}
		else DCC_SendUserMessage( user, "**Command Error:** Player is not connected!" );
	}
	return 1;
}

DQCMD:jail( DCC_Channel: channel, DCC_User: user, params[ ] )
{
	new
		bool: hasPermission;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleLead, hasPermission );
	if ( hasPermission )
	{
		new pID, reason[50], Seconds;
		if ( sscanf( params, ""#sscanf_u"dS(No Reason)[32]", pID, Seconds, reason ) ) return DCC_SendUserMessage( user, "**Usage:** !jail [PLAYER_ID] [SECONDS] [REASON]" );
		if ( Seconds > 20000 || Seconds < 1 ) return DCC_SendUserMessage( user, "**Command Error:** You're misleading the seconds limit! ( 0 - 20000 )");
		if ( IsPlayerConnected( pID ) )
		{
			DCC_SendChannelMessageFormatted( discordAdminChan, "**Command Success:** %s(%d) has been jailed for %d seconds.", ReturnPlayerName( pID ), pID, Seconds );
	    	SendGlobalMessage( -1, ""COL_GOLD"[DISCORD JAIL]{FFFFFF} %s(%d) has been sent to jail for %d seconds by %s "COL_GREEN"[REASON: %s]", ReturnPlayerName( pID ), pID, Seconds, ReturnDiscordName( user ), reason );
        	JailPlayer( pID, Seconds, 1 );
		}
		else DCC_SendUserMessage( user, "**Command Error:** Player is not connected!" );
	}
	return 1;
}

DQCMD:mute( DCC_Channel: channel, DCC_User: user, params[ ] )
{
	new
		bool: hasPermission;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleLead, hasPermission );
	if ( hasPermission )
	{
	    new pID, seconds, reason[ 32 ];

		if ( sscanf( params, ""#sscanf_u"dS(No Reason)[32]", pID, seconds, reason ) ) return DCC_SendUserMessage( user, "**Usage:** !amute [PLAYER_ID] [SECONDS] [REASON]");
	    else if ( !IsPlayerConnected( pID ) ) DCC_SendUserMessage( user, "**Command Error:** Invalid Player ID.");
		else if ( p_AdminLevel[ pID ] > 4 ) return DCC_SendUserMessage( user, "**Command Error:** No sexy head admin targetting!");
	    else if ( seconds < 0 || seconds > 10000000 ) return DCC_SendUserMessage( user, "**Command Error:** Specify the amount of seconds from 1 - 10000000." );
	    else
		{
	        SendGlobalMessage( -1, ""COL_PINK"[DISCORD ADMIN]{FFFFFF} %s has been muted by %s for %d seconds "COL_GREEN"[REASON: %s]", ReturnPlayerName( pID ), ReturnDiscordName( user ), seconds, reason );
			GameTextForPlayer( pID, "~r~Muted!", 4000, 4 );
	        p_Muted{ pID } = true;
	        p_MutedTime[ pID ] = g_iTime + seconds;
	    }
	}
	return 1;
}

DQCMD:unmute( DCC_Channel: channel, DCC_User: user, params[ ] )
{
	new
		bool: hasPermission;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleLead, hasPermission );
	if ( hasPermission )
	{
    	new pID;
	    if ( sscanf( params, ""#sscanf_u"", pID )) return DCC_SendUserMessage( user, "/mute [PLAYER_ID]");
	    else if ( !IsPlayerConnected( pID ) ) return DCC_SendUserMessage( user,  "**Command Error:** Invalid Player ID");
	    else if ( !p_Muted{ pID } ) return DCC_SendUserMessage( user,  "**Command Error:** This player isn't muted" );
	    else
		{
	        SendGlobalMessage( -1, ""COL_PINK"[DISCORD ADMIN]{FFFFFF} %s has been un-muted by %s.", ReturnPlayerName( pID ), ReturnDiscordName( user ) );
			GameTextForPlayer( pID, "~g~Un-Muted!", 4000, 4 );
	        p_Muted{ pID } = false;
	        p_MutedTime[ pID ] = 0;
	    }
	}
    return 1;
}

DQCMD:getip( DCC_Channel: channel, DCC_User: user, params[ ] )
{
	new
		bool: hasPermission;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleLead, hasPermission );
	if ( hasPermission )
	{
		new pID;
		if ( sscanf( params, ""#sscanf_u"", pID ) ) return DCC_SendUserMessage( user, "**Usage:** !warn [PLAYER_ID] [REASON]" );
		if ( IsPlayerConnected( pID ) )
		{
			if ( p_AdminLevel[ pID ] > 4 ) return DCC_SendUserMessage( user, "**Command Error:** No sexy head admin targetting!");
			DCC_SendChannelMessageFormatted( discordAdminChan, "**Command Success:** %s(%d)'s IP is 14%s", ReturnPlayerName( pID ), pID, ReturnPlayerIP( pID ) );
		}
		else DCC_SendUserMessage( user, "**Command Error:** Player is not connected!" );
	}
	return 1;
}

/* OP */
DQCMD:unban( DCC_Channel: channel, DCC_User: user, params[ ] )
{
	new
		player[24],
		Query[70],
		bool: hasPermission
	;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleHead, hasPermission );

	if ( ! hasPermission ) return 0;
	else if ( sscanf( params, "s[24]", player ) ) return DCC_SendUserMessage( user, "**Usage:** !unban [PLAYER]" );
	else
	{
		format( Query, sizeof( Query ), "SELECT `NAME` FROM `BANS` WHERE `NAME` = '%s'", mysql_escape( player ) );
		mysql_function_query( dbHandle, Query, true, "OnPlayerUnbanPlayer", "dds", INVALID_PLAYER_ID, 1, player );
	}
	return 1;
}

DQCMD:unbanip( DCC_Channel: channel, DCC_User: user, params[ ] )
{
	new
		address[16],
		Query[70],
		bool: hasPermission
	;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleHead, hasPermission );

	if ( ! hasPermission ) return 0;
	else if (sscanf(params, "s[16]", address)) return DCC_SendUserMessage( user, "**Usage:** !unbanip [IP]" );
	else
	{
		format( Query, sizeof( Query ), "SELECT `IP` FROM `BANS` WHERE `IP` = '%s'", mysql_escape( address ) );
		mysql_function_query( dbHandle, Query, true, "OnPlayerUnbanIP", "dds", INVALID_PLAYER_ID, 0, address );
	}
	return 1;
}

/* Executive */
DQCMD:kickall( DCC_Channel: channel, DCC_User: user, params[ ] )
{
	new
		bool: hasPermission;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleExecutive, hasPermission );
	if ( hasPermission )
	{
		SendGlobalMessage( -1, ""COL_PINK"[ADMIN]"COL_WHITE" Everyone has been kicked from the server due to a server update." );
		for( new i, g = GetMaxPlayers( ); i < g; i++ )
		{
		    if ( IsPlayerConnected( i ) )
		    {
		        Kick( i );
		    }
		}
		DCC_SendChannelMessage( discordAdminChan, "**Command Success:** All users have been kicked from the server." );
	}
	return 1;
}

DQCMD:rcon( DCC_Channel: channel, DCC_User: user, params[ ] )
{
	new
		bool: hasPermission;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleExecutive, hasPermission );

	if ( hasPermission )
	{
		if ( ! isnull( params ) )
		{
			if ( strcmp( params, "exit", true ) != 0 )
			{
				DCC_SendChannelMessageFormatted( discordAdminChan, "RCON command **%s** has been executed.", params );
				SendRconCommand( params );
			}
		}
	}
	return 1;
}
#endif
/* ** End of Commands ** */

public OnTrailerUpdate( playerid, vehicleid )
{
	new
		iModel = GetVehicleModel( GetPlayerVehicleID( playerid ) );

	if ( p_LastAttachedVehicle[ playerid ] != vehicleid && iModel != 525 )
	{
		if ( !p_hasTruckingJob{ playerid } )
			ShowPlayerHelpDialog( playerid, 3000, "You can begin a trucking job by typing ~g~~h~/work" );
		else
			cancelPlayerTruckingCourier( playerid, GetPlayerVehicleID( playerid ), .ticks = 0 );

		p_LastAttachedVehicle[ playerid ] = vehicleid;
	}
	return 1;
}

public OnPlayerEnterVehicle(playerid, vehicleid, ispassenger)
{
	new
		iModel = GetVehicleModel( vehicleid ),
    	driverid = GetVehicleDriver( vehicleid )
    ;

	ResetPlayerVendingMachineData( playerid );

	if ( !ispassenger )
	{
		new
			iObject = GetGVarInt( "heli_gunner", vehicleid );

		if ( !iObject && ( iModel == 487 || iModel == 497 ) ) { // Chopper gunner!
			SetGVarInt( "heli_gunner", CreateDynamicObject( 19464, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ), vehicleid );
			SetObjectInvisible( GetGVarInt( "heli_gunner", vehicleid ) );
			AttachDynamicObjectToVehicle( GetGVarInt( "heli_gunner", vehicleid ), vehicleid, 0.0, 0.3, -1.75, 0.0, 90.0, 0.0 );
		}

		else if ( iObject && !( iModel == 487 || iModel == 497 ) ) { // An issue, not a maverick but has maverick thing.
			DestroyDynamicObject( iObject );
			DeleteGVar( "heli_gunner", vehicleid );
		}

    	// Stop player team jacking
    	/*if ( driverid != INVALID_PLAYER_ID && p_Class[ playerid ] != CLASS_CIVILIAN && p_Class[ playerid ] == p_Class[ driverid ] )
    		SyncObject( playerid ), GameTextForPlayer( playerid, "~r~Don't jack your teammates~w~!", 2000, 4 );*/

		p_LastVehicle[ playerid ] = vehicleid;
	}
	else
    {
    	switch( iModel )
    	{
    		case 508: // Journey
    		{
		        if ( GetPlayerVirtualWorld( playerid ) == 0 ) // Place in Methlab
		    	{
		            SetPlayerPos( playerid, 1475.8126, 1460.5450, 1011.8170 );
		            SetPlayerInterior( playerid, VW_METH ); // Li
		            SetPlayerVirtualWorld( playerid, vehicleid + VW_METH );
		            SetPVarInt( playerid, "inMethLab", 1 );
		            pauseToLoad( playerid );
		        }
		   	}
		   	case 519: // Shamal
		   	{
		     	SetPlayerPos( playerid, 1322.6577, 1992.5508, 1200.2574 );
		     	SetPlayerVirtualWorld( playerid, vehicleid + VW_SHAMAL );
		   		SetPlayerInterior( playerid, VW_SHAMAL );
		     	pauseToLoad( playerid );
		   	}
    	}

		// Enter a wanted players vehicle?
    	if ( driverid != INVALID_PLAYER_ID && !p_WantedLevel[ playerid ] && p_Class[ playerid ] != CLASS_POLICE )
    	{
    		if ( p_WantedLevel[ driverid ] > 1 )
    			GivePlayerWantedLevel( playerid, 2 );

    		else if ( p_WantedLevel[ driverid ] > 5 )
    			GivePlayerWantedLevel( playerid, 6 );

    		else if ( p_WantedLevel[ driverid ] > 11 )
    			GivePlayerWantedLevel( playerid, 12 );
    	}
    }

	if ( IsPlayerAttachedObjectSlotUsed( playerid, 0 ) ) // [PRO_LIZZY] Once you enter a vehicle, and cancel entering, no animation is applied.
	    CallLocalFunction( "OnPlayerKeyStateChange", "ddd", playerid, KEY_CROUCH, KEY_SPRINT );

	return 1;
}

public OnPlayerExitVehicle(playerid, vehicleid)
{
	new
		iRace = p_raceLobbyId[ playerid ],
		iModel = GetVehicleModel( vehicleid ),
		iObject = GetGVarInt( "heli_gunner", vehicleid )
	;

	if ( GetPlayerState( playerid ) == PLAYER_STATE_DRIVER )
	{
		if ( iObject && ( iModel == 487 || iModel == 497 ) )
		{
			DestroyDynamicObject( iObject );
			DeleteGVar( "heli_gunner", vehicleid );
		}

		p_LastAttachedVehicle[ playerid ] = INVALID_VEHICLE_ID;
	}

	if ( Iter_Contains( races, iRace ) )
	{
		SendClientMessageToRace( iRace, COLOR_GREY, "[RACE]"COL_WHITE" %s(%d) has exited their vehicle and left the race.", ReturnPlayerName( playerid ), playerid );
		RemovePlayerFromRace( playerid );
	}

#if defined AC_INCLUDED

	// Weapon Hacks - credits to wups

	switch( GetVehicleModel( vehicleid ) )
	{
		case 457:
			p_PlayerHasWeapon[ playerid ] { 2 } = true;

		case 592, 577, 511, 512, 520, 593, 553, 476, 519, 460, 513, 548, 425, 417, 487, 488, 497, 563, 447, 469:
			p_PlayerHasWeapon[ playerid ] { 46 } = true;

		case 596, 597, 598, 599:
			p_PlayerHasWeapon[ playerid ] { 25 } = true;
	}

#endif
	return 1;
}

public OnVehicleDamageStatusUpdate( vehicleid, playerid )
{
    GetVehicleDamageStatus( vehicleid, panels, doors, lights, tires );
	if ( GetPlayerState( playerid ) == PLAYER_STATE_DRIVER )
	{
	    if ( lights || tires )
	        return 1;

		new time = GetTickCount( );
		switch( time - p_DamageSpamTime[ playerid ] )
		{
			case 0 .. 500:
			{
				p_DamageSpamCount{ playerid } ++;
				if ( p_DamageSpamCount{ playerid } >= 10 )
				{
					SendGlobalMessage( -1, ""COL_PINK"[ANTI-CHEAT]{FFFFFF} %s(%d) has been kicked for car particle spam.", ReturnPlayerName( playerid ), playerid );
					Kick( playerid );
					return 1;
				}
			}
			default: p_DamageSpamCount{ playerid } = 0;
		}
		p_DamageSpamTime[ playerid ] = time;
 	}
	return 1;
}

stock getVehicleSlotFromID( vID, &playerid=0, &slot=0 )
{
	foreach(new i : Player)
	{
		for( new x; x < MAX_BUYABLE_VEHICLES; x++ ) if ( g_vehicleData[ i ] [ x ] [ E_CREATED ] )
		{
	    	if ( g_vehicleData[ i ] [ x ] [ E_VEHICLE_ID ] == vID )
	    	{
	    		playerid = i;
	    		slot = x;
	    		return x;
	    	}
		}
	}
	return -1;
}

public OnPlayerDriveVehicle(playerid, vehicleid)
{
	new
	    model = GetVehicleModel( vehicleid ),
	    time = g_iTime,
	    iVehiclePrice
	;

	if ( p_InAnimation{ playerid } == true ) // cancel animations
   		CallLocalFunction( "OnPlayerKeyStateChange", "ddd", playerid, KEY_SPRINT, KEY_SECONDARY_ATTACK );

	if ( p_Cuffed{ playerid } ) {
        RemovePlayerFromVehicle( playerid );
        return 1;
	}

	#if ENABLED_SECURE_TRUCK == true
		if ( IsPlayerConnected( g_secureTruckDriver ) && vehicleid == g_secureTruckVehicle ) {
			SendError( playerid, "This vehicle cannot be accessed." );
			SyncObject( playerid, 1 ); // Just sets the players position where the vehicle is.
			return 1;
		}
	#endif

	if ( ! g_Driveby )
		SetPlayerArmedWeapon( playerid, 0 );

	if ( g_isBusinessVehicle[ vehicleid ] != -1 && Iter_Contains( business, g_isBusinessVehicle[ vehicleid ] ) )
	{
		new
			businessid = g_isBusinessVehicle[ vehicleid ];

		if ( IsBusinessAssociate( playerid, businessid ) )
		{
			if ( p_WantedLevel[ playerid ] < 12 )
				GivePlayerWantedLevel( playerid, 12 - p_WantedLevel[ playerid ] );

			if ( IsBusinessAerialVehicle( businessid, model ) && g_businessData[ businessid ] [ E_EXPORT_STARTED ] == 2 )
			{
				new
					ignore_drop_ids[ sizeof( g_airBusinessExportData[ ] ) ] = { -1, ... };

				for ( new x = 0; x < MAX_DROPS; x ++ )
				{
					new
						drop_off_index = randomExcept( sizeof( g_airBusinessExportData[ ] ), ignore_drop_ids, sizeof( ignore_drop_ids ) ),
						city = random( sizeof( g_airBusinessExportData ) )
					;

					// so we get random drops always
					ignore_drop_ids[ drop_off_index ] = drop_off_index;

					// clear them incase
					g_businessData[ businessid ] [ E_EXPORTED ] [ x ] = false;
					DestroyDynamicMapIcon( g_businessData[ businessid ] [ E_EXPORT_ICON ] [ x ] );
					DestroyDynamicRaceCP( g_businessData[ businessid ] [ E_EXPORT_CP ] [ x ] );
					DestroyDynamicArea( g_businessData[ businessid ] [ E_EXPORT_CIRCLE ] [ x ] );

					// assign indexes (used for dropping the shit off)
					g_businessData[ businessid ] [ E_EXPORT_CITY ] = city;
					g_businessData[ businessid ] [ E_EXPORT_INDEX ] [ x ] = drop_off_index;

					// map icons, cp, areas
					g_businessData[ businessid ] [ E_EXPORT_ICON ] [ x ] = CreateDynamicMapIcon( g_airBusinessExportData[ city ] [ drop_off_index ] [ 0 ], g_airBusinessExportData[ city ] [ drop_off_index ] [ 1 ], g_airBusinessExportData[ city ] [ drop_off_index ] [ 2 ], 19, -1, -1, -1, 0, 6000.0, MAPICON_GLOBAL );
					g_businessData[ businessid ] [ E_EXPORT_CP ] [ x ] = CreateDynamicRaceCP( 1, g_airBusinessExportData[ city ] [ drop_off_index ] [ 0 ], g_airBusinessExportData[ city ] [ drop_off_index ] [ 1 ], g_airBusinessExportData[ city ] [ drop_off_index ] [ 2 ], 0, 0, 0, 5.0, -1, -1, 0 );
					g_businessData[ businessid ] [ E_EXPORT_CIRCLE ] [ x ] = CreateDynamicCircle( g_airBusinessExportData[ city ] [ drop_off_index ] [ 0 ], g_airBusinessExportData[ city ] [ drop_off_index ] [ 1 ], 15.0 );

				  	// reset players in map icon/cp
				  	Streamer_RemoveArrayData( STREAMER_TYPE_MAP_ICON, g_businessData[ businessid ] [ E_EXPORT_ICON ] [ x ], E_STREAMER_PLAYER_ID, 0 );
				  	Streamer_RemoveArrayData( STREAMER_TYPE_RACE_CP, g_businessData[ businessid ] [ E_EXPORT_CP ] [ x ], E_STREAMER_PLAYER_ID, 0 );

				  	// stream to players
					foreach (new i : Player) if ( IsBusinessAssociate( i, businessid ) ) {
						Streamer_AppendArrayData( STREAMER_TYPE_MAP_ICON, g_businessData[ businessid ] [ E_EXPORT_ICON ] [ x ], E_STREAMER_PLAYER_ID, i );
						Streamer_AppendArrayData( STREAMER_TYPE_RACE_CP, g_businessData[ businessid ] [ E_EXPORT_CP ] [ x ], E_STREAMER_PLAYER_ID, i );
					}
				}

				// message people
				g_businessData[ businessid ] [ E_EXPORT_STARTED ] = 1;
				ShowPlayerHelpDialog( playerid, 5000, "Drop the drugs off on the flag blips of your radar." );
				SendGlobalMessage( COLOR_GREY, "[BUSINESS]"COL_WHITE" %s(%d) has begun transporting "COL_GOLD"%s"COL_WHITE" of business product!", ReturnPlayerName( playerid ), playerid, ConvertPrice( g_businessData[ businessid ] [ E_EXPORT_VALUE ] * ( MAX_DROPS - g_businessData[ businessid ] [ E_EXPORTED_AMOUNT ] ) ) );
			}
		}
	}

	if ( JobEquals( playerid, JOB_DIRTY_MECHANIC ) && p_Class[ playerid ] == CLASS_CIVILIAN && ( iVehiclePrice = calculateVehicleSellPrice( vehicleid ) ) )
	{
		if ( g_LastExportModel[ playerid ] == model )
			ShowPlayerHelpDialog( playerid, 4000, "You have already exported this vehicle recently and cannot export it again at the docks." );
		else
			ShowPlayerHelpDialog( playerid, 6000, "You can export this vehicle at the docks for around ~g~%s~w~~h~.~n~~n~~r~Damaging the vehicle will further decrease the value.", ConvertPrice( iVehiclePrice ) );
	}

	if ( IsPlayerInPoliceCar( playerid ) && p_Class[ playerid ] != CLASS_POLICE && p_LastDrovenPoliceVeh[ playerid ] != vehicleid && GetPVarInt( playerid, "entercopcar_ts" ) < time && !g_buyableVehicle{ vehicleid } )
		SetPVarInt( playerid, "entercopcar_ts", time + 30 ), GivePlayerWantedLevel( playerid, 2 );

	if ( model == 498 && p_Class[ playerid ] != CLASS_POLICE )
	{
		format( szSmallString, sizeof( szSmallString ), "vburg_%d_items", vehicleid );
		if ( GetGVarInt( szSmallString ) > 0 )
		{
			Beep( playerid );
			GameTextForPlayer( playerid, "Go to the truck blip on your radar for money!", 3000, 1 );
			SendServerMessage( playerid, "Note! You have %d stolen goods that you can export for money!", GetGVarInt( szSmallString ) );

			static aPlayer[ 1 ]; aPlayer[ 0 ] = playerid;
			DestroyDynamicMapIcon( p_PawnStoreMapIcon[ playerid ] );
			p_PawnStoreMapIcon[ playerid ] = CreateDynamicMapIconEx( -2480.2461, 6.0720, 25.6172, 51, 0, MAPICON_GLOBAL, 6000.0, { -1 }, { -1 }, aPlayer );

			p_PawnStoreExport[ playerid ] = CreateDynamicRaceCP( 1, -2480.2461, 6.0720, 25.6172, 0.0, 0.0, 0.0, 4.0, -1, -1, playerid );
		}
	}

	if ( model == 525 ) {
		ShowPlayerHelpDialog( playerid, 2500, "You can tow vehicles by pressing ~k~~VEHICLE_FIREWEAPON_ALT~!" );
	}

	if ( model == 573 )
	{
		format( szSmallString, sizeof( szSmallString ), "mine_%d_ores", vehicleid );
		if ( GetGVarInt( szSmallString ) > 0 )
		{
			Beep( playerid );
			GameTextForPlayer( playerid, "Go to the truck blip on your radar for money!", 3000, 1 );
			SendServerMessage( playerid, "Note! You have %d ores that you can export for money!", GetGVarInt( szSmallString ) );

			static aPlayer[ 1 ]; aPlayer[ 0 ] = playerid;
			DestroyDynamicMapIcon( p_PawnStoreMapIcon[ playerid ] );
			p_PawnStoreMapIcon[ playerid ] = CreateDynamicMapIconEx( -1945.6794, -1086.8906, 31.4261, 51, 0, MAPICON_GLOBAL, 6000.0, { -1 }, { -1 }, aPlayer );

			p_MiningExport[ playerid ] = CreateDynamicRaceCP( 1, -1945.6794, -1086.8906, 31.4261, 0.0, 0.0, 0.0, 4.0, -1, -1, playerid );
		}
	}

	p_LastDrovenPoliceVeh[ playerid ] = vehicleid;

	if ( g_buyableVehicle{ vehicleid } == true )
	{
		new
			ownerid, slotid,
			v = getVehicleSlotFromID( vehicleid, ownerid, slotid )
		;

		if ( v == -1 ) return 1;

        if ( ownerid != playerid )
	    {
			if ( g_vehicleData[ ownerid ] [ slotid ] [ E_LOCKED ] == true )
			{
				if ( p_AdminLevel[ playerid ] < 3 || !p_AdminOnDuty{ playerid } )
				{
					GetVehicleParamsEx( vehicleid, engine, lights, alarm, doors, bonnet, boot, objective );
					SetVehicleParamsEx( vehicleid, VEHICLE_PARAMS_ON, lights, VEHICLE_PARAMS_ON, doors, bonnet, boot, objective );

					// Remove helicopter bottoms
					if ( GetGVarInt( "heli_gunner", vehicleid ) && ( model == 487 || model == 497 ) ) {
						DestroyDynamicObject( GetGVarInt( "heli_gunner", vehicleid ) );
						DeleteGVar( "heli_gunner", vehicleid );
					}

					SyncObject( playerid, 1 ); // Just sets the players position where the vehicle is.
					SendError( playerid, "You cannot drive this car, it has been locked by the owner." );
				}
				else SendClientMessage( playerid, -1, ""COL_PINK"[ADMIN]"COL_GREY" This is a locked vehicle." );
			}
		}
        if ( ownerid == playerid )
		{
			SendClientMessage(playerid, -1, ""COL_GREY"[VEHICLE]"COL_WHITE" Welcome back to your vehicle.");
			Beep( playerid );
			GetVehicleParamsEx( vehicleid, engine, lights, alarm, doors, bonnet, boot, objective );
			SetVehicleParamsEx( vehicleid, VEHICLE_PARAMS_ON, lights, VEHICLE_PARAMS_OFF, doors, bonnet, boot, objective );
			return 1;
		}
		//if ( strmatch( g_vehicleData[ ownerid ] [ slotid ] [ E_OWNER ], "No-one" ) ) SendClientMessageFormatted( playerid, -1, ""COL_GREY"[VEHICLE]"COL_WHITE" This vehicle is for sale (%s)", ConvertPrice( g_vehicleData[ ownerid ] [ slotid ] [ E_PRICE ] ) );
		else SendClientMessageFormatted( playerid, -1, ""COL_GREY"[VEHICLE]"COL_WHITE" This vehicle is owned by %s.", ReturnPlayerName( ownerid ) );
	}
	if ( p_AdminLevel[ playerid ] < 3 )
	{
		if ( p_inArmy{ playerid } == false )
		{
		    if ( model == 520 || model == 425 || model == 432 )
		    {
				SyncObject( playerid, 1 );
			    //RemovePlayerFromVehicle( playerid );
			    SendError( playerid, "The army are only authorized to use this." );
			    return 1;
			}
		}
		if ( p_Class[ playerid ] != CLASS_FIREMAN )
		{
			if ( model == 407 || model == 544 )
			{
				SyncObject( playerid, 1 );
				//RemovePlayerFromVehicle( playerid );
				SendError( playerid, "Firemen are only authorized to use this." );
				return 1;
			}
		}
	}
	return 1;
}

public OnPlayerStateChange(playerid, newstate, oldstate)
{
	if ( IsPlayerNPC( playerid ) )
		return 1; // fcnpc

	new
		vID = GetPlayerVehicleID( playerid );

	p_LastPlayerState{ playerid } = oldstate;

	ResetPlayerVendingMachineData( playerid );

  	if ( newstate == PLAYER_STATE_DRIVER && p_AdminLevel[ playerid ] <= 0 )
    {
        if ( GetPlayerVehicleID( playerid ) != p_CarWarpVehicleID[ playerid ] )
        {
	        if ( p_CarWarpTime[ playerid ] > g_iTime )
	        {
	        	SendGlobalMessage( -1, ""COL_PINK"[ANTI-CHEAT]{FFFFFF} %s(%d) has been banned for car warping.", ReturnPlayerName( playerid ), playerid );
				BanEx( playerid, "Car Warp" );
	            return 1;
	        }
	        p_CarWarpTime[ playerid ] = g_iTime + 1;
	        p_CarWarpVehicleID[ playerid ] = GetPlayerVehicleID( playerid );
		}
    }

    if ( oldstate == PLAYER_STATE_SPECTATING )
    {
    	ResetPlayerWeapons( playerid );
        for( new i; i < sizeof( p_SpectateWeapons[ ] ); i++ )
        {
        	GivePlayerWeapon( playerid, p_SpectateWeapons[ playerid ] [ i ] [ 0 ], p_SpectateWeapons[ playerid ] [ i ] [ 1 ] );
        	p_SpectateWeapons[ playerid ] [ i ] [ 0 ] = 0, p_SpectateWeapons[ playerid ] [ i ] [ 1 ] = 0;
        }
    }

    if ( newstate != PLAYER_STATE_DRIVER && oldstate == PLAYER_STATE_DRIVER ) // Driver has a new state?
    {
    	if ( p_hasTruckingJob{ playerid } )
			cancelPlayerTruckingCourier( playerid, GetPlayerVehicleID( playerid ), .ticks = 0 );

    	if ( p_StartedLumberjack{ playerid } == true )
		{
	    	p_StartedLumberjack{ playerid } = false;
		 	GameTextForPlayer( playerid, "~r~job stopped!", 4000, 0 );
	        DestroyDynamicRaceCP( p_LumberjackReturn[ playerid ] );
	        p_LumberjackReturn[ playerid ] = 0xFFFF;
	        DestroyDynamicRaceCP( p_LumberjackDeliver[ playerid ] );
	        p_LumberjackDeliver[ playerid ] = 0xFFFF;
        	p_treeExportLocation[ playerid ] = 0xFF;
			DestroyDynamicMapIcon( p_LumberjackMapIcon[ playerid ] );
			p_LumberjackMapIcon[ playerid ]= 0xFFFF;
		}
		if ( p_PawnStoreExport[ playerid ] != 0xFFFF )
		{
			DestroyDynamicMapIcon( p_PawnStoreMapIcon[ playerid ] );
			p_PawnStoreMapIcon[ playerid ] = 0xFFFF;
			DestroyDynamicRaceCP( p_PawnStoreExport[ playerid ] );
			p_PawnStoreExport[ playerid ] = 0xFFFF;
		}
		if ( p_MiningExport[ playerid ] != 0xFFFF )
		{
			DestroyDynamicMapIcon( p_PawnStoreMapIcon[ playerid ] );
			p_PawnStoreMapIcon[ playerid ] = 0xFFFF;
			DestroyDynamicRaceCP( p_MiningExport[ playerid ] );
			p_MiningExport[ playerid ] = 0xFFFF;
		}
    }

	if ( newstate == PLAYER_STATE_DRIVER )
		CallLocalFunction( "OnPlayerDriveVehicle", "dd", playerid, vID );

	if ( newstate == PLAYER_STATE_ONFOOT && p_Detained{ playerid } == true && IsPlayerConnected( p_DetainedBy[ playerid ] ) )
	    return PutPlayerInEmptyVehicleSeat( p_LastVehicle[ p_DetainedBy[ playerid ] ], playerid );

	if ( newstate == PLAYER_STATE_PASSENGER )
	{
		if ( hasBadDrivebyWeapon( playerid ) ) // Some weapons are abusable.
			SetPlayerArmedWeapon( playerid, 0 );
	}
	return SyncSpectation( playerid, newstate );
}

public OnPlayerLeaveDynamicCP(playerid, checkpointid)
{
	return 1;
}

public OnPlayerEnterDynamicCP(playerid, checkpointid)
{
	static
		aPlayer[ 1 ];

	aPlayer[ 0 ] = playerid;

	/* ** Checkpoint Denials ** */
	if ( p_Spectating{ playerid } == true )
		return 1;

	if ( GetPlayerSpecialAction( playerid ) == SPECIAL_ACTION_CUFFED )
		return SendError( playerid, "You can't do anything as you are cuffed." );

	if ( IsPlayerTied( playerid ) )
		return SendError( playerid, "You can't do anything as you are tied." );

	/* ** Dropoff check ** */
	new
		bDropoff = false;

	for ( new i = CP_DROP_OFF_COP; i <= CP_DROP_OFF_HELI; i ++ )
		if ( checkpointid == g_Checkpoints[ i ] )
			bDropoff = true;

	if ( IsPlayerJailed( playerid ) && !bDropoff )
	    return SendError( playerid, "You're jailed, and you accessed a checkpoint. I smell a cheater." ), KickPlayerTimed( playerid ), 1;

	/* ** Continue ** */
	if ( checkpointid == g_Checkpoints[ CP_BOMB_SHOP ] || checkpointid == g_Checkpoints[ CP_BOMB_SHOP_LV ] || checkpointid == g_Checkpoints[ CP_BOMB_SHOP_LS ] )
	{
		if ( !JobEquals( playerid, JOB_TERRORIST ) )
			ShowPlayerHelpDialog( playerid, 4000, "You are not a ~r~terrorist~w~~h~ so you won't be able to use the C4 bought!" );
			//return ShowPlayerHelpDialog( playerid, 4000, "You need to be a ~r~terrorist~w~~h~ to buy C4!" );

		return ShowPlayerDialog( playerid, DIALOG_BOMB_SHOP, DIALOG_STYLE_LIST, "{FFFFFF}C4 Shop", "1 C4\t"COL_GOLD"$500\n5 C4\t"COL_GOLD"$2450\nSell C4\t"COL_GREEN"Goes at half price.", "Select", "Cancel" ), 1;
	}

	// Refill ammunition
	if ( checkpointid == g_Checkpoints[ CP_REFILL_AMMO ] || checkpointid == g_Checkpoints[ CP_REFILL_AMMO_LS ] || checkpointid == g_Checkpoints[ CP_REFILL_AMMO_LV ] ) {
		if ( p_Class[ playerid ] == CLASS_POLICE ) {
			if ( g_iTime < p_CopRefillTimestamp[ playerid ] ) {
				return SendError( playerid, "You must wait %s before refilling your weapons again.", secondstotime( p_CopRefillTimestamp[ playerid ] - g_iTime ) );
			} else {
				GivePlayerLeoWeapons( playerid );
				p_CopRefillTimestamp[ playerid ] = g_iTime + 300;
				return SendServerMessage( playerid, "You have refilled your ammunition." );
			}
		} else {
			return SendError( playerid, "Only law enforcement officers can use this feature." );
		}
	}

	if ( checkpointid == g_Checkpoints[ CP_BANK_MENU ] || checkpointid == g_Checkpoints[ CP_COUNTRY_BANK_MENU ] || checkpointid == g_Checkpoints[ CP_BANK_MENU_LS ] )
 		return ShowPlayerBankMenuDialog( playerid ), 1;

	if ( checkpointid == g_Checkpoints[ CP_CHANGE_JOB ] )
 		return ShowPlayerDialog( playerid, DIALOG_CITY_HALL, DIALOG_STYLE_LIST, "{FFFFFF}City Hall", ""COL_GOLD"$5,000"COL_WHITE"\t\tChange Job\n"COL_GOLD"free"COL_WHITE"\t\tChange City", "Select", "Close" ), 1;

	if ( checkpointid == g_Checkpoints[ CP_HOSPITAL ] || checkpointid == g_Checkpoints[ CP_HOSPITAL_LV ] || checkpointid == g_Checkpoints[ CP_HOSPITAL1_LS ] || checkpointid == g_Checkpoints[ CP_HOSPITAL2_LS ] || checkpointid == g_Checkpoints[ CP_HOSPITAL_FC ] )
		return ShowPlayerDialog( playerid, DIALOG_HOSPITAL, DIALOG_STYLE_LIST, "{FFFFFF}Medical Center", ""COL_GOLD"$2,000"COL_WHITE"\t\tHeal Yourself\n"COL_GOLD"$4,000"COL_WHITE"\t\tCure Yourself\n"COL_GOLD"$6,000"COL_WHITE"\t\tCure And Heal", "Select", "Close" ), 1;

	if ( checkpointid == g_Checkpoints[ CP_VEHDEALER ] || checkpointid == g_Checkpoints[ CP_VEHDEALER_2 ] || checkpointid == g_Checkpoints[ CP_VEHDEALER_3 ] )
		return ShowBuyableVehiclesList( playerid );

	if ( checkpointid == g_Checkpoints[ CP_BIZ_TERMINAL_COKE ] || checkpointid == g_Checkpoints[ CP_BIZ_TERMINAL_METH ] || checkpointid == g_Checkpoints[ CP_BIZ_TERMINAL_WEED ] || checkpointid == g_Checkpoints[ CP_BIZ_TERMINAL_WEAP ] )
		return ShowBusinessTerminal( playerid );

	if ( checkpointid == g_Checkpoints[ CP_247_MENU ] )
		return cmd_shop( playerid, "" );

	if ( checkpointid == g_Checkpoints[ CP_PAWNSHOP ] )
		return ShowPlayerDialog( playerid, DIALOG_TOYS_BUY, DIALOG_STYLE_LIST, "{FFFFFF}Purchase Toys", getToyCategories( .pawnshop = true ), "Select", "Cancel" );

	if ( checkpointid == g_Checkpoints[ CP_LUMBERJACK ] )
	{
	    if ( p_Class[ playerid ] != CLASS_CIVILIAN )
	        return SendError( playerid, "Only civilians can access this feature." );

	    szLargeString[ 0 ] = '\0';
	    strcat( szLargeString, ""COL_WHITE"Welcome to the "COL_ORANGE"Lumberjack"COL_WHITE" job! \n\nHere we cut trees, chop them further then process them into crates.\nWe pay well for cutting a tree down and processing the logs. You can also\nbe a driver that will transport the boxes to the" );
		strcat( szLargeString, "factory that requires it.\n\nOnly a specific vehicle can be driven to have these boxes delivered.\nIf it's not there and somewhere lost, contact an administrator to bring it back!" );
		ShowPlayerDialog( playerid, DIALOG_LUMBERJACK, DIALOG_STYLE_MSGBOX, "{FFFFFF}Lumberjack Job", szLargeString, "Join", "Cancel" );
	    return 1;
	}

	new
		houseid = p_InHouse[ playerid ];

	if ( houseid != -1 && GetPlayerInterior( playerid ) == g_houseData[ houseid ] [ E_INTERIOR_ID ] && checkpointid != g_houseData[ houseid ] [ E_CHECKPOINT ] [ 1 ] ) {
		return SetPlayerPos( playerid, g_houseData[ houseid ] [ E_TX ], g_houseData[ houseid ] [ E_TY ], g_houseData[ houseid ] [ E_TZ ] );
	}

	// Detain Mechanism
	if ( bDropoff )
	{
	    if ( p_Class[ playerid ] != CLASS_POLICE )
	    	return 1;

	    new
	    	iState = GetPlayerState( playerid ),
	    	iVehicle = GetPlayerVehicleID( playerid )
	    ;

	    if ( iState == PLAYER_STATE_DRIVER && iVehicle != 0 )
	    {
	    	new
	    		iDetained = 0, iCashEarned = 0;

	    	foreach(new victimid : Player)
	    	{
	    		if ( victimid != playerid && p_WantedLevel[ victimid ] && p_Class[ victimid ] != CLASS_POLICE )
	    		{
	    			if ( IsPlayerInVehicle( victimid, iVehicle ) && IsPlayerDetained( victimid ) )
	    			{
						new
							totalSeconds = p_WantedLevel[ victimid ] * ( JAIL_SECONDS_MULTIPLIER );

						iDetained++;
						iCashEarned += ( p_WantedLevel[ victimid ] < MAX_WANTED_LVL ? p_WantedLevel[ victimid ] : MAX_WANTED_LVL ) * ( 350 );
						KillTimer( p_CuffAbuseTimer[ victimid ] );
						SetPlayerSpecialAction( victimid, SPECIAL_ACTION_NONE );
			        	RemovePlayerAttachedObject( victimid, 2 );
						TogglePlayerControllable( victimid, 1 );
						p_Cuffed{ victimid } = false;
						GameTextForPlayer( victimid, "~r~Busted!", 4000, 0 );
						ClearAnimations( victimid );
						JailPlayer( victimid, totalSeconds );
						GivePlayerIrresistiblePoints( victimid, -2 );
						SendGlobalMessage( -1, ""COL_GOLD"[JAIL]{FFFFFF} %s(%d) has sent %s(%d) to jail for %d seconds!", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( victimid ), victimid, totalSeconds );
	    			}
	    		}
	    	}

	    	if ( iDetained )
	    	{
				if ( iCashEarned > 30000 )
					printf("[police dropoff] %s -> %d people - %s", ReturnPlayerName( playerid ), iDetained, ConvertPrice( iCashEarned ) ); // 8hska7082bmahu

				GivePlayerCash( playerid, iCashEarned );
				GivePlayerScore( playerid, iDetained * 2 );
				CallLocalFunction( "OnPlayerArrest", "dddd", playerid, INVALID_PLAYER_ID, p_Arrests[ playerid ], iDetained );
	    		return SendClientMessageFormatted( playerid, -1, ""COL_GREEN"[ACHIEVE]{FFFFFF} You have earned "COL_GOLD"%s{FFFFFF} and %d score for dropping off %d criminal(s) to prison.", ConvertPrice( iCashEarned ), iDetained * 2, iDetained );
	    	}
	    	else return SendError( playerid, "There are no detained criminals in your vehicle that can be jailed." );
	    }
	    else return SendError( playerid, "You need a driver of a vehicle with detained criminals to use this." );
	}

	if ( checkpointid == g_Checkpoints[ CP_FIGHTSTYLE ] || checkpointid == g_Checkpoints[ CP_FIGHTSTYLE_LV ] || checkpointid == g_Checkpoints[ CP_FIGHTSTYLE_LS ] )
	{
	    ShowPlayerDialog( playerid, DIALOG_FIGHTSTYLE, DIALOG_STYLE_LIST, "{FFFFFF}Fightstyle", ""COL_GOLD"$1000{FFFFFF} \tDefence\n"COL_GOLD"$4000{FFFFFF} \tBoxing\n"COL_GOLD"$9000{FFFFFF} \tKungfu", "Purchase", "Cancel" );
	    return 1;
	}

	if ( p_Class[ playerid ] == CLASS_POLICE )
	{
		foreach (new lockerid : WeaponLockers) if ( checkpointid == g_weaponLockerCheckpoint[ lockerid ] ) {
			return ShowAmmunationMenu( playerid, "{FFFFFF}Weapon Locker - Purchase Weapons", DIALOG_WEAPON_LOCKER );
		}
	}

	if ( checkpointid == g_Checkpoints[ CP_AMMUNATION_0 ] || checkpointid == g_Checkpoints[ CP_AMMUNATION_1 ] || checkpointid == g_Checkpoints[ CP_AMMUNATION_2 ] )
    	return ShowAmmunationMenu( playerid );

	if ( checkpointid == g_Checkpoints[ CP_PAINTBALL ] )
		return listPaintBallLobbies( playerid );

	if ( !IsPlayerInAnyVehicle( playerid ) )
	{
		for( new i; i < sizeof( g_atmData ); i ++ ) if ( g_atmData[ i ] [ E_CREATED ] && checkpointid == g_atmData[ i ] [ E_CHECKPOINT ] ) {
	    	if ( g_atmData[ i ] [ E_DISABLED ] ) {
	    		return SendError( playerid, "This ATM has recently been robbed and cannot be accessed for now." );
	    	} else {
	    		return ShowPlayerBankMenuDialog( playerid );
	    	}
		}
	}
	if ( hasTickcountPassed( p_EntranceTickcount[ playerid ], 2500 ) )
	{
		if ( !IsPlayerInAnyVehicle( playerid ) )
		{
			foreach(new i : entrances)
			{
		        if ( checkpointid == g_entranceData[ i ] [ E_ENTER ] )
				{
				    if ( g_entranceData[ i ] [ E_VIP ] && p_VIPLevel[ playerid ] < VIP_REGULAR ) {
				        SendError( playerid, "You are not a V.I.P, to become one visit "COL_GREY"donate.irresistiblegaming.com" );
						break;
				    }
					p_LastEnteredEntrance[ playerid ] = i;
				    SetPlayerInterior( playerid, g_entranceData[ i ] [ E_INTERIOR ] );
				    SetPlayerVirtualWorld( playerid, g_entranceData[ i ] [ E_WORLD ] );
				    SetPlayerPos( playerid, g_entranceData[ i ] [ E_LX ], g_entranceData[ i ] [ E_LY ], g_entranceData[ i ] [ E_LZ ] );
				    p_EntranceTickcount[ playerid ] = GetTickCount( );
				    if ( g_entranceData[ i ] [ E_CUSTOM ] )
				    {
				    	pauseToLoad( playerid );
				 		p_BulletInvulnerbility[ playerid ] = g_iTime + 6; // Additional 3 because of pausetoload
				    }
				    else
				    {
						TogglePlayerControllable( playerid, 0 );
						SetTimerEx( "ope_Unfreeze", 1250, false, "d", playerid );
				 		p_BulletInvulnerbility[ playerid ] = g_iTime + 3;
					}
					SyncSpectation( playerid );
				    break;
				}
				if ( checkpointid == g_entranceData[ i ] [ E_EXIT ] )
				{
					p_BulletInvulnerbility[ playerid ] = 0;
					p_LastEnteredEntrance[ playerid ] = -1;
				    SetPlayerPos( playerid, g_entranceData[ i ] [ E_EX ], g_entranceData[ i ] [ E_EY ], g_entranceData[ i ] [ E_EZ ] );
				    SetPlayerInterior( playerid, 0 );
					TogglePlayerControllable( playerid, 0 );
					SetTimerEx( "ope_Unfreeze", 1250, false, "d", playerid );
				    SetPlayerVirtualWorld( playerid, 0 );
				    p_EntranceTickcount[ playerid ] = GetTickCount( );
					SyncSpectation( playerid );
				    break;
				}
		    }
		}
		else
		{
			new
				iVehicle = GetPlayerVehicleID( playerid ),
				vModel = GetVehicleModel( iVehicle ),
				iCash = calculateVehicleSellPrice( iVehicle ),
				Float: X, Float: Y, Float: Z, Float: Angle
			;

			if ( p_Class[ playerid ] == CLASS_CIVILIAN && vModel )
			{
				foreach(new i : containers)
				{
					if ( checkpointid == g_containerData[ i ] [ E_CHECKPOINT ] && !g_containerData[ i ] [ E_CLOSED ] )
					{
						if ( !JobEquals( playerid, JOB_DIRTY_MECHANIC ) ) {
							ShowPlayerHelpDialog( playerid, 4000, "You need to be a ~r~dirty mechanic~w~~h~ to export stolen vehicles!" );
							break;
						}

						if ( g_LastExportModel[ playerid ] == vModel ) {
							ShowPlayerHelpDialog( playerid, 4000, "You cannot export the same type of vehicle, ~y~find a different vehicle." );
							break;
						}

						if ( !iCash ) {
							ShowPlayerHelpDialog( playerid, 4000, "~r~You cannot export this vehicle." );
							break;
						}

						if ( p_AntiExportCarSpam[ playerid ] > g_iTime ) {
							ShowPlayerHelpDialog( playerid, 4000, "You can export your next vehicle in %s.", secondstotime( p_AntiExportCarSpam[ playerid ] - g_iTime ) );
							break;
						}

						GetDynamicObjectPos( g_containerData[ i ] [ E_OBJECT ], X, Y, Z );
						GetDynamicObjectRot( g_containerData[ i ] [ E_OBJECT ], Angle, Angle, Angle );

						X += 6 * -floatsin( -Angle, degrees );
						Y += 6 * -floatcos( -Angle, degrees );

						SetPlayerPos( playerid, X, Y, Z + 0.6 );

						g_containerData		[ i ] [ E_CLOSED ] = true;
						g_LastExportModel	[ playerid ] = vModel;
						p_AntiExportCarSpam [ playerid ] = g_iTime + 120;

						MoveDynamicObject( g_containerData[ i ] [ E_DOOR ] [ 0 ], g_containerData[ i ] [ E_DOOR1_CORDS ] [ 0 ] + 0.05, g_containerData[ i ] [ E_DOOR1_CORDS ] [ 1 ] + 0.05, g_containerData[ i ] [ E_DOOR1_CORDS ] [ 2 ], ( 0.1 ), 0.0, 0.0, g_containerData[ i ] [ E_CLOSE_ANGLE ] [ 0 ] );
						MoveDynamicObject( g_containerData[ i ] [ E_DOOR ] [ 1 ], g_containerData[ i ] [ E_DOOR2_CORDS ] [ 0 ] + 0.05, g_containerData[ i ] [ E_DOOR2_CORDS ] [ 1 ] + 0.05, g_containerData[ i ] [ E_DOOR2_CORDS ] [ 2 ], ( 0.1 ), 0.0, 0.0, g_containerData[ i ] [ E_CLOSE_ANGLE ] [ 1 ] );

						GivePlayerWantedLevel( playerid, 6 );
						GivePlayerCash( playerid, iCash );
						GivePlayerScore( playerid, 2 );
						Achievement::HandleCarJacked( playerid );
						SetTimerEx( "ExportVehicle", 3000, false, "dd", iVehicle, i );
						SendServerMessage( playerid, "You have exported your "COL_GREY"%s"COL_WHITE" for "COL_GOLD"%s"COL_WHITE".", GetVehicleName( GetVehicleModel( iVehicle ) ), ConvertPrice( iCash ) );
						break;
					}
				}
			}
		}
	}
	return 1;
}

public OnPlayerEnterDynamicArea( playerid, areaid )
{
	new
		iVehicle = GetPlayerVehicleID( playerid ),
		iState = GetPlayerState( playerid )
	;

	// spikes
    if ( iState == PLAYER_STATE_DRIVER && iVehicle != 0 )
    {
    	new
    		iModel = GetVehicleModel( iVehicle );

    	// spike strip system
		foreach(new i : SpikeStrip) if ( g_spikestripData[ i ] [ E_SPHERE ] == areaid ) {
            GetVehicleDamageStatus( iVehicle, panels, doors, lights, tires );
            UpdateVehicleDamageStatus( iVehicle, panels, doors, lights, ( tires = encode_tires( 1, 1, 1, 1 ) ) );
			destroySpikeStrip( i );
			break;
		}

		// alert player if hes near the drugs
		if ( g_isBusinessVehicle[ iVehicle ] != -1 && Iter_Contains( business, g_isBusinessVehicle[ iVehicle ] ))
		{
			new
				businessid = g_isBusinessVehicle[ iVehicle ];

			if ( IsBusinessAerialVehicle( businessid, iModel ) && IsBusinessAssociate( playerid, businessid ) )
			{
				for ( new i = 0; i < 2; i ++ ) if ( areaid == g_businessData[ businessid ] [ E_EXPORT_CIRCLE ] [ i ] ) {
					ShowPlayerHelpDialog( playerid, 5000, "~y~~h~Press ~k~~PED_FIREWEAPON~ to drop off the drugs!" );
				}
			}
		}
    }

    // races
   	new
   		raceid = p_raceLobbyId[ playerid ];

	if ( Iter_Contains( races, raceid ) && g_raceData[ raceid ] [ E_OUTRUN_SPHERE ] == areaid && g_raceData[ raceid ] [ E_OUTRUN_LEAD ] != playerid )
	{
		// new leader
		g_raceData[ raceid ] [ E_OUTRUN_LEAD ] = playerid;

		// alert
		foreach (new i : Player) if ( p_raceLobbyId[ i ] == raceid ) {
			PlayerPlaySound( i, 1149, 0.0, 0.0, 0.0 );
			GameTextForPlayer( i, sprintf( "~b~~h~%s leading", ReturnPlayerName( playerid ) ), 2000, 3 );
			SendClientMessageFormatted( i, -1, ""COL_GREY"[RACE]"COL_WHITE" %s(%d) has taken the lead for the race.", ReturnPlayerName( playerid ), playerid );
		}

		// see if ahead
		AttachDynamicObjectToVehicle( g_raceData[ raceid ] [ E_OUTRUN_OBJECT ], iVehicle, 0.0, OUTRUN_DIST, -15.0, 0.0, 0.0, 0.0 );
		AttachDynamicAreaToVehicle( g_raceData[ raceid ] [ E_OUTRUN_SPHERE ], iVehicle, 0.0, -OUTRUN_DIST - 5.0 );
	}
    return 1;
}

public OnPlayerEnterDynamicRaceCP( playerid, checkpointid )
{
	new
		raceid = p_raceLobbyId[ playerid ],
		iVehicle = GetPlayerVehicleID( playerid )
	;

	static aPlayer[ 1 ]; aPlayer[ 0 ] = playerid;
	if ( checkpointid == p_TruckingCheckPoint[ playerid ] )
	{

		if ( !IsTrailerAttachedToVehicle( iVehicle ) )
			return SendError( playerid, "You cannot import/export anything without a trailer!" );

		DestroyDynamicMapIcon( p_TruckingMapIcon[ playerid ] );
		DestroyDynamicRaceCP ( p_TruckingCheckPoint[ playerid ] );
		KillTimer			 ( p_TruckingPositionTimer[ playerid ] );

		if ( g_aTrailerData[ p_TruckingTrailerModel{ playerid } ] [ p_TruckingTrailer{ playerid } ] [ E_RISK ] == RISK_FACTOR_HARD )
			GivePlayerWantedLevel( playerid, 6 );

		if ( p_TruckingRoute[ playerid ] { 0 } != INVALID_TRUCKING_ROUTE )
		{
			p_TruckingPositionTimer[ playerid ] = SetTimerEx( "OnTruckPositionUpdate", 750, false, "dd", playerid, p_TruckingRoute[ playerid ] { 1 } );
  			TextDrawShowForPlayer( playerid, p_TruckingTD[ playerid ] );

			ShowPlayerHelpDialog( playerid, 7500, "Your trailer has been loaded with %s. ~g~~h~Follow the truck blip on your radar to meet the destination.", g_aTrailerData[ p_TruckingTrailerModel{ playerid } ] [ p_TruckingTrailer{ playerid } ] [ E_NAME ] );
			p_TruckingMapIcon	[ playerid ] = CreateDynamicMapIconEx( g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 1 } ] [ E_X ], g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 1 } ] [ E_Y ], g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 1 } ] [ E_Z ], 51, 0, MAPICON_GLOBAL, 6000.0, { -1 }, { -1 }, aPlayer );
			p_TruckingCheckPoint[ playerid ] = CreateDynamicRaceCP( 0, g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 1 } ] [ E_X ], g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 1 } ] [ E_Y ], g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 1 } ] [ E_Z ], g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 1 } ] [ E_X ], g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 1 } ] [ E_Y ], g_aTruckingLocations[ p_TruckingRoute[ playerid ] { 1 } ] [ E_Z ], 10.0, -1, -1, playerid );
			return ( p_TruckingRoute[ playerid ] { 0 } = INVALID_TRUCKING_ROUTE ), 1;
		}

		else if ( p_TruckingRoute[ playerid ] { 1 } != INVALID_TRUCKING_ROUTE )
		{
			new
				iTimeElapsed = g_iTime - p_TruckingTimeElapsed[ playerid ],
				iTheoreticalFinish = floatround( p_TruckingDistance[ playerid ] / 25.0 ) // distance / 25m/s (2000m / 25m/s)
			;

			// Check if it is really quick to finish
			if ( iTimeElapsed < iTheoreticalFinish ) {
		    	SendServerMessage( playerid, "You've been kicked due to suspected teleport hacking (0xBC)." );
		    	KickPlayerTimed( playerid );
		    	return 1;
			}

			new
				iCashEarned = floatround( p_TruckingDistance[ playerid ] * 2.0 + g_aTrailerData[ p_TruckingTrailerModel{ playerid } ] [ p_TruckingTrailer{ playerid } ] [ E_BONUS ] );

			Achievement::HandleTruckingCouriers( playerid );
			TextDrawHideForPlayer( playerid, p_TruckingTD[ playerid ] );

			GivePlayerScore( playerid, 1 + floatround( p_TruckingDistance[ playerid ] / 1000.0 ) );
			GivePlayerCash( playerid, iCashEarned );

			p_TruckingDistance		[ playerid ] = 0.0;
			p_hasTruckingJob		{ playerid } = false;
			p_TruckingCheckPoint	[ playerid ] = 0xFFFF;
			p_TruckingMapIcon 		[ playerid ] = 0xFFFF;
			p_TruckingCancelTimer	[ playerid ] = 0xFFFF;

			//SetTimerEx( "RespawnVehicle", 3500, false, "d", GetVehicleTrailer( iVehicle ) );
			DetachTrailerFromVehicle( iVehicle );

			ShowPlayerHelpDialog( playerid, 7500, "You have earned ~y~~h~%s~w~~h~ for exporting %s!", ConvertPrice( iCashEarned ), g_aTrailerData[ p_TruckingTrailerModel{ playerid } ] [ p_TruckingTrailer{ playerid } ] [ E_NAME ] );
        	return ( p_TruckingRoute[ playerid ] { 1 } = INVALID_TRUCKING_ROUTE ), 1;
		}
		return 1;
	}

	else if ( checkpointid == p_PawnStoreExport[ playerid ] )
	{
	    new vehicleid = GetPlayerVehicleID( playerid );
	    if ( GetVehicleModel( vehicleid ) == 498 )
	    {
		    new
				szItems[ 18 ],
				cashEarned,
				items, score
			;
			format( szItems, sizeof( szItems ), "vburg_%d_items", vehicleid );
			for( new i; i < GetGVarInt( szItems ) + 1; i++ )
			{
				format( szSmallString, sizeof( szSmallString ), "vburg_%d_%d", vehicleid, i );
				if ( GetGVarInt( szSmallString ) != 0 )
				    cashEarned += floatround( g_houseFurniture[ GetGVarInt( szSmallString ) ] [ E_COST ] / 3 ), DeleteGVar( szSmallString );
			}
			items = GetGVarInt( szItems );
			score = floatround( items / 2 );
			GivePlayerScore( playerid, score == 0 ? 1 : score, .multiplier = 0.4 );
			DestroyDynamicMapIcon( p_PawnStoreMapIcon[ playerid ] );
			p_PawnStoreMapIcon[ playerid ] = 0xFFFF;
			DestroyDynamicRaceCP( p_PawnStoreExport[ playerid ] );
			p_PawnStoreExport[ playerid ] = 0xFFFF;
			GivePlayerCash( playerid, cashEarned );
			GivePlayerWantedLevel( playerid, items * 2 );
			SendServerMessage( playerid, "You have sold %d furniture item(s) to the Pawn Store, earning you "COL_GOLD"%s"COL_WHITE".", GetGVarInt( szItems ), ConvertPrice( cashEarned ) );
			DeleteGVar( szItems );
		}
		return 1;
	}

	else if ( p_MiningExport[ playerid ] == checkpointid )
	{
		new vehicleid = GetPlayerVehicleID( playerid );
	    if ( GetVehicleModel( vehicleid ) == 573 )
	    {
		    new
				szContent[ 15 ],
				cashEarned, oresExported
			;
			format( szContent, sizeof( szContent ), "mine_%d_ores", vehicleid );
			oresExported = GetGVarInt( szContent ), DeleteGVar( szContent );

			format( szContent, sizeof( szContent ), "mine_%d_cash", vehicleid );
			cashEarned = GetGVarInt( szContent ), DeleteGVar( szContent );

			DestroyDynamicMapIcon( p_PawnStoreMapIcon[ playerid ] );
			p_PawnStoreMapIcon[ playerid ] = 0xFFFF;
			DestroyDynamicRaceCP( p_MiningExport[ playerid ] );
			p_MiningExport[ playerid ] = 0xFFFF;
			GivePlayerCash( playerid, cashEarned );
			GivePlayerScore( playerid, floatround( oresExported / 2 ) ); // 16 score is a bit too much for ore... so half that = 8
			SendServerMessage( playerid, "You have exported %d rock ore(s) to an industry, earning you "COL_GOLD"%s"COL_WHITE".", oresExported, ConvertPrice( cashEarned ) );
		}
		return 1;
	}

	else if ( p_LumberjackDeliver[ playerid ] == checkpointid )
	{
		new
			Float: fDistance = GetDistanceFromPointToPoint( -2330.8535, -113.9084, g_treeExportLocations[ p_treeExportLocation[ playerid ] ] [ 0 ], g_treeExportLocations[ p_treeExportLocation[ playerid ] ] [ 1 ] ),
			iTimeElapsed = g_iTime - p_LumberjackTimeElapsed[ playerid ],
			iTheoreticalFinish = floatround( fDistance / 25.0 ) // distance / 25m/s (2000m / 25m/s)
		;

		// Check if it is really quick to finish
		if ( iTimeElapsed < iTheoreticalFinish ) {
	    	SendServerMessage( playerid, "You've been kicked due to suspected teleport hacking." );
	    	KickPlayerTimed( playerid );
	    	return 1;
		}

	    new cash = floatround( fDistance ) + 5000;
        DestroyDynamicRaceCP( p_LumberjackDeliver[ playerid ] );
        p_LumberjackDeliver[ playerid ] = 0xFFFF;
		ShowPlayerHelpDialog( playerid, 7500, "Great job! You've earned ~y~%s~w~~h~!~n~~n~Navigate to the import location to pack your truck with logs.~n~~n~~y~~h~Info: The truck blip has been updated, navigate to it.", ConvertPrice( cash ) );
        //SendServerMessage( playerid, "You've made "COL_GOLD"%s"COL_WHITE" from exporting. Go and pick another box up!"  );
	    GivePlayerCash( playerid, cash );
	    GivePlayerScore( playerid, 5 );

		DestroyDynamicMapIcon( p_LumberjackMapIcon[ playerid ] );
		p_LumberjackMapIcon[ playerid ] = CreateDynamicMapIconEx( -2330.8535, -113.9084, 34.00, 51, 0, MAPICON_GLOBAL, 6000.0, { -1 }, { -1 }, aPlayer );

	    p_LumberjackReturn[ playerid ] = CreateDynamicRaceCP( 0, -2330.8535, -113.9084, 34.00, g_treeExportLocations[ p_treeExportLocation[ playerid ] ] [ 0 ], g_treeExportLocations[ p_treeExportLocation[ playerid ] ] [ 1 ], g_treeExportLocations[ p_treeExportLocation[ playerid ] ] [ 2 ], 4.0, -1, -1, playerid );
		Beep( playerid );
		return 1;
	}

	else if ( p_LumberjackReturn[ playerid ] == checkpointid )
	{
	    if ( g_LogsInStock < 1 )
	    	return SendError( playerid, "There is not enough logs in stock to export." );

        DestroyDynamicRaceCP( p_LumberjackReturn[ playerid ] );
        p_LumberjackReturn[ playerid ] = 0xFFFF;
        g_LogsInStock--;
        UpdateWoodStockObject( );
		new id = random( sizeof( g_treeExportLocations ) );
		p_treeExportLocation[ playerid ] = id;

		DestroyDynamicMapIcon( p_LumberjackMapIcon[ playerid ] );
		p_LumberjackMapIcon[ playerid ] = CreateDynamicMapIconEx( g_treeExportLocations[ id ] [ 0 ], g_treeExportLocations[ id ] [ 1 ], g_treeExportLocations[ id ] [ 2 ], 51, 0, MAPICON_GLOBAL, 6000.0, { -1 }, { -1 }, aPlayer );

		ShowPlayerHelpDialog( playerid, 7500, "You've packed your truck with logs. ~g~~h~Navigate your way to the export location.~n~~n~Info:~y~~h~ The truck blip has been updated, navigate to it." );
        p_LumberjackDeliver[ playerid ] = CreateDynamicRaceCP( 0, g_treeExportLocations[ id ] [ 0 ], g_treeExportLocations[ id ] [ 1 ], g_treeExportLocations[ id ] [ 2 ], -2330.8535, -113.9084, 34.00, 4.0, -1, -1, playerid );
       	Beep( playerid );
		return 1;
	}

	else if( raceid != -1 && g_raceData[ raceid ] [ E_FINISH_CHECKPOINT ] == checkpointid )
	{
		if ( ! g_raceData[ raceid ] [ E_STARTED ] )
			return SendError( playerid, "The race has not started." );

		new
			position = ++ g_raceData[ raceid ] [ E_FINISHED_COUNT ];

		// give prize and alert
		if ( 1 <= position <= 3 )
			GivePlayerRaceWin( playerid, position, raceid );

		// close race after members finished
		new
			members = GetRaceMemberCount( raceid );

		printf ("Position : %d, Members : %d", position, members);
		if ( position >= 3 || position >= members ) {
			DestroyRace( raceid );
			print ("Shut race");
		}
		return 1;
	}

	printf("Entered Race Checkpoint : {user:%s,veh:%d,biz_veh:%d,valid_biz:%d}", ReturnPlayerName( playerid ), iVehicle, g_isBusinessVehicle[ iVehicle ],Iter_Contains( business, g_isBusinessVehicle[ iVehicle ] ));
	if ( p_Class[ playerid ] == CLASS_CIVILIAN && g_isBusinessVehicle[ iVehicle ] != -1 && Iter_Contains( business, g_isBusinessVehicle[ iVehicle ] ) )
	{
		new
			businessid = g_isBusinessVehicle[ iVehicle ];

		printf("Is Associate : {user:%s,veh:%d,associate:%d}", ReturnPlayerName( playerid ), iVehicle, IsBusinessAssociate( playerid, businessid ));
		if ( ! IsBusinessAerialVehicle( businessid, GetVehicleModel( iVehicle ) ) && IsBusinessAssociate( playerid, businessid ) )
		{
			for ( new i = 0; i < MAX_DROPS; i ++ )
			{
				if ( g_businessData[ businessid ] [ E_EXPORT_CP ] [ i ] == checkpointid )
				{
					if ( g_businessData[ businessid ] [ E_EXPORTED ] [ i ] )
						return SendError( playerid, "This location has already been sold product recently." );

					// count drugs exported
					SellBusinessProduct( playerid, businessid, i );
					break;
				}
			}
			return 1;
		}
	}
	return 1;
}

public OnRconCommand(cmd[])
{
	return 1;
}

public OnPlayerRequestSpawn( playerid )
{
	if ( IsPlayerSecurityDriver( playerid ) )
		return SetPlayerSkin( playerid, 71 );

	return approveClassSpawned( playerid );
}

stock approveClassSpawned( playerid ) {

	// is logged in
	if ( !p_PlayerLogged{ playerid } )
		return SendClientMessage( playerid, -1, ""COL_RED"[ERROR]"COL_WHITE" You must be authenticated to play the game." ), 0;

	// is verified
	if ( p_accountSecurityData[ playerid ] [ E_ID ] && ! p_accountSecurityData[ playerid ] [ E_VERIFIED ] && p_accountSecurityData[ playerid ] [ E_MODE ] == SECURITY_MODE_PARANOID )
		return SendClientMessage( playerid, -1, ""COL_RED"[ERROR]"COL_WHITE" You must be verified to play the game." ), 0;

	// is cop/army banned
	if ( p_CopBanned{ playerid } == MAX_CLASS_BAN_WARNS && ( IsPlayerPolice( playerid ) || IsPlayerFBI( playerid ) || IsPlayerCIA( playerid ) ) )
		return SendClientMessage( playerid, -1, ""COL_RED"[ERROR]"COL_WHITE" You are banned from using the police class(es). Use "COL_GREY"/unbanme"COL_WHITE" to pay for an unban." ), 0;

	if ( p_ArmyBanned{ playerid } == MAX_CLASS_BAN_WARNS && GetPlayerSkin( playerid ) == 287 )
		return SendClientMessage( playerid, -1, ""COL_RED"[ERROR]"COL_WHITE" You are banned from using the army class. Use "COL_GREY"/unbanme"COL_WHITE" to pay for an unban." ), 0;

	// wanted level an issue?
	if ( p_WantedLevel[ playerid ] > 0 && ( IsPlayerPolice( playerid ) || IsPlayerFBI( playerid ) || IsPlayerCIA( playerid ) || GetPlayerSkin( playerid ) == 287 ) )
		return SendClientMessage( playerid, -1, ""COL_RED"[ERROR]"COL_WHITE" You must not have a wanted level to use this class." ), 0;

	// bought xp
	if ( IsPlayerFBI( playerid ) && p_XP[ playerid ] < 10000 )
		return SendClientMessage( playerid, -1, ""COL_RED"[ERROR]"COL_WHITE" You need 10,000 XP to use this class." ), 0;

	if ( GetPlayerSkin( playerid ) == 287 && p_XP[ playerid ] < 20000 )
		return SendClientMessage( playerid, -1, ""COL_RED"[ERROR]"COL_WHITE" You need 20,000 XP to use this class." ), 0;

	if ( IsPlayerCIA( playerid ) && p_XP[ playerid ] < 15000 )
		return SendClientMessage( playerid, -1, ""COL_RED"[ERROR]"COL_WHITE" You need 15,000 XP to use this class." ), 0;

	if ( IsPlayerFireman( playerid ) && p_XP[ playerid ] < 1000 )
		return SendClientMessage( playerid, -1, ""COL_RED"[ERROR]"COL_WHITE" You need 1,000 XP to use this class." ), 0;

	if ( IsPlayerMedic( playerid ) && p_XP[ playerid ] < 2000 )
		return SendClientMessage( playerid, -1, ""COL_RED"[ERROR]"COL_WHITE" You need 2,000 XP to use this class." ), 0;

	/* if ( IsPlayerMayor( playerid ) && p_XP[ playerid ] < 5000 )
		return SendClientMessage( playerid, -1, ""COL_RED"[ERROR]"COL_WHITE" You need 5,000 XP to use this class." ), 0;

	// restrict to one mayor
	new
		mayorAccountId = GetGVarInt( "mayor" );

	if( mayorAccountId != 0 && mayorAccountId != p_AccountID[ playerid ] ) {
		return SendClientMessage( playerid, -1, ""COL_RED"[ERROR]"COL_WHITE" The mayor class is currently full." ), 0;
	} else {
		UpdateServerVariable( "mayor_timeout", 0, 0.0, "", GLOBAL_VARTYPE_INT );
		UpdateServerVariable( "mayor_timestamp", g_iTime, 0.0, "", GLOBAL_VARTYPE_INT );
		UpdateServerVariable( "mayor", p_AccountID[ playerid ], 0.0, "", GLOBAL_VARTYPE_INT );
	}*/

	// job not set
	if ( !p_JobSet{ playerid } || !p_CitySet{ playerid } )
		return SendClientMessage( playerid, -1, ""COL_RED"[ERROR]"COL_WHITE" You must ensure your job and city have been properly set." ), 0;

	return 1; // pass it
}

public OnObjectMoved(objectid)
{
	return 1;
}

public OnPlayerObjectMoved(playerid, objectid)
{
	return 1;
}

public OnPlayerUseSlotMachine( playerid, slotid, first_combo, second_combo, third_combo )
{
	new
		poolid = g_slotmachineData[ slotid ] [ E_POOL_ID ];

	if ( ! Iter_Contains( CasinoPool, poolid ) )
		return SendError( playerid, "This machine has an invalid casino pool! (0xFF33)" );

	// autospin
	if ( p_AutoSpin{ playerid } )
		TriggerPlayerSlotMachine( playerid, slotid );

	// check combinations
	printf("%s (%d, %d, %d)", ReturnPlayerName( playerid ), first_combo, second_combo, third_combo);
	if ( first_combo == second_combo && first_combo == third_combo )
	{
		new
			iNetWin;

		if ( first_combo == 0 ) iNetWin = g_casinoPoolData[ poolid ] [ E_POOL ];
		else
		{
			if ( g_slotmachineData[ slotid ] [ E_ENTRY_FEE ] == 10000 )
			{
				switch( first_combo )
				{
					// Single bar
					case 1: iNetWin = 100000;

					// Bells
					case 2: iNetWin = 50000;

					// Cherry
					case 3: iNetWin = 25000;

					// Grapes
					case 4: iNetWin = 10000;

					// 69
					case 5: iNetWin = 5000;
				}
			}
			else
			{
				switch( first_combo )
				{
					// Single bar
					case 1: iNetWin = 20000;

					// Bells
					case 2: iNetWin = 10000;

					// Cherry
					case 3: iNetWin = 5000;

					// Grapes
					case 4: iNetWin = 2000;

					// 69
					case 5: iNetWin = 1000;
				}
			}
		}

		// readjust casino pool data
		UpdateCasinoPoolData( poolid, .pool_increment = -iNetWin, .total_win = iNetWin );

		// give the cash
		GivePlayerCash( playerid, iNetWin );
		PlayerPlaySound( playerid, 4201, 0.0, 0.0, 0.0 ); // Coin fall

		GameTextForPlayer( playerid, "~w~~h~winner!", 5000, 6 );
   		return SendGlobalMessage( -1, ""COL_GREY"[CASINO]{FFFFFF} %s(%d) has won "COL_GOLD"%s"COL_WHITE" from the %s casino!", ReturnPlayerName( playerid ), playerid, ConvertPrice( iNetWin ), g_slotmachineData[ slotid ] [ E_ENTRY_FEE ] == 10000 ? ( "Four Dragons" ) : ( "Caligulas" ) );
		// return SendServerMessage( playerid, "Congratulations, you've won "COL_GOLD"%s"COL_WHITE"!", ConvertPrice( iNetWin ) );
	}

	return GameTextForPlayer( playerid, "~w~~h~no win!", 2500, 6 );
}

public OnPlayerClickTextDraw(playerid, Text: clickedid)
{
	// Pressed ESC
	if ( clickedid == Text: INVALID_TEXT_DRAW )
	{
		if ( GetPVarInt( playerid, "recently_previewed" ) < GetTickCount( ) && GetPVarInt( playerid, "viewing_vehicle" ) )
			return CancelVehicleView( playerid, 0 );
	}
	return 1;
}

public OnPlayerClickPlayerTextDraw(playerid, PlayerText: playertextid)
{
    return 1;
}

stock CancelVehicleView( playerid, cancel=1 )
{
	if ( cancel ) CancelSelectTextDraw( playerid );

	TextDrawHideForPlayer( playerid, g_VehiclePreviewBoxTD );
	TextDrawHideForPlayer( playerid, g_VehiclePreviewTxtTD );
	TextDrawHideForPlayer( playerid, p_VehiclePreviewCloseTD );

	for( new i; i < sizeof p_VehiclePreviewTD; i++ )
		PlayerTextDrawDestroy( playerid, p_VehiclePreviewTD[ i ] );

	cmd_moviemode( playerid, "" ); // Show textdraws :3

	DeletePVar( playerid, "viewing_vehicle" );
	SetPVarInt( playerid, "recently_previewed", GetTickCount( ) + 100 );

	SendServerMessage( playerid, "You have finished looking at the vehicle's preview." );
	return ShowPlayerDialog( playerid, DIALOG_VEHDEALER_OPTIONS, DIALOG_STYLE_LIST, "{FFFFFF}Vehicle Dealership", "Purchase This Vehicle\nPreview Vehicle", "Select", "Back" );
}

public OnPlayerPickUpDynamicPickup( playerid, pickupid )
{
	new
		Float: X, Float: Y, Float: Z;

#if defined AC_INCLUDED
	if ( GetGVarType( "ac_WeaponPickup", pickupid ) != GLOBAL_VARTYPE_NONE )
		p_PlayerHasWeapon[ playerid ] { GetGVarInt( "ac_WeaponPickup", pickupid ) } = true;
#endif

	if ( pickupid != PreviousPickupID[ playerid ] )
	{
		new
			iTimestamp = g_iTime; // Call it once, because swag

		if ( LastPickupTimestamp[ playerid ] > iTimestamp )
		{
			new
				Float: distance = GetPlayerDistanceFromPoint( playerid, p_LastPickupPos[ playerid ] [ 0 ], p_LastPickupPos[ playerid ] [ 1 ], p_LastPickupPos[ playerid ] [ 2 ] );

			//if ( distance < 50.0 ) printf( "[AC WARN] Player ID %d has entered a pickup near him really fast. (distance: %0.2fm, time: %ds)", playerid, distance, LastPickupTimestamp[ playerid ] - iTimestamp );
			if ( distance > 50.0 )
			{
	        	SendGlobalMessage( -1, ""COL_PINK"[ANTI-CHEAT]{FFFFFF} %s(%d) has been banned for rapid pickup spam.", ReturnPlayerName( playerid ), playerid );
				BanEx( playerid, "Pickup Spam" );
				return 0;
			}
		}
		LastPickupTimestamp[ playerid ] = iTimestamp + 1;
		PreviousPickupID[ playerid ] = pickupid;
	}
	GetPlayerPos( playerid, p_LastPickupPos[ playerid ] [ 0 ], p_LastPickupPos[ playerid ] [ 1 ], p_LastPickupPos[ playerid ] [ 2 ] );

	// Information Pickups
	for( new i = 0; i < sizeof( g_informationPickupsData ); i++ ) if ( g_informationPickupsData[ i ] [ E_PICKUP_ID ] == pickupid )
		return ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_MSGBOX, "{FFFFFF}Area Information", g_informationPickupsData[ i ] [ E_TEXT ], "Okay", "" );

	// Money bag from atms
	if ( p_Class[ playerid ] != CLASS_POLICE ) {
		for( new i = 0; i < sizeof( g_atmData ); i++ ) if ( g_atmData[ i ] [ E_CREATED ] && g_atmData[ i ] [ E_DISABLED ] ) {
			if ( g_atmData[ i ] [ E_PICKUP ] == pickupid && pickupid != -1 ) {
				new
					szCity[ MAX_ZONE_NAME ], szLocation[ MAX_ZONE_NAME ], iLoot = g_atmData[ i ] [ E_LOOT ];

				SplitPlayerCashForGang( playerid, iLoot );
				Achievement::HandlePlayerRobbery( playerid );
				DestroyDynamicPickup( g_atmData[ i ] [ E_PICKUP ] );

				g_atmData[ i ] [ E_PICKUP ] = -1;
				g_atmData[ i ] [ E_LOOT ] = 0;

				GivePlayerWantedLevel( playerid, 4 );
				GivePlayerScore( playerid, 1 );

				GetPlayerPos 			( playerid, X, Y, Z );
			    Get2DCity				( szCity, X, Y, Z );
			    GetZoneFromCoordinates	( szLocation, X, Y, Z );

				SendGlobalMessage( -1, ""COL_GOLD"[ROBBERY]"COL_WHITE" %s(%d) has robbed "COL_GOLD"%s"COL_WHITE" from an ATM near %s in %s!", ReturnPlayerName( playerid ), playerid, ConvertPrice( iLoot ), szLocation, szCity );
				return SendServerMessage( playerid, "You have successfully taken "COL_GOLD"%s"COL_WHITE" dispensed from the ATM.", ConvertPrice( iLoot ) );
			}
		}

		// Bribes
		foreach(new bribeid : BribeCount) if ( g_bribeData[ bribeid ] [ E_PICKUP ] [ 0 ] == pickupid || g_bribeData[ bribeid ] [ E_PICKUP ] [ 1 ] == pickupid )
		{
		    if ( !( g_bribeData[ bribeid ] [ E_DISABLED ] == true || p_WantedLevel[ playerid ] <= 0 || IsPlayerDetained( playerid ) || IsPlayerCuffed( playerid ) || GetPlayerState( playerid ) == PLAYER_STATE_SPECTATING ) )
		    {
		    	new
		    		iWanted = 2;

		    	// Play a sound so it matches the vehicle pickup
		    	if ( g_bribeData[ bribeid ] [ E_PICKUP ] [ 0 ] == pickupid )
		    		PlayerPlaySound( playerid, 1138, 0.0, 0.0, 5.0 );

		    	// Expire the bribe
		        g_bribeData[ bribeid ] [ E_TIMESTAMP ] = GetTickCount( );
		        g_bribeData[ bribeid ] [ E_DISABLED ] = true;
				UpdateDynamic3DTextLabelText( g_bribeData[ bribeid ] [ E_LABEL ], COLOR_GOLD, sprintf( "Bribe(%d)\n"COL_RED"Currently Expired!", bribeid ) );

				// Remove a custom wanted level
				if ( p_WantedLevel[ playerid ] > 1800 ) 		iWanted = 128;
				else if ( p_WantedLevel[ playerid ] > 1000 ) iWanted = 64;
				else if ( p_WantedLevel[ playerid ] > 500 )	iWanted = 32;
				else if ( p_WantedLevel[ playerid ] > 250 )	iWanted = 16;
				else if ( p_WantedLevel[ playerid ] > 100 ) 	iWanted = 8;
				else if ( p_WantedLevel[ playerid ] > 50 )	iWanted = 4;

				return GivePlayerWantedLevel( playerid, p_WantedLevel[ playerid ] <= 1 ? -1 : -iWanted );
		    }
		}
	}
	return 1;
}

public OnVehicleMod( playerid, vehicleid, componentid )
{
	if ( !isLegalCarMod( GetVehicleModel( vehicleid ), componentid ) )
	{
	    if ( g_buyableVehicle{ vehicleid } )
  			RespawnBuyableVehicle( vehicleid );
		else
		    DestroyVehicle( vehicleid );

		printf( "[INVALID_MOD] NAME: %s | VEHICLE: %d | COMPONENT: %d", ReturnPlayerName( playerid ), vehicleid, componentid );
 		Kick( playerid );
		return 0;
	}

	switch( componentid )
	{
	    case 1018: GivePlayerCash( playerid, -350 );
	    case 1019: GivePlayerCash( playerid, -300 );
	    case 1020: GivePlayerCash( playerid, -250 );
	    case 1021: GivePlayerCash( playerid, -200 );
	    case 1022: GivePlayerCash( playerid, -150 );
	    case 1028: GivePlayerCash( playerid, -770 );
	    case 1029: GivePlayerCash( playerid, -680 );
	    case 1034: GivePlayerCash( playerid, -790 );
	    case 1037: GivePlayerCash( playerid, -690 );
	    case 1043: GivePlayerCash( playerid, -500 );
	    case 1044: GivePlayerCash( playerid, -500 );
	    case 1045: GivePlayerCash( playerid, -510 );
	    case 1046: GivePlayerCash( playerid, -710 );
	    case 1059: GivePlayerCash( playerid, -720 );
	    case 1064: GivePlayerCash( playerid, -830 );
	    case 1065: GivePlayerCash( playerid, -850 );
	    case 1066: GivePlayerCash( playerid, -750 );
	    case 1089: GivePlayerCash( playerid, -650 );
	    case 1092: GivePlayerCash( playerid, -750 );
	    case 1104: GivePlayerCash( playerid, -1610 );
	    case 1105: GivePlayerCash( playerid, -1540 );
	    case 1113: GivePlayerCash( playerid, -3340 );
	    case 1114: GivePlayerCash( playerid, -3250 );
	    case 1126: GivePlayerCash( playerid, -3340 );
	    case 1127: GivePlayerCash( playerid, -3250 );
	    case 1129: GivePlayerCash( playerid, -1650 );
	    case 1132: GivePlayerCash( playerid, -1590 );
	    case 1135: GivePlayerCash( playerid, -1500 );
	    case 1136: GivePlayerCash( playerid, -1000 );
	    case 1004: GivePlayerCash( playerid, -100 );
	    case 1005: GivePlayerCash( playerid, -150 );
	    case 1011: GivePlayerCash( playerid, -220 );
	    case 1012: GivePlayerCash( playerid, -250 );
	    case 1117: GivePlayerCash( playerid, -2130 );
	    case 1152: GivePlayerCash( playerid, -910 );
	    case 1153: GivePlayerCash( playerid, -1200 );
	    case 1155: GivePlayerCash( playerid, -1030 );
	    case 1157: GivePlayerCash( playerid, -930 );
	    case 1160: GivePlayerCash( playerid, -1050 );
	    case 1165: GivePlayerCash( playerid, -850 );
	    case 1166: GivePlayerCash( playerid, -950 );
	    case 1169: GivePlayerCash( playerid, -970 );
	    case 1170: GivePlayerCash( playerid, -880 );
	    case 1171: GivePlayerCash( playerid, -990 );
	    case 1172: GivePlayerCash( playerid, -900 );
	    case 1173: GivePlayerCash( playerid, -950 );
	    case 1174: GivePlayerCash( playerid, -1000 );
	    case 1175: GivePlayerCash( playerid, -900 );
	    case 1179: GivePlayerCash( playerid, -2150 );
	    case 1181: GivePlayerCash( playerid, -2050 );
	    case 1182: GivePlayerCash( playerid, -2130 );
	    case 1185: GivePlayerCash( playerid, -2040 );
	    case 1188: GivePlayerCash( playerid, -2080 );
	    case 1189: GivePlayerCash( playerid, -2200 );
	    case 1190: GivePlayerCash( playerid, -1200 );
	    case 1191: GivePlayerCash( playerid, -1040 );
	    case 1140: GivePlayerCash( playerid, -870 );
	    case 1141: GivePlayerCash( playerid, -980 );
	    case 1148: GivePlayerCash( playerid, -890 );
	    case 1149: GivePlayerCash( playerid, -1000 );
	    case 1150: GivePlayerCash( playerid, -1090 );
	    case 1151: GivePlayerCash( playerid, -840 );
	    case 1154: GivePlayerCash( playerid, -1030 );
	    case 1156: GivePlayerCash( playerid, -920 );
	    case 1159: GivePlayerCash( playerid, -1050 );
	    case 1161: GivePlayerCash( playerid, -950 );
	    case 1167: GivePlayerCash( playerid, -850 );
	    case 1168: GivePlayerCash( playerid, -950 );
	    case 1176: GivePlayerCash( playerid, -1000 );
	    case 1177: GivePlayerCash( playerid, -900 );
	    case 1178: GivePlayerCash( playerid, -2050 );
	    case 1180: GivePlayerCash( playerid, -2130 );
	    case 1183: GivePlayerCash( playerid, -2040 );
	    case 1184: GivePlayerCash( playerid, -2150 );
	    case 1186: GivePlayerCash( playerid, -2095 );
	    case 1187: GivePlayerCash( playerid, -2175 );
	    case 1192: GivePlayerCash( playerid, -940 );
	    case 1193: GivePlayerCash( playerid, -1100 );
	    case 1006: GivePlayerCash( playerid, -80 );
	    case 1128: GivePlayerCash( playerid, -3340 );
	    case 1130: GivePlayerCash( playerid, -3380 );
	    case 1131: GivePlayerCash( playerid, -3290 );
	    case 1103: GivePlayerCash( playerid, -3250 );
	    case 1032: GivePlayerCash( playerid, -170 );
	    case 1033: GivePlayerCash( playerid, -120 );
	    case 1035: GivePlayerCash( playerid, -150 );
	    case 1038: GivePlayerCash( playerid, -190 );
	    case 1053: GivePlayerCash( playerid, -130 );
	    case 1054: GivePlayerCash( playerid, -210 );
	    case 1055: GivePlayerCash( playerid, -230 );
	    case 1061: GivePlayerCash( playerid, -180 );
	    case 1067: GivePlayerCash( playerid, -250 );
	    case 1068: GivePlayerCash( playerid, -200 );
	    case 1088: GivePlayerCash( playerid, -150 );
	    case 1091: GivePlayerCash( playerid, -100 );
	    case 1000: GivePlayerCash( playerid, -400 );
	    case 1001: GivePlayerCash( playerid, -550 );
	    case 1002: GivePlayerCash( playerid, -200 );
	    case 1003: GivePlayerCash( playerid, -250 );
	    case 1014: GivePlayerCash( playerid, -400 );
	    case 1015: GivePlayerCash( playerid, -500 );
	    case 1016: GivePlayerCash( playerid, -200 );
	    case 1023: GivePlayerCash( playerid, -350 );
	    case 1049: GivePlayerCash( playerid, -810 );
	    case 1050: GivePlayerCash( playerid, -620 );
	    case 1058: GivePlayerCash( playerid, -620 );
	    case 1060: GivePlayerCash( playerid, -530 );
	    case 1138: GivePlayerCash( playerid, -580 );
	    case 1139: GivePlayerCash( playerid, -470 );
	    case 1146: GivePlayerCash( playerid, -490 );
	    case 1147: GivePlayerCash( playerid, -600 );
	    case 1158: GivePlayerCash( playerid, -550 );
	    case 1162: GivePlayerCash( playerid, -650 );
	    case 1163: GivePlayerCash( playerid, -550 );
	    case 1164: GivePlayerCash( playerid, -450 );
	    case 1007: GivePlayerCash( playerid, -500 );
	    case 1017: GivePlayerCash( playerid, -500 );
	    case 1026: GivePlayerCash( playerid, -480 );
	    case 1027: GivePlayerCash( playerid, -480 );
	    case 1030: GivePlayerCash( playerid, -37 );
	    case 1031: GivePlayerCash( playerid, -370 );
	    case 1036: GivePlayerCash( playerid, -500 );
	    case 1039: GivePlayerCash( playerid, -390 );
	    case 1040: GivePlayerCash( playerid, -500 );
	    case 1041: GivePlayerCash( playerid, -390 );
	    case 1042: GivePlayerCash( playerid, -1000 );
	    case 1047: GivePlayerCash( playerid, -670 );
	    case 1048: GivePlayerCash( playerid, -530 );
	    case 1051: GivePlayerCash( playerid, -670 );
	    case 1052: GivePlayerCash( playerid, -530 );
	    case 1056: GivePlayerCash( playerid, -520 );
	    case 1057: GivePlayerCash( playerid, -430 );
	    case 1062: GivePlayerCash( playerid, -250 );
	    case 1063: GivePlayerCash( playerid, -430 );
	    case 1069: GivePlayerCash( playerid, -550 );
	    case 1070: GivePlayerCash( playerid, -450 );
	    case 1071: GivePlayerCash( playerid, -550 );
	    case 1072: GivePlayerCash( playerid, -450 );
	    case 1090: GivePlayerCash( playerid, -450 );
	    case 1093: GivePlayerCash( playerid, -350 );
	    case 1094: GivePlayerCash( playerid, -450 );
	    case 1095: GivePlayerCash( playerid, -350 );
	    case 1099: GivePlayerCash( playerid, -1000 );
	    case 1101: GivePlayerCash( playerid, -780 );
	    case 1102: GivePlayerCash( playerid, -830 );
	    case 1106: GivePlayerCash( playerid, -780 );
	    case 1107: GivePlayerCash( playerid, -780 );
	    case 1108: GivePlayerCash( playerid, -780 );
	    case 1118: GivePlayerCash( playerid, -780 );
	    case 1119: GivePlayerCash( playerid, -940 );
	    case 1120: GivePlayerCash( playerid, -780 );
	    case 1121: GivePlayerCash( playerid, -940 );
	    case 1122: GivePlayerCash( playerid, -780 );
	    case 1124: GivePlayerCash( playerid, -780 );
	    case 1133: GivePlayerCash( playerid, -830 );
	    case 1134: GivePlayerCash( playerid, -800 );
	    case 1137: GivePlayerCash( playerid, -800 );
	    case 1013: GivePlayerCash( playerid, -100 );
	    case 1024: GivePlayerCash( playerid, -50 );
	    case 1142: GivePlayerCash( playerid, -150 );
	    case 1143: GivePlayerCash( playerid, -150 );
	    case 1144: GivePlayerCash( playerid, -100 );
	    case 1145: GivePlayerCash( playerid, -100 );
	    case 1025: GivePlayerCash( playerid, -1000 );
	    case 1073: GivePlayerCash( playerid, -1000 );
	    case 1074: GivePlayerCash( playerid, -1030 );
	    case 1075: GivePlayerCash( playerid, -980 );
	    case 1076: GivePlayerCash( playerid, -1560 );
	    case 1077: GivePlayerCash( playerid, -1620 );
	    case 1078: GivePlayerCash( playerid, -1200 );
	    case 1079: GivePlayerCash( playerid, -1030 );
	    case 1080: GivePlayerCash( playerid, -1000 );
	    case 1081: GivePlayerCash( playerid, -1230 );
	    case 1082: GivePlayerCash( playerid, -820 );
	    case 1083: GivePlayerCash( playerid, -1560 );
	    case 1084: GivePlayerCash( playerid, -1350 );
	    case 1085: GivePlayerCash( playerid, -770 );
	    case 1096: GivePlayerCash( playerid, -1000 );
	    case 1097: GivePlayerCash( playerid, -620 );
	    case 1098: GivePlayerCash( playerid, -1140 );
	    case 1008: GivePlayerCash( playerid, -200 );
	    case 1009: GivePlayerCash( playerid, -500 );
	    case 1010: GivePlayerCash( playerid, -1000 );
	    case 1086: GivePlayerCash( playerid, -100 );
	    case 1087: GivePlayerCash( playerid, -1500 );
	    case 1100: GivePlayerCash( playerid, -940 );
	    case 1123: GivePlayerCash( playerid, -860 );
	    case 1125: GivePlayerCash( playerid, -1120 );
	    case 1109: GivePlayerCash( playerid, -1610 );
	    case 1110: GivePlayerCash( playerid, -1540 );
	    case 1115: GivePlayerCash( playerid, -2130 );
	    case 1116: GivePlayerCash( playerid, -2050 );
	}
	return 1;
}

public OnEnterExitModShop( playerid, enterexit, interiorid )
{
	new
	    vehicleid,
	    szMods[ MAX_CAR_MODS * 10 ]
	;

	if ( enterexit == 0 )
	{
	    if ( IsValidVehicle( ( vehicleid = GetPlayerVehicleID( playerid ) ) ) )
	    {
			if ( g_buyableVehicle{ vehicleid } == true )
			{
		        new
		        	ownerid = INVALID_PLAYER_ID,
		        	v = getVehicleSlotFromID( vehicleid, ownerid )
		        ;
			    if ( ownerid == playerid && v != -1 )
			    {
			        if ( UpdateBuyableVehicleMods( playerid, v ) )
			        {
						for( new i; i < MAX_CAR_MODS; i++ )
							format( szMods, sizeof( szMods ), "%s%d.", szMods, g_vehicleModifications[ playerid ] [ v ] [ i ] );

						format( szBigString, sizeof( szBigString ), "UPDATE `VEHICLES` SET `MODS`='%s' WHERE `ID`=%d", szMods, g_vehicleData[ playerid ] [ v ] [ E_SQL_ID ] );
						mysql_single_query( szBigString );
			        }
			        else SendError( playerid, "Couldn't update your vehicle mods due to an unexpected error (0x82FF)." );
			    }
			}
		}
	}
	return 1;
}

public OnVehiclePaintjob( playerid, vehicleid, paintjobid )
{
	if ( g_buyableVehicle{ vehicleid } == true )
	{
	    new
	    	ownerid = INVALID_PLAYER_ID,
	    	v = getVehicleSlotFromID( vehicleid, ownerid )
	    ;
	    if ( ownerid == playerid && v != -1 )
	    {
	        g_vehicleData[ playerid ] [ v ] [ E_PAINTJOB ] = paintjobid;
	        SaveVehicleData( playerid, v );
	    }
	}
	// GivePlayerCash( playerid, -500 );
	return 1;
}

public OnVehicleRespray( playerid, vehicleid, color1, color2 )
{
    if ( g_buyableVehicle{ vehicleid } == true )
    {
	    new
	    	ownerid = INVALID_PLAYER_ID,
	    	v = getVehicleSlotFromID( vehicleid, ownerid )
	    ;
	    if ( ownerid == playerid && v != -1 )
		{
			g_vehicleData[ playerid ] [ v ] [ E_COLOR ] [ 0 ] = color1;
	        g_vehicleData[ playerid ] [ v ] [ E_COLOR ] [ 1 ] = color2;
	        SaveVehicleData( playerid, v );
		}
    }
    GivePlayerCash( playerid, -100 );
	return 1;
}

public OnPlayerSelectedMenuRow( playerid, row )
{
	return 1;
}

public OnPlayerExitedMenu( playerid )
{
	return 1;
}

public OnPlayerInteriorChange( playerid, newinteriorid, oldinteriorid )
{
	if ( p_InHouse[ playerid ] == -1 && p_LastEnteredEntrance[ playerid ] != -1 && newinteriorid != 0 && oldinteriorid == 0 && p_Class[ playerid ] != CLASS_POLICE ) {

		if ( !IsPlayerInBank( playerid ) ) p_SafeHelperTimer[ playerid ] = SetTimerEx( "OnSafeHelperUpdate", 500, false, "dd", playerid, -1 );
		else
		{
			new
				iCity,
				iWorld = GetPlayerVirtualWorld( playerid )
			;

			for( iCity = 0; iCity < sizeof( g_bankvaultData ); iCity++ )
				if ( iWorld == g_bankvaultData[ iCity ] [ E_WORLD ] )
					break;

			if ( g_bankvaultData[ iCity ] [ E_TIMESTAMP ] < g_iTime && !g_bankvaultData[ iCity ] [ E_DISABLED ] )
				ShowPlayerHelpDialog( playerid, 5000, "This ~g~~h~bank~w~~h~ is available for a heist." );
			else
				ShowPlayerHelpDialog( playerid, 5000, "This bank is ~r~~h~unavailable for a heist." );
		}
	}

	SyncSpectation( playerid );
	return 1;
}

function OnSafeHelperUpdate( playerid, robberyid )
{
	if ( robberyid == -1 )
	{
		p_SafeHelperTimer[ playerid ] = SetTimerEx( "OnSafeHelperUpdate", 500, false, "dd", playerid, getClosestRobberySafe( playerid ) );
		return 1;
	}

	new
		Float: distance = distanceFromSafe( playerid, robberyid )
	;

	if ( robberyid == INVALID_OBJECT_ID || distance > 100.0 || !IsPlayerConnected( playerid ) || !IsPlayerSpawned( playerid ) )
	{
		p_SafeHelperTimer[ playerid ] = -1;
		HidePlayerHelpDialog( playerid );
		return 0;
	}

	if ( g_robberyData[ robberyid ] [ E_ROBBED ] )
	{
		p_SafeHelperTimer[ playerid ] = -1;
		ShowPlayerHelpDialog( playerid, 5000, "This store currently is ~r~~h~unavailable for robbing.~w~~h~~n~~n~Come back later." );
		return 0;
	}

	if ( distance < 2.0 )
	{
		p_SafeHelperTimer[ playerid ] = -1;
		ShowPlayerHelpDialog( playerid, 7500, "Great, you've ~g~~h~found the safe.~w~~h~~n~~n~To rob the safe, hit ~r~~h~Left Alt~w~~h~ key." );
		return 1;
	}

	ShowPlayerHelpDialog( playerid, 0, "To rob the store, find the safe first.~n~~n~You're ~g~~h~%0.2fm~w~~h~ from the safe here.", distance );
	return ( p_SafeHelperTimer[ playerid ] = SetTimerEx( "OnSafeHelperUpdate", 500, false, "dd", playerid, robberyid ) );
}

public OnPlayerArrest( playerid, victimid, totalarrests, totalpeople )
{
	new
		iBefore = p_Arrests[ playerid ],
		iAfter 	= ( p_Arrests[ playerid ] += totalpeople )
	;

	incrementPlayerStreak( playerid, STREAK_ARREST );

	if ( iBefore < 1000 && iAfter >= 1000 ) 	  ShowAchievement( playerid, "Arrested ~r~1000~w~~h~~h~ criminals!", 25 );
	else if ( iBefore < 500 && iAfter >= 500 ) ShowAchievement( playerid, "Arrested ~r~500~w~~h~~h~ criminals!", 18 );
	else if ( iBefore < 200 && iAfter >= 200 ) ShowAchievement( playerid, "Arrested ~r~200~w~~h~~h~ criminals!", 15 );
	else if ( iBefore < 100 && iAfter >= 100 ) ShowAchievement( playerid, "Arrested ~r~100~w~~h~~h~ criminals!", 12 );
	else if ( iBefore < 50  && iAfter >= 50 )  ShowAchievement( playerid, "Arrested ~r~50~w~~h~~h~ criminals!", 9 );
	else if ( iBefore < 20  && iAfter >= 20 )  ShowAchievement( playerid, "Arrested ~r~20~w~~h~~h~ criminals!", 6 );
	else if ( iBefore < 5   && iAfter >= 5 )   ShowAchievement( playerid, "Arrested ~r~5~w~~h~~h~ criminals!", 3 );
	return 1;
}

public VendingMachineUsed( playerid, Float: fHealthGiven )
{
	p_VendingUseTimer[ playerid ] = -1;

	if ( GetPlayerState( playerid ) == PLAYER_STATE_ONFOOT )
	{
		new
			Float: fHealth;

		GetPlayerHealth( playerid, fHealth );

		fHealth += fHealthGiven;

		if ( fHealth > 100.0 )
			fHealth = 100.0;

		SetPlayerHealth( playerid, fHealth );
	}
}

public OnPlayerKeyStateChange( playerid, newkeys, oldkeys )
{
	static
		Float: X, Float: Y, Float: Z, Float: Angle;

	new
 		iVehicle = GetPlayerVehicleID( playerid ),
		iWeapon = GetPlayerWeapon( playerid ),
		machineid = p_usingSlotMachine[ playerid ]
	;

	if ( HOLDING( KEY_SPRINT ) && HOLDING( KEY_WALK ) && IsPlayerUsingRadio( playerid ) )
		StopAudioStreamForPlayer( playerid );

    if ( PRESSED( KEY_JUMP ) && GetPlayerSpecialAction( playerid ) == SPECIAL_ACTION_CUFFED )
 		ApplyAnimation( playerid, "GYMNASIUM", "gym_jog_falloff", 4.1, 0, 1, 1, 0, 0 );

 	// Spectation
	if ( p_Spectating{ playerid } == true )
	{
	    if ( PRESSED( KEY_FIRE ) )
	    {
			for( new i = p_whomSpectating[ playerid ] + 1; i < MAX_PLAYERS; i++ )
			{
				if ( IsPlayerConnected( i ) && IsPlayerSpawned( i ) && !p_Spectating{ i } && i != playerid )
				{
					ForceSpectateOnPlayer( playerid, i );
					break;
				}
			}
	    }
	    if ( PRESSED( KEY_AIM ) )
	    {
			for( new i = p_whomSpectating[ playerid ] - 1; i > -1; i-- )
			{
				if ( IsPlayerConnected( i ) && IsPlayerSpawned( i ) && !p_Spectating{ i } && i != playerid )
				{
					ForceSpectateOnPlayer( playerid, i );
					break;
				}
			}
	    }
	    return 1;
	}

	if ( IsPlayerInCasino( playerid ) )
	{
        new
            blackjack_table = p_blackjackTable[ playerid ];

       	// Blackjack
        if ( blackjack_table != -1 )
        {
            new
                player_index = GetBlackjackPlayerIndex( blackjack_table, playerid );

            if ( player_index == -1 )
                return SendError( playerid, "You don't seem to be playing any blackjack table." );

		    if ( PRESSED( KEY_SPRINT ) ) {

	            if ( ! g_blackjackData[ blackjack_table ] [ E_CARDS_DRAWN ] && g_blackjackData[ blackjack_table ] [ E_GAME_TIMER ] == -1 )
	                return ( g_blackjackData[ blackjack_table ] [ E_GAME_TIMER ] = SetTimerEx( "BeginBlackJackTurn", BLACKJACK_DEALER_WAIT, false, "d", blackjack_table ) ), 1;

	            if ( g_blackjackPlayerState[ blackjack_table ] [ player_index ] == BLACKJACK_STATE_TURN ) {
	                g_blackjackPlayerState[ blackjack_table ] [ player_index ] = BLACKJACK_STATE_STAND;
	                SendClientMessageToBlackjack( blackjack_table, COLOR_GREY, "[BLACKJACK]"COL_WHITE" %s(%d) has decided to stand.", ReturnPlayerName( playerid ), playerid );
	                return 1;
	            }
		        return 1;
		    }

		    if ( PRESSED( KEY_CTRL_BACK ) )
		    {
	            if ( g_blackjackPlayerState[ blackjack_table ] [ player_index ] != BLACKJACK_STATE_TURN )
	                return SendError( playerid, "It's not your turn to hit. Please wait!" );

	            DrawPlayerBlackjackCard( blackjack_table, player_index );
	            CheckForBlackjack( blackjack_table );
	            return 1;
		    }
        }

		// Roulette
		if ( p_RouletteMarkerTimer[ playerid ] != -1 )
		{
			new
				rouletteid = p_RouletteTable[ playerid ];

			if ( ! Iter_Contains( roulettetables, rouletteid ) )
				return SendServerMessage( playerid, "Invalid Roulette Table." );

			if ( GetDistanceFromPlayerSquared( playerid, g_rouletteTableData[ rouletteid ] [ E_X ], g_rouletteTableData[ rouletteid ] [ E_Y ], g_rouletteTableData[ rouletteid ] [ E_Z ] ) > 16.0 ) // Squared
				return RemovePlayerFromRoulette( playerid );

			// confirm bet
			if ( PRESSED( KEY_SPRINT ) )
			{
				if ( g_rouletteTableData[ rouletteid ] [ E_NO_MORE_BETS ] )
					return SendError( playerid, "This roulette table must finish its spin before you can bet again." );

				if ( p_rouletteBetLocked{ playerid } )
					return SendError( playerid, "You have already locked in your bet. Wait for the spin to finish." );

				new
					totalBet = GetPlayerTotalRouletteBet( playerid );

				if ( totalBet <= 0 )
					return SendError( playerid, "You cannot spin the roulette without having placed any bets." );

				if ( totalBet > GetPlayerCash( playerid ) )
					return SendError( playerid, "You do not have enough money to make this bet." );

				// deduct money
				GivePlayerCash( playerid, -totalBet );

				// lock the player in
				p_rouletteBetLocked{ playerid } = true;

				if ( g_rouletteTableData[ rouletteid ] [ E_SPINNING_TIMER ] == -1 )
				{
					// randomize string
					GenerateRandomRouletteNumber( rouletteid );

					foreach (new i : Player) if ( p_RouletteTable[ i ] == rouletteid )
					{
						TextDrawShowForPlayer( i, g_rouletteNumberBG[ rouletteid ] );
						TextDrawShowForPlayer( i, g_rouletteNumberTD[ rouletteid ] );

						if ( ! p_rouletteBetLocked{ i } ) {
							SendServerMessage( i, "%s(%d) has waged %s with this spin, press SPACE to join the spin!", ReturnPlayerName( playerid ), playerid, ConvertPrice( totalBet ) );
						}
					}

					// allow bets
					g_rouletteTableData[ rouletteid ] [ E_NO_MORE_BETS ] = false;

					// fire the spin table
					g_rouletteTableData[ rouletteid ] [ E_SPINNING_TIMER ] = SetTimerEx( "OnSpinRouletteTable", 25, false, "ddd", rouletteid, 0, 1 );

					// inform other players
					SendServerMessage( playerid, "You have begun the spin with a wager of %s. Good luck!", ConvertPrice( totalBet ) );
				}
				else SendServerMessage( playerid, "You have joined the spin. Good luck!" );
			}
			// decrease bet
			if ( PRESSED( KEY_WALK ) )
			{
				if ( ( p_rouletteBetValue[ playerid ] /= 2 ) < 1000 )
					p_rouletteBetValue[ playerid ] = 1000;

				SendServerMessage( playerid, "You are now betting %s, gamble responsibly!", ConvertPrice( p_rouletteBetValue[ playerid ] ) );
			}

			// increase bet
			if ( PRESSED( KEY_JUMP  ) )
			{
				if ( ( p_rouletteBetValue[ playerid ] *= 2 ) > 100000 )
					p_rouletteBetValue[ playerid ] = 100000;

				SendServerMessage( playerid, "You are now betting %s, gamble responsibly!", ConvertPrice( p_rouletteBetValue[ playerid ] ) );
			}

			// Cancel Bets
			if ( PRESSED( KEY_CROUCH ) )
			{
				if ( p_rouletteBetLocked{ playerid } )
					return SendError( playerid, "You cannot cancel your bet once you have entered a spin." );

				for ( new column = 0; column < sizeof( g_rouletteOffsets ); column ++ )
				{
					g_rouletteChipValue[ playerid ] [ column ] = 0;
					DestroyDynamicObject( g_rouletteChip[ playerid ] [ column ] ), g_rouletteChip[ playerid ] [ column ] = -1;
					DestroyDynamic3DTextLabel( g_rouletteChipLabel[ playerid ] [ column ] ), g_rouletteChipLabel[ playerid ] [ column ] = Text3D: INVALID_3DTEXT_ID;
				}
			}

			// Place bet
			if ( PRESSED( KEY_FIRE ) || PRESSED( KEY_AIM ) )
			{
				if ( p_rouletteBetLocked{ playerid } )
					return SendError( playerid, "You cannot change your bet once you have entered a spin." );

				new
					column = p_RouletteMarkerColumn{ playerid };

				new Float: offsetX = g_rouletteTableData[ rouletteid ] [ E_X ] + g_rouletteOffsets[ column ] [ E_OFFSET ] * floatcos( g_rouletteTableData[ rouletteid ] [ E_ROTATION ] + g_rouletteOffsets[ column ] [ E_ANGLE ], degrees );
				new Float: offsetY = g_rouletteTableData[ rouletteid ] [ E_Y ] + g_rouletteOffsets[ column ] [ E_OFFSET ] * floatsin( g_rouletteTableData[ rouletteid ] [ E_ROTATION ] + g_rouletteOffsets[ column ] [ E_ANGLE ], degrees );

				if ( PRESSED( KEY_FIRE ) )
				{
					new
						totalBet = GetPlayerTotalRouletteBet( playerid );

					// Check if the player has even money
					if ( totalBet > GetPlayerCash( playerid ) ) {
						return SendError( playerid, "You cannot afford to wager any more money!" );
					}

					// Exceeded The Maximum
					if ( totalBet + p_rouletteBetValue[ playerid ] > 100000 ) {
						return SendError( playerid, "You are only allowed to bet a total of $100,000 per spin on this table." );
					}

					PlayerPlaySound( playerid, 1083, 0.0, 0.0, 5.0 );
					g_rouletteChipValue[ playerid ] [ column ] += p_rouletteBetValue[ playerid ];
				}
				else
				{
					PlayerPlaySound( playerid, 1084, 0.0, 0.0, 5.0 );
					g_rouletteChipValue[ playerid ] [ column ] -= p_rouletteBetValue[ playerid ];
				}

				//printf("COLUMN : %d", column);
				if ( g_rouletteChipValue[ playerid ] [ column ] <= 0 )
				{
					DestroyDynamic3DTextLabel( g_rouletteChipLabel[ playerid ] [ column ] ), g_rouletteChipLabel[ playerid ] [ column ] = Text3D: -1;
					DestroyDynamicObject( g_rouletteChip[ playerid ] [ column ] ), g_rouletteChip[ playerid ] [ column ] = -1;
					g_rouletteChipValue[ playerid ] [ column ] = 0;
					//printf("removed");
				}
				else
				{
					// Calculate chip height
					new
						Float: height = 0.295 - float( g_rouletteChipValue[ playerid ] [ column ] / 1000 ) * 0.005;

					if ( height < 0.18 )
						height = 0.18;

					//printf("g_rouletteChip[%s][%d] = %d", ReturnPlayerName( playerid ), column, g_rouletteChip[ playerid ] [ column ] );
					if ( g_rouletteChip[ playerid ] [ column ] == -1 )
					{
						g_rouletteChip[ playerid ] [ column ] = CreateDynamicObject( 1902, offsetX, offsetY, g_rouletteTableData[ rouletteid ] [ E_Z ] - height, 0.00000, 0.00000, 0.0 ); // 2992
						SetDynamicObjectMaterial( g_rouletteChip[ playerid ] [ column ], 0, 1902, "chip_stack08", "chip_stck6", ( ( g_rouletteChipColor[ playerid ] >> 8 ) | 0x99000000 ) );
						g_rouletteChipLabel[ playerid ] [ column ] = CreateDynamic3DTextLabel( sprintf( "%s", ConvertPrice( g_rouletteChipValue[ playerid ] [ column ] ) ), g_rouletteChipColor[ playerid ], offsetX, offsetY, g_rouletteTableData[ rouletteid ] [ E_Z ] - 0.15 + ( float( playerid ) / 100 ), 5.0 ); //INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, -1, -1, playerid );
						//printf("(%s) CREATED CHIP %d:%d", ReturnPlayerName( playerid ), g_rouletteChip[ playerid ] [ column ], _: g_rouletteChipLabel[ playerid ] [ column ] );
					}
					else
					{
						SetDynamicObjectPos( g_rouletteChip[ playerid ] [ column ], offsetX, offsetY, g_rouletteTableData[ rouletteid ] [ E_Z ] - height );
						UpdateDynamic3DTextLabelText( g_rouletteChipLabel[ playerid ] [ column ], g_rouletteChipColor[ playerid ], sprintf( "%s", ConvertPrice( g_rouletteChipValue[ playerid ] [ column ] ) ) );
						//printf("(%s) UPDATED CHIP %d:%d", ReturnPlayerName( playerid ), g_rouletteChip[ playerid ] [ column ], _: g_rouletteChipLabel[ playerid ] [ column ] );
					}
				}

				// sometimes it doesnt show up
				SyncObject( playerid, 0.005, 0.005, 0.005 );
				ApplyAnimation( playerid, "DEALER", "DEALER_IDLE", 4.1, 1, 1, 1, 1, 0, 1 );
			}
		}

		if ( PRESSED( KEY_SECONDARY_ATTACK ) )
		{
			if ( p_rouletteBetLocked{ playerid } )
				return SendError( playerid, "Please wait until the spin is completed before leaving the table." );

			if ( p_RouletteTable[ playerid ] != -1 )
				return RemovePlayerFromRoulette( playerid );

			if ( p_blackjackTable[ playerid ] != -1 )
				return RemovePlayerFromBlackjack( playerid, .reset_cam = 1 );

			foreach(new id : blackjacktables)
	        {
	            if ( IsPlayerInRangeOfPoint( playerid, 3.0, g_blackjackData[ id ] [ E_X ], g_blackjackData[ id ] [ E_Y ], g_blackjackData[ id ] [ E_Z ] ) ) {

	                new
	                    player_index;

	                for ( ; player_index < MAX_BLACKJACK_PLAYERS; player_index ++ )
	                    if ( g_blackjackSlotData[ id ] [ player_index ] == -1 )
	                        break;

	                if ( player_index >= MAX_BLACKJACK_PLAYERS || g_blackjackSlotData[ id ] [ player_index ] != -1 )
	                    return SendError( playerid, "There are no more vacant slots for this table." );

	                if ( GetPlayerCash( playerid ) < g_blackjackData[ id ] [ E_PAYOUT ] )
	                    return SendError( playerid, "You don't have any money to wager." );

	                new
	                    Float: lookatX, Float: lookatY, Float: lookatZ,
	                    Float: tmpX, Float: tmpY, Float: tmpZ
	                ;

	                GetPlayerCameraPos( playerid, X, Y, Z );
	                GetPlayerCameraFrontVector( playerid, lookatX, lookatY, lookatZ );

	                tmpX = g_blackjackData[ id ] [ E_X ] - 1.3 * floatcos( g_blackjackData[ id ] [ E_ROTATION ] + 90.0, degrees );
	                tmpY = g_blackjackData[ id ] [ E_Y ] - 1.3 * floatsin( g_blackjackData[ id ] [ E_ROTATION ] + 90.0, degrees );
	                tmpZ = g_blackjackData[ id ] [ E_Z ] + 1.7;

	                InterpolateCameraPos( playerid, X, Y, Z, tmpX, tmpY, tmpZ, 1000, CAMERA_MOVE );

	                X += floatmul( lookatX, 20.0 );
	                Y += floatmul( lookatY, 20.0 );
	                Z += floatmul( lookatZ, 20.0 );

	                InterpolateCameraLookAt( playerid, X, Y, Z, g_blackjackData[ id ] [ E_X ], g_blackjackData[ id ] [ E_Y ], g_blackjackData[ id ] [ E_Z ] - 1.0, 1000, CAMERA_MOVE );

	                p_blackjackTable[ playerid ] = id;
	                g_blackjackSlotData[ id ] [ player_index ] = playerid;

	                // reset player cards
	                for ( new c = 0; c < MAX_BLACKJACK_CARDS; c ++ )
	                    g_blackjackPlayerCardIndex[ id ] [ c ] [ player_index ] = -1;

	                // show cards to players
	                for ( new player = 0; player < MAX_BLACKJACK_PLAYERS; player ++ )
	                {
	                    new
	                        gamerid = g_blackjackSlotData[ id ] [ player ];

	                    // deal only first two cards
	                    for ( new c = 0; c < MAX_BLACKJACK_CARDS; c ++ )
	                    {
	                        TextDrawShowForPlayer( gamerid, g_blackjackDealerCards[ id ] [ c ] );

	                        // show two player cards only
	                        if ( c >= 2 )
	                            continue;

	                        for ( new p = 0; p < GetBlackjackPlayers( id ); p ++ ) {
	                            TextDrawShowForPlayer( gamerid, g_blackjackPlayerCards[ id ] [ c ] [ p ] );
	                        }
	                    }
	                }

					szBigString = "~y~~k~~PED_SPRINT~~w~ - Begin game/Stand~n~~y~~k~~GROUP_CONTROL_BWD~~w~ - Hit~n~~y~~k~~VEHICLE_ENTER_EXIT~~w~ - Exit";
					ShowPlayerHelpDialog( playerid, 0, szBigString );

	                SendServerMessage( playerid, "You have entered the %s hand blackjack table.", ConvertPrice( g_blackjackData[ id ] [ E_PAYOUT ] ) );
	                ApplyAnimation( playerid, "DEALER", "DEALER_IDLE", 4.1, 1, 1, 1, 1, 0, 1 );
	                return 1;
	            }
	        }

			foreach(new id : roulettetables)
			{
				if ( IsPlayerInRangeOfPoint( playerid, 3.1, g_rouletteTableData[ id ] [ E_X ], g_rouletteTableData[ id ] [ E_Y ], g_rouletteTableData[ id ] [ E_Z ] ) ) {

					static
						Float: lookatX, Float: lookatY, Float: lookatZ,
						Float: tmpX, Float: tmpY, Float: tmpZ
					;

					GetPlayerCameraPos( playerid, X, Y, Z );
					GetPlayerCameraFrontVector( playerid, lookatX, lookatY, lookatZ );

					tmpX = g_rouletteTableData[ id ] [ E_X ] + -1.8 * floatcos( g_rouletteTableData[ id ] [ E_ROTATION ] + 74.0, degrees );
					tmpY = g_rouletteTableData[ id ] [ E_Y ] + -1.8 * floatsin( g_rouletteTableData[ id ] [ E_ROTATION ] + 74.0, degrees );
					tmpZ = g_rouletteTableData[ id ] [ E_Z ] + 1.7;

					InterpolateCameraPos( playerid, X, Y, Z, tmpX, tmpY, tmpZ, 1000, CAMERA_MOVE );

					X += floatmul( lookatX, 20.0 );
					Y += floatmul( lookatY, 20.0 );
					Z += floatmul( lookatZ, 20.0 );

					InterpolateCameraLookAt( playerid, X, Y, Z, g_rouletteTableData[ id ] [ E_X ], g_rouletteTableData[ id ] [ E_Y ], g_rouletteTableData[ id ] [ E_Z ] - 1.0, 1000, CAMERA_MOVE );

					p_RouletteTable[ playerid ] = id;
					p_RouletteMarkerColumn{ playerid } = 0;

					new Float: offsetX = g_rouletteOffsets[ 0 ] [ E_OFFSET ] * floatcos( Angle + g_rouletteOffsets[ 0 ] [ E_ANGLE ], degrees );
					new Float: offsetY = g_rouletteOffsets[ 0 ] [ E_OFFSET ] * floatsin( Angle + g_rouletteOffsets[ 0 ] [ E_ANGLE ], degrees );
					DestroyDynamicObject( p_RouletteMarker[ playerid ] );
					p_RouletteMarker[ playerid ] = CreateDynamicObject( 2992, X + offsetX, Y + offsetY, Z - 0.17, 0.00000, 0.00000, 0.0, -1, -1, playerid );

					// starting bet
					p_rouletteBetValue[ playerid ] = 1000;
					g_rouletteChipColor[ playerid ] = makeColor( RandomEx( 128, 255 ), RandomEx( 128, 255 ), RandomEx( 128, 255 ), 0xFF );
					SendServerMessage( playerid, "Your starting bet is $1,000 for this table. {%06x}This is your chip color.", g_rouletteChipColor[ playerid ] >>> 8 );

					ApplyAnimation( playerid, "DEALER", "DEALER_IDLE", 4.1, 1, 1, 1, 1, 0, 1 );

					szBigString = "~y~~k~~PED_SPRINT~~w~ - Spin Wheel~n~~y~~k~~PED_FIREWEAPON~/~k~~PED_LOCK_TARGET~~w~ - Place/Remove Bet~n~~y~~k~~PED_JUMPING~/~k~~SNEAK_ABOUT~~w~ - Increase/Decrease Bet~n~~y~~k~~PED_DUCK~~w~ - Cancel Bets~n~~y~~k~~VEHICLE_ENTER_EXIT~~w~ - Exit";
					ShowPlayerHelpDialog( playerid, 0, szBigString );

					// printf("(%s) BEFORE TIMER %d", ReturnPlayerName( playerid ), p_RouletteMarkerTimer[ playerid ] );
					KillTimer( p_RouletteMarkerTimer[ playerid ] );
					p_RouletteMarkerTimer[ playerid ] = SetTimerEx( "OnRouletteMarkerUpdate", 100, true, "d", playerid );
					return 1;
				}
			}
		}

		// Gambling Slots
		if ( machineid != -1 )
		{
			if ( GetDistanceFromPlayerSquared( playerid, g_slotmachineData[ machineid ] [ E_X ], g_slotmachineData[ machineid ] [ E_Y ], g_slotmachineData[ machineid ] [ E_Z ] ) > 4.0 ) // Squared
				return StopPlayerUsingSlotMachine( playerid );

			if ( PRESSED( KEY_JUMP ) ) {
				if ( ( p_AutoSpin{ playerid } = ! p_AutoSpin{ playerid } ) == true )
					TriggerPlayerSlotMachine( playerid, machineid );

				return SendServerMessage( playerid, "You have %s autospin for this slot machine.", p_AutoSpin{ playerid } ? ( "enabled" ) : ( "disabled" ) );
			}

			if ( PRESSED( KEY_SPRINT ) ) {
				TriggerPlayerSlotMachine( playerid, machineid );
			}

			if ( PRESSED( KEY_SECONDARY_ATTACK ) )
			{
				if ( g_slotmachineData[ machineid ] [ E_ROLLING ] )
					return SendError( playerid, "Please wait for the slot machine to finish spinning." );

				return StopPlayerUsingSlotMachine( playerid );
			}
		}
		else
		{
			if ( PRESSED( KEY_SECONDARY_ATTACK ) )
			{
				new
					id = GetClosestSlotMachine( playerid );

				if ( id != -1 )
				{
					X = g_slotmachineData[ id ] [ E_X ] + floatcos( g_slotmachineData[ id ] [ E_A ] - 90, degrees );
					Y = g_slotmachineData[ id ] [ E_Y ] + floatsin( g_slotmachineData[ id ] [ E_A ] - 90, degrees );

					if ( IsPlayerInRangeOfPoint( playerid, 1.0, X, Y, g_slotmachineData[ id ] [ E_Z ] ) && GetPlayerPos( playerid, Z, Z, Z ) )
					{
						if ( GetPlayerCash( playerid ) < 100 )
						{
							PlayerPlaySound( playerid, 1055, 0.0, 0.0, 0.0 );
							return 1;
						}

						p_AutoSpin{ playerid } = false;
						p_usingSlotMachine[ playerid ] = id;

						SetPlayerPos( playerid, X, Y, Z );
						TogglePlayerControllable( playerid, 0 );
						SetPlayerFacingAngle( playerid, g_slotmachineData[ id ] [ E_A ] );

						TextDrawSetString( g_SlotMachineOneTD[ id ], g_slotmachineColors[ floatround( floatfract( g_slotmachineData[ id ] [ E_SPIN_ROTATE ] [ 0 ] / 360 ) * 18 ) ] );
						TextDrawShowForPlayer( playerid, g_SlotMachineOneTD[ id ] );

						TextDrawSetString( g_SlotMachineTwoTD[ id ], g_slotmachineColors[ floatround( floatfract( g_slotmachineData[ id ] [ E_SPIN_ROTATE ] [ 1 ] / 360 ) * 18 ) ] );
						TextDrawShowForPlayer( playerid, g_SlotMachineTwoTD[ id ] );

						TextDrawSetString( g_SlotMachineThreeTD[ id ], g_slotmachineColors[ floatround( floatfract( g_slotmachineData[ id ] [ E_SPIN_ROTATE ] [ 2 ] / 360 ) * 18 ) ] );
						TextDrawShowForPlayer( playerid, g_SlotMachineThreeTD[ id ] );

						TextDrawSetString( p_SlotMachineFigureTD[ id ], sprintf( "~y~~h~%s", ConvertPrice( g_slotmachineData[ id ] [ E_ENTRY_FEE ] ) ) );
						TextDrawShowForPlayer( playerid, p_SlotMachineFigureTD[ id ] );

						TextDrawShowForPlayer( playerid, g_SlotMachineBoxTD[ 0 ] );
						TextDrawShowForPlayer( playerid, g_SlotMachineBoxTD[ 1 ] );

						KillTimer( p_SafeHelperTimer[ playerid ] ), p_SafeHelperTimer[ playerid ] = -1; // Stop safe helper
						return ShowPlayerHelpDialog( playerid, 0, "~y~~h~~k~~PED_SPRINT~~w~ - Spin The Wheels~n~~y~~h~~k~~PED_JUMPING~~w~ - Toggle Autospin~n~~y~~h~~k~~VEHICLE_ENTER_EXIT~~w~ - Exit" );
					}
				}
			}
		}
	}

	// Hunter Kill Detection
	if ( iVehicle && IsValidVehicle( iVehicle ) )
	{
		new
			modelid = GetVehicleModel( iVehicle );

		if ( ( modelid == 425 && ( HOLDING( KEY_ACTION ) || PRESSED( KEY_FIRE ) ) ) || ( ( modelid == 520 || modelid == 447 || modelid == 476 ) && HOLDING( KEY_ACTION ) ) )
		{
			new
				closest_vehicle = GetClosestVehicle( playerid, iVehicle );

			if ( closest_vehicle != INVALID_VEHICLE_ID )
			{
				static
					Float: tX, Float: tY, Float: tZ;

				GetVehiclePos( iVehicle, X, Y, Z );
				GetVehiclePos( closest_vehicle, tX, tY, tZ );

				if ( VectorSize( tX - X, tY - Y, tZ - Z ) < 80.0 )
				{
					new
						Float: facingAngle,
						Float: angle = atan2( tY - Y, tX - X ) - 90.0
					;

					// addresses a small bug
					if ( angle < 0.0 )
						angle += 360.0;

					GetVehicleZAngle( iVehicle, facingAngle );

					// check if player is facing vehicle
					if ( floatabs( facingAngle - angle ) < 17.5 ) { // 15m radius

						g_VehicleLastAttacker[ closest_vehicle ] = playerid;
						g_VehicleLastAttacked[ closest_vehicle ] = g_iTime;

						// anticipate a kill in the vehicle too
						foreach (new i : Player) if ( GetPlayerVehicleID( i ) == closest_vehicle ) {
							if ( p_Class[ playerid ] != CLASS_POLICE && p_WantedLevel[ playerid ] < 6 && p_Class[ i ] == CLASS_POLICE ) GivePlayerWantedLevel( playerid, 6 - p_WantedLevel[ playerid ] );
							AC_UpdateDamageInformation( i, playerid, PRESSED( KEY_FIRE ) ? 51 : 38 );
						}

						// debug
						// printf("Player is shooting vehicle ... %d (%s)", iVehicle, PRESSED( KEY_FIRE ) ? ("rocket") : ("lmg"));
					}
				}
			}
		}
	}

	// Various keys
	if ( PRESSED( KEY_FIRE ) )
	{
		if ( IsPlayerAttachedObjectSlotUsed( playerid, 3 ) ) return RemovePlayerStolensFromHands( playerid ), SendServerMessage( playerid, "You dropped your stolen good and broke it." ), 1;
		if ( IsPlayerAttachedObjectSlotUsed( playerid, 4 ) ) return RemoveEquippedOre( playerid ), SendServerMessage( playerid, "You have disposed of your mined ore." ), 1;

		// business system
		if ( IsPlayerInAnyVehicle( playerid ) )
		{
			new
				vehicleid = GetPlayerVehicleID( playerid );

			if ( p_Class[ playerid ] == CLASS_CIVILIAN && g_isBusinessVehicle[ vehicleid ] != -1 && Iter_Contains( business, g_isBusinessVehicle[ vehicleid ] ) )
			{
				new
					businessid = g_isBusinessVehicle[ vehicleid ];

				if ( IsBusinessAerialVehicle( businessid, GetVehicleModel( vehicleid ) ) && IsBusinessAssociate( playerid, businessid ) )
				{
					new
						Float: playerZ, tempObject, moveSpeed;

					for ( new i = 0; i < MAX_DROPS; i ++ ) if ( IsPlayerInDynamicArea( playerid, g_businessData[ businessid ] [ E_EXPORT_CIRCLE ] [ i ] ) )
					{
						new
							city = g_businessData[ businessid ] [ E_EXPORT_CITY ], drop_off_index = g_businessData[ businessid ] [ E_EXPORT_INDEX ] [ i ];

						GetVehiclePos( vehicleid, playerZ, playerZ, playerZ );

						//if ( g_airBusinessExportData[ city ] [ drop_off_index ] [ 2 ] > finalZ + 20.0 )
						//	finalZ = g_airBusinessExportData[ city ] [ drop_off_index ] [ 2 ];

						if ( playerZ - g_airBusinessExportData[ city ] [ drop_off_index ] [ 2 ] < 20.0 )
							return SendError( playerid, "You need to be HIGHER to drop off the drugs (%0.1f metres).", 20.0 - ( playerZ - g_airBusinessExportData[ city ] [ drop_off_index ] [ 2 ] ) );

						if ( playerZ - g_airBusinessExportData[ city ] [ drop_off_index ] [ 2 ] > 100.0 )
							return SendError( playerid, "You need to be LOWER to drop off the drugs (%0.1f metres).", 100.0 - ( playerZ - g_airBusinessExportData[ city ] [ drop_off_index ] [ 2 ] ) );

						if ( g_businessData[ businessid ] [ E_EXPORTED ] [ i ] )
							return SendError( playerid, "This location has already been sold product recently." );

						// create temporary bag object
						tempObject = CreateDynamicObject( 18849, g_airBusinessExportData[ city ] [ drop_off_index ] [ 0 ], g_airBusinessExportData[ city ] [ drop_off_index ] [ 1 ], playerZ + 2.0, 0.0, 0.0, 0.0 );
						moveSpeed = MoveDynamicObject( tempObject, g_airBusinessExportData[ city ] [ drop_off_index ] [ 0 ], g_airBusinessExportData[ city ] [ drop_off_index ] [ 1 ], g_airBusinessExportData[ city ] [ drop_off_index ] [ 2 ] + 7.0, 8.0 );
						SetTimerEx( "DestroyDrugObject", moveSpeed + 4000, false, "d", tempObject );

						// count drugs exported
						SellBusinessProduct( playerid, businessid, i );
						break;
					}
				}
			}
		}

		if ( IsPlayerInRangeOfPoint( playerid, 2.0, 1476.0264, 1463.6255, 1011.8170 ) && IsPlayerInMethlab( playerid ) && p_Class[ playerid ] != CLASS_POLICE )
		{
			new
				vehicleid = GetPlayerMethLabVehicle( playerid ),
				objectid = GetGVarInt( "meth_yield", vehicleid ),
				Float: fAimDistance = 0.25
			;

			if ( IsValidDynamicObject( objectid ) && Streamer_GetIntData( STREAMER_TYPE_OBJECT, objectid, E_STREAMER_MODEL_ID ) == 1579 )
			{
				if ( GetDynamicObjectPos( objectid, X, Y, Z ) )
				{
					if ( IsPlayerAimingAt( playerid, X, Y, Z, fAimDistance ) )
						ApplyAnimation( playerid, "CARRY", "liftup105", 4.0, 1, 0, 0, 1, 0 ), ShowProgressBar( playerid, "Taking Meth", PROGRESS_GRAB_METH, 300, 0x87CEEBFF );
				}
			}
			else
			{
				if (	GetGVarType( "meth_chef", vehicleid ) != GLOBAL_VARTYPE_NONE && IsPlayerConnected( GetGVarInt( "meth_chef", vehicleid ) ) && GetGVarType( "meth_cooktimer", vehicleid ) == GLOBAL_VARTYPE_NONE && !p_ProgressStarted{ playerid } )
				{
					if ( IsPlayerAimingAt( playerid, 1477.07068, 1464.22253, 1011.95422, fAimDistance ) )
					{
						if ( !p_CausticSoda{ playerid } )
							return SendError( playerid, "You don't have any caustic soda." );

						SetPVarInt( playerid, "pouring_chemical", CHEMICAL_CS );
						ApplyAnimation( playerid, "CARRY", "putdwn105", 4.0, 1, 0, 0, 1, 0 );
						ShowProgressBar( playerid, "Pouring Caustic Soda", PROGRESS_CHEMICAL, 250, 0x3E7EFFFF );
					}
					else if ( IsPlayerAimingAt( playerid, 1476.64514, 1464.43201, 1012.21051, fAimDistance ) )
					{
						if ( !p_HydrogenChloride{ playerid } )
							return SendError( playerid, "You don't have any hydrogen chloride." );

						SetPVarInt( playerid, "pouring_chemical", CHEMICAL_HLC );
						ApplyAnimation( playerid, "CARRY", "putdwn105", 4.0, 1, 0, 0, 1, 0 );
						ShowProgressBar( playerid, "Pouring Hydrogen Chloride", PROGRESS_CHEMICAL, 250, 0xEE9911FF );
					}
					else if ( IsPlayerAimingAt( playerid, 1475.14404, 1464.33667, 1012.11896, fAimDistance ) )
					{
						if ( !p_MuriaticAcid{ playerid } )
							return SendError( playerid, "You don't have any muriatic acid." );

						SetPVarInt( playerid, "pouring_chemical", CHEMICAL_MU );
						ApplyAnimation( playerid, "CARRY", "putdwn105", 4.0, 1, 0, 0, 1, 0 );
						ShowProgressBar( playerid, "Pouring Muriatic Acid", PROGRESS_CHEMICAL, 250, 0xFF0000FF );
					}
				}
			}
   		}
   	}

   	else if ( PRESSED( KEY_YES ) )
   	{
	    if ( p_Class[ playerid ] == CLASS_CIVILIAN && JobEquals( playerid, JOB_TERRORIST ) && !IsPlayerJailed( playerid ) )
	   		ExplodePlayerC4s( playerid );
   	}

 	else if ( PRESSED( KEY_NO ) )
 	{
 		// Press N to deatach trailer from vehicle
 		if ( iVehicle && IsTrailerAttachedToVehicle( iVehicle ) )
 			DetachTrailerFromVehicle( iVehicle );
 	}

	else if ( PRESSED( KEY_CROUCH ) )
	{
		if ( p_ProgressStarted{ playerid } && !p_CancelProgress{ playerid } )
		{
			SendServerMessage( playerid, "You have canceled this operation." );
			p_CancelProgress{ playerid } = true;
			return 1;
		}
	}

	else if ( PRESSED( KEY_ACTION ) )
	{
		if ( IsPlayerInAnyVehicle( playerid ) && GetPlayerState( playerid ) == PLAYER_STATE_DRIVER && GetVehicleModel( iVehicle ) == 525 ) {
			new
				Float: pX, Float: pY, Float: pZ, Float: pAngle
			;

			GetVehiclePos( iVehicle, pX, pY, pZ );
			GetVehicleZAngle( iVehicle, pAngle );

			pX += 2.0 * floatsin( pAngle, degrees );
			pY += 2.0 * floatcos( pAngle, degrees );

			if ( !IsTrailerAttachedToVehicle( iVehicle ) ) {
				for( new i = 0; i < MAX_VEHICLES; i++ ) if ( IsValidVehicle( i ) && i != iVehicle ) {
					if ( GetVehicleDistanceFromPoint( i, pX, pY, pZ ) < 7.0 ) {
						AttachTrailerToVehicle( i, iVehicle );
						break;
					}
				}
			} else {
				DetachTrailerFromVehicle( iVehicle );
			}
		}
	}

	else if ( PRESSED( KEY_SECONDARY_ATTACK ) )
	{
		if ( GetPlayerState( playerid ) == PLAYER_STATE_ONFOOT && p_VendingUseTimer[ playerid ] == -1 && GetPlayerAnimationIndex( playerid ) != 1660 )
		{
			new
				bool: bFailed,
				Float: fHealth
			;

			GetPlayerHealth( playerid, fHealth );

			if ( GetPlayerCash( playerid ) <= 0 || fHealth >= 100.0 )
				bFailed = true;

			for( new i = 0; i < sizeof( g_VendingMachines ); i++ )
			{
				if ( IsPlayerInRangeOfPoint( playerid, 1.0, g_VendingMachines[ i ] [ E_FX ], g_VendingMachines[ i ] [ E_FY ], g_VendingMachines[ i ] [ E_Z ] ) )
				{
					if ( bFailed )
					{
						PlayerPlaySound( playerid, 1055, 0.0, 0.0, 0.0 );
						return 1;
					}

					new
						Float: health_given = 35.0;

					if ( GetPlayerPos( playerid, Z, Z, Z ) )
					{
						GivePlayerCash( playerid, -500 );

						p_VendingUseTimer[ playerid ] = SetTimerEx( "VendingMachineUsed", 2500, false, "if", playerid, health_given );

						SetPlayerFacingAngle( playerid, g_VendingMachines[ i ] [ E_RZ ] );
						SetPlayerPos( playerid, g_VendingMachines[ i ] [ E_FX ], g_VendingMachines[ i ] [ E_FY ], Z );

						ApplyAnimation( playerid, "VENDING", "VEND_USE", 4.1, 0, 0, 1, 0, 0, 1 );
						PlayerPlaySound( playerid, 42600, 0.0, 0.0, 0.0 );
					}
					else
					{
						PlayerPlaySound( playerid, 1055, 0.0, 0.0, 0.0 );
					}
					return 1;
				}
			}
		}

		if ( GetPVarInt( playerid, "viewing_houseints" ) == 1 )
		{
			new id = p_InHouse[ playerid ];
			SendServerMessage( playerid, "You've stopped viewing the house interior." );
			SetPlayerPos( playerid, g_houseData[ id ] [ E_TX ], g_houseData[ id ] [ E_TY ], g_houseData[ id ] [ E_TZ ] );
			SetPlayerInterior( playerid, g_houseData[ id ] [ E_INTERIOR_ID ] );
		    DeletePVar( playerid, "viewing_houseints" );
			TogglePlayerControllable( playerid, 1 );
			SetCameraBehindPlayer( playerid );
			return 1;
		}

		if ( GetPVarInt( playerid, "viewing_garageints" ) == 1 )
		{
			new
				iInterior = g_garageData[ p_InGarage[ playerid ] ] [ E_INTERIOR_ID ];

			SendServerMessage( playerid, "You've stopped viewing the garage interior." );
			SetPlayerPos( playerid, g_garageInteriorData[ iInterior ] [ E_X ], g_garageInteriorData[ iInterior ] [ E_Y ], g_garageInteriorData[ iInterior ] [ E_Z ] );
			SetPlayerInterior( playerid, g_garageInteriorData[ iInterior ] [ E_INTERIOR ] );
		    DeletePVar( playerid, "viewing_garageints" );
			TogglePlayerControllable( playerid, 1 );
			SetCameraBehindPlayer( playerid );
			return 1;
		}

		if ( g_iTime > p_CheckpointEnterTick[ playerid ] && !p_pausedToLoad{ playerid } && !IsPlayerTied( playerid ) )
		{
		  	p_CheckpointEnterTick[ playerid ] = g_iTime + 2;

			// Enter Methlab Interior
		   	if ( IsPlayerInMethlab( playerid ) )
	    	{
	    		new
	    			vehicleid = GetPlayerVirtualWorld( playerid ) - VW_METH
				;

	    		if ( IsValidVehicle( vehicleid ) && IsPlayerInRangeOfPoint( playerid, 1.5, 1475.8126, 1460.5450, 1011.8170 ) )
	    		{
			        GetVehiclePos( vehicleid, X, Y, Z );
			        GetVehicleZAngle( vehicleid, Angle );

			        X += ( 2.0 * floatsin( -( Angle - 45.0 ), degrees ) );
			        Y += ( 2.0 * floatcos( -( Angle - 45.0 ), degrees ) );

			        SetPlayerInterior( playerid, 0 );
			        SetPlayerVirtualWorld( playerid, 0 );
			        SetPlayerPos( playerid, X, Y, Z - 0.94 );
			        SetPlayerFacingAngle( playerid, Angle );

			        haltMethamphetamine( playerid, vehicleid );
			        DeletePVar( playerid, "inMethLab" );
			        pauseToLoad( playerid );
	    		}
	    	}

	    	// Enter Shamal Interior
	    	if ( IsPlayerInShamal( playerid ) )
	    	{
	    		if ( IsPlayerInRangeOfPoint( playerid, 10.0, 1322.6577, 1992.5508, 1200.2574 ) )
	    		{
	    			new
	    				vehicleid = GetPlayerVirtualWorld( playerid ) - VW_SHAMAL
	    			;

	    			if ( IsValidVehicle( vehicleid ) )
	    			{
		                GetVehiclePos( vehicleid, X, Y, Z );
		                GetVehicleZAngle( vehicleid, Angle );

		                X += ( 3.2 * floatsin( -( Angle - 45.0 ), degrees ) );
		                Y += ( 3.2 * floatcos( -( Angle - 45.0 ), degrees ) );

		                SetPlayerInterior( playerid, 0 );
		                SetPlayerVirtualWorld( playerid, 0 );
		                SetPlayerFacingAngle( playerid, Angle );
		                SetPlayerPos( playerid, X, Y, Z - 1 );

			        	pauseToLoad( playerid );
	    			}
	    		}
	    	}

	    	// Call Elevator Down
		    if ( !iVehicle )
		    {
				if ( IsPlayerInArea( playerid, -2005.859375, -1917.968750, 1339.843750, 1396.484375 ) && GetPlayerInterior( playerid ) == 0 )
				{
					GetDynamicObjectPos( g_apartmentElevator, X, Y, Z );
					if ( IsPlayerInRangeOfPoint( playerid, 2.0, X, Y, Z ) )
					{
						ClearAnimations( playerid ); // clear-fix

					    if ( IsDynamicObjectMoving( g_apartmentElevator ) )
					        return SendError( playerid, "You must wait for the elevator to stop operating to select a floor again." );

		                szLargeString[ 0 ] = '\0';
		                strins( szLargeString, "Ground Floor\n", 0 );
		                for( new i; i < sizeof( g_apartmentData ); i++ ) // First floor
		                {
		                    if ( g_apartmentData[ i ] [ E_CREATED ] )
		                    	format( szLargeString, sizeof( szLargeString ), "%s%s - %s\n", szLargeString, g_apartmentData[ i ] [ E_OWNER ], g_apartmentData[ i ] [ E_NAME ] );
							else
							    strcat( szLargeString, "$5,000,000 - Available For Purchase!\n" );
						}

						ShowPlayerDialog( playerid, DIALOG_APARTMENTS, DIALOG_STYLE_LIST, "{FFFFFF}Apartments", szLargeString, "Select", "Cancel" );
						return 1;
					}

					for( new floors; floors < MAX_AFLOORS; floors++ )
					{
						GetDynamicObjectPos( g_apartmentElevatorDoor1[ floors ], X, Y, Z );
	                	if ( IsPlayerInRangeOfPoint( playerid, 4.0, X, Y, Z ) )
	                	{
							ClearAnimations( playerid ); // clear-fix
						    if ( IsDynamicObjectMoving( g_apartmentElevator ) ) {
			       				SendError( playerid, "The elevator is operating, please wait." );
			       				break;
							}

		    				PlayerPlaySound( playerid, 1085, 0.0, 0.0, 0.0 );
							apartment_CallElevator( floors ); // First floor
							break;
	                	}
					}
					return 1;
				}

				// Enter Business
				foreach (new b : business)
				{
					if ( IsPlayerInDynamicCP( playerid, g_businessData[ b ] [ E_ENTER_CP ] ) )
					{
						if ( ! IsBusinessAssociate( playerid, b ) )
							return SendError( playerid, "You cannot access this business as you are not an associate of it." );

						if ( p_Class[ playerid ] != CLASS_CIVILIAN )
							return SendError( playerid, "You must be a civilian to access this facility." );

						new
							bType = g_businessData[ b ] [ E_INTERIOR_TYPE ];

			        	pauseToLoad( playerid );
						p_InBusiness[ playerid ] = b;
						SetPlayerPos( playerid, g_businessInteriorData[ bType ] [ E_X ], g_businessInteriorData[ bType ] [ E_Y ], g_businessInteriorData[ bType ] [ E_Z ] );
					  	SetPlayerVirtualWorld( playerid, g_businessData[ b ] [ E_WORLD ] );
						SetPlayerInterior( playerid, g_businessData[ b ] [ E_INTERIOR_TYPE ] + 20 );
						return 1;
					}
					else if ( IsPlayerInDynamicCP( playerid, g_businessData[ b ] [ E_EXIT_CP ] ) )
					{
						p_InBusiness[ playerid ] = -1;
						TogglePlayerControllable( playerid, 0 );
						SetTimerEx( "ope_Unfreeze", 1250, false, "d", playerid );
						SetPlayerPosEx( playerid, g_businessData[ b ] [ E_X ], g_businessData[ b ] [ E_Y ], g_businessData[ b ] [ E_Z ], 0 ), SetPlayerVirtualWorld( playerid, 0 );
					}
				}

				// Enter Houses
				for( new i = 0; i < MAX_HOUSES; i++ )
				{
				    if ( g_houseData[ i ] [ E_CREATED ] )
					{
					    if ( IsPlayerInDynamicCP( playerid, g_houseData[ i ] [ E_CHECKPOINT ] [ 0 ] ) )
					    {
							ClearAnimations( playerid ); // clear-fix

					        if ( IsHouseOnFire( i ) )
					        {
					            SendError( playerid, "This house is on fire, you cannot enter it!" );
					            return 1;
					        }
							if ( GetPlayerSpecialAction( playerid ) == SPECIAL_ACTION_CUFFED )
							{
								SendError( playerid, "You can't do anything as you are cuffed." );
								return 1;
							}

							if ( g_iTime > g_houseData[ i ] [ E_CRACKED_TS ] && g_houseData[ i ] [ E_CRACKED ] )
								g_houseData[ i ] [ E_CRACKED ] = false; // The Virus Is Disabled.

					        if ( !g_houseData[ i ] [ E_CRACKED ] && !strmatch( g_houseData[ i ] [ E_PASSWORD ], "N/A" ) && !strmatch( g_houseData[ i ] [ E_OWNER ], ReturnPlayerName( playerid ) ) )
							{
							    p_PasswordedHouse[ playerid ] = i;
							    ShowPlayerDialog( playerid, DIALOG_HOUSE_PW, DIALOG_STYLE_PASSWORD, "{FFFFFF}House Authentication", ""COL_GREEN"This house is password locked!\n"COL_WHITE"You may only enter this house if you enter the correct password.", "Enter", "Cancel" );
								return 1;
							}
							p_InHouse[ playerid ] = i;
							p_ApartmentEditing{ playerid } = -1;
							SetPlayerPos( playerid, g_houseData[ i ] [ E_TX ], g_houseData[ i ] [ E_TY ], g_houseData[ i ] [ E_TZ ] );
						  	SetPlayerVirtualWorld( playerid, g_houseData[ i ] [ E_WORLD ] );
							SetPlayerInterior( playerid, g_houseData[ i ] [ E_INTERIOR_ID ] );
							return 1;
						}
						else if ( IsPlayerInDynamicCP( playerid, g_houseData[ i ] [ E_CHECKPOINT ] [ 1 ] ) )
						{
							p_InHouse[ playerid ] = -1;
							p_ApartmentEditing{ playerid } = -1;
							CancelEdit( playerid );
							TogglePlayerControllable( playerid, 0 );
							SetTimerEx( "ope_Unfreeze", 1250, false, "d", playerid );
							SetPlayerPosEx( playerid, g_houseData[ i ] [ E_EX ], g_houseData[ i ] [ E_EY ], g_houseData[ i ] [ E_EZ ], 0 ), SetPlayerVirtualWorld( playerid, 0 );
							return 1;
						}
					}
				}
			}

		}
	}

	else if ( PRESSED( KEY_WALK ) )
	{
		if ( !iVehicle && g_iTime > p_CheckpointEnterTick[ playerid ] && !p_pausedToLoad{ playerid } )
	    {
	        p_CheckpointEnterTick[ playerid ] = g_iTime + 2;

	    	#if ENABLED_SECURE_TRUCK == true
				// Secured Truck!
	        	new Float: fX, Float: fY;
	    		GetVehiclePos( g_secureTruckVehicle, X, Y, Z );
	    		GetVehicleZAngle( g_secureTruckVehicle, Angle );
			    fX = X + ( SECURE_TRUCK_DISTANCE * floatsin( -Angle + 180, degrees ) );
			    fY = Y + ( SECURE_TRUCK_DISTANCE * floatcos( -Angle + 180, degrees ) );

				if ( IsPlayerInRangeOfPoint( playerid, SECURE_TRUCK_RADIUS, fX, fY, Z ) && p_Class[ playerid ] != CLASS_POLICE )
				{
					new
						every_thing_shot = allSecurityOffsetsShot( );

					if ( every_thing_shot && g_secureTruckData[ E_OPEN ] == true  ) {
						if ( IsSecurityDriverAFK( ) ) return 1;
						if ( g_secureTruckData[ E_BEING_ROBBED ] ) return SendError( playerid, "This truck is currently being robbed." );
						if ( g_secureTruckData[ E_ROBBED ] ) return SendError( playerid, "This truck has been robbed." );
						SetPlayerFacePoint( playerid, X, Y );
						//SetPlayerPos( playerid, fX, fY, Z );
						g_secureTruckData[ E_BEING_ROBBED ] = true;
						ApplyAnimation( playerid, "CARRY", "liftup105", 4.0, 1, 0, 0, 1, 0 );
						ShowProgressBar( playerid, "Robbing Truck", PROGRESS_ROBTRUCK, 350, COLOR_GOLD );
					}
					return 1;
				}
			#endif

	       	return handlePlayerRobbery( playerid, newkeys, oldkeys );
		}
	}

	else if ( PRESSED( KEY_SPRINT ) )
	{
		if ( p_InAnimation{ playerid } == true )
		{
			if ( IsPlayerTied( playerid ) || IsPlayerCuffed( playerid ) || IsPlayerTazed( playerid ) )
				return SendError( playerid, "You cannot stop your animation at the moment." );

			TextDrawHideForPlayer( playerid, g_AnimationTD );
		    p_InAnimation{ playerid } = false;
		    ClearAnimations( playerid );
		    SetPlayerSpecialAction( playerid, 0 );
		}
	}

	else if ( HOLDING( KEY_AIM ) )
	{
	  	if ( IsPlayerAttachedObjectSlotUsed( playerid, 1 ) && iWeapon == WEAPON_SNIPER )
	 		RemovePlayerAttachedObject( playerid, 1 );
	}

	// taze mechanism
	else if ( PRESSED( KEY_LOOK_BEHIND ) )
	{
		if ( p_Class[ playerid ] == CLASS_POLICE ) {
			new
				closestid = GetClosestPlayer( playerid );

			if ( closestid != INVALID_PLAYER_ID && p_Class[ closestid ] != CLASS_POLICE && ! ( GetDistanceBetweenPlayers( playerid, closestid ) > 10.0 || !IsPlayerConnected( closestid ) ) ) {
				if ( p_WantedLevel[ closestid ] > 5 )
					GameTextForPlayer( playerid, sprintf( "~n~~y~~h~/taze %d", closestid ), 2000, 4 ); // TazePlayer( playerid, closestid );
				else {
					TicketPlayer( closestid, playerid );
				}
			}
		}
	}
	return 1;
}

stock IsPlayingAnimation( playerid, library[ ], animation[ ] )
{
	if ( IsPlayerConnected( playerid ) )
	{
	    static
	    	animlib[ 32 ], animname[ 32 ];

	    GetAnimationName( GetPlayerAnimationIndex( playerid ), animlib, 32, animname, 32 );
	    return strmatch( library, animlib ) && strmatch( animation, animname );
	}
	return 0;
}

stock pauseToLoad( playerid )
{
	p_pausedToLoad{ playerid } = true;
	KillTimer( p_pausedToLoadTimer[ playerid ] );
	TogglePlayerControllable( playerid, 0 );
	TextDrawShowForPlayer(playerid, g_ObjectLoadTD);

	p_pausedToLoadTimer[ playerid ] = SetTimerEx( "unpause_Player", 3000, false, "d", playerid );
	return 1;
}

function unpause_Player( playerid )
{
	p_pausedToLoad{ playerid } = false;
	if ( !IsPlayerTied( playerid ) || !IsPlayerTazed( playerid ) ) TogglePlayerControllable( playerid, 1 );
	TextDrawHideForPlayer(playerid, g_ObjectLoadTD);
	return KillTimer( p_pausedToLoadTimer[ playerid ] ), 1;
}

#if defined AC_INCLUDED
	public OnPlayerCheatDetected( playerid, detection )
	{
		if ( detection == CHEAT_TYPE_REMOTE_JACK )
		{
	        if ( GetPlayerScore( playerid ) < 200 )
	        {
				SendGlobalMessage( -1, ""COL_PINK"[ANTI-CHEAT]{FFFFFF} %s(%d) has been kicked for abnormally jacking vehicles.", ReturnPlayerName( playerid ), playerid );
				SendClientMessageToAdmins( -1, ""COL_PINK"[ABNORMAL JACKING]"COL_GREY" %s(%d) - %d score - %d ping - %s IP", ReturnPlayerName( playerid ), playerid, GetPlayerScore( playerid ), GetPlayerPing( playerid ), ReturnPlayerIP( playerid ) );
	        	return Kick( playerid ), 1;
			}
			SendClientMessageToAdmins( -1, ""COL_PINK"[ABNORMAL JACKING]"COL_GREY" %s(%d) is a suspect of jacking vehicles abnormally.", ReturnPlayerName( playerid ), playerid );
			return 1;
		}
		else if ( detection == CHEAT_TYPE_AIRBRAKE )
		{
			//SendGlobalMessage( -1, ""COL_PINK"[ANTI-CHEAT]{FFFFFF} %s(%d) has been banned for airbraking.", ReturnPlayerName( playerid ), playerid );
			//AdvancedBan( playerid, "Server", "Airbrake", ReturnPlayerIP( playerid ) );
			SendClientMessageToAdmins( -1, ""COL_PINK"[ABNORMAL MOVEMENT]"COL_GREY" %s(%d) has been detected for airbrake.", ReturnPlayerName( playerid ), playerid );
			return 1;
		}
		else if ( detection == CHEAT_TYPE_FLYHACKS )
		{
			SendClientMessageToAdmins( -1, ""COL_PINK"[ABNORMAL MOVEMENT]"COL_GREY" %s(%d) has been detected for fly hacks.", ReturnPlayerName( playerid ), playerid );
			// SendGlobalMessage( -1, ""COL_PINK"[ANTI-CHEAT]{FFFFFF} %s(%d) has been banned for fly hacks.", ReturnPlayerName( playerid ), playerid );
			// AdvancedBan( playerid, "Server", "Fly Hacks", ReturnPlayerIP( playerid ) );
		}
		else SendClientMessageToAdmins( -1, ""COL_PINK"[ANTI-CHEAT]"COL_GREY" %s(%d) has been detected for %s.", ReturnPlayerName( playerid ), playerid, detectionToString( detection ) );
		return 1;
	}
#endif

public OnPlayerUpdate( playerid )
{
	if ( IsPlayerSecurityDriver( playerid ) )
		return 1;

	if ( !p_PlayerLogged{ playerid } )
		return 0;

	static
		Float: X, 	Float: Y, 	Float: Z,
		Float: vX, 	Float: vY, 	Float: vZ,

		iDrunkLevel, iKeys, iLeftRight, iState
	;

	if ( g_iTime < p_DesyncTime[ playerid ] )
		return 0; // Desync Feature

	GetPlayerKeys( playerid, iKeys, tmpVariable, iLeftRight );
	p_AFKTime[ playerid ] = GetTickCount( );

	// Disable Driveby
	if ( !g_Driveby )
	{
		iState = GetPlayerState( playerid );
		if ( iState == PLAYER_STATE_DRIVER ) {
			SetPlayerArmedWeapon( playerid, 0 );
		}
	}

	// Duffel Bug And Sniper Bug
	if ( !( iKeys & KEY_AIM ) && !IsPlayerAttachedObjectSlotUsed( playerid, 1 ) && p_MoneyBag{ playerid } ) {
		//SetPlayerAttachedObject( playerid, 1, 1550, 1, 0.131999, -0.140999, 0.053999, 11.299997, 65.599906, 173.900054, 0.652000, 0.573000, 0.594000 );
		SetPlayerAttachedObject( playerid, 1, 1210, 7, 0.302650, -0.002469, -0.193321, 296.124053, 270.396881, 8.941717, 1.000000, 1.000000, 1.000000 );
	}

	// Don't teleport with the car!
#if ENABLED_SECURE_TRUCK == true
	if ( GetPlayerSurfingVehicleID( playerid ) == g_secureTruckVehicle || IsPlayerInVehicle( playerid, g_secureTruckVehicle ) ) {
		if ( IsSecurityDriverAFK( ) ) {
			SetPlayerRandomSpawn( playerid );
			SendServerMessage( playerid, "You seemed to fly away with the security guard. You've been teleported to a spawn." );
		}
	}
#endif

    // FPS Counter
    iDrunkLevel = GetPlayerDrunkLevel( playerid );
    if ( iDrunkLevel < 100 ) SetPlayerDrunkLevel( playerid, 2000 );
   	else
   	{
        if ( p_FPS_DrunkLevel[ playerid ] != iDrunkLevel ) {
            new iFPS = p_FPS_DrunkLevel[ playerid ] - iDrunkLevel;

            if ( ( iFPS > 0 ) && ( iFPS < 200 ) )
                p_FPS[ playerid ] = iFPS;

            p_FPS_DrunkLevel[ playerid ] = iDrunkLevel;
        }
    }

    formatFPSCounter( playerid );

    // Fugga.cs
	GetPlayerVelocity( playerid, vX, vY, vZ );
	if ( ( ( vX < -10.0 || vX > 10.0 ) && ( vZ > 1.0 || vZ < -1.0 ) ) || ( ( vX < -3.0 || vX > 3.0 ) && ( vY < -3.0 || vY > 3.0 ) && ( vZ > 3.0 || vZ < -3.0 ) ) )
	{
    	//SendGlobalMessage( -1, ""COL_PINK"[ANTI-CHEAT]{FFFFFF} %s(%d) has been banned for player swinging.", ReturnPlayerName( playerid ), playerid );
		//BanEx( playerid, "Player Swing" );
		p_DesyncTime[ playerid ] = g_iTime + 3;
		return 0;
	}

    // PlayerBugger.cs
	GetPlayerPos( playerid, X, Y, Z );
	if ( X >= 99999.0 || Y >= 99999.0 || Z >= 99999.0 || X <= -99999.0 || Y <= -99999.0 || Z <= -99999.0 ) {
	  	SendClientMessage( playerid, 0xa9c4e4ff, "Warning: Excessive X, Y, Z has been breached thus last location set." );
		SetPlayerPos( playerid, p_PlayerBuggerX[ playerid ], p_PlayerBuggerY[ playerid ], p_PlayerBuggerZ[ playerid ] );
	}
	else
	{
	    p_PlayerBuggerX[ playerid ] = X;
	    p_PlayerBuggerY[ playerid ] = Y;
	    p_PlayerBuggerZ[ playerid ] = Z;
	}

	if ( IsPlayerInAnyVehicle( playerid ) && GetPlayerState( playerid ) == PLAYER_STATE_DRIVER )
	{
		GetPlayerPos( playerid, X, Y, Z );
  		GetVehicleVelocity( GetPlayerVehicleID( playerid ), vX, vY, vZ );
		if ( ( vX > 3.0 || vY > 3.0 || vZ > 3.0 || vX < -3.0 || vY < -3.0 || vZ < -3.0 ) && ( vX != X && vY != Y && vZ != Z ) )
		{
        	//SendGlobalMessage( -1, ""COL_PINK"[ANTI-CHEAT]{FFFFFF} %s(%d) has been banned for car swinging.", ReturnPlayerName( playerid ), playerid );
			//BanEx( playerid, "Car Swing" );
			p_DesyncTime[ playerid ] = g_iTime + 3;
			return 0;
		}
	}
	return fix_NightThermalVisionHack( playerid );
}

public OnPlayerEditAttachedObject( playerid, response, index, modelid, boneid, Float:fOffsetX, Float:fOffsetY, Float:fOffsetZ, Float:fRotX, Float:fRotY, Float:fRotZ, Float:fScaleX, Float:fScaleY, Float:fScaleZ )
{
	new
		slot = p_ToySlotSelected{ playerid };

	if ( response )
	{
		new bool: modded;
	    if ( fScaleX < 0.25 || fScaleX > 2.5 ) fScaleX = 1.0, modded = true;
	    if ( fScaleY < 0.25 || fScaleY > 2.5 ) fScaleY = 1.0, modded = true;
	    if ( fScaleZ < 0.25 || fScaleZ > 2.5 ) fScaleZ = 1.0, modded = true;
	    if ( modded ) SendServerMessage( playerid, "Some scaling parts were either too small, or too big. They have been scaled to the default size." );
	   	p_AttachedObjectsData[ playerid ] [ slot ] [ E_BONE ] = boneid;
		p_AttachedObjectsData[ playerid ] [ slot ] [ E_OX ] = fOffsetX;
		p_AttachedObjectsData[ playerid ] [ slot ] [ E_OY ] = fOffsetY;
		p_AttachedObjectsData[ playerid ] [ slot ] [ E_OZ ] = fOffsetZ;
		p_AttachedObjectsData[ playerid ] [ slot ] [ E_RX ] = fRotX;
		p_AttachedObjectsData[ playerid ] [ slot ] [ E_RY ] = fRotY;
		p_AttachedObjectsData[ playerid ] [ slot ] [ E_RZ ] = fRotZ;
		p_AttachedObjectsData[ playerid ] [ slot ] [ E_SX ] = fScaleX;
		p_AttachedObjectsData[ playerid ] [ slot ] [ E_SY ] = fScaleY;
		p_AttachedObjectsData[ playerid ] [ slot ] [ E_SZ ] = fScaleZ;
		p_AttachedObjectsData[ playerid ] [ slot ] [ E_MODELID ] = modelid;
		RemovePlayerAttachedObject( playerid, index );
		SetPlayerAttachedObject( playerid, index, modelid, boneid, fOffsetX, fOffsetY, fOffsetZ, fRotX, fRotY, fRotZ, fScaleX, fScaleY, fScaleZ );

		format( szBigString, sizeof( szBigString ), "UPDATE `TOYS` SET `OX`=%f,`OY`=%f,`OZ`=%f,`RX`=%f,`RY`=%f,`RZ`=%f,`SX`=%f,`SY`=%f,`SZ`=%f WHERE `ID`=%d", fOffsetX, fOffsetY, fOffsetZ, fRotX, fRotY, fRotZ, fScaleX, fScaleY, fScaleZ, p_AttachedObjectsData[ playerid ] [ slot ] [ E_SQL_ID ] );
		mysql_single_query( szBigString );

		//printf("SetPlayerAttachedObject( playerid, %d, %d, %d, %f, %f, %f, %f, %f, %f, %f, %f, %f );",index, modelid, boneid, fOffsetX, fOffsetY, fOffsetZ, fRotX, fRotY, fRotZ, fScaleX, fScaleY, fScaleZ );
	}
	else
	{
		// User Cancelled
		RemovePlayerAttachedObject( playerid, index );
		SetPlayerAttachedObject( playerid, index, p_AttachedObjectsData[ playerid ] [ slot ] [ E_MODELID ], p_AttachedObjectsData[ playerid ] [ slot ] [ E_BONE ],
			p_AttachedObjectsData[ playerid ] [ slot ] [ E_OX ], p_AttachedObjectsData[ playerid ] [ slot ] [ E_OY ], p_AttachedObjectsData[ playerid ] [ slot ] [ E_OZ ],
			p_AttachedObjectsData[ playerid ] [ slot ] [ E_RX ], p_AttachedObjectsData[ playerid ] [ slot ] [ E_RY ], p_AttachedObjectsData[ playerid ] [ slot ] [ E_RZ ],
			p_AttachedObjectsData[ playerid ] [ slot ] [ E_SX ], p_AttachedObjectsData[ playerid ] [ slot ] [ E_SY ], p_AttachedObjectsData[ playerid ] [ slot ] [ E_SZ ]
		);
	}
	showToyEditMenu( playerid, slot );
	return 1;
}

public OnPlayerStreamIn(playerid, forplayerid)
{
	return 1;
}

public OnPlayerStreamOut(playerid, forplayerid)
{
	return 1;
}

public AC_OnFileExecuted( playerid, module[ ], md5[ ] ) {
	/*format( szNormalString, sizeof( szNormalString ), "[ANTI-CHEAT]{FFFFFF} %s(%d) executed a file:"COL_GREY"%s", ReturnPlayerName( playerid ), playerid, module );
	SendClientMessageToAdmins( COLOR_PINK, szNormalString );*/
	return 1;
}

public AC_OnImgFileModifed( playerid, filename[ ], md5[ ] ) {
	format( szNormalString, sizeof( szNormalString ), "[ANTI-CHEAT]{FFFFFF} %s(%d) modified an img file: "COL_GREY"%s", ReturnPlayerName( playerid ), playerid, filename );
	SendClientMessageToAdmins( COLOR_PINK, szNormalString );
	return 1;
}

public AC_OnFileCalculated( playerid, filename[ ], md5[ ], bool: isCheat )
{
	if ( isCheat ) {
		format( szNormalString, sizeof( szNormalString ), "[ANTI-CHEAT]{FFFFFF} %s(%d) executed a blacklisted file: "COL_GREY"%s", ReturnPlayerName( playerid ), playerid, filename );
		SendClientMessageToAdmins( COLOR_PINK, szNormalString );
	}
	return 1;
}

thread OnPlayerLogin( playerid, password[ ] )
{
	new
	    rows, fields
	;
    cache_get_data( rows, fields );

    if ( rows )
    {
    	new
    		szHashed[ 129 ],
    		szPassword[ 129 ],
    		szSalt[ 25 ],
    		bool: isSalted = false
    	;

		cache_get_field_content( 0,  "SALT", szSalt );
		cache_get_field_content( 0,  "PASSWORD", szPassword );

		if ( !strcmp( szSalt, "NULL", false ) ) // User doesn't have a salt
		{
			WP_Hash( szHashed, sizeof( szHashed ), password );
			isSalted = false;
		}
		else
		{
			pencrypt( szHashed, sizeof( szHashed ), password, szSalt );
			isSalted = true;
		}

		if ( !strcmp( szHashed, szPassword, false ) )
    	{
    		if ( !isSalted ) // Converting from insecure to secure
    		{
             	randomString( szSalt, 24 );
             	pencrypt( szHashed, sizeof( szHashed ), password, szSalt );

    			format( szBigString, sizeof( szBigString ), "UPDATE USERS SET `PASSWORD`='%s', `SALT`='%s' WHERE `NAME`='%s'", szHashed, mysql_escape( szSalt ), ReturnPlayerName( playerid ) );
    			mysql_single_query( szBigString );
    		}

    		p_AccountID[ playerid ] = cache_get_field_content_int( 0, "ID", dbHandle );

			new iScore 		= cache_get_field_content_int( 0, "SCORE", dbHandle );
			new iCash 		= cache_get_field_content_int( 0, "CASH", dbHandle );
			new iFightStyle = cache_get_field_content_int( 0, "FIGHTSTYLE", dbHandle );
			new iWanted 	= cache_get_field_content_int( 0, "WANTEDLVL", dbHandle );
			new iGang		= cache_get_field_content_int( 0, "GANG_ID", dbHandle );

			printf("[%s] Reading gang id %d", ReturnPlayerName( playerid ), iGang );

			SetPlayerCash			( playerid, iCash );
			SetPlayerScore			( playerid, iScore );
			SetPlayerFightingStyle	( playerid, iFightStyle );
			GivePlayerWantedLevel	( playerid, iWanted, true );

			p_AdminLevel[ playerid ] 		= cache_get_field_content_int( 0, "ADMINLEVEL", dbHandle );
			p_BankMoney[ playerid ] 		= cache_get_field_content_int( 0, "BANKMONEY", dbHandle );
			p_Kills[ playerid ] 			= cache_get_field_content_int( 0, "KILLS", dbHandle );
			p_Deaths[ playerid ] 			= cache_get_field_content_int( 0, "DEATHS", dbHandle );
			p_VIPLevel[ playerid ] 			= cache_get_field_content_int( 0, "VIP_PACKAGE", dbHandle );
			p_XP[ playerid ] 				= cache_get_field_content_int( 0, "XP", dbHandle );
			p_VIPExpiretime[ playerid ] 	= cache_get_field_content_int( 0, "VIP_EXPIRE", dbHandle );
			p_LastSkin[ playerid ] 			= cache_get_field_content_int( 0, "LAST_SKIN", dbHandle );
			p_Burglaries[ playerid ] 		= cache_get_field_content_int( 0, "BURGLARIES", dbHandle );
			p_CopBanned{ playerid } 		= cache_get_field_content_int( 0, "COP_BAN", dbHandle );
			p_ArmyBanned{ playerid } 		= cache_get_field_content_int( 0, "ARMY_BAN", dbHandle );
			p_Uptime[ playerid ] 			= cache_get_field_content_int( 0, "UPTIME", dbHandle );
			p_Arrests[ playerid ] 			= cache_get_field_content_int( 0, "ARRESTS", dbHandle );
			p_VIPWep1{ playerid } 			= cache_get_field_content_int( 0, "VIPWEP1", dbHandle );
			p_VIPWep2{ playerid } 			= cache_get_field_content_int( 0, "VIPWEP2", dbHandle );
			p_VIPWep3{ playerid } 			= cache_get_field_content_int( 0, "VIPWEP3", dbHandle );
			p_MutedTime[ playerid ] 		= cache_get_field_content_int( 0, "MUTE_TIME", dbHandle );
			p_Robberies[ playerid ] 		= cache_get_field_content_int( 0, "ROBBERIES", dbHandle );
			p_Fires[ playerid ] 			= cache_get_field_content_int( 0, "FIRES", dbHandle );
			p_PingImmunity{ playerid } 		= cache_get_field_content_int( 0, "PING_IMMUNE", dbHandle );
			p_HitsComplete[ playerid ] 		= cache_get_field_content_int( 0, "CONTRACTS", dbHandle );
			p_TruckedCargo[ playerid ] 		= cache_get_field_content_int( 0, "TRUCKED", dbHandle );
			//p_CopTutorial{ playerid } 		= cache_get_field_content_int( 0, "COP_TUTORIAL", dbHandle );
			p_Job{ playerid } 				= cache_get_field_content_int( 0, "JOB", dbHandle );
			p_VIPJob{ playerid } 			= cache_get_field_content_int( 0, "VIP_JOB", dbHandle );
			p_AdminJailed{ playerid } 		= cache_get_field_content_int( 0, "JAIL_ADMIN", dbHandle );
			p_JailTime[ playerid ] 			= cache_get_field_content_int( 0, "JAIL_TIME", dbHandle );
			p_Ropes[ playerid ] 			= cache_get_field_content_int( 0, "ROPES", dbHandle );
			p_C4Amount[ playerid ] 			= cache_get_field_content_int( 0, "C4", dbHandle );
			p_MetalMelter[ playerid ] 		= cache_get_field_content_int( 0, "MELTERS", dbHandle );
			p_Scissors[ playerid ] 			= cache_get_field_content_int( 0, "SCISSORS", dbHandle );
			p_AntiEMP[ playerid ] 			= cache_get_field_content_int( 0, "FOILS", dbHandle );
			p_BobbyPins[ playerid ] 		= cache_get_field_content_int( 0, "PINS", dbHandle );
			p_ContractedAmount[ playerid ] 	= cache_get_field_content_int( 0, "BOUNTY", dbHandle );
			p_WeedGrams[ playerid ] 		= cache_get_field_content_int( 0, "WEED", dbHandle );
			p_SpawningCity{ playerid } 		= cache_get_field_content_int( 0, "CITY", dbHandle );
			p_Methamphetamine{ playerid }	= cache_get_field_content_int( 0, "METH", dbHandle );
			p_CausticSoda{ playerid } 		= cache_get_field_content_int( 0, "SODA", dbHandle );
			p_MuriaticAcid{ playerid } 		= cache_get_field_content_int( 0, "ACID", dbHandle );
			p_HydrogenChloride{ playerid } 	= cache_get_field_content_int( 0, "GAS", dbHandle );
			p_LeftCuffed{ playerid } 		= !!cache_get_field_content_int( 0, "IS_CUFFED", dbHandle );
			p_JailsBlown[ playerid ] 		= cache_get_field_content_int( 0, "BLEW_JAILS", dbHandle );
			p_BankBlown[ playerid ] 		= cache_get_field_content_int( 0, "BLEW_VAULT", dbHandle );
			p_CarsJacked[ playerid ] 		= cache_get_field_content_int( 0, "VEHICLES_JACKED", dbHandle );
			p_MethYielded[ playerid ] 		= cache_get_field_content_int( 0, "METH_YIELDED", dbHandle );
			p_drillStrength[ playerid ] 	= cache_get_field_content_int( 0, "DRILL", dbHandle );
			p_IrresistibleCoins[ playerid ] = cache_get_field_content_float( 0, "COINS", dbHandle );
			p_HouseSpawnLocation[ playerid ]= cache_get_field_content_int( 0, "HOUSE_ID", dbHandle );
			p_IrresistiblePoints[ playerid ]= cache_get_field_content_float( 0, "RANK", dbHandle );
			p_ExtraAssetSlots{ playerid }	= cache_get_field_content_int( 0, "EXTRA_SLOTS", dbHandle );
			p_forcedAnticheat[ playerid ] 	= cache_get_field_content_int( 0, "FORCE_AC", dbHandle );
			p_BusinessSpawnLocation[ playerid ] = cache_get_field_content_int( 0, "BUSINESS_ID", dbHandle );

			if ( p_forcedAnticheat[ playerid ] > 0 && ! IsPlayerUsingSampAC( playerid ) ) {
				SendError( playerid, "You must install an anticheat to play the server. Visit "COL_GREY"www.samp-ac.com"COL_WHITE" to install the anticheat." );
				KickPlayerTimed( playerid );
				return 1;
			}

			// house & biz validation
			if ( p_HouseSpawnLocation[ playerid ] != -1 && !strmatch( g_houseData[ p_HouseSpawnLocation[ playerid ] ] [ E_OWNER ], ReturnPlayerName( playerid ) ) )
				p_HouseSpawnLocation[ playerid ] = -1;

			if ( p_BusinessSpawnLocation[ playerid ] != -1 && ! IsBusinessAssociate( playerid, p_BusinessSpawnLocation[ playerid ] ) )
				p_BusinessSpawnLocation[ playerid ] = -1;

			// Load some other variables too
		   	p_OwnedHouses 		[ playerid ] = GetPlayerOwnedHouses( playerid );
		   	p_OwnedBusinesses 	[ playerid ] = GetPlayerOwnedBusinesses( playerid );

		    p_PlayerLogged	{ playerid } = true;
			p_JobSet 		{ playerid } = true;
			p_CitySet 		{ playerid } = true;
			p_Muted 		{ playerid } = p_MutedTime[ playerid ] > 0 ? true : false; // Save muting :X

			// Check if vip expired
			CheckPlayerVipExpiry( playerid );

			// Load some more linking tables
			format( szNormalString, sizeof( szNormalString ), "SELECT * FROM `EMAILS` WHERE `USER_ID`=%d", p_AccountID[ playerid ] );
			mysql_function_query( dbHandle, szNormalString, true, "OnEmailLoad", "d", playerid );

			format( szNormalString, sizeof( szNormalString ), "SELECT * FROM `VEHICLES` WHERE `OWNER`=%d", p_AccountID[ playerid ] );
			mysql_function_query( dbHandle, szNormalString, true, "OnVehicleLoad", "d", playerid );

			format( szNormalString, sizeof( szNormalString ), "SELECT * FROM `TOY_UNLOCKS` WHERE `USER_ID`=%d", p_AccountID[ playerid ] );
			mysql_function_query( dbHandle, szNormalString, true, "OnToyLoad", "d", playerid );

			format( szNormalString, sizeof( szNormalString ), "SELECT * FROM `TOYS` WHERE `USER_ID`=%d", p_AccountID[ playerid ] );
			mysql_function_query( dbHandle, szNormalString, true, "OnToyOffsetLoad", "d", playerid );

			format( szNormalString, sizeof( szNormalString ), "SELECT * FROM `SETTINGS` WHERE `USER_ID`=%d", p_AccountID[ playerid ] );
			mysql_function_query( dbHandle, szNormalString, true, "OnSettingsLoad", "d", playerid );

			format( szNormalString, sizeof( szNormalString ), "SELECT * FROM `STREAKS` WHERE `USER_ID`=%d", p_AccountID[ playerid ] );
			mysql_function_query( dbHandle, szNormalString, true, "OnStreaksLoad", "d", playerid );

			format( szNormalString, sizeof( szNormalString ), "SELECT * FROM `WEAPON_STATS` WHERE `USER_ID`=%d", p_AccountID[ playerid ] );
			mysql_function_query( dbHandle, szNormalString, true, "OnWeaponStatsLoad", "d", playerid );

			if ( p_VIPLevel[ playerid ] ) {
				format( szBigString, 192, "SELECT `ID` FROM `NOTES` WHERE (`NOTE` LIKE '{FFDC2E}%%' OR `NOTE` LIKE '{CD7F32}%%') AND `USER_ID`=%d AND `DELETED` IS NULL", p_AccountID[ playerid ] );
				mysql_function_query( dbHandle, szBigString, true, "checkforvipnotes", "d", playerid );
			}

			// Player is online
			mysql_single_query( sprintf( "UPDATE `USERS` SET `ONLINE`=1 WHERE `ID`=%d", p_AccountID[ playerid ] ) );

			// Log in player
		  	SendServerMessage( playerid, "You have " COL_GREEN "successfully" COL_WHITE " logged in!" );

		  	// UNDERCOVER USERS
			if ( IsPlayerUnderCover( playerid ) )
		  	{
		  		// all undercover are american ips
				format( p_PlayerIP[ playerid ], 16, "104.131.%d.%d", random( 255 ), random( 255 ) );
		  	}

		  	// Reset gang id just incase
		  	p_GangID[ playerid ] = INVALID_GANG_ID;

		  	// Gang create
		  	new
		  		bool: foundGang = false;

			foreach(new g : gangs) if( iGang != INVALID_GANG_ID && iGang == g_gangData[ g ] [ E_SQL_ID ] ) {
				p_GangID[ playerid ] = g, foundGang = true;
				break;
			}

			printf("[%s] Found gang ? %d , id %d, gangid %d", ReturnPlayerName( playerid ), foundGang ? 1 : 0, p_GangID[ playerid ], iGang );

			if ( ! foundGang ) {
				SendServerMessage( playerid, "[DEBUG] Your gang is not preloaded, we will add it in the server now (id %d)", iGang );
				format( szNormalString, sizeof( szNormalString ), "SELECT * FROM `GANGS` WHERE `ID`=%d LIMIT 0,1", iGang );
				mysql_function_query( dbHandle, szNormalString, true, "OnGangLoad", "d", playerid );
			}

		  	// Send gang join message
		  	if ( p_GangID[ playerid ] != INVALID_GANG_ID && strlen( g_gangData[ p_GangID[ playerid ] ] [ E_JOIN_MSG ] ) ) {
				SendServerMessage( playerid, "[DEBUG] The server has found your old gang, %s (id %d)", g_gangData[ p_GangID[ playerid ] ] [ E_NAME ], iGang );
		  		SendClientMessageFormatted( playerid, g_gangData[ p_GangID[ playerid ] ] [ E_COLOR ], "[GANG]"COL_GREY" %s", g_gangData[ p_GangID[ playerid ] ] [ E_JOIN_MSG ] );
		  	}
		}
	    else
	    {
	        p_IncorrectLogins{ playerid } ++;
	        format( szBigString, sizeof( szBigString ), "{FFFFFF}Welcome, this account ("COL_GREEN"%s"COL_WHITE") is registered.\nPlease enter the password to login.\n\n"COL_RED"Wrong password! Try again! [%d/3]\n\n"COL_GREY"If you are not the owner of this account, leave and rejoin with a different nickname.", ReturnPlayerName( playerid ), p_IncorrectLogins{ playerid } );
			ShowPlayerDialog(playerid, DIALOG_LOGIN, DIALOG_STYLE_PASSWORD, "{FFFFFF}Account - Login", szBigString, "Login", "Leave");
			if ( p_IncorrectLogins{ playerid } >= 3 ) {
			    p_IncorrectLogins{ playerid } = 0;
				SendServerMessage( playerid, "You have been kicked for too many incorrect login attempts." );
				KickPlayerTimed( playerid );
			}
	    }
    }
    else
    {
    	Kick( playerid );
    	printf( "User::Error - User Not Created Attempting Login" );
    }
	return 1;
}

thread OnPlayerRegister( playerid )
{
	p_AccountID[ playerid ]		= cache_insert_id( );
	return 1;
}

stock pencrypt( szLeFinale[ ], iSize = sizeof( szLeFinale ), szPassword[ ], szSalt[ 25 ], iPepper = 24713018, szCost[ 3 ] = "2y" )
{
	static
    	szHash[ 256 ];

    WP_Hash( szHash, sizeof( szHash ), szPassword );

    format( szHash, sizeof( szHash ), "%s%d%s$%s$", szSalt, iPepper, szHash, szCost );
    WP_Hash( szLeFinale, iSize, szHash );
}

stock randomString(strDest[], strLen = 10)
{
    while(strLen--)
        strDest[strLen] = random(2) ? (random(26) + (random(2) ? 'a' : 'A')) : (random(10) + '0');
}

public OnDialogResponse(playerid, dialogid, response, listitem, inputtext[])
{
    new
        Query[ 256 ],
        szBigQuery[ 764 ]
    ;

    if ( response == 1 ) PlayerPlaySound( playerid, 1083, 0.0, 0.0, 0.0 ); // Confirmation sound
    else 				PlayerPlaySound( playerid, 1084, 0.0, 0.0, 0.0 ); // Cancellation sound

	if ( g_DialogLogging ) printf( "[DIALOG_LOG] %s(%d) - %d, %d, %d, %s", ReturnPlayerName( playerid ), playerid, dialogid, response, listitem, inputtext );

	if ( strlen( inputtext ) ) strreplacechar( inputtext, '%', '#' ); // The percentage injection crasher (critical)

    if ( dialogid == DIALOG_LOGIN )
    {
        if ( response )
        {
        	if ( p_PlayerLogged{ playerid } )
        	{
        		AdvancedBan( playerid, "Server", "Exploiting", ReturnPlayerIP( playerid ) );
        		return SendError( playerid, "You are already logged in!" );
        	}

			format( szBigQuery, sizeof( szBigQuery ), "SELECT * FROM `USERS` WHERE `NAME` = '%s' LIMIT 0,1", mysql_escape( ReturnPlayerName( playerid ) ) );
       		mysql_function_query( dbHandle, szBigQuery, true, "OnPlayerLogin", "ds", playerid, inputtext );
        }
        else return ShowPlayerDialog( playerid, DIALOG_LOGIN_QUIT, DIALOG_STYLE_MSGBOX, "{FFFFFF}Account - Authentication", "{FFFFFF}Are you sure you want to leave the server?", "Yes", "No" );
    }
    if ( dialogid == DIALOG_LOGIN_QUIT ) {
    	if ( response ) {
    		return Kick( playerid );
    	} else {
	        format( szBigString, sizeof( szBigString ), "{FFFFFF}Welcome, this account ("COL_GREEN"%s"COL_WHITE") is registered.\nPlease enter the password to login.\n\n"COL_GREY"If you are not the owner of this account, leave and rejoin with a different nickname.", ReturnPlayerName( playerid ) );
	        return ShowPlayerDialog(playerid, DIALOG_LOGIN, DIALOG_STYLE_PASSWORD, "{FFFFFF}Account - Authentication", szBigString, "Login", "Leave");
    	}
    }
    if ( dialogid == DIALOG_REGISTER )
    {
        if ( response )
        {
        	if ( p_PlayerLogged{ playerid } )
        		return SendError( playerid, "You are already logged in!" );

            if ( strlen( inputtext ) > 24 || strlen( inputtext ) < 3 )
            {
            	format( szBigQuery, 300, "{FFFFFF}Welcome, this account ("COL_RED"%s"COL_WHITE") is not registered.\nPlease enter your desired password for this account.\n\n"COL_RED"Your password length must vary from 3 to 24 characters.\n\n"COL_GREY"Once you are registered, do not share your password with anyone besides yourself!", ReturnPlayerName( playerid ) );
				ShowPlayerDialog(playerid, DIALOG_REGISTER, DIALOG_STYLE_INPUT, "{FFFFFF}Account - Register", szBigQuery, "Register", "Leave");
            }
            else
            {
                static
                	szHashed[ 129 ],
                	szSalt[ 25 ],
                	szIP[ 16 ]
                ;

             	randomString( szSalt, 24 );
             	pencrypt( szHashed, sizeof( szHashed ), inputtext, szSalt );
				GetPlayerIp( playerid, szIP, sizeof( szIP ) );
				format( szBigQuery, sizeof( szBigQuery ), "INSERT INTO `USERS` (`NAME`,`PASSWORD`,`SALT`,`IP`,`SCORE`,`CASH`,`ADMINLEVEL`,`BANKMONEY`,`OWNEDHOUSES`,`KILLS`,`DEATHS`,`VIP_PACKAGE`,`XP`,`OWNEDCARS`,`LASTLOGGED`,`VIP_EXPIRE`,`LAST_SKIN`,`COP_BAN`,`UPTIME`,`ARRESTS`,`FIGHTSTYLE`,`VIPWEP1`,`VIPWEP2`,`VIPWEP3`,`MUTE_TIME`,`WANTEDLVL`,`ROBBERIES`,`PING_IMMUNE`,`FIRES`,`CONTRACTS`,`COP_TUTORIAL`,`JOB`,`LAST_IP`,`ONLINE`) " );
				format( szBigQuery, sizeof( szBigQuery ), "%s VALUES('%s','%s','%s','%s',0,0,0,0,0,1,1,0,0,0,%d,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,'%s',1)", szBigQuery, mysql_escape( ReturnPlayerName( playerid ) ), szHashed, mysql_escape( szSalt ), mysql_escape( szIP ), g_iTime, mysql_escape( szIP ) );
       			mysql_function_query( dbHandle, szBigQuery, true, "OnPlayerRegister", "d", playerid );
				p_JobSet{ playerid } = false;
				p_CitySet{ playerid } = false;
				p_Uptime[ playerid ] = 0;
				ShowAchievement( playerid, "Registering to SF-CnR!", 1 );
                p_PlayerLogged{ playerid } = true;
                SetPlayerCash( playerid, 0 );
                SetPlayerScore( playerid, 0 );
				p_Kills[ playerid ] = 1;
				p_Deaths[ playerid ] = 1;
				p_XP[ playerid ] = 0;
				//p_CopTutorial{ playerid } = 0;
				p_drillStrength[ playerid ] = MAX_DRILL_STRENGTH;
				p_OwnedHouses[ playerid ] = 0;
				p_OwnedBusinesses[ playerid ] = 0;
				p_OwnedVehicles[ playerid ] = 0;
				p_IrresistibleCoins[ playerid ] = 0;
				p_Burglaries[ playerid ] = 0;
				ShowPlayerDialog( playerid, DIALOG_JOB, DIALOG_STYLE_LIST, "{FFFFFF}Job Selection", "Rapist\nKidnapper\nTerrorist\nHitman\nProstitute\nWeapon Dealer\nDrug Dealer\nDirty Mechanic\nBurglar", "Select", "" );
                SendServerMessage( playerid, "You have "COL_GREEN"successfully{FFFFFF} registered! You have been automatically logged in!" );
            }
        }
        else return ShowPlayerDialog( playerid, DIALOG_REGISTER_QUIT, DIALOG_STYLE_MSGBOX, "{FFFFFF}Account - Authentication", "{FFFFFF}Are you sure you want to leave the server?", "Yes", "No" );
    }
    if ( dialogid == DIALOG_REGISTER_QUIT ) {
    	if ( response ) {
    		return Kick( playerid );
    	} else {
	        format( szBigString, sizeof( szBigString ), "{FFFFFF}Welcome, this account ("COL_RED"%s"COL_WHITE") is not registered.\nPlease enter your desired password for this account.\n\n"COL_GREY"Once you are registered, do not share your password with anyone besides yourself!", ReturnPlayerName( playerid ) );
	        return ShowPlayerDialog(playerid, DIALOG_REGISTER, DIALOG_STYLE_INPUT, "{FFFFFF}Account - Register", szBigString, "Register", "Leave");
    	}
    }
    if ( dialogid == DIALOG_JOB )
    {
        if (response)
        {
          	p_Job{ playerid } = listitem;

          	if ( !IsPlayerJailed( playerid ) && IsPlayerSpawned( playerid ) )
          	{
            	ResetPlayerWeapons( playerid );
	     		switch( listitem )
				{
			        case JOB_RAPIST:
			        {
			            GivePlayerWeapon( playerid, 22, 150 );
			            GivePlayerWeapon( playerid, 30, 400 );
			        }
			        case JOB_KIDNAPPER:
			        {
			            GivePlayerWeapon( playerid, 29, 220 );
			            GivePlayerWeapon( playerid, 30, 400 );
			        }
			        case JOB_TERRORIST:
			        {
			            GivePlayerWeapon( playerid, 33, 50 );
			            GivePlayerWeapon( playerid, 30, 400 );
			        }
			        case JOB_HITMAN:
			        {
			            GivePlayerWeapon( playerid, 4, 1 );
			            GivePlayerWeapon( playerid, 23, 130 );
			            GivePlayerWeapon( playerid, 34, 30 );
			        }
			        case JOB_PROSTITUTE:
			        {
			            GivePlayerWeapon( playerid, 10, 1 );
			            GivePlayerWeapon( playerid, 25, 30 );
			            GivePlayerWeapon( playerid, 30, 300 );
			        }
			        case JOB_WEAPON_DEALER:
			        {
			            GivePlayerWeapon( playerid, 5 , 1 );
			            GivePlayerWeapon( playerid, 22, 150 );
			            GivePlayerWeapon( playerid, 31, 300 );
			        }
			        case JOB_DRUG_DEALER:
			        {
			            GivePlayerWeapon( playerid, 5 , 1 );
			            GivePlayerWeapon( playerid, 22, 150 );
			            GivePlayerWeapon( playerid, 25, 30 );
			        }
			        case JOB_DIRTY_MECHANIC:
			        {
			            GivePlayerWeapon( playerid, 22, 150 );
			            GivePlayerWeapon( playerid, 27, 90 );
					}
			        case JOB_BURGLAR:
			        {
			            GivePlayerWeapon( playerid, 23, 130 );
			            GivePlayerWeapon( playerid, 31, 300 );
					}
			    }
			}

            TogglePlayerControllable( playerid, 1 );
            p_JobSet{ playerid } = true;

            if ( !p_CitySet{ playerid } )
            	ShowPlayerDialog( playerid, DIALOG_SPAWN_CITY, DIALOG_STYLE_LIST, "{FFFFFF}Select Spawning City", "San Fierro\nLas Venturas\nLos Santos", "Select", "" );

           	SendServerMessage( playerid, "Your job has been set to %s. you can change it at the City Hall for "COL_GOLD"$5,000"COL_WHITE".", GetJobName( p_Job{ playerid } ) );
		}
        else
        {
         	TogglePlayerControllable( playerid, 0 );
			ShowPlayerDialog( playerid, DIALOG_JOB, DIALOG_STYLE_LIST, "{FFFFFF}Job Selection", "Rapist\nKidnapper\nTerrorist\nHitman\nProstitute\nWeapon Dealer\nDrug Dealer\nDirty Mechanic\nBurglar", "Select", "" );
        }
    }
	if ( dialogid == DIALOG_BOMB_SHOP )
	{
	    if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this while you're in jail." );
		if ( response )
		{
			if ( listitem == ( 0 ) )
			{
			    if ( GetPlayerCash( playerid ) < 500 )
			        return SendError( playerid, "You don't have enough money for this item" );

				if ( p_C4Amount[ playerid ] >= MAX_C4 )
					return SendError( playerid, "You've reached the maximum C4 limit" );

			    GivePlayerCash( playerid, -500 );
				p_C4Amount[ playerid ] ++;
				SendServerMessage( playerid, "You have purchased 1 C4 for "COL_GOLD"$500"COL_WHITE"." );
				ShowPlayerDialog( playerid, DIALOG_BOMB_SHOP, DIALOG_STYLE_LIST, "{FFFFFF}C4 Shop", "1 C4\t"COL_GOLD"$500\n5 C4\t"COL_GOLD"$2450\nSell C4\t"COL_GREEN"Goes at half price.", "Select", "Cancel" );
			}
			else if ( listitem == ( 1 ) )
			{
			    if ( GetPlayerCash( playerid ) < 2450 )
			        return SendError( playerid, "You don't have enough money for this item" );

				if ( p_C4Amount[ playerid ] >= MAX_C4 )
					return SendError( playerid, "You've reached the maximum C4 limit" );

				if ( p_C4Amount[ playerid ] + 5 > MAX_C4 )
				{
				    new amount = MAX_C4 - p_C4Amount[ playerid ];
					SendServerMessage( playerid, "You have bought %d C4(s) for "COL_GOLD"%s"COL_WHITE" as adding five would exceed the C4 limit.", MAX_C4 - p_C4Amount[ playerid ], ConvertPrice( amount * 495 ) );
					p_C4Amount[ playerid ] += amount;
				    GivePlayerCash( playerid, -( amount * 495 ) );
				}
				else
				{
				    SendServerMessage( playerid, "You have purchased 5 C4 for "COL_GOLD"$2450"COL_WHITE"." );
				    p_C4Amount[ playerid ] += 5;
				    GivePlayerCash( playerid, -2450 );
				}
				ShowPlayerDialog( playerid, DIALOG_BOMB_SHOP, DIALOG_STYLE_LIST, "{FFFFFF}C4 Shop", "1 C4\t"COL_GOLD"$500\n5 C4\t"COL_GOLD"$2450\nSell C4\t"COL_GREEN"Goes at half price.", "Select", "Cancel" );
			}
			else if ( listitem == ( 2 ) )
			{
			    if ( p_C4Amount[ playerid ] < 1 )
			        return SendError( playerid, "You don't have any C4's" );

                GivePlayerCash( playerid, 250 );
                p_C4Amount[ playerid ] --;

				SendServerMessage( playerid, "You have sold 1 C4 for "COL_GOLD"$250"COL_WHITE"." );
				ShowPlayerDialog( playerid, DIALOG_BOMB_SHOP, DIALOG_STYLE_LIST, "{FFFFFF}C4 Shop", "1 C4\t"COL_GOLD"$500\n5 C4\t"COL_GOLD"$2450\nSell C4\t"COL_GREEN"Goes at half price.", "Select", "Cancel" );
			}
		}
	}
    if ( ( dialogid == DIALOG_BANK_MENU ) && response )
	{
		new
			gangid = p_GangID[ playerid ];

	    if ( IsPlayerJailed( playerid ) )
	    	return SendError( playerid, "You cannot use this while you're in jail." );

		if ( gangid == INVALID_GANG_ID && listitem > 2 )
	    	return SendError( playerid, "You are not in any gang!" );

        switch( listitem )
		{
            case 0:
            {
                format( Query, sizeof( Query ), "{FFFFFF}Enter the amount that you are willing to withdraw from your bank account.\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( p_BankMoney[ playerid ] ) );
                ShowPlayerDialog(playerid, DIALOG_BANK_WITHDRAW, DIALOG_STYLE_INPUT, "{FFFFFF}Personal Account", Query, "Withdraw", "Back");
            }
            case 1:
            {
                format( Query, sizeof( Query ), "{FFFFFF}Enter the amount that you are willing to deposit into your bank account below.\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( p_BankMoney[ playerid ] ) );
                ShowPlayerDialog(playerid, DIALOG_BANK_DEPOSIT, DIALOG_STYLE_INPUT, "{FFFFFF}Personal Account", Query, "Deposit", "Back");
            }
            case 2:
            {
                format( Query, sizeof( Query ), ""COL_GREY"Current Balance:"COL_WHITE" %s\n"COL_GREY"Current Money:{FFFFFF} %s", ConvertPrice( p_BankMoney[ playerid ] ), ConvertPrice( GetPlayerCash( playerid ) ) );
                ShowPlayerDialog(playerid, DIALOG_BANK_INFO, DIALOG_STYLE_MSGBOX, "{FFFFFF}Personal Account", Query, "Ok", "Back");
            }
            case 3:
            {
                format( Query, sizeof( Query ), "{FFFFFF}Enter the amount that you are willing to withdraw from your gang bank account.\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( g_gangData[ gangid ] [ E_BANK ] ) );
                ShowPlayerDialog(playerid, DIALOG_GANG_BANK_WITHDRAW, DIALOG_STYLE_INPUT, "{FFFFFF}Gang Account", Query, "Withdraw", "Back");
            }
            case 4:
            {
                format( Query, sizeof( Query ), "{FFFFFF}Enter the amount that you are willing to deposit into your gang bank account below.\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( g_gangData[ gangid ] [ E_BANK ] ) );
                ShowPlayerDialog(playerid, DIALOG_GANG_BANK_DEPOSIT, DIALOG_STYLE_INPUT, "{FFFFFF}Gang Account", Query, "Deposit", "Back");
            }
            case 5:
            {
                format( Query, sizeof( Query ), ""COL_GREY"Current Balance:"COL_WHITE" %s\n"COL_GREY"Current Money:{FFFFFF} %s", ConvertPrice( g_gangData[ gangid ] [ E_BANK ] ), ConvertPrice( GetPlayerCash( playerid ) ) );
                ShowPlayerDialog(playerid, DIALOG_GANG_BANK_INFO, DIALOG_STYLE_MSGBOX, "{FFFFFF}Gang Account", Query, "Ok", "Back");
            }
        }
    }
    if (dialogid == DIALOG_BANK_WITHDRAW)
	{
	    if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this while you're in jail." );
        if (response)
		{
            if (!strlen(inputtext))
			{
			    format( Query, sizeof( Query ), "{FFFFFF}Enter the amount that you are willing to withdraw from your bank account.\n\n"COL_RED"Invalid amount entered!\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( p_BankMoney[ playerid ] ) );
                ShowPlayerDialog(playerid, DIALOG_BANK_WITHDRAW, DIALOG_STYLE_INPUT, "{FFFFFF}Personal Account", Query, "Withdraw", "Back");
            }
            else if (!IsNumeric(inputtext)) {
                format( Query, sizeof( Query ), "{FFFFFF}Enter the amount that you are willing to withdraw from your bank account.\n\n"COL_RED"Invalid amount entered!\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( p_BankMoney[ playerid ] ) );
                ShowPlayerDialog(playerid, DIALOG_BANK_WITHDRAW, DIALOG_STYLE_INPUT, "{FFFFFF}Personal Account", Query, "Withdraw", "Back");
            }
            else if ( strval( inputtext ) > 99999999 || strval( inputtext ) < 0 )
            {
                format( Query, sizeof( Query ), "{FFFFFF}Enter the amount that you are willing to withdraw from your bank account.\n\n"COL_RED"Invalid amount entered!\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( p_BankMoney[ playerid ] ) );
                ShowPlayerDialog(playerid, DIALOG_BANK_WITHDRAW, DIALOG_STYLE_INPUT, "{FFFFFF}Personal Account", Query, "Withdraw", "Back");
            }
            else if (strval(inputtext) > p_BankMoney[ playerid ]) {
                format( Query, sizeof( Query ), "{FFFFFF}Enter the amount that you are willing to withdraw from your bank account.\n\n"COL_RED"Insufficient balance, therefore withdrawal failed.\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( p_BankMoney[ playerid ] ) );
                ShowPlayerDialog(playerid, DIALOG_BANK_WITHDRAW, DIALOG_STYLE_INPUT, "{FFFFFF}Personal Account", Query, "Withdraw", "Back");
            }
            else {
            	new iWithdraw = strval( inputtext );
                p_BankMoney[ playerid ] -= iWithdraw;
                GivePlayerCash( playerid, iWithdraw );
                format( Query, sizeof( Query ), ""COL_GREY"Amount Withdrawn:"COL_WHITE" %s\n"COL_GREY"Current Balance:"COL_WHITE" %s\n"COL_GREY"Current Money:{FFFFFF} %s", ConvertPrice( iWithdraw ), ConvertPrice( p_BankMoney[ playerid ] ), ConvertPrice( GetPlayerCash( playerid ) ) );
                ShowPlayerDialog( playerid, DIALOG_BANK_INFO, DIALOG_STYLE_MSGBOX, "{FFFFFF}Personal Account", Query, "Ok", "Back" );
            }
        }
        else ShowPlayerBankMenuDialog( playerid );
    }
    if ( dialogid == DIALOG_BANK_DEPOSIT )
	{
	    if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this while you're in jail." );
        if (response) {
            if (!strlen(inputtext)) {
                format( Query, sizeof( Query ), "{FFFFFF}Enter the amount that you are willing to deposit into your bank account below.\n\n"COL_RED"Invalid amount entered!\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( p_BankMoney[ playerid ] ) );
                ShowPlayerDialog(playerid, DIALOG_BANK_DEPOSIT, DIALOG_STYLE_INPUT, "{FFFFFF}Personal Account", Query, "Deposit", "Back");
            }
            else if (!IsNumeric(inputtext)) {
                format( Query, sizeof( Query ), "{FFFFFF}Enter the amount that you are willing to deposit into your bank account below.\n\n"COL_RED"Invalid amount entered!\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( p_BankMoney[ playerid ] ) );
                ShowPlayerDialog(playerid, DIALOG_BANK_DEPOSIT, DIALOG_STYLE_INPUT, "{FFFFFF}Personal Account", Query, "Deposit", "Back");
            }
            else if (strval(inputtext) > GetPlayerCash( playerid )) {
                format( Query, sizeof( Query ), "{FFFFFF}Enter the amount that you are willing to deposit into your bank account below.\n\n"COL_RED"Insufficient balance, therefore deposition failed.\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( p_BankMoney[ playerid ] ) );
                ShowPlayerDialog(playerid, DIALOG_BANK_DEPOSIT, DIALOG_STYLE_INPUT, "{FFFFFF}Personal Account", Query, "Deposit", "Back");
            }
            else if ( strval( inputtext ) > 99999999 || strval( inputtext ) < 0 )
            {
            	format( Query, sizeof( Query ), "{FFFFFF}Enter the amount that you are willing to deposit into your bank account below.\n\n"COL_RED"Invalid amount entered!\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( p_BankMoney[ playerid ] ) );
                ShowPlayerDialog( playerid, DIALOG_BANK_DEPOSIT, DIALOG_STYLE_INPUT, "{FFFFFF}Personal Account", Query, "Deposit", "Back" );
            }
            else {
            	new iDeposit = strval( inputtext );
                p_BankMoney[ playerid ] += iDeposit;
                GivePlayerCash( playerid, -iDeposit );
                format( Query, sizeof( Query ), ""COL_GREY"Amount Deposited:"COL_WHITE" %s\n"COL_GREY"Current Balance:"COL_WHITE" %s\n"COL_GREY"Current Money:{FFFFFF} %s", ConvertPrice( iDeposit ), ConvertPrice( p_BankMoney[ playerid ] ), ConvertPrice( GetPlayerCash( playerid ) ) );
                ShowPlayerDialog( playerid, DIALOG_BANK_INFO, DIALOG_STYLE_MSGBOX, "{FFFFFF}Personal Account", Query, "Ok", "Back" );
            }
        }
        else ShowPlayerBankMenuDialog( playerid );
    }
    if ( ( dialogid == DIALOG_BANK_INFO || dialogid == DIALOG_GANG_BANK_INFO ) && !response )
    {
	    if ( IsPlayerJailed( playerid ) )
	    	return SendError( playerid, "You cannot use this while you're in jail." );

  		return ShowPlayerBankMenuDialog( playerid );
    }
	if ( dialogid == DIALOG_GANG_BANK_WITHDRAW )
	{
		if ( !response )
			return ShowPlayerBankMenuDialog( playerid );

		new
			iWithdraw,
			gangid = p_GangID[ playerid ]
		;

		if ( gangid == INVALID_GANG_ID )
			return SendError( playerid, "You must be in a gang to use this feature." );

	    if ( IsPlayerJailed( playerid ) )
	    	return SendError( playerid, "You cannot use this while you're in jail." );

	    if ( !IsPlayerGangLeader( playerid, gangid ) )
	    	return ShowPlayerBankMenuDialog( playerid ), SendError( playerid, "You must be the gang leader to use this feature." );

	    if ( sscanf( inputtext, "d", iWithdraw ) )
	    {
		    format( Query, sizeof( Query ), "{FFFFFF}Enter the amount that you are willing to withdraw from your gang bank account.\n\n"COL_RED"Invalid amount entered!\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( g_gangData[ gangid ] [ E_BANK ] ) );
            ShowPlayerDialog(playerid, DIALOG_GANG_BANK_WITHDRAW, DIALOG_STYLE_INPUT, "{FFFFFF}Gang Account", Query, "Withdraw", "Back");
	    }
        else if ( iWithdraw > 99999999 || iWithdraw < 0 )
        {
            format( Query, sizeof( Query ), "{FFFFFF}Enter the amount that you are willing to withdraw from your gang bank account.\n\n"COL_RED"Invalid amount entered!\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( g_gangData[ gangid ] [ E_BANK ] ) );
            ShowPlayerDialog(playerid, DIALOG_GANG_BANK_WITHDRAW, DIALOG_STYLE_INPUT, "{FFFFFF}Gang Account", Query, "Withdraw", "Back");
        }
        else if ( iWithdraw > g_gangData[ gangid ] [ E_BANK ] )
        {
            format( Query, sizeof( Query ), "{FFFFFF}Enter the amount that you are willing to withdraw from your gang bank account.\n\n"COL_RED"Insufficient balance, therefore withdrawal failed.\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( g_gangData[ gangid ] [ E_BANK ] ) );
            ShowPlayerDialog(playerid, DIALOG_GANG_BANK_WITHDRAW, DIALOG_STYLE_INPUT, "{FFFFFF}Gang Account", Query, "Withdraw", "Back");
        }
        else
        {
        	new
        		iAfterTax = floatround( iWithdraw * 0.9 );

            g_gangData[ gangid ] [ E_BANK ] -= iWithdraw;
            GivePlayerCash( playerid, iAfterTax );
            SaveGangData( gangid );

			// transaction
	    	format( szNormalString, sizeof( szNormalString ), "INSERT INTO `TRANSACTIONS` (`TO_ID`, `FROM_ID`, `CASH`, `NATURE`) VALUES (%d, %d, %d, 'gang withdraw')", p_AccountID[ playerid ], g_gangData[ gangid ] [ E_SQL_ID ], iWithdraw );
	     	mysql_single_query( szNormalString );

	     	// withdraw
            SendClientMessageToGang( gangid, g_gangData[ gangid ] [ E_COLOR ], "[GANG]"COL_GREY" %s(%d) has withdrawn %s (inc. 10%s fee) from the gang bank account.", ReturnPlayerName( playerid ), playerid, ConvertPrice( iAfterTax ), "%%" );
            format( Query, sizeof( Query ), ""COL_GREY"Amount Withdrawn:"COL_WHITE" %s\n"COL_GREY"Current Balance:"COL_WHITE" %s\n"COL_GREY"Current Money:{FFFFFF} %s", ConvertPrice( iWithdraw ), ConvertPrice( g_gangData[ gangid ] [ E_BANK ] ), ConvertPrice( GetPlayerCash( playerid ) ) );
            ShowPlayerDialog( playerid, DIALOG_GANG_BANK_INFO, DIALOG_STYLE_MSGBOX, "{FFFFFF}Gang Account", Query, "Ok", "Back" );
        }
        return 1;
    }
    if ( dialogid == DIALOG_GANG_BANK_DEPOSIT )
	{
		if ( !response )
			return ShowPlayerBankMenuDialog( playerid );

		if ( p_accountSecurityData[ playerid ] [ E_ID ] && ! p_accountSecurityData[ playerid ] [ E_VERIFIED ] && p_accountSecurityData[ playerid ] [ E_MODE ] != SECURITY_MODE_DISABLED )
			return SendError( playerid, "You must be verified in order to use this feature. "COL_YELLOW"(use /verify)" );

		new
			iDeposit,
			gangid = p_GangID[ playerid ]
		;

		if ( gangid == INVALID_GANG_ID )
			return SendError( playerid, "You must be in a gang to use this feature." );

	    if ( IsPlayerJailed( playerid ) )
	    	return SendError( playerid, "You cannot use this while you're in jail." );

        if ( sscanf( inputtext, "d", iDeposit ) )
        {
            format( Query, sizeof( Query ), "{FFFFFF}Enter the amount that you are willing to deposit into your gang bank account below.\n\n"COL_RED"Invalid amount entered!\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( g_gangData[ gangid ] [ E_BANK ] ) );
            ShowPlayerDialog(playerid, DIALOG_GANG_BANK_DEPOSIT, DIALOG_STYLE_INPUT, "{FFFFFF}Gang Account", Query, "Deposit", "Back");
        }
        else if ( iDeposit > 99999999 || iDeposit < 1 )
        {
        	format( Query, sizeof( Query ), "{FFFFFF}Enter the amount that you are willing to deposit into your gang bank account below.\n\n"COL_RED"Invalid amount entered!\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( g_gangData[ gangid ] [ E_BANK ] ) );
            ShowPlayerDialog( playerid, DIALOG_GANG_BANK_DEPOSIT, DIALOG_STYLE_INPUT, "{FFFFFF}Gang Account", Query, "Deposit", "Back" );
        }
        else if ( iDeposit > GetPlayerCash( playerid ) )
        {
            format( Query, sizeof( Query ), "{FFFFFF}Enter the amount that you are willing to deposit into your gang bank account below.\n\n"COL_RED"Insufficient balance, therefore deposition failed.\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( g_gangData[ gangid ] [ E_BANK ] ) );
            ShowPlayerDialog(playerid, DIALOG_GANG_BANK_DEPOSIT, DIALOG_STYLE_INPUT, "{FFFFFF}Gang Account", Query, "Deposit", "Back");
        }
        else
        {
            g_gangData[ gangid ] [ E_BANK ] += iDeposit;
            GivePlayerCash( playerid, -iDeposit );
            SaveGangData( gangid );

			// transaction
	    	format( szNormalString, sizeof( szNormalString ), "INSERT INTO `TRANSACTIONS` (`TO_ID`, `FROM_ID`, `CASH`, `NATURE`) VALUES (%d, %d, %d, 'gang deposit')", p_AccountID[ playerid ], g_gangData[ gangid ] [ E_SQL_ID ], iDeposit );
	     	mysql_single_query( szNormalString );

	     	// deposit
            SendClientMessageToGang( gangid, g_gangData[ gangid ] [ E_COLOR ], "[GANG]"COL_GREY" %s(%d) has deposited %s into the gang bank account.", ReturnPlayerName( playerid ), playerid, ConvertPrice( iDeposit ) );
            format( Query, sizeof( Query ), ""COL_GREY"Amount Deposited:"COL_WHITE" %s\n"COL_GREY"Current Balance:"COL_WHITE" %s\n"COL_GREY"Current Money:{FFFFFF} %s", ConvertPrice( iDeposit ), ConvertPrice( g_gangData[ gangid ] [ E_BANK ] ), ConvertPrice( GetPlayerCash( playerid ) ) );
            ShowPlayerDialog( playerid, DIALOG_GANG_BANK_INFO, DIALOG_STYLE_MSGBOX, "{FFFFFF}Gang Account", Query, "Ok", "Back" );
        }
        return 1;
    }
	if ( ( dialogid == DIALOG_HOUSES ) && response )
	{
	    if ( listitem == 0 )
	    {
	        p_HouseSpawnLocation[ playerid ] = -1;
	        SendServerMessage( playerid, "You have canceled your house spawning." );
	        return 1;
	    }
	    else
	    {
		    for( new i, x = 1; i < MAX_HOUSES; i ++ )
			{
				if ( g_houseData[ i ] [ E_CREATED ] == true && strmatch( g_houseData[ i ] [ E_OWNER ], ReturnPlayerName( playerid ) ) )
			 	{
			       	if ( x == listitem )
			      	{
		        		if ( IsHouseOnFire( i ) )
		        		{
		        			SendError( playerid, "This house is on fire. You cannot spawn there at the moment." );
		        			cmd_h( playerid, "spawn" );
		        			break;
		        		}
			      		p_BusinessSpawnLocation[ playerid ] = -1, p_ApartmentSpawnLocation[ playerid ] = -1, p_HouseSpawnLocation[ playerid ] = i;
					 	SendServerMessage( playerid, "House spawning has been set at "COL_GREY"%s"COL_WHITE".", g_houseData[ i ] [ E_HOUSE_NAME ] );
					 	break;
		      		}
			      	x ++;
				}
			}
		}
	}
	if ( ( dialogid == DIALOG_BUSINESSES ) && response )
	{
	    if ( listitem == 0 )
	    {
	        p_BusinessSpawnLocation[ playerid ] = -1;
	        SendServerMessage( playerid, "You have canceled your business spawning." );
	        return 1;
	    }
	    else
	    {
	    	new
	    		x = 1;

		    foreach (new b : business)
			{
				if ( IsBusinessAssociate( playerid, b ) )
				{
			       	if ( x == listitem )
			      	{
			      		p_HouseSpawnLocation[ playerid ] = -1, p_ApartmentSpawnLocation[ playerid ] = -1, p_BusinessSpawnLocation[ playerid ] = b;
					 	SendServerMessage( playerid, "Business spawning has been set at "COL_GREY"%s"COL_WHITE".", g_businessData[ b ] [ E_NAME ] );
					 	break;
		      		}
			      	x ++;
				}
			}
		}
	}
	if ( ( dialogid == DIALOG_CITY_HALL ) && response )
	{
		switch( listitem )
		{
		    case 0:
		    {
		    	if ( p_Class[ playerid ] != CLASS_CIVILIAN )
		    		return SendError( playerid, "You must be a civilian to change your current job." );

		        if ( GetPlayerCash( playerid ) < 5000 )
		       		return SendError( playerid, "You need "COL_GOLD"$5,000"COL_WHITE" to change your job." );

	            TogglePlayerControllable( playerid, 0 );
				ShowPlayerDialog( playerid, DIALOG_JOB, DIALOG_STYLE_LIST, "{FFFFFF}Job Selection", "Rapist\nKidnapper\nTerrorist\nHitman\nProstitute\nWeapon Dealer\nDrug Dealer\nDirty Mechanic\nBurglar", "Select", "" );
				GivePlayerCash( playerid, -( 5000 ) );
				SendServerMessage( playerid, "You have been directed to the job selection, refer to your new job." );
		    }
		    case 1:
		    {
				SendServerMessage( playerid, "You have been directed to the city selection, refer to your new spawning city." );
				ShowPlayerDialog( playerid, DIALOG_SPAWN_CITY, DIALOG_STYLE_LIST, "{FFFFFF}Change Spawning City", "San Fierro\nLas Venturas\nLos Santos", "Select", "Back" );
		    }
		}
	}
	if ( dialogid == DIALOG_SPAWN_CITY )
	{
		if ( !response )
		{
			if ( !p_CitySet{ playerid } )
            	return ShowPlayerDialog( playerid, DIALOG_SPAWN_CITY, DIALOG_STYLE_LIST, "{FFFFFF}Select Spawning City", "San Fierro\nLas Venturas\nLos Santos", "Select", "" ), 1;

       		return ShowPlayerDialog( playerid, DIALOG_CITY_HALL, DIALOG_STYLE_LIST, "{FFFFFF}City Hall", ""COL_GOLD"$5,000"COL_WHITE"\t\tChange Job\n"COL_GOLD"free"COL_WHITE"\t\tChange City", "Select", "Close" ), 1;
		}

 		p_CitySet{ playerid } = true;
		p_SpawningCity{ playerid } = listitem;
		SendClientMessageFormatted( playerid, -1, ""COL_GOLD"[CITY]"COL_WHITE" You have set your spawning city to "COL_GREY"%s"COL_WHITE".", returnCityName( listitem ) );
	}
	if ( ( dialogid == DIALOG_HOSPITAL ) && response )
	{
		#if ENABLE_CITY_LV == true
	    if ( !IsPlayerInDynamicCP( playerid, g_Checkpoints[ CP_HOSPITAL ] ) && !IsPlayerInDynamicCP( playerid, g_Checkpoints[ CP_HOSPITAL_LV ] ) && !IsPlayerInDynamicCP( playerid, g_Checkpoints[ CP_HOSPITAL1_LS ] ) && !IsPlayerInDynamicCP( playerid, g_Checkpoints[ CP_HOSPITAL2_LS ] ) && !IsPlayerInDynamicCP( playerid, g_Checkpoints[ CP_HOSPITAL_FC ] ) )
			return SendError( playerid, "You must be in the hospital's checkpoint to use this." );
	    #else
	    if ( !IsPlayerInDynamicCP( playerid, g_Checkpoints[ CP_HOSPITAL ] ) ) return SendError( playerid, "You must be in the hospital's checkpoint to use this." );
	    #endif

		switch( listitem )
		{
			case 0:
			{
				if ( GetPlayerCash( playerid ) >= 2000 ) GivePlayerCash( playerid, -(2000) ), SetPlayerHealth( playerid, 100.0 ), SendServerMessage( playerid, "You have healed your self for $2,000.");
				else return SendError( playerid, "You cannot afford this item." );
			}
			case 1:
			{
				if ( GetPlayerCash( playerid ) >= 4000 ) GivePlayerCash( playerid, -(4000) ), p_InfectedHIV{ playerid } = false, SendServerMessage( playerid, "You cured all your infections for $4,000.");
                else return SendError( playerid, "You cannot afford this item." );
			}
			case 2:
			{
				if ( GetPlayerCash( playerid ) >= 6000 ) GivePlayerCash( playerid, -(6000) ), p_InfectedHIV{ playerid } = false, SetPlayerHealth( playerid, 100.0 ), SendServerMessage( playerid, "You cured all your infections and healed yourself for $6,000." );
                else return SendError( playerid, "You cannot afford this item." );
			}
		}
	}
	if ( ( dialogid == DIALOG_HOUSE_CONFIG ) && response )
	{
		if ( p_InHouse[ playerid ] == -1 ) return SendError( playerid, "You're not inside any house." );
	   	if ( !strmatch( g_houseData[ p_InHouse[ playerid ] ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this house." );
	   	DeletePVar( playerid, "gate_edititem" ); // Definitely not in the gate dialog lol
		switch( listitem )
		{
		    case 0: ShowPlayerDialog( playerid, DIALOG_HOUSE_TITLE, DIALOG_STYLE_INPUT, "{FFFFFF}Set House Title", ""COL_WHITE"Input the house title you want to change with:", "Confirm", "Back" );
		    case 1: ShowPlayerDialog( playerid, DIALOG_HOUSE_INTERIORS, DIALOG_STYLE_LIST, "{FFFFFF}House Interiors", szg_houseInteriors, "Select", "Back" );
		    case 2: ShowPlayerDialog( playerid, DIALOG_HOUSE_SET_PW, DIALOG_STYLE_INPUT, "{FFFFFF}Set House Password", ""COL_WHITE"Enter your desired house password below.\n\n"COL_GREY"Note:"COL_WHITE" You can disable it by typing \"N/A\" (without the quotation marks).", "Confirm", "Back" );
			case 3: ShowHouseWeaponStorage( playerid );
			case 4: ShowPlayerDialog( playerid, DIALOG_FURNITURE, DIALOG_STYLE_LIST, "{FFFFFF}Furniture", "Purchase Furniture\nSelect Furniture Easily\nSelect Furniture Manually\nSelect Furniture Nearest\n"COL_RED"Remove All Furniture", "Confirm", "Back" );
		}
	}
	if ( dialogid == DIALOG_HOUSE_WEAPONS )
	{
	 	if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this while you're in jail." );
	    if ( response )
	    {
	        if ( p_InHouse[ playerid ] == -1 ) return SendError( playerid, "You're not inside any house." );
	        if ( !strmatch( g_houseData[ p_InHouse[ playerid ] ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this house." );
			if ( g_HouseWeapons[ p_InHouse[ playerid ] ] [ listitem ] != 0 )
			{
				GivePlayerWeapon( playerid, g_HouseWeapons[ p_InHouse[ playerid ] ] [ listitem ], g_HouseWeaponAmmo[ p_InHouse[ playerid ] ] [ listitem ] );
			    SendServerMessage( playerid, "You have withdrawn your "COL_GREY"%s"COL_WHITE" with %d ammo.", ReturnWeaponName( g_HouseWeapons[ p_InHouse[ playerid ] ] [ listitem ] ), g_HouseWeaponAmmo[ p_InHouse[ playerid ] ] [ listitem ] );
                g_HouseWeapons[ p_InHouse[ playerid ] ] [ listitem ] = 0;
			    g_HouseWeaponAmmo[ p_InHouse[ playerid ] ] [ listitem ] = -1;
                SaveHouseWeaponStorage( p_InHouse[ playerid ] );
			    ShowHouseWeaponStorage( playerid );
			}
			else
			{
				if ( listitem > 2 && p_VIPLevel[ playerid ] < VIP_REGULAR ) return SendError( playerid, "You are not a V.I.P, to become one visit "COL_GREY"donate.irresistiblegaming.com" );
				p_HouseWeaponAddSlot{ playerid } = listitem;
				ShowPlayerDialog( playerid, DIALOG_HOUSE_WEAPONS_ADD, DIALOG_STYLE_MSGBOX, "{FFFFFF}House Weapon Storage", "{FFFFFF}Would you like to insert your current weapon into this slot?", "Insert", "Back" );
			}
	    }
	    else cmd_h( playerid, "config" );
	}
	if ( dialogid == DIALOG_HOUSE_WEAPONS_ADD )
	{
	    if ( response )
	    {
	    	if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this while you're in jail." );
	        if ( p_InHouse[ playerid ] == -1 ) return SendError( playerid, "You're not inside any house." );
	        if ( !strmatch( g_houseData[ p_InHouse[ playerid ] ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this house." );
			if ( IsMeleeWeapon( GetPlayerWeapon( playerid ) ) )
			{
			    SendError( playerid, "You cannot insert melee weapons." );
			    cmd_h( playerid, "config" );
			    return 1;
			}
			if ( GetPlayerWeapon( playerid ) == 16 || GetPlayerWeapon( playerid ) == 42 )
			{
			    SendError( playerid, "You cannot store this weapon." );
			    cmd_h( playerid, "config" );
			    return 1;
			}
			new iAmmo = GetPlayerAmmo( playerid );
			if ( iAmmo > 0x7FFF || iAmmo <= 0 ) iAmmo = 0x7FFF;
			listitem = p_HouseWeaponAddSlot{ playerid };
            g_HouseWeapons[ p_InHouse[ playerid ] ] [ listitem ] = GetPlayerWeapon( playerid );
            g_HouseWeaponAmmo[ p_InHouse[ playerid ] ] [ listitem ] = iAmmo;
            SendServerMessage( playerid, "You have inserted your "COL_GREY"%s"COL_WHITE" into your weapon storage.", ReturnWeaponName( GetPlayerWeapon( playerid ) ) );
            RemovePlayerWeapon( playerid, GetPlayerWeapon( playerid ) );
         	SaveHouseWeaponStorage( p_InHouse[ playerid ] );
			ShowHouseWeaponStorage( playerid );
	    }
	    else ShowHouseWeaponStorage( playerid );
	}
	if ( dialogid == DIALOG_HOUSE_SET_PW )
	{
	    if ( response )
	    {
	        if ( p_InHouse[ playerid ] == -1 ) return SendError( playerid, "You're not inside any house." );
	        else if ( !strmatch( g_houseData[ p_InHouse[ playerid ] ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this house." );
			else if ( !strlen( inputtext ) || strlen( inputtext ) > 4 )
			{
			    SendError( playerid, "Your password must vary between 0 and 4 characters." );
				ShowPlayerDialog( playerid, DIALOG_HOUSE_SET_PW, DIALOG_STYLE_INPUT, "{FFFFFF}Set House Password", ""COL_WHITE"Enter your desired house password below.\n\n"COL_GREY"Note:"COL_WHITE" You can disable it by typing \"N/A\" or \"NULL\" (without the quotation marks).", "Confirm", "Back" );
			}
			else if ( strmatch( inputtext, "N/A" ) || strmatch( inputtext, "NULL" ) )
			{
				format( g_houseData[ p_InHouse[ playerid ] ] [ E_PASSWORD ], 4, "N/A" );
			    SendServerMessage( playerid, "You have successfully disabled your house's password." );
			    format( szNormalString, 60, "UPDATE `HOUSES` SET `PASSWORD`='N/A' WHERE `ID`=%d", p_InHouse[ playerid ] );
			    mysql_single_query( szNormalString );
			    cmd_h( playerid, "config" );
			}
			else
			{
			    SendServerMessage( playerid, "You have changed your house password to "COL_GREY"%s"COL_WHITE".", inputtext );
			    format( g_houseData[ p_InHouse[ playerid ] ] [ E_PASSWORD ], 5, "%s", inputtext );
			    format( szNormalString, 60, "UPDATE `HOUSES` SET `PASSWORD`='%s' WHERE `ID`=%d", mysql_escape( inputtext ), p_InHouse[ playerid ] );
			    mysql_single_query( szNormalString );
			    cmd_h( playerid, "config" );
			}
	    }
	    else cmd_h( playerid, "config" );
	}
	if ( dialogid == DIALOG_HOUSE_INTERIORS )
	{
	    if ( response )
	    {
	        if ( p_InHouse[ playerid ] == -1 )
				return SendError( playerid, "You're not inside any house." );

	        if ( !strmatch( g_houseData[ p_InHouse[ playerid ] ] [ E_OWNER ], ReturnPlayerName( playerid ) ) )
				return SendError( playerid, "You are not the owner of this house." );

			p_ViewingInterior{ playerid } = listitem;
			ShowPlayerDialog( playerid, DIALOG_HOUSE_INT_CONFIRM, DIALOG_STYLE_LIST, "{FFFFFF}House Interiors", "Purchase House Interior\nPreview House Interior", "Select", "Back" );
		}
	    else cmd_h( playerid, "config" );
	}
	if ( dialogid == DIALOG_HOUSE_INT_CONFIRM )
	{
		if ( response )
		{
	        if ( p_InHouse[ playerid ] == -1 )
				return SendError( playerid, "You're not inside any house." );

	        if ( !strmatch( g_houseData[ p_InHouse[ playerid ] ] [ E_OWNER ], ReturnPlayerName( playerid ) ) )
				return SendError( playerid, "You are not the owner of this house." );

			new
				intid = p_ViewingInterior{ playerid };

			switch( listitem )
			{
				case 0:
				{
					if ( g_houseInteriors[ intid ] [ E_COST ] > GetPlayerCash( playerid ) )
					{
						ShowPlayerDialog( playerid, DIALOG_HOUSE_INT_CONFIRM, DIALOG_STYLE_LIST, "{FFFFFF}House Interiors", "Purchase House Interior\nPreview House Interior", "Select", "Back" );
						SendError( playerid, "This interior costs "COL_GOLD"%s"COL_WHITE". You don't have this amount.", ConvertPrice( g_houseInteriors[ intid ] [ E_COST ] ) );
					}
					else if ( g_houseInteriors[ intid ] [ E_VIP ] && !p_VIPLevel[ playerid ] )
					{
						ShowPlayerDialog( playerid, DIALOG_HOUSE_INT_CONFIRM, DIALOG_STYLE_LIST, "{FFFFFF}House Interiors", "Purchase House Interior\nPreview House Interior", "Select", "Back" );
						SendError( playerid, "You are not a V.I.P, to become one visit "COL_GREY"donate.irresistiblegaming.com" );
					}
					else if ( ArePlayersInHouse( p_InHouse[ playerid ], playerid ) )
					{
						ShowPlayerDialog( playerid, DIALOG_HOUSE_INT_CONFIRM, DIALOG_STYLE_LIST, "{FFFFFF}House Interiors", "Purchase House Interior\nPreview House Interior", "Select", "Back" );
						SendError( playerid, "You cannot purchase a house interior if there are people inside the building." );
					}
					else
					{
						if ( g_houseInteriors[ intid ] [ E_VIP ] && p_VIPLevel[ playerid ] && ( ( p_VIPExpiretime[ playerid ] - g_iTime ) / 86400 ) < 3 )
							return SendError( playerid, "You need more than 3 days of V.I.P in order to complete this." );

					    new houseid = p_InHouse[ playerid ];
					    GivePlayerCash( playerid, -( g_houseInteriors[ intid ] [ E_COST ] ) );

					    if ( intid != 0 )
							SendServerMessage( playerid, "You have purchased a %s for "COL_GOLD"%s"COL_WHITE". This has been applied to the House ID %d.", g_houseInteriors[ intid ] [ E_NAME ], ConvertPrice( g_houseInteriors[ intid ] [ E_COST ] ), houseid );
						else
						    SendServerMessage( playerid, "You have successfully reset your interior to the default interior." );

		                destroyAllFurniture( houseid );
						g_houseData[ houseid ] [ E_TX ] = g_houseInteriors[ intid ] [ E_EX ];
					    g_houseData[ houseid ] [ E_TY ] = g_houseInteriors[ intid ] [ E_EY ];
					    g_houseData[ houseid ] [ E_TZ ] = g_houseInteriors[ intid ] [ E_EZ ];
					    g_houseData[ houseid ] [ E_INTERIOR_ID ] = g_houseInteriors[ intid ] [ E_INTERIOR_ID ];
					    SetPlayerPos( playerid, g_houseInteriors[ intid ] [ E_EX ], g_houseInteriors[ intid ] [ E_EY ], g_houseInteriors[ intid ] [ E_EZ ] );
					    SetPlayerInterior( playerid, g_houseInteriors[ intid ] [ E_INTERIOR_ID ] );
					    DestroyDynamicCP( g_houseData[ houseid ] [ E_CHECKPOINT ] [ 1 ] );
					    g_houseData[ houseid ] [ E_CHECKPOINT ] [ 1 ] = CreateDynamicCP( g_houseInteriors[ intid ] [ E_EX ], g_houseInteriors[ intid ] [ E_EY ], g_houseInteriors[ intid ] [ E_EZ ], 1.0, g_houseData[ houseid ] [ E_WORLD ], g_houseData[ houseid ] [ E_INTERIOR_ID ], -1, 50.0 );
						format( Query, sizeof( Query ), "UPDATE HOUSES SET TX=%f, TY=%f, TZ=%f, INTERIOR=%d WHERE ID=%d", g_houseInteriors[ intid ] [ E_EX ], g_houseInteriors[ intid ] [ E_EY ], g_houseInteriors[ intid ] [ E_EZ ], g_houseData[ houseid ] [ E_INTERIOR_ID ], houseid );
						mysql_single_query( Query );
						DestroyDynamic3DTextLabel( g_houseData[ houseid ] [ E_LABEL ] [ 1 ] );
						g_houseData[ houseid ] [ E_LABEL ] [ 1 ] = CreateDynamic3DTextLabel( "[EXIT]", COLOR_GOLD, g_houseData[ houseid ] [ E_TX ], g_houseData[ houseid ] [ E_TY ], g_houseData[ houseid ] [ E_TZ ], 20.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, g_houseData[ houseid ] [ E_WORLD ] );
						pauseToLoad( playerid );
					}
				}
				case 1:
				{
					if ( p_WantedLevel[ playerid ] ) {
						ShowPlayerDialog( playerid, DIALOG_HOUSE_INT_CONFIRM, DIALOG_STYLE_LIST, "{FFFFFF}House Interiors", "Purchase House Interior\nPreview House Interior", "Select", "Back" );
						return SendError( playerid, "This feature requires you not to have a wanted level." );
					}
					if ( ArePlayersInHouse( p_InHouse[ playerid ], playerid ) ) {
						ShowPlayerDialog( playerid, DIALOG_HOUSE_INT_CONFIRM, DIALOG_STYLE_LIST, "{FFFFFF}House Interiors", "Purchase House Interior\nPreview House Interior", "Select", "Back" );
						return SendError( playerid, "You cannot view a house interior if there are people inside the building." );
					}
					TogglePlayerControllable( playerid, 0 );
				    SetPlayerPos( playerid, g_houseInteriors[ intid ] [ E_EX ], g_houseInteriors[ intid ] [ E_EY ], g_houseInteriors[ intid ] [ E_EZ ] );
				    SetPlayerInterior( playerid, g_houseInteriors[ intid ] [ E_INTERIOR_ID ] );
					InterpolateCameraPos( playerid, g_houseInteriors[ intid ] [ E_PREVIEW_POS ] [ 0 ], g_houseInteriors[ intid ] [ E_PREVIEW_POS ] [ 1 ], g_houseInteriors[ intid ] [ E_PREVIEW_POS ] [ 2 ] + 1.5, g_houseInteriors[ intid ] [ E_PREVIEW_LOOKAT ] [ 0 ], g_houseInteriors[ intid ] [ E_PREVIEW_LOOKAT ] [ 1 ], g_houseInteriors[ intid ] [ E_PREVIEW_LOOKAT ] [ 2 ], 15000, CAMERA_MOVE );
					InterpolateCameraLookAt( playerid, g_houseInteriors[ intid ] [ E_PREVIEW_LOOKAT ] [ 0 ], g_houseInteriors[ intid ] [ E_PREVIEW_LOOKAT ] [ 1 ], g_houseInteriors[ intid ] [ E_PREVIEW_LOOKAT ] [ 2 ], g_houseInteriors[ intid ] [ E_PREVIEW_POS ] [ 0 ], g_houseInteriors[ intid ] [ E_PREVIEW_POS ] [ 1 ], g_houseInteriors[ intid ] [ E_PREVIEW_POS ] [ 2 ] + 1.5, 15000, CAMERA_MOVE );
					SendServerMessage( playerid, "You are now previewing "COL_GREY"%s "COL_GOLD"%s"COL_WHITE". Press your enter key to stop.", g_houseInteriors[ intid ] [ E_NAME ], ConvertPrice( g_houseInteriors[ intid ] [ E_COST ] ) );
					SetPVarInt( playerid, "viewing_houseints", 1 );
				}
			}
		}
		else ShowPlayerDialog( playerid, DIALOG_HOUSE_INTERIORS, DIALOG_STYLE_LIST, "{FFFFFF}House Interiors", szg_houseInteriors, "Select", "Back" );
	}
	if ( dialogid == DIALOG_HOUSE_TITLE )
	{
	    if ( response )
	    {
	        if ( p_InHouse[ playerid ] == -1 )
				return SendError( playerid, "You're not inside any house." );

	        if ( !strmatch( g_houseData[ p_InHouse[ playerid ] ] [ E_OWNER ], ReturnPlayerName( playerid ) ) )
				return SendError( playerid, "You are not the owner of this house." );

	        if ( ! ( 1 <= strlen( inputtext ) <= 30 ) )
				return ShowPlayerDialog( playerid, DIALOG_HOUSE_TITLE, DIALOG_STYLE_INPUT, "{FFFFFF}Set House Title", ""COL_WHITE"Input the house title you want to change with:\n\n"COL_RED"Must be between 1 and 30 characters.", "Confirm", "Back" );

			if ( textContainsIP( inputtext ) )
				return SendError( playerid, "We do not condone advertising." );

			new houseid = p_InHouse[ playerid ];
			format( g_houseData[ houseid ] [ E_HOUSE_NAME ], 30, "%s", inputtext);
			format( Query, sizeof( Query ), "UPDATE `HOUSES` SET NAME='%s' WHERE ID=%d", mysql_escape( g_houseData[ houseid ] [ E_HOUSE_NAME ] ), p_InHouse[ playerid ] );
			mysql_single_query( Query );
			format( szBigString, sizeof( szBigString ), ""COL_GOLD"House:"COL_WHITE" %s(%d)\n"COL_GOLD"Owner:"COL_WHITE" %s\n"COL_GOLD"Price:"COL_WHITE" %s", g_houseData[ houseid ] [ E_HOUSE_NAME ], houseid, g_houseData[ houseid ] [ E_OWNER ], ConvertPrice( g_houseData[ houseid ] [ E_COST ] ) );
 			UpdateDynamic3DTextLabelText( g_houseData[ houseid ] [ E_LABEL ] [ 0 ], COLOR_WHITE, szBigString );
 			SendServerMessage( playerid, "You have successfully changed the name of your house." );
 			cmd_h( playerid, "config" );
	    }
	    else cmd_h( playerid, "config" );
	}
	if ( ( dialogid == DIALOG_VEHICLE_SPAWN ) && response )
	{
		if ( !listitem )
		{
			for( new id; id < MAX_BUYABLE_VEHICLES; id ++ )
				if ( g_vehicleData[ playerid ] [ id ] [ E_CREATED ] && g_vehicleData[ playerid ] [ id ] [ E_OWNER_ID ] == p_AccountID[ playerid ] && IsValidVehicle( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ] ) )
			 		RespawnBuyableVehicle( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ] );

			SendServerMessage( playerid, "You have respawned all your vehicles." );
		}
		else
		{
			for( new id, x = 1; id < MAX_BUYABLE_VEHICLES; id ++ )
			{
				if ( g_vehicleData[ playerid ] [ id ] [ E_CREATED ] && g_vehicleData[ playerid ] [ id ] [ E_OWNER_ID ] == p_AccountID[ playerid ] && IsValidVehicle( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ] ) )
				{
			       	if ( x == listitem )
			      	{
						RespawnBuyableVehicle( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ] );
						SendServerMessage( playerid, "You have respawned your "COL_GREY"%s"COL_WHITE".", GetVehicleName( GetVehicleModel( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ] ) ) );
					 	break;
			   		}
			      	x ++;
				}
			}
		}
	}
	if ( ( dialogid == DIALOG_VEHICLE_LOCATE ) && response )
	{
	    new
		    Float: X, Float: Y, Float: Z;

		GetPlayerPos( playerid, X, Y, Z );

		for( new id, x = 0; id < MAX_BUYABLE_VEHICLES; id ++ )
		{
			if ( g_vehicleData[ playerid ] [ id ] [ E_CREATED ] == true && g_vehicleData[ playerid ] [ id ] [ E_OWNER_ID ] == p_AccountID[ playerid ] && IsValidVehicle( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ] ) )
			{
		       	if ( x == listitem )
		      	{
		      		if ( GetPlayerCash( playerid ) < 10000 )
		      			return SendError( playerid, "You need $10,000 to bring your vehicle to you." );

					new
						Float: nodeX, Float: nodeY, Float: nodeZ, Float: nextX, Float: nextY,
						nodeid = NearestNodeFromPoint( X, Y, Z ),
						nextNodeid = NearestNodeFromPoint( X, Y, Z, 9999.9, nodeid )
					;

					GetNodePos( nextNodeid, nextX, nextY, nodeZ );
					GetNodePos( nodeid, nodeX, nodeY, nodeZ );

					new
						Float: rotation = atan2( nextY - nodeY, nextX - nodeX ) - 90.0;

					SetVehiclePos( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], nodeX, nodeY, nodeZ + 1.0 );
					SetVehicleZAngle( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], rotation );
					LinkVehicleToInterior( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], 0 );
					SetVehicleVirtualWorld( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], 0 );

					// alert
					Beep( playerid );
					GivePlayerCash( playerid, -10000 );
					p_VehicleBringCooldown[ playerid ] = g_iTime + 120;
					SendServerMessage( playerid, "You have brought your "COL_GREY"%s"COL_WHITE". Check the nearest road for it.", GetVehicleName( GetVehicleModel( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ] ) ) );
					break;
		   		}
		      	x ++;
			}
		}
	}
	if ( ( dialogid == DIALOG_ARENAS ) && response )
	{
	    switch( listitem )
	    {
			case 0:
			{
			    SetPlayerPosition( playerid, 1412.639892, -1.787510, 1000.924377, 1, 69 );
			    SendServerMessage( playerid, "You have been teleported to Warehouse 1." );
			}
			case 1:
			{
			    SetPlayerPosition( playerid, 1302.519897, -1.787510, 1001.028259, 18, 69 );
			    SendServerMessage( playerid, "You have been teleported to Warehouse 2." );
			}
			case 2:
			{
			    SetPlayerPosition( playerid, -1398.103515, 937.631164, 1036.479125, 15, 69 );
			    SendServerMessage( playerid, "You have been teleported to Bloodbowl." );
			}
			case 3:
			{
			    SetPlayerPosition( playerid, -1398.065307, -217.028900, 1051.115844, 7, 69 );
			    SendServerMessage( playerid, "You have been teleported to 8-Track." );
			}
			case 4:
			{
			    SetPlayerPosition( playerid, -975.975708,1060.983032,1345.671875, 10, 69 );
			    SendServerMessage( playerid, "You have been teleported to RC Battlefield." );
			}
			case 5:
			{
			    SetPlayerPosition( playerid, 501.980987,-69.150199,998.757812, 11, 69 );
			    SendServerMessage( playerid, "You have been teleported to Bar." );
			}
			case 6:
			{
			    SetPlayerPosition( playerid, 2543.462646,-1308.379882,1026.728393, 2, 69 );
			    SendServerMessage( playerid, "You have been teleported to Crack Factory." );
			}

			case 7:
			{
			    SetPlayerPosition( playerid, -794.806396,497.738037,1376.195312, 1, 69 );
			    SendServerMessage( playerid, "You have been teleported to Liberty City Inside." );
			}
			case 8:
			{
			    SetPlayerPosition( playerid, 1059.895996,2081.685791,10.820312, 0, 69 );
			    SendServerMessage( playerid, "You have been teleported to LV Warehouse." );
			}
			case 9:
			{
			    SetPlayerPosition( playerid, -1465.268676,1557.868286,1052.531250, 14, 69 );
			    SendServerMessage( playerid, "You have been teleported to Kickstart." );
			}
			case 10:
			{
			    SetPlayerPosition( playerid, -1444.645507,-664.526000,1053.572998, 4, 69 );
			    SendServerMessage( playerid, "You have been teleported to Dirt Track." );
			}
			case 11:
			{
			    SetPlayerPosition( playerid, 1453.1576,-1066.7552,213.3828, 0, 69 );
			    SendServerMessage( playerid, "You have been teleported to Dodge the Plane." );
			}
	    }
	}
	if ( ( dialogid == DIALOG_GANG_COLOR ) && response )
	{
	    if ( listitem != 0 )
	    {
	        listitem -= 1; // So it starts from 0...
			g_gangData[ p_GangID[ playerid ] ] [ E_COLOR ] = g_gangColors[ listitem ];
			SendClientMessageToGang( p_GangID[ playerid ], g_gangData[ p_GangID[ playerid ] ] [ E_COLOR ], "[GANG]{FFFFFF} %s(%d) has changed the gang color to %s", ReturnPlayerName( playerid ), playerid, ReturnGangNameColor( listitem ) );
	      	SetGangColorsToGang( p_GangID[ playerid ] );
		}
		else {
			if ( p_VIPLevel[ playerid ] < VIP_REGULAR ) return SendError( playerid, "You are not a V.I.P, to become one visit "COL_GREY"donate.irresistiblegaming.com" );
			ShowPlayerDialog( playerid, DIALOG_GANG_COLOR_INPUT, DIALOG_STYLE_INPUT, "{FFFFFF}Gang Colors", "{FFFFFF}Write a hexidecimal color within the textbox", "Submit", "Cancel" );
		}
	}
	if ( ( dialogid == DIALOG_GANG_COLOR_INPUT ) && response )
	{
		if ( !strlen( inputtext ) || !isHex( inputtext ) )
		    return ShowPlayerDialog( playerid, DIALOG_GANG_COLOR_INPUT, DIALOG_STYLE_INPUT, "{FFFFFF}Gang Colors", "{FFFFFF}Write a hexidecimal color within the textbox\n\n{ff0000}Invalid HEX color.", "Submit", "Cancel" );

		new
			iHex = HexToInt( inputtext );

		g_gangData[ p_GangID[ playerid ] ] [ E_COLOR ] = setAlpha( iHex, 0xFF );
		SendClientMessageToGang( p_GangID[ playerid ], g_gangData[ p_GangID[ playerid ] ] [ E_COLOR ], "[GANG]{FFFFFF} %s(%d) has changed the gang color to HEX(%d)", ReturnPlayerName( playerid ), playerid, iHex );
	 	SetGangColorsToGang( p_GangID[ playerid ] );
	}
	if ( ( dialogid == DIALOG_GANG_LIST ) && response )
	{
		new
			x = 0;

		foreach(new g : gangs)
		{
	       	if ( x == listitem )
	      	{
	      		SetPVarInt( playerid, "viewing_gangid", g );
	      		ShowPlayerDialog( playerid, DIALOG_GANG_LIST_OPTIONS, DIALOG_STYLE_LIST, "{FFFFFF}Gang Options", "View Statistics\nView Gang Members", "Select", "Back" );
				break;
	   		}
	      	x ++;
		}
	}
	if ( dialogid == DIALOG_GANG_LIST_OPTIONS )
	{
		if ( !response )
			return cmd_gangs( playerid, "" );

		new
			g = GetPVarInt( playerid, "viewing_gangid" );

		switch( listitem )
		{
			case 0: // View statistics
			{
				new iPlayers = GetOnlineGangMembers( g );
				format( szLargeString, 350, ""COL_GREY"Gang ID:"COL_WHITE" %d\n"COL_GREY"Online Members:"COL_WHITE" %d\n"COL_GREY"Score:"COL_WHITE" %d\n"COL_GREY"Kills:"COL_WHITE" %d\n"COL_GREY"Deaths:"COL_WHITE" %d\n"COL_GREY"K/D Ratio:"COL_WHITE" %0.2f\n", g_gangData[ g ] [ E_SQL_ID ], iPlayers, g_gangData[ g ] [ E_SCORE ], g_gangData[ g ] [ E_KILLS ], g_gangData[ g ] [ E_DEATHS ], floatdiv( g_gangData[ g ] [ E_KILLS ], g_gangData[ g ] [ E_DEATHS ] ) );
				format( szLargeString, 350, "%s"COL_GREY"Bank:"COL_WHITE" %s\n"COL_GREY"Zones Captured:"COL_WHITE" %d", szLargeString, ConvertPrice( g_gangData[ g ] [ E_BANK ] ), GetGangCapturedTurfs( g ) );
				ShowPlayerDialog( playerid, DIALOG_GANG_LIST_RESPONSE, DIALOG_STYLE_MSGBOX, "{FFFFFF}Gang Statistics", szLargeString, "Close", "Back" );
			}
			case 1: mysql_function_query( dbHandle, sprintf( "SELECT `NAME`,`ONLINE` FROM `USERS` WHERE `GANG_ID`=%d ORDER BY `ONLINE` DESC", g_gangData[ g ] [ E_SQL_ID ] ), true, "OnListGangMembers", "dd", playerid, g ); // View gang members
		}
		return 1;
	}
	if ( dialogid == DIALOG_GANG_LIST_RESPONSE || dialogid == DIALOG_GANG_LIST_MEMBERS )
	{
		ShowPlayerDialog( playerid, DIALOG_GANG_LIST_OPTIONS, DIALOG_STYLE_LIST, "{FFFFFF}Gang Options", "View Statistics\nView Gang Members", "Select", "Back" );
	}
	if ( ( dialogid == DIALOG_PERKS ) && response )
	{
		switch( listitem )
		{
			case 0: ShowPlayerDialog( playerid, DIALOG_PERKS_P, DIALOG_STYLE_TABLIST, "{FFFFFF}Game Perks", "Unlimited Ammunition\t"COL_GOLD"100 XP", "Select", "Back" );
			case 1: ShowPlayerDialog( playerid, DIALOG_PERKS_V, DIALOG_STYLE_TABLIST, "{FFFFFF}Game Perks", "Fix & Flip vehicle\t"COL_GOLD"200 XP\nFlip vehicle\t"COL_GOLD"50 XP\n"COL_WHITE"Add NOS\t"COL_GOLD"80 XP\n"COL_WHITE"Repair Vehicle\t"COL_GOLD"120 XP", "Select", "Back" );
		}
	}
	if ( ( dialogid == DIALOG_PERKS_P ) )
	{
	    if ( !response )
	        return ShowPlayerDialog( playerid, DIALOG_PERKS, DIALOG_STYLE_LIST, "{FFFFFF}Game Perks", "Player Perks\nVehicle Perks", "Select", "Cancel" );

	    switch( listitem )
	    {
	        case 0:
	        {
	            if ( p_XP[ playerid ] >= 100 )
	            {
	                GivePlayerXP( playerid, -100 );
	                for( new i; i < MAX_WEAPONS; i++ )
					{
					    if ( IsWeaponInAnySlot( playerid, i ) && i != 0 && !( 16 <= i <= 18 ) && i != 47 && i != WEAPON_BOMB )
					    {
					        GivePlayerWeapon( playerid, i, 15000 );
					    }
					}
					SendServerMessage( playerid, "You have bought unlimited ammunition for 100 XP." );
					SetPlayerArmedWeapon( playerid, 0 );
					Beep( playerid );
	            }
				else return SendError( playerid, "You don't have enough XP for this." );
	        }
	    }
	}
	if ( ( dialogid == DIALOG_PERKS_V ) )
	{
	    if ( !response )
	        return ShowPlayerDialog( playerid, DIALOG_PERKS, DIALOG_STYLE_LIST, "{FFFFFF}Game Perks", "Player Perks\nVehicle Perks", "Select", "Cancel" );

		if ( !IsPlayerInAnyVehicle( playerid ) || GetPlayerState( playerid ) != PLAYER_STATE_DRIVER )
		    return SendError( playerid, "You are not in any vehicle as a driver." );

	    switch( listitem )
	    {
	    	case 0:
	        {
	        	if ( p_XP[ playerid ] >= 200 )
	            {
		            new Float: vZ, vehicleid = GetPlayerVehicleID( playerid );
					GetVehicleZAngle( vehicleid, vZ ), SetVehicleZAngle( vehicleid, vZ );
					p_DamageSpamCount{ playerid } = 0;
	                RepairVehicle( GetPlayerVehicleID( playerid ) );
					GivePlayerXP( playerid, -200 );
					SendServerMessage( playerid, "You have fixed and flipped your vehicle for 200 XP." );
					PlayerPlaySound( playerid, 1133, 0.0, 0.0, 5.0 );
	            }
	        	else return SendError( playerid, "You don't have enough XP for this." );
	        }
	        case 1:
	        {
	        	if ( p_XP[ playerid ] >= 50 )
	            {
		            new Float: vZ, vehicleid = GetPlayerVehicleID( playerid );
					GetVehicleZAngle( vehicleid, vZ ), SetVehicleZAngle( vehicleid, vZ );
					GivePlayerXP( playerid, -50 );
					SendServerMessage( playerid, "You have flipped your vehicle for 50 XP." );
					PlayerPlaySound( playerid, 1133, 0.0, 0.0, 5.0 );
	            }
	        	else return SendError( playerid, "You don't have enough XP for this." );
	        }
	        case 2:
	        {
	        	if ( p_XP[ playerid ] >= 80 )
	            {
	                AddVehicleComponent( GetPlayerVehicleID( playerid ), 1010 );
					GivePlayerXP( playerid, -80 );
					SendServerMessage( playerid, "You have installed nitro on your car for 80 XP." );
					PlayerPlaySound( playerid, 1133, 0.0, 0.0, 5.0 );
	            }
	        	else return SendError( playerid, "You don't have enough XP for this." );
	        }
	        case 3:
	        {
	            if ( p_XP[ playerid ] >= 120 )
	            {
					PlayerPlaySound( playerid, 1133, 0.0, 0.0, 5.0 );
					p_DamageSpamCount{ playerid } = 0;
	                RepairVehicle( GetPlayerVehicleID( playerid ) );
					GivePlayerXP( playerid, -120 );
					SendServerMessage( playerid, "You have repaired your car for 120 XP." );
	            }
	        	else return SendError( playerid, "You don't have enough XP for this." );
	        }
	    }
	}
	if ( ( dialogid == DIALOG_SHOP_MENU ) && response )
    {
	    if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this while you're in jail." );
        if ( !listitem ) return cmd_shop( playerid, "" ); // Array index out of bounds fix

        new
        	i = listitem - 1;

        if ( g_shopItemData[ i ] [ E_LIMIT ] == LIMIT_ONE )
        {
        	cmd_shop( playerid, "" );

        	if ( GetPlayerCash( playerid ) < g_shopItemData[ i ] [ E_PRICE ] ) return SendError( playerid, "You don't have enough money for this item." );

        	switch( i )
        	{
        		case 3:
        		{
        			if ( p_AidsVaccine{ playerid } == true ) return SendError( playerid, "You have already purchased this item." );
        			p_AidsVaccine{ playerid } = true;
        		}
        		case 4:
        		{
        			if ( p_SecureWallet{ playerid } == true ) return SendError( playerid, "You have already purchased this item." );
        			p_SecureWallet{ playerid } = true;
        		}
        		case 7:
        		{
        			if ( p_MoneyBag{ playerid } == true ) return SendError( playerid, "You have already purchased this item." );
					if ( p_Class[ playerid ] != CLASS_POLICE ) SetPlayerAttachedObject( playerid, 1, 1210, 7, 0.302650, -0.002469, -0.193321, 296.124053, 270.396881, 8.941717, 1.000000, 1.000000, 1.000000 );
        			p_MoneyBag{ playerid } = true;
        			//SetPlayerAttachedObject( playerid, 1, 1550, 1, 0.131999, -0.140999, 0.053999, 11.299997, 65.599906, 173.900054, 0.652000, 0.573000, 0.594000 );
        		}
        		case 10:
        		{
        			if ( p_drillStrength[ playerid ] == MAX_DRILL_STRENGTH ) return SendError( playerid, "You have already purchased this item." );
        			p_drillStrength[ playerid ] = MAX_DRILL_STRENGTH;
        		}
        	}
			GivePlayerCash( playerid, -( g_shopItemData[ i ] [ E_PRICE ] ) );
			SendServerMessage( playerid, "You have bought a "COL_GREY"%s"COL_WHITE" for "COL_GOLD"%s"COL_WHITE".", g_shopItemData[ i ] [ E_NAME ], ConvertPrice( g_shopItemData[ i ] [ E_PRICE ] ) );
        }
        else
       	{
       		SetPVarInt( playerid, "shop_item", i );
       		ShowPlayerDialog( playerid, DIALOG_SHOP_AMOUNT, DIALOG_STYLE_LIST, "{FFFFFF}Shop Items - Buy Quantity", "Buy 1\nBuy 5\nBuy Max", "Select", "Back" );
       	}
    }
    if ( dialogid == DIALOG_SHOP_AMOUNT )
    {
    	if ( response )
    	{
	    	if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this while you're in jail." );

    		new
    			iAmount = LIMIT_ONE,

    			i = GetPVarInt( playerid, "shop_item" ),
    			iCurrentQuantity = GetShopItemVariable( playerid, i ),

    			iLimit = g_shopItemData[ i ] [ E_LIMIT ] + ( 2 * p_VIPLevel[ playerid ] )
    		;

    		switch( listitem )
    		{
    			case 0: iAmount = 1;
    			case 1: iAmount = 5;
    			case 2: iAmount = iLimit;
    		}

    		if ( ( iCurrentQuantity + iAmount ) > iLimit )
    		{
    			// Specified more than he can carry!
    			if ( ( iAmount = iLimit - iCurrentQuantity ) != 0 )
    				SendServerMessage( playerid, "You've breached the quantity limit therefore we have set it to %d.", iAmount );
    		}

    		if ( GetPlayerCash( playerid ) < ( g_shopItemData[ i ] [ E_PRICE ] * iAmount ) ) SendError( playerid, "You cannot afford the price of the item(s)." );
    		else if ( iAmount <= 0 ) SendError( playerid, "You cannot buy anymore of this item." );
    		else {
    			SetShopItemVariable( playerid, i, iCurrentQuantity + iAmount );
    			GivePlayerCash( playerid, -( g_shopItemData[ i ] [ E_PRICE ] * iAmount ) );
				SendServerMessage( playerid, "You have bought %dx "COL_GREY"%s"COL_WHITE" for "COL_GOLD"%s"COL_WHITE".", iAmount, g_shopItemData[ i ] [ E_NAME ], ConvertPrice( g_shopItemData[ i ] [ E_PRICE ] * iAmount ) );
    		}

    		ShowPlayerDialog( playerid, DIALOG_SHOP_AMOUNT, DIALOG_STYLE_LIST, "{FFFFFF}Shop Items - Buy Quantity", "Buy 1\nBuy 5\nBuy Max", "Select", "Back" );
    	}
    	else cmd_shop( playerid, "" );
    }
	if ( ( dialogid == DIALOG_RADIO ) && response )
	{
		if ( listitem == 0 )
		{
			if ( p_VIPLevel[ playerid ] < VIP_REGULAR )
				return SendError( playerid, "You must be a V.I.P to use this, to become one visit "COL_GREY"donate.irresistiblegaming.com" ), 1;

		 	ShowPlayerDialog(playerid, DIALOG_RADIO_CUSTOM, DIALOG_STYLE_INPUT, "{FFFFFF}Custom Radio", ""COL_WHITE"Enter the URL below, and streaming will begin.\n\n"COL_ORANGE"Please note, if there isn't a response. It's likely to be an invalid URL.", "Stream", "Back");
			return 1;
		}
	   	p_UsingRadio{ playerid } = true;
	   	StopAudioStreamForPlayer( playerid );
	   	PlayAudioStreamForPlayer( playerid, g_RadioData[ listitem - 1 ] [ E_URL ] );
	    SendServerMessage( playerid, "If the radio doesn't respond then it must be offline. Use "COL_GREY"/stopradio"COL_WHITE" to stop the radio." );
	}
	if ( dialogid == DIALOG_RADIO_CUSTOM )
	{
		if ( !response ) return cmd_radio( playerid, "" );
	   	p_UsingRadio{ playerid } = true;
	   	StopAudioStreamForPlayer( playerid );
	   	PlayAudioStreamForPlayer( playerid, inputtext );
	    SendServerMessage( playerid, "If the radio doesn't respond then it must be offline. Use "COL_GREY"/stopradio"COL_WHITE" to stop the radio." );
	}
	if ( ( dialogid == DIALOG_XPMARKET ) && response )
	{
		if ( !strlen( inputtext ) || !IsNumeric( inputtext ) )
		    return SendError( playerid, "The input you have entered is invalid, must be a numeric with over 0 characters." ), cmd_xpmarket( playerid, "" ), 1;

		if ( strval( inputtext ) < 0 || strval( inputtext ) > GetPlayerXP( playerid ) || strval( inputtext ) > 99999999 )
		    return SendError( playerid, "Invalid amount, must be from 0 to the amount of XP you have." ), cmd_xpmarket( playerid, "" ), 1;

		GivePlayerXP( playerid, -( strval( inputtext ) ) );
		GivePlayerCash( playerid, strval( inputtext ) * EXCHANGE_XPCASH );
		printf( "[xpmarket] %s -> %s", ReturnPlayerName( playerid ), ConvertPrice( strval( inputtext ) * EXCHANGE_XPCASH ) ); // 8hska7082bmahu
		SendServerMessage( playerid, "You have successfully exchanged %d XP for %s dollars.", strval( inputtext ), ConvertPrice( strval( inputtext ) * EXCHANGE_XPCASH ) );
	}
	if ( ( dialogid == DIALOG_PAINTBALL ) && response )
	{
		for( new id, x = 0; id < MAX_PAINTBALL_ARENAS; id ++ )
		{
	       	if ( x == listitem )
	      	{
				if ( Iter_Contains(paintball, id) )
				{
					if ( !g_paintballData[ id ] [ E_ACTIVE ] )
					{
						SendError( playerid, "This paintball lobby is currently not active and being edited." );
						listPaintBallLobbies( playerid );
						return 1;
					}

		      		if ( g_paintballData[ id ] [ E_PASSWORDED ] && !isnull( g_paintballData[ id ] [ E_PASSWORD ] ) && !strmatch( g_paintballData[ id ] [ E_PASSWORD ], "NULL" ) )
		      		{
					 	if ( g_Debugging ) {
					 		SendClientMessageToRCON( COLOR_YELLOW, "PAINTBALL: host %s, passworded %d, password %s", ReturnPlayerName( g_paintballData[ id ] [ E_HOST ] ), g_paintballData[ id ] [ E_PASSWORDED ], g_paintballData[ id ] [ E_PASSWORD ] );
					 	}
						p_PaintBallArena{ playerid } = id;
		      			SendServerMessage( playerid, "You are trying to join the paintball lobby: "COL_GREY"%s", g_paintballData[ id ] [ E_NAME ] );
		      			ShowPlayerDialog( playerid, DIALOG_PAINTBALL_PW, DIALOG_STYLE_INPUT, "{FFFFFF}Paintball - Join", "{FFFFFF}This lobby requires a password.", "Join", "Back" );
		      			return 1;
		      		}
		      		JoinPlayerPaintball( playerid, id );
				}
				else
				{
			    	if ( hasPaintBallArena( playerid ) )
			    		return SendError( playerid, "You already have an paintball arena set. You've been spawned." ), SpawnPlayer( playerid );

				  	if ( GetPlayerCash( playerid ) < 5000 )
			    		return listPaintBallLobbies( playerid ), SendError( playerid, "You're insufficient of funds. ($5,000)" ), 1;

			    	if ( !CreatePaintballLobby( id, playerid, "Paintball", 8, 0 ) )
			    		return SendError( playerid, "Unable to create lobby due to an error. Maybe someone's occupied the slot?" );

			    	GivePlayerCash( playerid, -5000 );
			    	showPaintBallLobbyData( playerid, id );
			    	p_PaintBallArena{ playerid } = id;
				}
				break;
	   		}
	      	x ++;
		}
	}
	if ( dialogid == DIALOG_PAINTBALL_PW )
	{
		if ( response )
		{
			new
				szPassword[ 5 ];

			strreplacechar( inputtext, '\\', '/' );
			if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "This is no longer available as you're in jail." );
	    	if ( !Iter_Contains( paintball, p_PaintBallArena{ playerid } ) ) return SendError( playerid, "This lobby no longer exists." );
	    	if ( sscanf( inputtext, "s[5]", szPassword ) ) return ShowPlayerDialog( playerid, DIALOG_PAINTBALL_PW, DIALOG_STYLE_INPUT, "{FFFFFF}Paintball - Join", "{FFFFFF}This lobby requires a password.\n\n"COL_RED"Incorrect password, please try again.", "Join", "Back" );
			if ( g_paintballData[ p_PaintBallArena{ playerid } ] [ E_PASSWORDED ] ) {
				if ( !strmatch( szPassword, g_paintballData[ p_PaintBallArena{ playerid } ] [ E_PASSWORD ] ) ) return ShowPlayerDialog( playerid, DIALOG_PAINTBALL_PW, DIALOG_STYLE_INPUT, "{FFFFFF}Paintball - Join", "{FFFFFF}This lobby requires a password.\n\n"COL_RED"Incorrect password, please try again.", "Join", "Back" );
			}
			else SendServerMessage( playerid, "Seems like the lobby you were trying to join is not passworded anymore." );
			JoinPlayerPaintball( playerid, p_PaintBallArena{ playerid } );
		}
		else listPaintBallLobbies( playerid );
	}
	if ( dialogid == DIALOG_PAINTBALL_EDIT )
	{
		if ( response )
		{
			SetPVarInt( playerid, "paintball_edititem", listitem );

			switch( listitem )
			{
				case 0 .. 4: 	ShowPlayerDialog( playerid, DIALOG_PAINTBALL_EDIT_VAL, DIALOG_STYLE_INPUT, "{FFFFFF}Paintball - Edit", "{FFFFFF}What would you like to set the value of this to?", "Commit", "Back" );
				case 5:
				{
					new iLobby = p_PaintBallArena{ playerid };
					g_paintballData[ iLobby ] [ E_REFILLER ] = !g_paintballData[ iLobby ] [ E_REFILLER ];
					SendClientMessageToPaintball( iLobby, -1, ""COL_GREY"[PAINTBALL]"COL_WHITE" Upon death, armour and/or health will%s be restored.", g_paintballData[ iLobby ] [ E_REFILLER ] == false ? ( " not" ) : ( "" ) );
					showPaintBallLobbyData( playerid, iLobby );
				}
				case 6: 		ShowPlayerPaintballArenas( playerid );
				case 7 .. 9: 	ShowPlayerDialog( playerid, DIALOG_PAINTBALL_WEP, DIALOG_STYLE_LIST, "{FFFFFF}Paintball - Edit", ""COL_RED"Remove Weapon On This Slot\n9mm Pistol\nSilenced Pistol\nDesert Eagle\nShotgun\nSawn-off Shotgun\nSpas 12\nMac 10\nMP5\nAK-47\nM4\nTec 9\nRifle\nSniper", "Select", "Cancel");
			}
		}
		else
		{
			new
				i = p_PaintBallArena{ playerid };

			if ( !g_paintballData[ i ] [ E_ACTIVE ] )
			{
				g_paintballData[ i ] [ E_ACTIVE ] = true;
			  	JoinPlayerPaintball( playerid, i );
			  	SendServerMessage( playerid, "You can edit your lobby with "COL_GREY"/paintball edit"COL_WHITE"." );
			}
		}
	}
	if ( dialogid == DIALOG_PAINTBALL_EDIT_VAL )
	{
		new
			iLobby = p_PaintBallArena{ playerid };

		if ( response )
		{
			switch( GetPVarInt( playerid, "paintball_edititem" ) )
			{
				case 0: // name
				{
					new
						szName[ 16 ];

					if ( sscanf( inputtext, "s[16]", szName ) )
				 		return ShowPlayerDialog( playerid, DIALOG_PAINTBALL_EDIT_VAL, DIALOG_STYLE_INPUT, "{FFFFFF}Paintball - Edit", "{FFFFFF}What would you like to set the value of this to?\n\n"COL_RED"Invalid Lobby Name.", "Commit", "Back" );

					if ( strlen( inputtext ) < 3 || strlen( inputtext ) >= 16 )
				 		return ShowPlayerDialog( playerid, DIALOG_PAINTBALL_EDIT_VAL, DIALOG_STYLE_INPUT, "{FFFFFF}Paintball - Edit", "{FFFFFF}What would you like to set the value of this to?\n\n"COL_RED"The lobby name must be ranged between 3 and 16 characters.", "Commit", "Back" );

					format( g_paintballData[ iLobby ] [ E_NAME ], 16, "%s", szName );
					SendClientMessageToPaintball( iLobby, -1, ""COL_GREY"[PAINTBALL]"COL_WHITE" The lobby name has been updated by %s(%d)", ReturnPlayerName( playerid ), playerid );
				}
				case 1: // pw
				{
					new
						szPassword[ 5 ];

					if ( sscanf( inputtext, "s[5]", szPassword ) ) return ShowPlayerDialog( playerid, DIALOG_PAINTBALL_EDIT_VAL, DIALOG_STYLE_INPUT, "{FFFFFF}Paintball - Edit", "{FFFFFF}What would you like to set the value of this to?\n\n"COL_RED"The password can only be a maximum of 4 characters. Set to NULL to disable.", "Commit", "Back" );
					if ( !strlen( szPassword ) || strlen( szPassword ) >= 5 ) return ShowPlayerDialog( playerid, DIALOG_PAINTBALL_EDIT_VAL, DIALOG_STYLE_INPUT, "{FFFFFF}Paintball - Edit", "{FFFFFF}What would you like to set the value of this to?\n\n"COL_RED"The password can only be a maximum of 4 characters. Set to NULL to disable.", "Commit", "Back" );

					if ( strmatch( szPassword, "NULL" ) )
					{
						SendClientMessageToPaintball( iLobby, -1, ""COL_GREY"[PAINTBALL]"COL_WHITE" The lobby password has been%sdisabled.", " " );
						g_paintballData[ iLobby ] [ E_PASSWORDED ] = false;
					}
					else
					{
						SendClientMessageToPaintball( iLobby, -1, ""COL_GREY"[PAINTBALL]"COL_WHITE" The lobby password has been changed to: "COL_GREY"%s"COL_WHITE".", szPassword );
						g_paintballData[ iLobby ] [ E_PASSWORDED ] = true;
					}
					format( g_paintballData[ iLobby ] [ E_PASSWORD ], 5, "%s", szPassword );
				}
				case 2: // limit
				{
					new iLimit;

					if ( sscanf( inputtext, "d", iLimit ) )
				 		return ShowPlayerDialog( playerid, DIALOG_PAINTBALL_EDIT_VAL, DIALOG_STYLE_INPUT, "{FFFFFF}Paintball - Edit", "{FFFFFF}What would you like to set the value of this to?\n\n"COL_RED"Ensure the player capacity is an integer.", "Commit", "Back" );

					if ( iLimit < 2 || iLimit > 32 )
				 		return ShowPlayerDialog( playerid, DIALOG_PAINTBALL_EDIT_VAL, DIALOG_STYLE_INPUT, "{FFFFFF}Paintball - Edit", "{FFFFFF}What would you like to set the value of this to?\n\n"COL_RED"Please specify between 2 and 32 players.", "Commit", "Back" );

					if ( iLimit < g_paintballData[ iLobby ] [ E_PLAYERS ] )
						return ShowPlayerDialog( playerid, DIALOG_PAINTBALL_EDIT_VAL, DIALOG_STYLE_INPUT, "{FFFFFF}Paintball - Edit", "{FFFFFF}What would you like to set the value of this to?\n\n"COL_RED"Your limit can not be less than the number of players joined already.", "Commit", "Back" );

				 	g_paintballData[ iLobby ] [ E_LIMIT ] = iLimit;
					SendClientMessageToPaintball( iLobby, -1, ""COL_GREY"[PAINTBALL]"COL_WHITE" The lobby player limit has been set to %d.", g_paintballData[ iLobby ] [ E_LIMIT ] );
				}
				case 3: // health
				{
					new Float: fHealth;

					if ( sscanf( inputtext, "f", fHealth ) )
				 		return ShowPlayerDialog( playerid, DIALOG_PAINTBALL_EDIT_VAL, DIALOG_STYLE_INPUT, "{FFFFFF}Paintball - Edit", "{FFFFFF}What would you like to set the value of this to?\n\n"COL_RED"Ensure the player capacity is a numerical number.", "Commit", "Back" );

					if ( fHealth < 1 || fHealth > 150 )
				 		return ShowPlayerDialog( playerid, DIALOG_PAINTBALL_EDIT_VAL, DIALOG_STYLE_INPUT, "{FFFFFF}Paintball - Edit", "{FFFFFF}What would you like to set the value of this to?\n\n"COL_RED"Please specify between 1 and 150 health.", "Commit", "Back" );

				 	g_paintballData[ iLobby ] [ E_HEALTH ] = fHealth;
					SendClientMessageToPaintball( iLobby, -1, ""COL_GREY"[PAINTBALL]"COL_WHITE" The lobby spawn health has been set to %0.2f.", g_paintballData[ iLobby ] [ E_HEALTH ] );

					respawnAllInPaintballLobby( iLobby );
				}
				case 4: // armour
				{
					new Float: fArmour;

					if ( sscanf( inputtext, "f", fArmour ) )
				 		return ShowPlayerDialog( playerid, DIALOG_PAINTBALL_EDIT_VAL, DIALOG_STYLE_INPUT, "{FFFFFF}Paintball - Edit", "{FFFFFF}What would you like to set the value of this to?\n\n"COL_RED"Ensure the player capacity is a numerical number.", "Commit", "Back" );

					if ( fArmour < 0 || fArmour > 150 )
				 		return ShowPlayerDialog( playerid, DIALOG_PAINTBALL_EDIT_VAL, DIALOG_STYLE_INPUT, "{FFFFFF}Paintball - Edit", "{FFFFFF}What would you like to set the value of this to?\n\n"COL_RED"Please specify between 0 and 150 armour.", "Commit", "Back" );

				 	g_paintballData[ iLobby ] [ E_ARMOUR ] = fArmour;
					SendClientMessageToPaintball( iLobby, -1, ""COL_GREY"[PAINTBALL]"COL_WHITE" The lobby spawn armour has been set to %0.2f.", g_paintballData[ iLobby ] [ E_ARMOUR ] );

					respawnAllInPaintballLobby( iLobby );
				}
			}
			showPaintBallLobbyData( playerid, iLobby );
		}
		else showPaintBallLobbyData( playerid, iLobby );
	}
	if ( dialogid == DIALOG_PAINTBALL_ARENAS )
	{
		new
			iLobby = p_PaintBallArena{ playerid };

		if ( response )
		{
			g_paintballData[ iLobby ] [ E_ARENA ] = listitem;
			SendClientMessageToPaintball( iLobby, -1, ""COL_GREY"[PAINTBALL]"COL_WHITE" The lobby arena has been set to %s.", g_paintballArenaData[ listitem ] [ E_NAME ] );
			respawnAllInPaintballLobby( iLobby );
			showPaintBallLobbyData( playerid, iLobby );
		}
		else showPaintBallLobbyData( playerid, iLobby );
	}
	if ( dialogid == DIALOG_PAINTBALL_WEP )
	{
		new
			iLobby = p_PaintBallArena{ playerid };

		if ( response )
		{
			if ( !listitem )
				g_paintballData[ iLobby ] [ E_WEAPONS ] [ GetPVarInt( playerid, "paintball_edititem" ) - 7 ] = 0;
			else
				g_paintballData[ iLobby ] [ E_WEAPONS ] [ GetPVarInt( playerid, "paintball_edititem" ) - 7 ] = 21 + listitem;

			SendClientMessageToPaintball( iLobby, -1, ""COL_GREY"[PAINTBALL]"COL_WHITE" The lobby weapon set has been%supdated.", " " );
			respawnAllInPaintballLobby( iLobby );
			showPaintBallLobbyData( playerid, iLobby );
		}
		else showPaintBallLobbyData( playerid, iLobby );
	}
	if ( ( dialogid == DIALOG_GPS ) && response )
	{
		if ( p_GPSToggled{ playerid } == true || !IsPlayerInAnyVehicle( playerid ) )
		    return SendError( playerid, "An error has occurred." ), 0;

	    for( new i, x = 0; i < sizeof( g_gpsData ); i++ )
		{
	        if ( g_gpsData[ i ] [ E_CREATED ] == true && g_gpsData[ i ] [ E_CITY ] == GetPVarInt( playerid, "gps_city" ) )
			{
		       	if ( x == listitem )
		      	{
					p_GPSLocation[ playerid ] = i;
			 		p_GPSObject[ playerid ] = CreateDynamicObject( 1318, 0.0, 0.0, 0.0, 0.0, 0.0, 0 );
					p_GPSTimer[ playerid ] = SetTimerEx( "gps_Update", 100, true, "d", playerid );
					p_GPSToggled{ playerid } = true;

					SendClientMessageFormatted( playerid, -1, ""COL_GREY"[GPS]"COL_WHITE" You have set your destination to %s. Follow the arrow to reach your destination.", g_gpsData[ i ] [ E_NAME ] );
					TextDrawShowForPlayer( playerid, p_GPSInformation[ playerid ] );
		      		break;
				}
		      	x++;
			}
		}
	}
	if ( ( dialogid == DIALOG_GPS_CITY ) && response )
	{
		if ( p_GPSToggled{ playerid } == true || !IsPlayerInAnyVehicle( playerid ) )
		    return SendError( playerid, "An error has occurred." ), 0;

	    new
	    	GPS[ sizeof( g_gpsData ) * 22 ];

	    for( new i; i < sizeof( g_gpsData ); i++ )
	    {
	        if ( g_gpsData[ i ] [ E_CREATED ] == true && g_gpsData[ i ] [ E_CITY ] == listitem )
	        	format( GPS, sizeof( GPS ), "%s%s\n", GPS, g_gpsData[ i ] [ E_NAME ] );
	    }

	    SetPVarInt( playerid, "gps_city", listitem );

	    ShowPlayerDialog( playerid, DIALOG_GPS, DIALOG_STYLE_LIST, "{FFFFFF}GPS - Navigator", GPS, "Select", "Cancel");
	}
	if ( ( dialogid == DIALOG_VIP_LOCKER ) && response )
	{
	    if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot use this while you're in jail." );
	    if ( IsPlayerInEvent( playerid ) ) return SendError( playerid, "You cannot use this while you're in an event." );
		if ( listitem == 0 )
		{
		 	if ( p_VIPLevel[ playerid ] < VIP_GOLD )
		     	return SendError( playerid, "You must be a GOLD V.I.P to acquire this." );

			if ( !IsPlayerInRangeOfPoint( playerid, 5.0, -1966.1591, 852.7100, 1214.2678 ) && !IsPlayerInRangeOfPoint( playerid, 5.0, -1944.1324, 830.0725, 1214.2678 ) && !IsPlayerInRangeOfPoint( playerid, 5.0, 60.3115, 121.5226, 1017.4534 ) )
				return SendError( playerid, "You must be near a gun vending machine inside the V.I.P lounge to use this." );

            if ( p_VIPArmourRedeem[ playerid ] > g_iTime && p_VIPLevel[ playerid ] < VIP_DIAMOND )
 				return SendError( playerid, "You must wait %d seconds to redeem another armour set again.", p_VIPArmourRedeem[ playerid ] - g_iTime );

			SetPlayerArmour( playerid, 100.0 );
			p_VIPArmourRedeem[ playerid ] = g_iTime + ( p_VIPLevel[ playerid ] == VIP_PLATINUM ? 60 : 300 );
			SendServerMessage( playerid, "You have redeemed an armour set." );
		}
		else
		{
		    if ( p_VIPWeaponRedeem[ playerid ] > g_iTime && p_VIPLevel[ playerid ] < VIP_PLATINUM )
		        return SendError( playerid, "You must wait %d seconds to redeem another weapon again.", p_VIPWeaponRedeem[ playerid ] - g_iTime );

		    new weaponid;
		    switch( listitem )
		    {
		    	case 1 .. 13: weaponid = 21 + listitem;
		    	case 14 .. 23: weaponid = listitem - 13;
		    	case 24 .. 25: weaponid = listitem - 10;
		    }
		    GivePlayerWeapon( playerid, weaponid, 0xFFFF );
		    SendServerMessage( playerid, "You have redeemed a %s.", ReturnWeaponName( weaponid ) );
			p_VIPWeaponRedeem[ playerid ] = g_iTime + 30;
		}
	}
	if ( ( dialogid == DIALOG_LUMBERJACK ) && response )
	{
	    if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "This feature is disabled if you are jailed." );
	    GivePlayerWeapon( playerid, 9, 1 );
		SendServerMessage( playerid, "Thank you for your participation, you have been given a chainsaw!" );
	}
	if ( ( dialogid == DIALOG_FIGHTSTYLE ) && response )
	{
		switch( listitem )
		{
			case 0:
			{
			    if ( GetPlayerFightingStyle( playerid ) == FIGHT_STYLE_KNEEHEAD )
			    {
			        SendError( playerid, "You already have this fighting style activated." );
			        return 1;
			    }
			    if ( GetPlayerCash( playerid ) < 1000 )
			    {
			        SendError( playerid, "You don't have enough money to learn this fighting style." );
			        return 1;
			    }
			    SetPlayerFightingStyle( playerid, FIGHT_STYLE_KNEEHEAD );
				format( szNormalString, sizeof( szNormalString ), "UPDATE `USERS` SET `FIGHTSTYLE`=%d WHERE `NAME` = '%s'", GetPlayerFightingStyle( playerid ), mysql_escape( ReturnPlayerName( playerid ) ) );
				mysql_single_query( szNormalString );
				GivePlayerCash( playerid, -1000 );
				SendServerMessage( playerid, "You have paid $1,000 and learnt "COL_ORANGE"Defending{FFFFFF}." );
			}
			case 1:
			{
			    if ( GetPlayerFightingStyle( playerid ) == FIGHT_STYLE_BOXING )
			    {
			        SendError( playerid, "You already have this fighting style activated." );
			        return 1;
			    }
			    if ( GetPlayerCash( playerid ) < 4000 )
			    {
			        SendError( playerid, "You don't have enough money to learn this fighting style." );
			        return 1;
			    }
			    SetPlayerFightingStyle( playerid, FIGHT_STYLE_BOXING );
				format( szNormalString, sizeof( szNormalString ), "UPDATE `USERS` SET `FIGHTSTYLE`=%d WHERE `NAME` = '%s'", GetPlayerFightingStyle( playerid ), mysql_escape( ReturnPlayerName( playerid ) ) );
				mysql_single_query( szNormalString );
				GivePlayerCash( playerid, -4000 );
				SendServerMessage( playerid, "You have paid $4,000 and learnt "COL_ORANGE"Boxing{FFFFFF}." );
			}
			case 2:
			{
			    if ( GetPlayerFightingStyle( playerid ) == FIGHT_STYLE_KUNGFU )
			    {
			        SendError( playerid, "You already have this fighting style activated." );
			        return 1;
			    }
			    if ( GetPlayerCash( playerid ) < 9000 )
			    {
			        SendError( playerid, "You don't have enough money to learn this fighting style." );
			        return 1;
			    }
			    SetPlayerFightingStyle( playerid, FIGHT_STYLE_KUNGFU );
				format( szNormalString, sizeof( szNormalString ), "UPDATE `USERS` SET `FIGHTSTYLE`=%d WHERE `NAME` = '%s'", GetPlayerFightingStyle( playerid ), mysql_escape( ReturnPlayerName( playerid ) ) );
				mysql_single_query( szNormalString );
				GivePlayerCash( playerid, -9000 );
				SendServerMessage( playerid, "You have paid $9,000 and learnt "COL_ORANGE"Kungfu{FFFFFF}." );
			}
		}
	}
	if ( ( dialogid == DIALOG_TOYS_MAIN ) && response )
	{
		if ( !listitem )
		{
			if ( !p_AttachedObjectsData[ playerid ] [ 0 ] [ E_ENABLED ] && !p_AttachedObjectsData[ playerid ] [ 1 ] [ E_ENABLED ] && !p_AttachedObjectsData[ playerid ] [ 2 ] [ E_ENABLED ] )
				return SendError( playerid, "All attached toys are already disabled." );

			format( szNormalString, sizeof( szNormalString ), "UPDATE `TOYS` SET `ENABLED`=0 WHERE `USER_ID`=%d", p_AccountID[ playerid ] );
			mysql_single_query( szNormalString );

			RemovePlayerAttachedObject( playerid, 9 );
			RemovePlayerAttachedObject( playerid, 8 );
			RemovePlayerAttachedObject( playerid, 7 );
			p_AttachedObjectsData[ playerid ] [ 0 ] [ E_ENABLED ] = 0;
			p_AttachedObjectsData[ playerid ] [ 1 ] [ E_ENABLED ] = 0;
			p_AttachedObjectsData[ playerid ] [ 2 ] [ E_ENABLED ] = 0;
			return SendServerMessage( playerid, "All attached toys have been disabled." );
		}

		p_ToySlotSelected{ playerid } = listitem - 1;
		if ( p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_BONE ] ) {
			showToyEditMenu( playerid, p_ToySlotSelected{ playerid } );
		} else {
          	ShowPlayerDialog( playerid, DIALOG_TOYS, DIALOG_STYLE_LIST, "{FFFFFF}Toys", getToyCategories( ), "Select", "Back" );
      	}
	}
	if ( ( dialogid == DIALOG_TOYS_ITEMS ) )
	{
	    if ( !response )
	    	return ShowPlayerDialog( playerid, DIALOG_TOYS, DIALOG_STYLE_LIST, "{FFFFFF}Toys", getToyCategories( ), "Select", "Back" );

		for( new id, x = 0; id < MAX_TOYS; id++ )
		{
			if ( g_ToyData[ id ] [ E_CATEGORY ] == p_ToyCategorySelected{ playerid } )
			{
		       	if ( x == listitem )
		      	{
		      		p_ToyIDSelected{ playerid } = id;

				    if ( g_ToyData[ id ] [ E_ID ] == -1 )
				    {
						showToyCategoryItems( playerid, p_ToyCategorySelected{ playerid } );

				    	if ( p_VIPLevel[ playerid ] < VIP_REGULAR )
				        	return SendError( playerid, "You must be a V.I.P to use this, to become one visit "COL_GREY"donate.irresistiblegaming.com" ), 1;

						if ( ( ( p_VIPExpiretime[ playerid ] - g_iTime ) / 86400 ) < 3 )
							return SendError( playerid, "You need more than 3 days of V.I.P in order to complete this." ), 1;
				    }

				    if ( g_ToyData[ id ] [ E_ID ] != -1 && !p_ToyUnlocked[ playerid ] { g_ToyData[ id ] [ E_ID ] } )
				    {
						showToyCategoryItems( playerid, p_ToyCategorySelected{ playerid } );
						return SendError( playerid, "You have not unlocked this toy." );
				    }

		      		SendServerMessage( playerid, "You have selected "COL_GREY"%s"COL_WHITE". Proceed with bone selection to place the toy.", g_ToyData[ id ] [ E_NAME ] );
		      		ShowPlayerDialog( playerid, DIALOG_TOYS_BONE, DIALOG_STYLE_LIST, "{FFFFFF}Toys - Bones", ""COL_GREY"Use Default Bone\nSpine\nHead\nLeft Upper Arm\nRight Upper Arm\nLeft Hand\nRight Hand\nLeft Thigh\nRight Thigh\nLeft Foot\nRight Foot\nRight Calf\nLeft Calf\nLeft Forearm\nRight Forearm\nLeft Clavicle\nRight Clavicle\nNeck\nJaw", "Select", "Back" );
					break;
		   		}
		      	x ++;
			}
		}
	}
	if ( ( dialogid == DIALOG_TOYS_ITEMS_BUY ) )
	{
	    if ( !response )
	    	return ShowPlayerDialog( playerid, DIALOG_TOYS_BUY, DIALOG_STYLE_LIST, "{FFFFFF}Purchase Toys", getToyCategories( .pawnshop = true ), "Select", "Cancel" );

		for( new id, x = 0; id < MAX_TOYS; id++ )
		{
			if ( g_ToyData[ id ] [ E_CATEGORY ] == p_ToyCategorySelected{ playerid } )
			{
		       	if ( x == listitem )
		      	{
				    if ( p_ToyUnlocked[ playerid ] { g_ToyData[ id ] [ E_ID ] } )
				    {
						showToyCategoryItems( playerid, p_ToyCategorySelected{ playerid }, .pawnshop = true );
						return SendError( playerid, "You have already bought this toy." );
				    }

		      		if ( GetPlayerCash( playerid ) < g_ToyData[ id ] [ E_PRICE ] )
		      		{
						showToyCategoryItems( playerid, p_ToyCategorySelected{ playerid }, .pawnshop = true );
						return SendError( playerid, "You cannot afford this toy." );
		      		}

				    unlockPlayerToy( playerid, g_ToyData[ id ] [ E_ID ] );
				    GivePlayerCash( playerid, -g_ToyData[ id ] [ E_PRICE ] );
					showToyCategoryItems( playerid, p_ToyCategorySelected{ playerid }, .pawnshop = true );
		      		SendServerMessage( playerid, "You have bought a "COL_GREY"%s"COL_WHITE" for "COL_GOLD"%s"COL_WHITE".", g_ToyData[ id ] [ E_NAME ], ConvertPrice( g_ToyData[ id ] [ E_PRICE ] ) );
		      		break;
		   		}
		      	x ++;
			}
		}
	}
	if ( dialogid == DIALOG_TOYS_BONE || dialogid == DIALOG_TOYS_BONE_EDIT )
	{
		new
			iSlot = p_ToySlotSelected{ playerid };

	    if ( !response && dialogid == DIALOG_TOYS_BONE )
			return showToyCategoryItems( playerid, p_ToyCategorySelected{ playerid } );

	    if ( !response && dialogid == DIALOG_TOYS_BONE_EDIT )
			return showToyEditMenu( playerid, iSlot );

	    if ( !listitem ) {
    		p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_BONE ] = g_ToyData[ p_ToyIDSelected{ playerid } ] [ E_DEFAULT_BONE ];
	        SendServerMessage( playerid, "You have now placed your toy on the default bone." );
	    }
	    else {
	        p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_BONE ] = listitem;
	        SendServerMessage( playerid, "You have now placed your toy on this bone." );
	    }

		RemovePlayerAttachedObject( playerid, 7 + iSlot );
	    SetPlayerAttachedObject( playerid, 7 + iSlot, g_ToyData[ p_ToyIDSelected{ playerid } ] [ E_MODEL ], p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_BONE ] );

	    p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_ENABLED ] = 1;
		p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_MODELID ] = g_ToyData[ p_ToyIDSelected{ playerid } ] [ E_MODEL ];

	    if ( dialogid == DIALOG_TOYS_BONE ) {
			format( szBigString, sizeof( szBigString ), "INSERT INTO `TOYS`(`USER_ID`,`SLOT_ID`,`ENABLED`,`MODEL_ID`,`BONE`) VALUES (%d,%d,1,%d,%d)", p_AccountID[ playerid ], iSlot, g_ToyData[ p_ToyIDSelected{ playerid } ] [ E_MODEL ], p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_BONE ] );
			mysql_function_query( dbHandle, szBigString, true, "OnPlayerAddToy", "dd", playerid, iSlot );
	    } else {
			format( szNormalString, sizeof( szNormalString ), "UPDATE `TOYS` SET `BONE`=%d,`OX`=0,`OY`=0,`OZ`=0,`RX`=0,`RY`=0,`RZ`=0,`SX`=1,`SY`=1,`SZ`=1 WHERE `ID`=%d", p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_BONE ], p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_SQL_ID ] );
			mysql_single_query( szNormalString );
	    }

		showToyEditMenu( playerid, iSlot );
	}
	if ( ( dialogid == DIALOG_TOYS_EDIT ) )
	{
		if ( !response )
			return cmd_toys( playerid, "" );

		switch( listitem )
		{
			case 0:
			{
				if ( !p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_ENABLED ] ) {
					SendError( playerid, "You cannot edit a disabled toy." );
					return showToyEditMenu( playerid, p_ToySlotSelected{ playerid } );
				}

			    EditAttachedObject( playerid, 7 + p_ToySlotSelected{ playerid } );
			    SendServerMessage( playerid, "You are now editing a toy." );
			}
			case 1:
			{
				if ( !p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_ENABLED ] ) {
					SendError( playerid, "You cannot reselect a bone of a disabled toy." );
					return showToyEditMenu( playerid, p_ToySlotSelected{ playerid } );
				}

				ShowPlayerDialog( playerid, DIALOG_TOYS_BONE_EDIT, DIALOG_STYLE_LIST, "{FFFFFF}Toys - Bones", ""COL_GREY"Use Default Bone\nSpine\nHead\nLeft Upper Arm\nRight Upper Arm\nLeft Hand\nRight Hand\nLeft Thigh\nRight Thigh\nLeft Foot\nRight Foot\nRight Calf\nLeft Calf\nLeft Forearm\nRight Forearm\nLeft Clavicle\nRight Clavicle\nNeck\nJaw", "Select", "Back" );
			    SendServerMessage( playerid, "You are now reselecting your toy's bone." );
			}
			case 2:
			{
				p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_ENABLED ] = !p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_ENABLED ];

				if ( !p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_ENABLED ] )
				{
					RemovePlayerAttachedObject( playerid, 7 + p_ToySlotSelected{ playerid } );
					SendServerMessage( playerid, "You have disabled this toy." );
				}
				else
				{
					RemovePlayerAttachedObject( playerid, 7 + p_ToySlotSelected{ playerid } ); // Just incase.
					SetPlayerAttachedObject( playerid, 7 + p_ToySlotSelected{ playerid }, p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_MODELID ], p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_BONE ],
						p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_OX ], p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_OY ], p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_OZ ],
						p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_RX ], p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_RY ], p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_RZ ],
						p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_SX ], p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_SY ], p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_SZ ]
					);
					SendServerMessage( playerid, "You have enabled this toy." );
				}

				format( szNormalString, sizeof( szNormalString ), "UPDATE `TOYS` SET `ENABLED`=%d WHERE `ID`=%d", p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_ENABLED ], p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_SQL_ID ] );
				mysql_single_query( szNormalString );

				showToyEditMenu( playerid, p_ToySlotSelected{ playerid } );
			}
			case 3:
			{
				RemovePlayerAttachedObject( playerid, 7 + p_ToySlotSelected{ playerid } );
			   	p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_BONE ] = 0;
				p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_MODELID ] = 0;

				format( szNormalString, sizeof( szNormalString ), "DELETE FROM `TOYS` WHERE `ID`=%d", p_AttachedObjectsData[ playerid ] [ p_ToySlotSelected{ playerid } ] [ E_SQL_ID ] );
				mysql_single_query( szNormalString );

				SendServerMessage( playerid, "You have removed this toy." );
				cmd_toys( playerid, "" );
			}
		}
	}
	if ( ( dialogid == DIALOG_TOYS ) ) {
		if ( !response )
			return cmd_toys( playerid, "" );

		p_ToyCategorySelected{ playerid } = listitem;
		showToyCategoryItems( playerid, listitem );
	}
	if ( ( dialogid == DIALOG_TOYS_BUY ) && response ) {
		p_ToyCategorySelected{ playerid } = listitem;
		showToyCategoryItems( playerid, listitem, .pawnshop = true );
	}
	if ( ( dialogid == DIALOG_VIP_WEP ) && response )
	{
	    if ( listitem == 1 && p_VIPLevel[ playerid ] < VIP_GOLD ) return SendError( playerid, "You can only use this slot if you are a "COL_GOLD"GOLD V.I.P{FFFFFF} or higher." );
	    if ( listitem == 2 && p_VIPLevel[ playerid ] < VIP_PLATINUM ) return SendError( playerid, "You can only use this slot if you are a "COL_PLATINUM"PLATINUM V.I.P{FFFFFF} or higher." );
	    ShowPlayerDialog( playerid, DIALOG_VIP_WEP_SELECT, DIALOG_STYLE_LIST, "{FFFFFF}Weapon Select", ""COL_RED"Remove Weapon On This Slot\n9mm Pistol\nSilenced Pistol\nDesert Eagle\nShotgun\nSawn-off Shotgun\nSpas 12\nMac 10\nMP5\nAK-47\nM4\nTec 9\nRifle\nSniper", "Select", "Cancel");
		p_VIPWep_Modify{ playerid } = listitem;
	}
	if ( dialogid == DIALOG_VIP_WEP_SELECT )
	{
	    if ( response )
	    {
	        if ( listitem == 0 )
	        {
	            switch( p_VIPWep_Modify{ playerid } )
				{
				    case 0: p_VIPWep1{ playerid } = 0, SendClientMessage( playerid, COLOR_GREY, "[SERVER]{FFFFFF} You have "COL_RED"removed"COL_WHITE" the weapon in the first slot." );
				    case 1: p_VIPWep2{ playerid } = 0, SendClientMessage( playerid, COLOR_GREY, "[SERVER]{FFFFFF} You have "COL_RED"removed"COL_WHITE" the weapon in the second slot." );
				    case 2: p_VIPWep3{ playerid } = 0, SendClientMessage( playerid, COLOR_GREY, "[SERVER]{FFFFFF} You have "COL_RED"removed"COL_WHITE" the weapon in the third slot." );
				}
				return 1;
	    	}
			new wep = 21 + listitem;
			switch( p_VIPWep_Modify{ playerid } )
			{
			    case 0: p_VIPWep1{ playerid } = wep;
			    case 1: p_VIPWep2{ playerid } = wep;
			    case 2: p_VIPWep3{ playerid } = wep;
			}
		    SendServerMessage( playerid, "You have selected a "COL_GREY"%s"COL_WHITE" for your %s slot.", ReturnWeaponName( wep ), p_VIPWep_Modify{ playerid } == 0 ? ("first") : ( p_VIPWep_Modify{ playerid } == 1 ? ("second") : ("third") )  );
	    }
	    else cmd_vipspawnwep( playerid, "" );
	}
	if ( ( dialogid == DIALOG_CMDS ) && response )
	{
	    static szCMDS[ 1920 ];
	    switch( listitem )
	    {
	        case 0:
	        {
	            szCMDS[ 0 ] = '\0';
	            strcat( szCMDS, ""COL_GREY"/help{FFFFFF} - Displays the general help information of the server.\n"\
								""COL_GREY"/rules{FFFFFF} - Displays the server rules.\n"\
								""COL_GREY"/commands{FFFFFF} - Displays a list of all the server commands.\n"\
								""COL_GREY"/report{FFFFFF} - Sends a report to the in-game administrators.\n"\
								""COL_GREY"/ask{FFFFFF} - Sends a question (must be game/server-related) to the in-game admins.\n" );
				strcat( szCMDS, ""COL_GREY"/admins{FFFFFF} - Displays the current online administrators.\n"\
								""COL_GREY"/vip{FFFFFF} - View the list of VIP packages for this server.\n"\
								""COL_GREY"/donated{FFFFFF} - Redeem VIP after donating with a transaction id.\n"\
								""COL_GREY"/gettaxrate{FFFFFF} - See what the tax rate is currently set to.\n"\
								""COL_GREY"/gettotalcash{FFFFFF} - View the total sum of money in the server.\n" );
				strcat( szCMDS, ""COL_GREY"/calc(ulator){FFFFFF} - Calculate mathematical expressions in-game.\n"\
								""COL_GREY"/eventbank{FFFFFF} - Help fund events by donating to the event bank.\n"\
								""COL_GREY"/cnr{FFFFFF} - Shows the cops and robbers balance in the server.\n"\
								""COL_GREY"/playerjobs{FFFFFF} - Display the players using a particular job/skill.\n" );
				strcat( szCMDS, ""COL_GREY"/policetutorial{FFFFFF} - Allows you to retake the law enforcement tutorial.\n"\
								""COL_GREY"/idletime{FFFFFF} - Shows the time of the last sent update by a player.\n"\
								""COL_GREY"/rank{FFFFFF} - View your or someone's current global rank in the server." );

				ShowPlayerDialog( playerid, DIALOG_CMDS_REDIRECT, DIALOG_STYLE_MSGBOX, "{FFFFFF}Basic Commands", szCMDS, "Okay", "Back" );
	        }
	        case 1:
	        {
	            szCMDS[ 0 ] = '\0';
	            strcat( szCMDS,	""COL_GOLD"General Commands\n\n"\
								""COL_GREY"/sendmoney{FFFFFF} - Sends money to another in-game player.\n"\
								""COL_GREY"/gps{FFFFFF} - Toggles GPS to locate important locations inside the server.\n"\
								""COL_GREY"/controlpanel{FFFFFF} - Displays your control panel.\n"\
								""COL_GREY"/request{FFFFFF} - Request for a specific-job person.\n"\
								""COL_GREY"/fps{FFFFFF} - Displays your frame rate.\n" );
	            strcat( szCMDS, ""COL_GREY"/getmytax{FFFFFF} - See how much tax you may need to pay.\n"\
								""COL_GREY"/packetloss{FFFFFF} - View your packet loss to the server.\n"\
								""COL_GREY"/unbanme{FFFFFF} - Pay your way out of a class ban.\n"\
								""COL_GREY"/chuffloc{FFFFFF} - Display the location of the ChuffSec security van.\n"\
								""COL_GREY"/richlist{FFFFFF} - Displays the three most richest players in-game.\n\n" );
                strcat( szCMDS,	""COL_GOLD"Account Commands\n\n"\
								""COL_GREY"/stats{FFFFFF} - Displays your statistics.\n"\
								""COL_GREY"/savestats{FFFFFF} - Saves your current statistics.\n"\
								""COL_GREY"/achievements{FFFFFF} - Displays achievements you can unlock.\n"\
								""COL_GREY"/myaccid{FFFFFF} - Shows your account ID.\n"\
								""COL_GREY"/changepassword{FFFFFF} - Changes your current password to a new one.\n"\
								""COL_GREY"/xpmarket{FFFFFF} - Allows you to trade some XP to in-game money.\n\n" );
                strcat( szCMDS,	""COL_GOLD"Information Commands\n\n"\
								""COL_GREY"/idof{FFFFFF} - Displays the specified player's ID and their username.\n"\
								""COL_GREY"/lastlogged{FFFFFF} - Shows the last played time of a user.\n"\
								""COL_GREY"/animlist{FFFFFF} - Shows the animation list.\n"\
								""COL_GREY"/jaillist{FFFFFF} - Shows the jailed player list.\n"\
								""COL_GREY"/twitter{FFFFFF} - Shows the latest tweets from @IrresistibleDev\n" );
                strcat( szCMDS, ""COL_GREY"/weeklytime{FFFFFF} - Shows the weekly time of a player.\n\n" );
                strcat( szCMDS, ""COL_GOLD"Communication Commands\n\n"\
								""COL_GREY"/me{FFFFFF} - Sends a message based action with yourself.\n"\
								""COL_GREY"/pm{FFFFFF} - Sends a private message to a specified player.\n"\
								""COL_GREY"/r{FFFFFF} - Responds to the latest person you messaged.\n"\
								""COL_GREY"/dnd(all){FFFFFF} - Toggles access of receiving PM's from a specified/or all player(s).\n"\
								""COL_GREY"/ircpm{FFFFFF} - Sends a message to the IRC channel.\n" );
                strcat( szCMDS, ""COL_GREY"/(w)hisper{FFFFFF} - Whisper to nearby players." );

				ShowPlayerDialog( playerid, DIALOG_CMDS_REDIRECT, DIALOG_STYLE_MSGBOX, "{FFFFFF}Main Commands", szCMDS, "Okay", "Back" );
	        }
	        case 2:
	        {
	            szCMDS[ 0 ] = '\0';
	            strcat( szCMDS, ""COL_GOLD"General Civilian Commands\n\n"\
								""COL_GREY"/rob{FFFFFF} - Robs the closest player.\n"\
								""COL_GREY"/rape{FFFFFF} - Rapes the closest player.\n"\
								""COL_GREY"/robstore{FFFFFF} - Displays the key to press in-order to rob a store.\n"\
								""COL_GREY"/pdjail{FFFFFF} - Displays the time until jail cells are available for raiding.\n"\
								""COL_GREY"/banks{FFFFFF} - Displays the time until certain banks are available for robbing.\n" );
				strcat( szCMDS, ""COL_GREY"/stoprob{FFFFFF} - Stops your current robbery.\n"\
								""COL_GREY"/job{FFFFFF} - Shows your job.\n"\
								""COL_GREY"/911{FFFFFF} - Calls the emergency services.\n"\
								""COL_GREY"/placehit{FFFFFF} - Places a hit on a specified player.\n"\
								""COL_GREY"/viewguns{FFFFFF} - Displays weapons that can be purchased from a weapon dealer.\n" );
				strcat( szCMDS, ""COL_GREY"/payticket{FFFFFF} - Pays the issued ticket by a Law Enforcement Officer.\n"\
								""COL_GREY"/takeover{FFFFFF} - Take over a gangzone with your gang.\n" );
                strcat( szCMDS, ""COL_GREY"/gang{FFFFFF} - Displays gang commands.\n\n"\
								""COL_GOLD"Job Commands\n\n"\
								""COL_ORANGE"Rapist{FFFFFF} - /rape\n"\
								""COL_ORANGE"Kidnapper{FFFFFF} - /(un)tie, /kidnap, /ransom(pay)\n"\
								""COL_ORANGE"Terrorist{FFFFFF} - /c4\n" );
				strcat( szCMDS, ""COL_ORANGE"Hitman{FFFFFF} - /(hide)tracker, /hitlist\n"\
								""COL_ORANGE"Prostitute{FFFFFF} - /blowjob, /robitems\n"\
								""COL_ORANGE"Weapon Dealer{FFFFFF} - /sellgun\n"\
								""COL_ORANGE"Drug Dealer{FFFFFF} - /weed\n" );
				strcat( szCMDS, ""COL_ORANGE"Dirty Mechanic{FFFFFF} - /mech\n"\
								""COL_ORANGE"Burglar{FFFFFF} - /burglar\n"\
								""COL_PINK"Lumberjack Minijob{FFFFFF} - /wood\n"\
								""COL_PINK"Meth Production Minijob{FFFFFF} - /meth\n"\
								""COL_PINK"Mining Minijob{FFFFFF} - /ore\n" );
				strcat( szCMDS, ""COL_PINK"Trucking Minijob{FFFFFF} - /work" );
				ShowPlayerDialog( playerid, DIALOG_CMDS_REDIRECT, DIALOG_STYLE_MSGBOX, "{FFFFFF}Civilian Commands", szCMDS, "Okay", "Back" );
	        }
	        case 3:
	        {
	            szCMDS[ 0 ] = '\0';
	            strcat( szCMDS, ""COL_GREY"/shop{FFFFFF} - Displays the shop menu whilst in Supa Save.\n"\
								""COL_GREY"/tie{FFFFFF} - Ties the closest player with your rope(s).\n"\
								""COL_GREY"/untie{FFFFFF} - Unties the closest player.\n" );
				strcat( szCMDS, ""COL_GREY"/cuttie{FFFFFF} - Cuts your tie currently on you.\n"\
								""COL_GREY"/breakout{FFFFFF} - Breaks out the jail by melting the cell bars using a Metal Melter.\n"\
								""COL_GREY"/breakcuff{FFFFFF} - Unlocks the handcuffs placed by a LEO using a bobby pin." );
				ShowPlayerDialog( playerid, DIALOG_CMDS_REDIRECT, DIALOG_STYLE_MSGBOX, "{FFFFFF}Shop/Item Commands", szCMDS, "Okay", "Back" );
	        }
	        case 4:
	        {
	            szCMDS[ 0 ] = '\0';
	            strcat( szCMDS, ""COL_GOLD"General LEO Commands\n\n"\
								""COL_GREY"/arrest{FFFFFF} - Arrests a specificed player.\n"\
								""COL_GREY"/(un)cuff{FFFFFF} - (un)cuffs a specified player.\n"\
								""COL_GREY"/taze{FFFFFF} - Tazes a specified player.\n"\
								""COL_GREY"/ticket{FFFFFF} - Tickets a specified player.\n" );
				strcat( szCMDS, ""COL_GREY"/issuewarrant{FFFFFF} - Warrants a specified player.\n"\
								""COL_GREY"/location{FFFFFF} - Displays the located of a specified player.\n"\
								""COL_GREY"/backup{FFFFFF} - Calls your team for backup.\n"\
								""COL_GREY"/pullover{FFFFFF} - Asks a specified player to pull over.\n"\
								""COL_GREY"/detain{FFFFFF} - Detains the closest cuffed player.\n" );
                strcat( szCMDS, ""COL_GREY"/search{FFFFFF} - Searches a player for any drugs and issues a warrant on them.\n"\
								""COL_GREY"/bail{FFFFFF} - Bails a person for money out of jail.\n"\
								""COL_GREY"/getwanted{FFFFFF} - Obtain a suspect's wanted level.\n\n"\
								""COL_GOLD"Special LEO Commands\n\n"\
								""COL_GREY"/crb{FFFFFF} - Creates a roadblock.\n" );
                strcat( szCMDS, ""COL_GREY"/drb{FFFFFF} - Destroys a specified roadblock id.\n"\
								""COL_GREY"/drball{FFFFFF} - Removes all roadblocks.\n"\
								""COL_GREY"/spike{FFFFFF} - Sets a spike set.\n"\
								""COL_GREY"/dss{FFFFFF} - Destroys a specified spike set id.\n"\
								""COL_GREY"/dssall{FFFFFF} - Removes all spike sets.\n"\
								""COL_GREY"/emp{FFFFFF} - Shuts down the engine of a driver's vehicle.\n"\
								""COL_GREY"/bruteforce{FFFFFF} - Brute forces a houses' password." );
				ShowPlayerDialog( playerid, DIALOG_CMDS_REDIRECT, DIALOG_STYLE_MSGBOX, "{FFFFFF}Police Commands", szCMDS, "Okay", "Back" );
	        }
	        case 5: {
				ShowPlayerDialog( playerid, DIALOG_CMDS_REDIRECT, DIALOG_STYLE_MSGBOX, "{FFFFFF}Fireman Commands", ""COL_GREY"/firetracker"COL_WHITE" - Displays a tracker of active fires in a list.\n"COL_GREY"/rfiretracker"COL_WHITE" - Hides the fire tracker.", "Okay", "Back" );
	        }
	        case 6: {
				ShowPlayerDialog( playerid, DIALOG_CMDS_REDIRECT, DIALOG_STYLE_MSGBOX, "{FFFFFF}Paramedic Commands", ""COL_GREY"/heal"COL_WHITE" - Offers a specified player a health refill for $750.\n"COL_GREY"/cure"COL_WHITE" - Offers a specified player a cure for $4875.", "Okay", "Back" );
	        }
	        case 7:
	        {
	            szCMDS[ 0 ] = '\0';
	            strcat( szCMDS, ""COL_GOLD"General Vehicle Commands\n\n"\
								""COL_GREY"/eject{FFFFFF} - Ejects a specified player.\n"\
								""COL_GOLD"Owned Vehicle Commands\n\n" );
				strcat( szCMDS, ""COL_GREY"/v{FFFFFF} - Shows the commands for buyable vehicles.\n"\
								""COL_GREY"/v reset{FFFFFF} - Resets a vehicles modification data.\n"\
								""COL_GREY"/v park{FFFFFF} - Parks the vehicle at your marked position.\n"\
								""COL_GREY"/v respawn{FFFFFF} - Respawns the vehicle to the location where he parked it.\n" );
				strcat( szCMDS, ""COL_GREY"/v locate{FFFFFF} - Enables the tracker in the map to locate the player's owned vehicle.\n"\
								""COL_GREY"/v color{FFFFFF} - Modifies the color of the vehicle.\n"\
								""COL_GREY"/v paintjob{FFFFFF} - Applies a paintjob to the vehicle.\n"\
								""COL_GREY"/v sell{FFFFFF} - Sells the vehicle to 50% of its original price (requires the player to be inside it)." );
				ShowPlayerDialog( playerid, DIALOG_CMDS_REDIRECT, DIALOG_STYLE_MSGBOX, "{FFFFFF}Vehicle Commands", szCMDS, "Okay", "Back" );
	        }
     		case 8:
	        {
	            szCMDS[ 0 ] = '\0';
	            strcat( szCMDS, ""COL_GREY"/h{FFFFFF} - Shows the commands for buyable houses.\n"\
								""COL_GREY"/h buy{FFFFFF} - Purchases a buyable house (must be in the house entrance checkpoint).\n"\
								""COL_GREY"/h config{FFFFFF} - Configures some house settings. (Requires the player to be inside the house).\n" );
				strcat( szCMDS, ""COL_GREY"/h spawn{FFFFFF} - Spawns you at your house after each death.\n"\
								""COL_GREY"/h sell{FFFFFF} - Sells the house to 50% of its original price (requires the player to be inside the house)." );
				ShowPlayerDialog( playerid, DIALOG_CMDS_REDIRECT, DIALOG_STYLE_MSGBOX, "{FFFFFF}House Commands", szCMDS, "Okay", "Back" );
	        }
	        case 9:
	        {
	            szCMDS[ 0 ] = '\0';
	            strcat( szCMDS, ""COL_GREY"/perks{FFFFFF} - A menu where you can benefit your gameplay and waste some XP.\n"\
								""COL_GREY"/toys{FFFFFF} - Adds attachable objects to the player (requires 500 score).\n"\
								""COL_GREY"/label{FFFFFF} - Places a message above your head (must have over 3,500 XP).\n"\
								""COL_GREY"/labelcolor{FFFFFF} - Change your label's color.\n"\
								""COL_GREY"/rlabel{FFFFFF} - Removes the label on your head.\n" );
				strcat( szCMDS, ""COL_GREY"/labelinfo{FFFFFF} - Displays your label text with the 32 character limit.\n"\
								""COL_GREY"/radio{FFFFFF} - Shows the list of radio stations you can listen to.\n"\
								""COL_GREY"/stopradio{FFFFFF} - Stops the radio from playing.\n"\
								""COL_GREY"/moviemode{FFFFFF} - Toggles movie mode so you can record without all the text on the screen." );
				ShowPlayerDialog( playerid, DIALOG_CMDS_REDIRECT, DIALOG_STYLE_MSGBOX, "{FFFFFF}Miscellaneous Commands", szCMDS, "Okay", "Back" );
	        }
	        case 10:
	        {
				if ( p_VIPLevel[ playerid ] < VIP_REGULAR ) return SendError( playerid, "You are not a V.I.P, to become one visit "COL_GREY"donate.irresistiblegaming.com" );
				cmd_vipcmds( playerid, "" );
	        }
	    }
	    return 1;
	}
	if ( ( dialogid == DIALOG_CMDS_REDIRECT ) && !response ) { cmd_cmds( playerid, "" ); }
	if ( ( dialogid == DIALOG_STATS ) && response )
	{
	    new pID = p_ViewingStats[ playerid ], gangid = p_GangID[ pID ];
		switch( listitem )
		{
			case 0:
			{
				new
					vipSeconds = p_VIPExpiretime[ pID ] - g_iTime;

			    format( szLargeString, 750, ""COL_GREY"Name:{FFFFFF} %s(%d)\n"\
											""COL_GREY"Account ID:{FFFFFF} %d\n"\
											""COL_GREY"Admin Level:{FFFFFF} %d\n"\
											""COL_GREY"Time Online:{FFFFFF} %s\n"\
											""COL_GREY"Irresistible Rank:{FFFFFF} %s\n"\
											""COL_GREY"Irresistible Coins:{FFFFFF} %f\n", ReturnPlayerName( pID ), pID, p_AccountID[ pID ], p_AdminLevel[ pID ], secondstotime( p_Uptime[ pID ] ), g_aPlayerRanks[ GetPlayerRank( pID ) ] [ E_NAME ], p_IrresistibleCoins[ pID ] );

				format( szLargeString, 750, "%s"COL_GREY"V.I.P Level:{FFFFFF} %s\n"\
											""COL_GREY"V.I.P Expiry:{FFFFFF} %s\n"\
											""COL_GREY"Cop Warns:{FFFFFF} %d/" #MAX_CLASS_BAN_WARNS "\n"\
											""COL_GREY"Army Warns:{FFFFFF} %d/" #MAX_CLASS_BAN_WARNS "\n"\
											""COL_GREY"V.I.P Job:{FFFFFF} %s\n"\
											""COL_GREY"Current Job:{FFFFFF} %s",
											szLargeString, VIPToString( p_VIPLevel[ pID ] ), vipSeconds > 0 ? secondstotime( vipSeconds ) : ( "N/A" ), p_CopBanned{ pID }, p_ArmyBanned{ pID }, p_VIPLevel[ pID ] < 5 ? ( "N/A" ) : GetJobName( p_VIPJob{ pID } ), GetJobName( p_Job{ pID } ) );

				if ( gangid != -1 ) {
					format( szLargeString, 750, "%s\n"COL_GREY"Gang:"COL_WHITE" %s(%d)", szLargeString, g_gangData[ gangid ] [ E_NAME ], gangid );
				}

				ShowPlayerDialog( playerid, DIALOG_STATS_REDIRECT, DIALOG_STYLE_MSGBOX, "{FFFFFF}General Statistics", szLargeString, "Okay", "Back" );
			}
			case 1:
			{
				format( szLargeString, 720,	""COL_GREY"Score:{FFFFFF} %d\n"\
											""COL_GREY"XP:{FFFFFF} %d\n"\
											""COL_GREY"Money:{FFFFFF} %s\n"\
											""COL_GREY"Bank Money:{FFFFFF} %s\n"\
											""COL_GREY"Kills:{FFFFFF} %d\n"\
											""COL_GREY"Deaths:{FFFFFF} %d\n"\
											""COL_GREY"Ratio (K/D):{FFFFFF} %0.2f\n",
											GetPlayerScore( pID ), p_XP[ pID ], ConvertPrice( GetPlayerCash( pID ) ), ConvertPrice( p_BankMoney[ pID ] ), p_Kills[ pID ], p_Deaths[ pID ], floatdiv( p_Kills[ pID ], p_Deaths[ pID ] ) );

				format( szLargeString, 720,	"%s"COL_GREY"Owned Houses:{FFFFFF} %d (Limit %d)\n"\
				                          	""COL_GREY"Owned Vehicles:{FFFFFF} %d (Limit %d)\n"\
				                          	""COL_GREY"Total Arrests:{FFFFFF} %d\n"\
				                          	""COL_GREY"Total Robberies:{FFFFFF} %d\n"\
				                          	""COL_GREY"Total Extinguished Fires:{FFFFFF} %d\n"\
				                          	""COL_GREY"Total Completed Hits:{FFFFFF} %d\n"\
				                          	""COL_GREY"Total Burglaries:{FFFFFF} %d\n",
											szLargeString, p_OwnedHouses[ pID ], getPlayerHouseCapacity( pID ), p_OwnedVehicles[ pID ], getPlayerVehicleCapacity( pID ), p_Arrests[ pID ], p_Robberies[ pID ], p_Fires[ pID ], p_HitsComplete[ pID ], p_Burglaries[ pID ] );

				format( szLargeString, 720,	"%s"COL_GREY"Total Jail Raids:{FFFFFF} %d\n"\
				                          	""COL_GREY"Total Bank Raids:{FFFFFF} %d\n"\
				                          	""COL_GREY"Total Cars Jacked:{FFFFFF} %d\n"\
				                          	""COL_GREY"Total Trucked Cargo:{FFFFFF} %d\n"\
				                          	""COL_GREY"Total Meth Yielded:{FFFFFF} %d",
											szLargeString, p_JailsBlown[ pID ], p_BankBlown[ pID ], p_CarsJacked[ pID ], p_TruckedCargo[ pID ], p_MethYielded[ pID ] );

				ShowPlayerDialog( playerid, DIALOG_STATS_REDIRECT, DIALOG_STYLE_MSGBOX, "{FFFFFF}Main Statistics", szLargeString, "Okay", "Back" );
			}
			case 2:
			{
				new
					Float: fDrill = float( p_drillStrength[ playerid ] ) / float( MAX_DRILL_STRENGTH ) * 100.0;

				format( szLargeString, 512, ""COL_GREY"Thermal Drill:{FFFFFF} %0.0f%%\n"\
											""COL_GREY"Ropes:{FFFFFF} %d\n"\
											""COL_GREY"Metal Melters:{FFFFFF} %d\n"\
											""COL_GREY"Scissors:{FFFFFF} %d\n"\
											""COL_GREY"Weed:{FFFFFF} %d gram(s)\n"\
											""COL_GREY"Meth:{FFFFFF} %d pounds\n"\
											""COL_GREY"Money Case:{FFFFFF} %s\n",
											fDrill, p_Ropes[ pID ], p_MetalMelter[ pID ], p_Scissors[ pID ], p_WeedGrams[ pID ], p_Methamphetamine{ pID }, p_MoneyBag{ pID } == true ? ( "Yes" ) : ( "No" ) );

				format( szLargeString, 512, "%s"COL_GREY"Aluminium Foil:{FFFFFF} %d\n"\
											""COL_GREY"Secure Wallet:{FFFFFF} %s\n"\
											""COL_GREY"Bobby Pins:{FFFFFF} %d\n"\
											""COL_GREY"C4:{FFFFFF} %d\n"\
											""COL_GREY"Chastity Belt:{FFFFFF} %s\n"\
											""COL_GREY"Caustic Soda:{FFFFFF} %d\n"\
											""COL_GREY"Muriatic Acid:{FFFFFF} %d\n"\
											""COL_GREY"Hydrogen Chloride:{FFFFFF} %d\n",
											szLargeString, p_AntiEMP[ pID ], p_SecureWallet{ pID } == true ? ( "Yes" ) : ( "No" ), p_BobbyPins[ pID ], p_C4Amount[ pID ], p_AidsVaccine{ pID } == true ? ("Yes") : ("No"),
											p_CausticSoda{ pID }, p_MuriaticAcid{ pID }, p_HydrogenChloride{ pID } );
				ShowPlayerDialog( playerid, DIALOG_STATS_REDIRECT, DIALOG_STYLE_MSGBOX, "{FFFFFF}Item Statistics", szLargeString, "Okay", "Back" );
			}
			case 3: displayStreaks( pID, DIALOG_STATS_REDIRECT, "Back", playerid );
			case 4: displayAchievements( pID, DIALOG_STATS_REDIRECT, "Back", playerid );
		}
	}
	if ( ( dialogid == DIALOG_STATS_REDIRECT ) && !response ) {
		ShowPlayerDialog( playerid, DIALOG_STATS, DIALOG_STYLE_LIST, "{FFFFFF}Statistics", "General Statistics\nGame Statistics\nItem Statistics\nStreak Statistics\nAchievements", "Okay", "Cancel" );
	}
	if ( ( dialogid == DIALOG_VEHDEALER ) && response ) {
		ShowBuyableVehiclesTypeDialog( playerid, listitem + 1 );
	}
	if ( dialogid == DIALOG_VEHDEALER_BUY )
	{
		if ( response )
		{
			new
				x = 0; // Error check

			for( new id; id < sizeof( g_BuyableVehicleData ); id ++ )
			{
				if ( g_BuyableVehicleData[ id ] [ E_TYPE ] == GetPVarInt( playerid, "vehicle_preview" ) )
				{
			       	if ( x == listitem )
			      	{
			      		SetPVarInt( playerid, "buying_vehicle", id );
			      		ShowPlayerDialog( playerid, DIALOG_VEHDEALER_OPTIONS, DIALOG_STYLE_LIST, "{FFFFFF}Vehicle Dealership", "Purchase This Vehicle\nPreview Vehicle", "Select", "Back" );
			      		return 1;
					}
			      	x++;
				}
			}

			ShowBuyableVehiclesList( playerid ), SendError( playerid, "An error has occurred. (0x68F)");
		}
		else ShowBuyableVehiclesList( playerid );
	}
	if ( dialogid == DIALOG_VEHDEALER_OPTIONS )
	{
		if ( !response )
			return ShowBuyableVehiclesTypeDialog( playerid, GetPVarInt( playerid, "vehicle_preview" ) ), 1;

		switch( listitem )
		{
			case 0:
			{
				new
					data_id = GetPVarInt( playerid, "buying_vehicle" ),
					model = g_BuyableVehicleData[ data_id ] [ E_MODEL ]
				;
			    if ( hasTooManyVehicles( playerid ) ) return SendError( playerid, "You have reached the limit of purchasing vehicles." );
				if ( GetPlayerScore( playerid ) < 200 ) return SendError( playerid, "You need at least 200 score to buy a vehicle." );
				if ( GetPlayerCash( playerid ) < g_BuyableVehicleData[ data_id ] [ E_PRICE ] ) return SendError( playerid, "You don't have enough money for this vehicle." );

				// VIP Check
				if ( g_BuyableVehicleData[ data_id ] [ E_VIP ] )
				{
					if ( p_VIPLevel[ playerid ] < VIP_REGULAR )
						return SendError( playerid, "You are not a V.I.P, to become one visit "COL_GREY"donate.irresistiblegaming.com" );

					if ( ( ( p_VIPExpiretime[ playerid ] - g_iTime ) / 86400 ) < 3 )
						return SendError( playerid, "You need more than 3 days of V.I.P in order to complete this." );
				}

		        new Float: X, Float: Y, Float: Z, Float: fA;

		        #if ENABLE_CITY_LV == true
		        if ( IsPlayerInDynamicCP( playerid, g_Checkpoints[ CP_VEHDEALER_2 ] ) )
		        {
					if ( IsBoatVehicle( model ) ) 		X = 1633.71860, Y = 563.73600, Z = -0.0579, fA = 90.00000;
					else if ( IsAirVehicle( model ) ) 	X = 1477.43920, Y = 1761.4778, Z = 11.2735, fA = 180.9139;
			        else               	 				X = 1986.85240, Y = 2049.2278, Z = 10.8203, fA = 132.5364;
		        }
		        else if ( IsPlayerInDynamicCP( playerid, g_Checkpoints[ CP_VEHDEALER_3 ] ) )
		        {
					if ( IsBoatVehicle( model ) ) 		X = 728.4574, Y = -1516.2633, Z = 0.3122, fA = 178.5724;
					else if ( IsAirVehicle( model ) ) 	X = 2048.7910, Y = -2493.8928, Z = 14.4686, fA = 90.00000;
			        else               	 				X = 560.9333, Y = -1267.5469, Z = 16.9957, fA = 17.2539;
		        }
		        else
		        #else
		        if ( playerid != INVALID_PLAYER_ID )
		        #endif
		        {
					if ( IsBoatVehicle( model ) ) 		X = -2686.6484, Y = -938.5189, Z = -0.1212, fA = 109.4955;
					else if ( IsAirVehicle( model ) ) 	X = -1666.2905, Y = -173.4397, Z = 15.0692, fA = 314.6289;
			        else               	 				X = -2518.9045, Y = -614.8578, Z = 132.302, fA = 267.8874;
			  	}

		        SetPlayerInterior( playerid, 0 );
		        SetPlayerVirtualWorld( playerid, 0 );

		        X += fRandomEx( 0, 1 );
		        Z += 3; // Just plane jams or someshit...

			   	new bID = CreateBuyableVehicle( playerid, model, random( 126 ), random( 126 ), X, Y, Z, fA, g_BuyableVehicleData[ data_id ] [ E_PRICE ] );
				if ( bID == -1 ) return SendClientMessage( playerid, -1, ""COL_GREY"[VEHICLE]"COL_WHITE" Unable to create a vehicle due to a unexpected error." );
				GivePlayerCash( playerid, -g_BuyableVehicleData[ data_id ] [ E_PRICE ], .force_save = true );

		        GetVehicleParamsEx( g_vehicleData[ playerid ] [ bID ] [ E_VEHICLE_ID ], engine, lights, alarm, doors, bonnet, boot, objective );
				SetVehicleParamsEx( g_vehicleData[ playerid ] [ bID ] [ E_VEHICLE_ID ], VEHICLE_PARAMS_ON, lights, alarm, doors, bonnet, boot, objective );
				PutPlayerInVehicle( playerid, g_vehicleData[ playerid ] [ bID ] [ E_VEHICLE_ID ], 0 );

				SendServerMessage( playerid, "You have bought an "COL_GREY"%s"COL_WHITE" for "COL_GOLD"%s"COL_WHITE"!", g_BuyableVehicleData[ data_id ] [ E_NAME ], ConvertPrice( g_BuyableVehicleData[ data_id ] [ E_PRICE ] )  );
				ShowPlayerDialog( playerid, DIALOG_BOUGHT_VEH, DIALOG_STYLE_MSGBOX, "{FFFFFF}You've purchased a vehicle!", "{FFFFFF}Glad to see you've purchased a vehicle. Please ensure you read:\n\n* Vehicles are kept until you sell them or go two months inactive. This is not refundable.\n* Do not mispark your vehicle or it can be removed/impounded.\n* Check out /v for vehicle commands.\n* Find an acceptable place to park your new vehicle such as your house or a parking lot.", "Okay", "" );
				SetPVarInt( playerid, "bought_veh_ts", g_iTime + 30 );
			}
			case 1:
			{
				new model = g_BuyableVehicleData[ GetPVarInt( playerid, "buying_vehicle" ) ] [ E_MODEL ];

				p_VehiclePreviewTD[ 0 ] = CreatePlayerTextDraw(playerid,289.000000, 230.000000, "preview 2");
				PlayerTextDrawBackgroundColor(playerid,p_VehiclePreviewTD[ 0 ], 112);
				PlayerTextDrawFont(playerid,p_VehiclePreviewTD[ 0 ], 5);
				PlayerTextDrawLetterSize(playerid,p_VehiclePreviewTD[ 0 ], 0.500000, 4.400000);
				PlayerTextDrawColor(playerid,p_VehiclePreviewTD[ 0 ], -1);
				PlayerTextDrawUseBox(playerid,p_VehiclePreviewTD[ 0 ], 1);
				PlayerTextDrawBoxColor(playerid,p_VehiclePreviewTD[ 0 ], 0);
				PlayerTextDrawTextSize(playerid,p_VehiclePreviewTD[ 0 ], 60.000000, 60.000000);
				PlayerTextDrawSetPreviewModel(playerid, p_VehiclePreviewTD[ 0 ], model);
				PlayerTextDrawSetPreviewRot(playerid, p_VehiclePreviewTD[ 0 ], -16.000000, 0.000000, 0.000000, 1.000000);
				PlayerTextDrawSetSelectable(playerid,p_VehiclePreviewTD[ 0 ], 0);

				p_VehiclePreviewTD[ 1 ] = CreatePlayerTextDraw(playerid,358.000000, 160.000000, "preview 3");
				PlayerTextDrawBackgroundColor(playerid,p_VehiclePreviewTD[ 1 ], 112);
				PlayerTextDrawFont(playerid,p_VehiclePreviewTD[ 1 ], 5);
				PlayerTextDrawLetterSize(playerid,p_VehiclePreviewTD[ 1 ], 0.500000, 4.400000);
				PlayerTextDrawColor(playerid,p_VehiclePreviewTD[ 1 ], -1);
				PlayerTextDrawUseBox(playerid,p_VehiclePreviewTD[ 1 ], 1);
				PlayerTextDrawBoxColor(playerid,p_VehiclePreviewTD[ 1 ], 0);
				PlayerTextDrawTextSize(playerid,p_VehiclePreviewTD[ 1 ], 60.000000, 60.000000);
				PlayerTextDrawSetPreviewModel(playerid, p_VehiclePreviewTD[ 1 ], model);
				PlayerTextDrawSetPreviewRot(playerid, p_VehiclePreviewTD[ 1 ], -16.000000, 0.000000, 270.000000, 1.000000);
				PlayerTextDrawSetSelectable(playerid,p_VehiclePreviewTD[ 1 ], 0);

				p_VehiclePreviewTD[ 2 ] = CreatePlayerTextDraw(playerid,358.000000, 230.000000, "preview 4");
				PlayerTextDrawBackgroundColor(playerid,p_VehiclePreviewTD[ 2 ], 112);
				PlayerTextDrawFont(playerid,p_VehiclePreviewTD[ 2 ], 5);
				PlayerTextDrawLetterSize(playerid,p_VehiclePreviewTD[ 2 ], 0.500000, 4.400000);
				PlayerTextDrawColor(playerid,p_VehiclePreviewTD[ 2 ], -1);
				PlayerTextDrawUseBox(playerid,p_VehiclePreviewTD[ 2 ], 1);
				PlayerTextDrawBoxColor(playerid,p_VehiclePreviewTD[ 2 ], 0);
				PlayerTextDrawTextSize(playerid,p_VehiclePreviewTD[ 2 ], 60.000000, 60.000000);
				PlayerTextDrawSetPreviewModel(playerid, p_VehiclePreviewTD[ 2 ], model);
				PlayerTextDrawSetPreviewRot(playerid, p_VehiclePreviewTD[ 2 ], -16.000000, 0.000000, 90.000000, 1.000000);
				PlayerTextDrawSetSelectable(playerid,p_VehiclePreviewTD[ 2 ], 0);

				p_VehiclePreviewTD[ 3 ] = CreatePlayerTextDraw(playerid,428.000000, 160.000000, "preview 4");
				PlayerTextDrawBackgroundColor(playerid,p_VehiclePreviewTD[ 3 ], 112);
				PlayerTextDrawFont(playerid,p_VehiclePreviewTD[ 3 ], 5);
				PlayerTextDrawLetterSize(playerid,p_VehiclePreviewTD[ 3 ], 0.500000, 4.400000);
				PlayerTextDrawColor(playerid,p_VehiclePreviewTD[ 3 ], -1);
				PlayerTextDrawUseBox(playerid,p_VehiclePreviewTD[ 3 ], 1);
				PlayerTextDrawBoxColor(playerid,p_VehiclePreviewTD[ 3 ], 0);
				PlayerTextDrawTextSize(playerid,p_VehiclePreviewTD[ 3 ], 60.000000, 60.000000);
				PlayerTextDrawSetPreviewModel(playerid, p_VehiclePreviewTD[ 3 ], model);
				PlayerTextDrawSetPreviewRot(playerid, p_VehiclePreviewTD[ 3 ], 270.000000, 0.000000, 0.000000, 1.000000);
				PlayerTextDrawSetSelectable(playerid,p_VehiclePreviewTD[ 3 ], 0);

				p_VehiclePreviewTD[ 4 ] = CreatePlayerTextDraw(playerid,428.000000, 230.000000, "preview 5");
				PlayerTextDrawBackgroundColor(playerid,p_VehiclePreviewTD[ 4 ], 112);
				PlayerTextDrawFont(playerid,p_VehiclePreviewTD[ 4 ], 5);
				PlayerTextDrawLetterSize(playerid,p_VehiclePreviewTD[ 4 ], 0.500000, 4.400000);
				PlayerTextDrawColor(playerid,p_VehiclePreviewTD[ 4 ], -1);
				PlayerTextDrawUseBox(playerid,p_VehiclePreviewTD[ 4 ], 1);
				PlayerTextDrawBoxColor(playerid,p_VehiclePreviewTD[ 4 ], 0);
				PlayerTextDrawTextSize(playerid,p_VehiclePreviewTD[ 4 ], 60.000000, 60.000000);
				PlayerTextDrawSetPreviewModel(playerid, p_VehiclePreviewTD[ 4 ], model);
				PlayerTextDrawSetPreviewRot(playerid, p_VehiclePreviewTD[ 4 ], 90.000000, 0.000000, 0.000000, 1.000000);
				PlayerTextDrawSetSelectable(playerid,p_VehiclePreviewTD[ 4 ], 0);

				p_VehiclePreviewTD[ 5 ] = CreatePlayerTextDraw(playerid,150.000000, 160.000000, "big preview");
				PlayerTextDrawBackgroundColor(playerid,p_VehiclePreviewTD[ 5 ], 112);
				PlayerTextDrawFont(playerid,p_VehiclePreviewTD[ 5 ], 5);
				PlayerTextDrawLetterSize(playerid,p_VehiclePreviewTD[ 5 ], 0.500000, 1.000000);
				PlayerTextDrawColor(playerid,p_VehiclePreviewTD[ 5 ], -1);
				PlayerTextDrawUseBox(playerid,p_VehiclePreviewTD[ 5 ], 1);
				PlayerTextDrawBoxColor(playerid,p_VehiclePreviewTD[ 5 ], 0);
				PlayerTextDrawTextSize(playerid,p_VehiclePreviewTD[ 5 ], 130.000000, 130.000000);
				PlayerTextDrawSetPreviewModel(playerid, p_VehiclePreviewTD[ 5 ], model);
				PlayerTextDrawSetPreviewRot(playerid, p_VehiclePreviewTD[ 5 ], -16.000000, 0.000000, 45.000000, 1.000000);
				PlayerTextDrawSetSelectable(playerid,p_VehiclePreviewTD[ 5 ], 0);

				p_VehiclePreviewTD[ 6 ] = CreatePlayerTextDraw(playerid,289.000000, 160.000000, "preview 6");
				PlayerTextDrawBackgroundColor(playerid,p_VehiclePreviewTD[ 6 ], 112);
				PlayerTextDrawFont(playerid,p_VehiclePreviewTD[ 6 ], 5);
				PlayerTextDrawLetterSize(playerid,p_VehiclePreviewTD[ 6 ], 0.500000, 4.400000);
				PlayerTextDrawColor(playerid,p_VehiclePreviewTD[ 6 ], -1);
				PlayerTextDrawUseBox(playerid,p_VehiclePreviewTD[ 6 ], 1);
				PlayerTextDrawBoxColor(playerid,p_VehiclePreviewTD[ 6 ], 0);
				PlayerTextDrawTextSize(playerid,p_VehiclePreviewTD[ 6 ], 60.000000, 60.000000);
				PlayerTextDrawSetPreviewModel(playerid, p_VehiclePreviewTD[ 6 ], model);
				PlayerTextDrawSetPreviewRot(playerid, p_VehiclePreviewTD[ 6 ], -16.000000, 0.000000, 180.000000, 1.000000);
				PlayerTextDrawSetSelectable(playerid, p_VehiclePreviewTD[ 6 ], 0);

				TextDrawShowForPlayer( playerid, g_VehiclePreviewBoxTD );
				TextDrawShowForPlayer( playerid, g_VehiclePreviewTxtTD );
				TextDrawShowForPlayer( playerid, p_VehiclePreviewCloseTD );
				PlayerTextDrawShow( playerid, p_VehiclePreviewTD[ 0 ] );
				PlayerTextDrawShow( playerid, p_VehiclePreviewTD[ 1 ] );
				PlayerTextDrawShow( playerid, p_VehiclePreviewTD[ 2 ] );
				PlayerTextDrawShow( playerid, p_VehiclePreviewTD[ 3 ] );
				PlayerTextDrawShow( playerid, p_VehiclePreviewTD[ 4 ] );
				PlayerTextDrawShow( playerid, p_VehiclePreviewTD[ 5 ] );
				PlayerTextDrawShow( playerid, p_VehiclePreviewTD[ 6 ] );


				p_inMovieMode{ playerid } = false;
				cmd_moviemode( playerid, "" ); // Hide textdraws :3

				SelectTextDraw( playerid, COLOR_RED );
				SetPVarInt( playerid, "viewing_vehicle", 1 );
			}
		}
	}
	if ( dialogid == DIALOG_BOUGHT_VEH )
	{
		if ( GetPVarInt( playerid, "bought_veh_ts" ) < g_iTime )
		{
			DeletePVar( playerid, "bought_veh_ts" );
			return 1;
		}
		SendServerMessage( playerid, "Please read this thoroughly so you know what you can be facing. %d seconds left.", GetPVarInt( playerid, "bought_veh_ts" ) - g_iTime );
		ShowPlayerDialog( playerid, DIALOG_BOUGHT_VEH, DIALOG_STYLE_MSGBOX, "{FFFFFF}You've purchased a vehicle!", "{FFFFFF}Glad to see you've purchased a vehicle. Please ensure you read:\n\n* Vehicles are kept until you sell them or go two months inactive. This is not refundable.\n* Do not mispark your vehicle or it can be removed/impounded.\n* Check out /v for vehicle commands.\n* Find an acceptable place to park your new vehicle such as your house or a parking lot.", "Okay", "" );
	}
	if ( ( dialogid == DIALOG_ACC_GUARD ) && response )
	{
		if ( p_accountSecurityData[ playerid ] [ E_ID ] && ! p_accountSecurityData[ playerid ] [ E_VERIFIED ] )
			return SendError( playerid, "You must be verified to use this feature." );

		switch ( listitem )
		{
			case 0:
			{
				if ( p_accountSecurityData[ playerid ] [ E_ID ] )
					return SendError( playerid, "Your email is already confirmed!" ), ShowPlayerAccountGuard( playerid ), 1;

				format( szNormalString, sizeof( szNormalString ), "SELECT * FROM `EMAILS` WHERE `USER_ID`=%d", p_AccountID[ playerid ] );
	    		mysql_function_query( dbHandle, szNormalString, true, "OnEmailConfirm", "d", playerid );
			}
			case 1: ShowPlayerDialog( playerid, DIALOG_ACC_GUARD_MODE, DIALOG_STYLE_TABLIST, "{FFFFFF}Irresistible Guard - Mode", "Mild\t"COL_GREY"Must verify IP before making transactions\nParanoid\t"COL_GREY"Must verify IP after logging in\nDisable\t"COL_GREY"No form of verification", "Select", "Back" );
			case 2:
			{
				format( szBigString, sizeof( szBigString ), "SELECT * FROM `EMAILS` WHERE `ID`=%d", p_accountSecurityData[ playerid ] [ E_ID ] );
				mysql_function_query( dbHandle, szBigString, true, "OnAccountGuardDelete", "d", playerid );
			}
		}
		return 1;
	}
	if ( dialogid == DIALOG_ACC_GUARD_CONFIRM )
	{
		if ( ! response )
		{
			if ( p_accountSecurityData[ playerid ] [ E_MODE ] == SECURITY_MODE_PARANOID ) {
				return Kick( playerid );
			}

			// allow other modes
			return 1;
		}

		static
			szInput[ 10 ];

		format( szInput, sizeof( szInput ), "%s", inputtext );
		trimString( szInput ); // gotta take out the whitespace

		if ( strlen( szInput ) != 8 )
			return SendError( playerid, "The verification code must be 8 characters." ), ShowPlayerAccountVerification( playerid );

		format( szBigString, sizeof( szBigString ), "SELECT * FROM `USER_CONFIRMED_IPS` WHERE `USER_ID`=%d AND `IP`='%s' AND `TOKEN`='%s'", p_AccountID[ playerid ], mysql_escape( ReturnPlayerIP( playerid ) ), szInput );
		mysql_function_query( dbHandle, szBigString, true, "OnAccountGuardVerify", "d", playerid );
		return 1;
	}
	if ( dialogid == DIALOG_ACC_GUARD_DEL_CANCEL )
	{
		if ( !response )
			return ShowPlayerAccountGuard( playerid );

		p_accountSecurityData[ playerid ] [ E_LAST_DISABLED ] = 0;
		mysql_single_query( sprintf( "UPDATE `EMAILS` SET `LAST_CHANGED`=%d,`LAST_DISABLED`=0 WHERE `ID`=%d", g_iTime, p_accountSecurityData[ playerid ] [ E_ID ] ) );
		return SendServerMessage( playerid, "You have cancelled the process to removing Irresistible Guard." );
	}
	if ( dialogid == DIALOG_ACC_GUARD_MODE )
	{
		if ( !response )
			return ShowPlayerAccountGuard( playerid );

		if ( ! p_accountSecurityData[ playerid ] [ E_ID ] )
			return SendError( playerid, "You need to assign an email to your account." );

		p_accountSecurityData[ playerid ] [ E_MODE ] = listitem;
		mysql_single_query( sprintf( "UPDATE `EMAILS` SET `MODE`=%d WHERE `ID`=%d", listitem, p_accountSecurityData[ playerid ] [ E_ID ] ) );
		SendServerMessage( playerid, "Your Irresistible Guard mode is now set to "COL_GREY"%s"COL_WHITE".", SecurityModeToString( listitem ) );
		return ShowPlayerAccountGuard( playerid );
	}
	if ( dialogid == DIALOG_ACC_GUARD_EMAIL )
	{
		if ( ! response )
			return SendError( playerid, "Nothing to show!" );

		new
			email[ 64 ];

		if ( sscanf( inputtext, "s[64]", email ) )
			return SendError( playerid, "Your email must be between 4 and 64 characters long." );

		if ( ! ( 3 < strlen( email ) < 64 ) )
			return SendError( playerid, "Your email must be between 4 and 64 characters long." );

		if ( ! regex_match( email, "[a-zA-Z0-9_\\.]+@([a-zA-Z0-9\\-]+\\.)+[a-zA-Z]{2,4}" ) )
			return SendError( playerid, "Your email must be valid (foo@example.com)." );

	    format( szBigString, sizeof( szBigString ), "INSERT INTO `EMAIL_VERIFY`(`USER_ID`, `EMAIL`) VALUES (%d, '%s') ON DUPLICATE KEY UPDATE `EMAIL`='%s',`DATE`=CURRENT_TIMESTAMP", p_AccountID[ playerid ], mysql_escape( email ), mysql_escape( email ) );
	    mysql_function_query( dbHandle, szBigString, true, "OnQueueEmailVerification", "ds", playerid, email );
		return 1;
	}
	if ( ( dialogid == DIALOG_CP_MENU ) && response )
	{
		if ( GetPlayerVirtualWorld( playerid ) == 69 ) return SendError( playerid, "You cannot modify your player settings within an event." );

		if ( listitem == 0 ) {
			return ShowPlayerAccountGuard( playerid );
		}

		new
			settingid = listitem - 1;

		if ( ( p_PlayerSettings[ playerid ] { settingid } = !p_PlayerSettings[ playerid ] { settingid } ) == true )
		{
			if ( settingid == SETTING_VIPSKIN )
			{
				if ( p_VIPLevel[ playerid ] < VIP_REGULAR ) return SendError( playerid, "You are not a V.I.P, to become one visit "COL_GREY"donate.irresistiblegaming.com" );
				SyncObject( playerid );
				ClearAnimations( playerid );
				SetPlayerSkin( playerid, p_LastSkin[ playerid ] );
			}

			else if ( settingid == SETTING_COINS_BAR )
			 	ShowPlayerTogglableTextdraws( playerid, .force = false );

			else if ( settingid == SETTING_TOP_DONOR )
 				HidePlayerTogglableTextdraws( playerid, .force = false );

			format( szNormalString, 68, "INSERT INTO `SETTINGS`(`USER_ID`, `SETTING_ID`) VALUES (%d, %d)", p_AccountID[ playerid ], settingid );
		}
		else
		{
			if ( settingid == SETTING_COINS_BAR )
 				HidePlayerTogglableTextdraws( playerid, .force = false );

			else if ( settingid == SETTING_TOP_DONOR )
 				ShowPlayerTogglableTextdraws( playerid, .force = false );

			format( szNormalString, 64, "DELETE FROM `SETTINGS` WHERE USER_ID=%d AND SETTING_ID=%d", p_AccountID[ playerid ], settingid );
		}
		mysql_single_query( szNormalString );
		SendServerMessage( playerid, "You have %s "COL_GREY"%s"COL_WHITE". Changes may take effect after spawning/relogging.", p_PlayerSettings[ playerid ] { settingid } != g_PlayerSettings[ settingid ] [ E_DEFAULT_VAL ] ? ( "disabled" ) : ( "enabled" ), g_PlayerSettings[ settingid ] [ E_NAME ] );
	    cmd_cp( playerid, "" ); // Redirect to control panel again...
	}
	if ( dialogid == DIALOG_WEAPON_DEAL )
	{
	    if ( !response )
 		{
 			new
 				iDealer = p_WeaponDealer[ playerid ];

		  	if ( IsPlayerConnected( iDealer ) )
		  	{
		  		if ( GetPVarInt( iDealer, "weapon_sell_cd" ) < g_iTime )
		  			GivePlayerWantedLevel( iDealer, 6 ), SetPVarInt( iDealer, "weapon_sell_cd", g_iTime + 60 );

			  	SendClientMessageFormatted( iDealer, -1, ""COL_ORANGE"[WEAPON DEAL]{FFFFFF} %s(%d) has closed the deal.", ReturnPlayerName ( playerid ), playerid );
		  	}

			new purchased = GetPVarInt( playerid, "purchased_weapon" );
			if ( purchased ) {
				SetPVarInt( playerid, "weapon_buy_cool", g_iTime + 40 );
				GivePlayerWantedLevel( playerid, ( purchased * 2 ) > 6 ? 6 : purchased );
				DeletePVar( playerid, "purchased_weapon" );
			}

			SetPlayerArmedWeapon( playerid, 0 );
			p_WeaponDealing{ playerid } = false;
 			p_WeaponDealer[ playerid ] = INVALID_PLAYER_ID;
		  	return 1;
		}

	    p_WeaponDealMenu{ playerid } = listitem;
      	RedirectAmmunation( playerid, listitem, "{FFFFFF}Weapon Deal - Purchase Weapons", DIALOG_WEAPON_DEAL_BUY, 0.75, true );
	}
	if ( dialogid == DIALOG_WEAPON_DEAL_BUY )
	{
	    // The discount is %50 - You can change it above!
	    if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot buy weapons in jail." );
	    if ( GetPlayerVirtualWorld( playerid ) == 69 ) return SendError( playerid, "You cannot buy weapons in an event." );
		if ( GetPlayerState( playerid ) == PLAYER_STATE_WASTED || !IsPlayerSpawned( playerid ) ) return SendError( playerid, "You are unable to purchase any weapons at this time." );

		new
			weapondealerid = p_WeaponDealer[ playerid ];

		if ( !IsPlayerConnected( weapondealerid ) ) return SendError( playerid, "You are unable to purchase any weapons at this time." );
		if ( GetDistanceBetweenPlayers( playerid, weapondealerid ) > 33.0 ) return SendError( playerid, "You are unable to purchase any weapons at this time." );

		if ( response )
		{
		    for( new i, x = 0; i < sizeof( g_AmmunationWeapons ); i++ )
		    {
		        if ( g_AmmunationWeapons[ i ] [ E_MENU ] == p_WeaponDealMenu{ playerid } )
		        {
		            if ( x == listitem )
		            {
		                new price = floatround( g_AmmunationWeapons[ i ] [ E_PRICE ] * 0.75 ); // Change the discount here!!
					 	if ( price > GetPlayerCash( playerid ) )
						{
						    SendError( playerid, "You don't have enough money for this." );
      						RedirectAmmunation( playerid, p_WeaponDealMenu{ playerid }, "{FFFFFF}Weapon Deal - Purchase Weapons", DIALOG_WEAPON_DEAL_BUY, 0.75, true );
							return 1;
						}
						GivePlayerCash( weapondealerid, floatround( price * 0.75 ) );
		                SendClientMessageFormatted( weapondealerid, -1, ""COL_ORANGE"[WEAPON DEAL]{FFFFFF} %s(%d) has purchased a %s for "COL_GOLD"%s"COL_WHITE" (tax applied).", ReturnPlayerName( playerid ), playerid, g_AmmunationWeapons[ i ] [ E_NAME ], ConvertPrice( price ) );
						SetPVarInt( playerid, "purchased_weapon", GetPVarInt( playerid, "purchased_weapon" ) + 1 );
						SendClientMessageFormatted( playerid, -1, ""COL_ORANGE"[WEAPON DEAL]{FFFFFF} You have purchased a %s for "COL_GOLD"%s"COL_WHITE".", g_AmmunationWeapons[ i ] [ E_NAME ], ConvertPrice( price ) );
						GivePlayerWeapon( playerid, g_AmmunationWeapons[ i ] [ E_WEPID ], 15000 ); // Infinite
						SetPlayerArmedWeapon( playerid, 0 );
						GivePlayerCash( playerid, -( price ) );
						RedirectAmmunation( playerid, p_WeaponDealMenu{ playerid }, "{FFFFFF}Weapon Deal - Purchase Weapons", DIALOG_WEAPON_DEAL_BUY, 0.75, true );
						break;
		            }
		            x ++;
		        }
		    }
		}
		else ShowAmmunationMenu( playerid, "{FFFFFF}Weapon Deal - Purchase Weapons", DIALOG_WEAPON_DEAL );
	}
	if ( ( dialogid == DIALOG_AMMU ) && response )
	{
    	p_AmmunationMenu{ playerid } = listitem;
        return RedirectAmmunation( playerid, listitem );
	}
	if ( ( dialogid == DIALOG_WEAPON_LOCKER ) && response )
	{
    	p_WeaponLockerMenu{ playerid } = listitem;
      	return RedirectAmmunation( playerid, listitem, "{FFFFFF}Weapon Locker - Purchase Weapons", DIALOG_WEAPON_LOCKER_BUY, 1.25 );
	}
	if ( dialogid == DIALOG_WEAPON_LOCKER_BUY )
	{
	   	if ( p_Class[ playerid ] != CLASS_POLICE ) return SendError( playerid, "You must be a law enforcement officer to use this feature." );
	    if ( IsPlayerJailed( playerid ) ) return SendError( playerid, "You cannot buy weapons in jail." );
		if ( GetPlayerState( playerid ) == PLAYER_STATE_WASTED || !IsPlayerSpawned( playerid ) ) return SendError( playerid, "You are unable to purchase any weapons at this time." );

		// Check if user is in the locker checkpoint
		foreach (new lockerid : WeaponLockers)
		{
			if ( IsPlayerInDynamicCP( playerid, g_weaponLockerCheckpoint[ lockerid ] ) )
			{
				if ( response )
				{
				    for( new i, x = 0; i < sizeof( g_AmmunationWeapons ); i++ )
				    {
				        if ( g_AmmunationWeapons[ i ] [ E_MENU ] == p_WeaponLockerMenu{ playerid } )
				        {
				            if ( x == listitem )
				            {
								new
									iCostPrice = floatround( float( g_AmmunationWeapons[ i ] [ E_PRICE ] ) * 1.25 );

							 	if ( iCostPrice > GetPlayerCash( playerid ) )
								{
								    SendError( playerid, "You don't have enough money for this." );
								    RedirectAmmunation( playerid, p_WeaponLockerMenu{ playerid }, "{FFFFFF}Weapon Locker - Purchase Weapons", DIALOG_WEAPON_LOCKER_BUY, 1.25 );
									return 1;
								}

								GivePlayerCash( playerid, -iCostPrice );
								GivePlayerWeapon( playerid, g_AmmunationWeapons[ i ] [ E_WEPID ], g_AmmunationWeapons[ i ] [ E_AMMO ] );
								RedirectAmmunation( playerid, p_WeaponLockerMenu{ playerid }, "{FFFFFF}Weapon Locker - Purchase Weapons", DIALOG_WEAPON_LOCKER_BUY, 1.25 );
								SendServerMessage( playerid, "You have purchased a %s(%d) for "COL_GOLD"%s"COL_WHITE"%s (inc. fees).", g_AmmunationWeapons[ i ] [ E_NAME ], g_AmmunationWeapons[ i ] [ E_AMMO ], ConvertPrice( iCostPrice ) );
								break;
				            }
				            x ++;
				        }
				    }
				}
				else
				{
					ShowAmmunationMenu( playerid, "{FFFFFF}Weapon Locker - Purchase Weapons", DIALOG_WEAPON_LOCKER );
				}
				return 1;
			}
		}
		return SendError( playerid, "You are not inside any gun locker checkpoint." );
	}
	if ( dialogid == DIALOG_AMMU_BUY )
	{
		if ( !IsPlayerInDynamicCP( playerid, g_Checkpoints[ CP_AMMUNATION_0 ] ) && !IsPlayerInDynamicCP( playerid, g_Checkpoints[ CP_AMMUNATION_1 ] ) && !IsPlayerInDynamicCP( playerid, g_Checkpoints[ CP_AMMUNATION_2 ] ) ) return SendError( playerid, "You must be in the Ammu-Nation purchasing checkpoint to use this." );
		if ( GetPlayerState( playerid ) == PLAYER_STATE_WASTED || !IsPlayerSpawned( playerid ) ) return SendError( playerid, "You are unable to purchase any weapons at this time." );
		if ( response )
		{
		    for( new i, x = 0; i < sizeof( g_AmmunationWeapons ); i++ )
		    {
		        if ( g_AmmunationWeapons[ i ] [ E_MENU ] == p_AmmunationMenu{ playerid } )
		        {
		            if ( x == listitem )
		            {
					 	if ( g_AmmunationWeapons[ i ] [ E_PRICE ] > GetPlayerCash( playerid ) )
						{
						    SendError( playerid, "You don't have enough money for this." );
						    RedirectAmmunation( playerid, p_AmmunationMenu{ playerid } );
							return 1;
						}

						new
							bDealer = JobEquals( playerid, JOB_WEAPON_DEALER ),
							iCostPrice = g_AmmunationWeapons[ i ] [ E_PRICE ]
						;

						if ( bDealer )
							iCostPrice = floatround( iCostPrice * 0.75 );

						GivePlayerCash( playerid, -iCostPrice );

						RedirectAmmunation( playerid, p_AmmunationMenu{ playerid } );
						GivePlayerWeapon( playerid, g_AmmunationWeapons[ i ] [ E_WEPID ], g_AmmunationWeapons[ i ] [ E_AMMO ] );
						SendServerMessage( playerid, "You have purchased a %s(%d) for "COL_GOLD"%s"COL_WHITE"%s.", g_AmmunationWeapons[ i ] [ E_NAME ], g_AmmunationWeapons[ i ] [ E_AMMO ], ConvertPrice( iCostPrice ), bDealer ? ( " (inc. discount)" ) : ( "" ) );
		                break;
		            }
		            x ++;
		        }
		    }
		}
		else ShowAmmunationMenu( playerid );
	}
	if ( ( dialogid == DIALOG_APARTMENTS ) && response )
	{
		new Float: X, Float: Y, Float: Z;
		GetDynamicObjectPos( g_apartmentElevator, X, Y, Z );
		if ( !IsPlayerInRangeOfPoint( playerid, 2.0, X, Y, Z ) )
			return SendError( playerid, "You must be near the elevator to use this!" );

	    if ( listitem == 0 ) apartment_CallElevator( 0 );
	    else
	    {
			new id = listitem - 1;
			p_ApartmentEnter{ playerid } = id;
			if ( strmatch( g_apartmentData[ id ] [ E_OWNER ], "No-one" ) || isnull( g_apartmentData[ id ] [ E_OWNER ] ) || !g_apartmentData[ id ] [ E_CREATED ] )
			{
			 	ShowPlayerDialog( playerid, DIALOG_APARTMENTS_BUY, DIALOG_STYLE_MSGBOX, "{FFFFFF}Are you interested?", "{FFFFFF}This apartment is available for sale. The price is $5,000,000.\nIf you wish to buy it, please click 'Purchase'.", "Purchase", "Deny" );
			}
			else if ( !strmatch( g_apartmentData[ id ] [ E_OWNER ], ReturnPlayerName( playerid ) ) )
			{
			    if ( g_apartmentData[ id ] [ E_LOCKED ] ) {
					return SendError( playerid, "This apartment has been locked by its owner." );
				}
			}
	    	apartment_CallElevator( id + 1 );
		}
	}
	if ( ( dialogid == DIALOG_APARTMENTS_BUY ) && response )
	{
	    if ( GetPlayerOwnedApartments( playerid ) > 0 )
	        return SendError( playerid, "You can only own one apartment." );

	    if ( GetPlayerCash( playerid ) < 5000000 )
	        return SendError( playerid, "You don't have enough money for this ($5,000,000)." );

		GivePlayerCash( playerid, -5000000, .force_save = true );

		new aID = p_ApartmentEnter{ playerid };
		g_apartmentData[ aID ] [ E_CREATED ] = true;
		format( g_apartmentData[ aID ] [ E_OWNER ], 24, "%s", ReturnPlayerName( playerid ) );
		format( g_apartmentData[ aID ] [ E_NAME ], 30, "Apartment %d", aID );
		g_apartmentData[ aID ] [ E_LOCKED ] = 0;

		format( szNormalString, 100, "INSERT INTO `APARTMENTS` VALUES (%d,'%s','Apartment %d',0)", aID, mysql_escape( ReturnPlayerName( playerid ) ), aID );
	    mysql_single_query( szNormalString );

		SendServerMessage( playerid, "You have purchased an apartment for "COL_GOLD"$5,000,000"COL_WHITE"." );
	}
	if ( ( dialogid == DIALOG_FLAT_CONFIG ) && response )
	{
		for( new id, x = 0; id < sizeof( g_apartmentData ); id ++ )
		{
			if ( g_apartmentData[ id ] [ E_CREATED ] && strmatch( g_apartmentData[ id ] [ E_OWNER ], ReturnPlayerName( playerid ) ) )
			{
		       	if ( x == listitem )
		      	{
					p_ApartmentEditing{ playerid } = id;
		      	    SendServerMessage( playerid, "You are now controlling the settings over "COL_GREY"%s", g_apartmentData[ id ] [ E_NAME ] );
		      		ShowPlayerDialog( playerid, DIALOG_FLAT_CONTROL, DIALOG_STYLE_LIST, "{FFFFFF}Owned Apartments", "Spawn Here\nLock Apartment\nModify Apartment Name\nSell Apartment\nFurniture", "Select", "Back" );
		      		break;
				}
		      	x++;
			}
		}
	}
	if ( dialogid == DIALOG_FLAT_CONTROL )
	{
	    if ( !response )
	        return cmd_flat( playerid, "config" );

		switch( listitem )
		{
		    case 0:
		    {
		       	p_ApartmentSpawnLocation[ playerid ] = p_ApartmentEditing{ playerid };
				SendServerMessage( playerid, "You have set your spawning location to the specified apartment. To stop this you can use \"/flat stopspawn\"." );
				ShowPlayerDialog( playerid, DIALOG_FLAT_CONTROL, DIALOG_STYLE_LIST, "{FFFFFF}Owned Apartments", "Spawn Here\nLock Apartment\nModify Apartment Name\nSell Apartment\nFurniture", "Select", "Back" );
			}
			case 1:
			{
		        new id = p_ApartmentEditing{ playerid };
             	g_apartmentData[ id ] [ E_LOCKED ] = ( g_apartmentData[ id ] [ E_LOCKED ] == 1 ? 0 : 1 );
				format( Query, 100, "UPDATE `APARTMENTS` SET `LOCKED`=%d WHERE `ID`=%d", g_apartmentData[ id ] [ E_LOCKED ], id );
				mysql_single_query( Query );
				SendServerMessage( playerid, "You have %s the specified apartment.", g_apartmentData[ id ] [ E_LOCKED ] == 1 ? ( "locked" ) : ( "unlocked" ) );
				ShowPlayerDialog( playerid, DIALOG_FLAT_CONTROL, DIALOG_STYLE_LIST, "{FFFFFF}Owned Apartments", "Spawn Here\nLock Apartment\nModify Apartment Name\nSell Apartment\nFurniture", "Select", "Back" );
			}
		    case 2:
		    {
		   		ShowPlayerDialog( playerid, DIALOG_FLAT_TITLE, DIALOG_STYLE_INPUT, "{FFFFFF}Owned Apartments", ""COL_WHITE"Input the apartment title you want to change with:", "Submit", "Back" );
			}
		    case 3: ShowPlayerDialog( playerid, DIALOG_YOU_SURE_APART, DIALOG_STYLE_MSGBOX, "{FFFFFF}Owned Apartments", ""COL_WHITE"Are you sure that you want to sell your apartment?", "Yes", "No" );
		    case 4: ShowPlayerDialog( playerid, DIALOG_FLAT_FURNITURE, DIALOG_STYLE_MSGBOX, ""COL_RED"Important Notice!", ""COL_WHITE"We are strict with furniture in apartments! So listen up!\n\nPlease ensure your furniture is not placed:\n\n* Inside a tenants apartment.\n* Outside your apartment's walkable area.\n"COL_ORANGE"* Do not place furniture within the elevator's area.\n\n"COL_WHITE"Stick to the rules, and keep your apartment and avoid the fines!", "I accept", "Back" );
		}
	}
	if ( dialogid == DIALOG_YOU_SURE_APART )
	{
		if ( !response )
   			return ShowPlayerDialog( playerid, DIALOG_FLAT_CONTROL, DIALOG_STYLE_LIST, "{FFFFFF}Owned Apartments", "Spawn Here\nLock Apartment\nModify Apartment Name\nSell Apartment\nFurniture", "Select", "Back" );

        new id = p_ApartmentEditing{ playerid };
        p_ApartmentSpawnLocation[ playerid ] = -1;

		g_apartmentData[ id ] [ E_CREATED ] = false;
		strcpy( g_apartmentData[ id ] [ E_OWNER ], "No-one" );
		// format( g_apartmentData[ id ] [ E_OWNER ], MAX_PLAYER_NAME, "%s", "No-one" );
		format( g_apartmentData[ id ] [ E_NAME ], 30, "Apartment %d", id );
		g_apartmentData[ id ] [ E_LOCKED ] = 0;

		destroyAllFurniture( id, true );

		format( szNormalString, 40, "DELETE FROM `APARTMENTS` WHERE `ID`=%d", id );
	    mysql_single_query( szNormalString );

        GivePlayerCash( playerid, 3000000 );
		p_ApartmentEditing{ playerid } = -1;

   		return SendClientMessage( playerid, -1, ""COL_GREY"[SERVER]"COL_WHITE" You have successfully sold your apartment for "COL_GOLD"$3,000,000"COL_WHITE".");
	}
	if ( dialogid == DIALOG_FLAT_FURNITURE )
	{
		if ( response ) ShowPlayerDialog( playerid, DIALOG_FURNITURE, DIALOG_STYLE_LIST, "{FFFFFF}Furniture", "Purchase Furniture\nSelect Furniture Easily\nSelect Furniture Manually\nSelect Furniture Nearest\n"COL_RED"Remove All Furniture", "Confirm", "Back" );
		else ShowPlayerDialog( playerid, DIALOG_FLAT_CONTROL, DIALOG_STYLE_LIST, "{FFFFFF}Owned Apartments", "Spawn Here\nLock Apartment\nModify Apartment Name\nSell Apartment\nFurniture", "Select", "Back" );
	}
	if ( ( dialogid == DIALOG_FLAT_TITLE ) )
	{
	    if ( !response )
	        return ShowPlayerDialog( playerid, DIALOG_FLAT_CONTROL, DIALOG_STYLE_LIST, "{FFFFFF}Owned Apartments", "Spawn Here\nLock Apartment\nModify Apartment Name\nSell Apartment\nFurniture", "Select", "Back" );

		if ( !strlen( inputtext ) )
			return ShowPlayerDialog( playerid, DIALOG_FLAT_TITLE, DIALOG_STYLE_INPUT, "{FFFFFF}Owned Apartments", ""COL_WHITE"Input the apartment title you want to change with:\n\n"COL_RED"Must be more than 0 characters.", "Submit", "Back" );

		new id = p_ApartmentEditing{ playerid };
		format( Query, sizeof( Query ), "UPDATE `APARTMENTS` SET `NAME`='%s' WHERE `ID`=%d", mysql_escape( inputtext ), id );
		mysql_single_query( Query );
		format( g_apartmentData[ id ] [ E_NAME ], 30, "%s", inputtext );
 		SendServerMessage( playerid, "You have successfully changed the name of your apartment." );
  		ShowPlayerDialog( playerid, DIALOG_FLAT_CONTROL, DIALOG_STYLE_LIST, "{FFFFFF}Owned Apartments", "Spawn Here\nLock Apartment\nModify Apartment Name\nSell Apartment\nFurniture", "Select", "Back" );
	}
	/*if ( ( dialogid == DIALOG_POLICE_TUTORIAL ) )
	{
	    if ( response )
	    {
		    if ( g_iTime > p_CopTutorialTick[ playerid ] )
		     	p_CopTutorialProgress{ playerid }++, p_CopTutorialTick[ playerid ] = g_iTime + 25;
			else
				SendServerMessage( playerid, "You can press %s in %d seconds.", p_CopTutorialProgress{ playerid } == 3 ? ( "finish" ) : ( "next" ), p_CopTutorialTick[ playerid ] - g_iTime );
		}

		switch( p_CopTutorialProgress{ playerid } )
		{
			case 0:
			{
				szLargeString[ 0 ] = '\0';
				strcat( szLargeString, "{FFFFFF}Welcome! This is a tutorial that every player must complete at some point in time! Within this tutorial, you'll be taught how become a successful\nlaw enforcement officer. Player colors are the most important thing to remember as an officer. You can view the player colors by simply typing '/pc'.\n\n" );
				strcat( szLargeString, "You can view a list of commands by typing '/commands (/cmds)' in the chat box, then selecting the 'Police Commands' option." );
				ShowPlayerDialog( playerid, DIALOG_POLICE_TUTORIAL, DIALOG_STYLE_MSGBOX, "{FFFFFF}Law Enforcement Officer Tutorial", szLargeString, "Next", "" );
			}
			case 1:
			{
		    	szLargeString[ 0 ] = '\0';
				strcat( szLargeString, "{FFFFFF}If you plan on arresting a player, you must use the following commands in the order provided to successfully arrest them. First you must /taze the\nsuspect, /cuff them and then finally /arrest (/ar) them.\n\n" );
				strcat( szLargeString, "Detaining is ideal for experienced players. It promotes fun, and is challenging as you must travel your suspect to the drop off zone at any police\nstation without their friends helping the suspect break free.\n\n" );
				strcat( szLargeString, "Note: The system will uncuff a criminal after 5 minutes of being cuffed.\nTip: Detaining a player pays more than arresting. Arresting pays more than killing." );
				ShowPlayerDialog( playerid, DIALOG_POLICE_TUTORIAL, DIALOG_STYLE_MSGBOX, "{FFFFFF}Law Enforcement Officer Tutorial", szLargeString, "Next", "" );
			}
			case 2:
			{
				szLargeString[ 0 ] = '\0';
				strcat( szLargeString, "{FFFFFF}Do not ever shoot an innocent player, they will be wanted automatically if they attack you.\n\nYou will be jailed for 200 seconds if you are caught attacking an innocent. By killing them, you will be both cop-banned and jailed for 200 seconds.\n\n" );
				strcat( szLargeString, "Abusing the cop class can lead to a cop-ban which disables your ability to use the cop class. Every player may receive up to 3 warns until they are\ncop-banned. If you have been banned from the cop-class, you may pay to be unbanned through the command /unbanme.\n\n" );
				strcat( szLargeString, "Note: You will lose 1 score and $1,000 if you kill anyone that is under 5 wanted, but you will not be jailed." );
				ShowPlayerDialog( playerid, DIALOG_POLICE_TUTORIAL, DIALOG_STYLE_MSGBOX, "{FFFFFF}Law Enforcement Officer Tutorial", szLargeString, "Next", "" );
			}
			case 3:
			{
				szLargeString[ 0 ] = '\0';
				strcat( szLargeString, "{FFFFFF}If you have any questions, make sure you use /ask. An admin will answer you as soon as possible.\n\nIf you need to re-read this cop tutorial at anytime, feel free to /ask an admin to send you into the cop tutorial.\n\n" );
				strcat( szLargeString, "Thank you for reading the law enforcement officer tutorial, we hope that you've understood what to do. Have a fun and safe time playing on the server!\n\nCheck out our website at {00CCFF}"#SERVER_WEBSITE"{FFFFFF} for more information, discussion, and other stuff!" );
				ShowPlayerDialog( playerid, DIALOG_POLICE_TUTORIAL, DIALOG_STYLE_MSGBOX, "{FFFFFF}Law Enforcement Officer Tutorial", szLargeString, "Finish", "" );
			}
			case 4:
			{
				// Completed the tutorial
				format( szNormalString, 100, "UPDATE `USERS` SET `COP_TUTORIAL`=1 WHERE `NAME`='%s'", mysql_escape( ReturnPlayerName( playerid ) ) );
				mysql_single_query( szNormalString );
			    p_CopTutorial{ playerid } = 1;
			    TogglePlayerSpectating( playerid, 0 );
				p_inMovieMode{ playerid } = true;
				cmd_moviemode( playerid, "" ); // Show textdraws...
				SendServerMessage( playerid, "You have finished the law enforcement officer tutorial. You can view it again by typing "COL_GREY"/policetutorial" );
			}
		}
	}*/
	if ( ( dialogid == DIALOG_HOUSE_PW ) && response )
	{
		new i = p_PasswordedHouse[ playerid ];
		if ( !strlen( inputtext ) || strlen( inputtext ) > 4 || strmatch( inputtext, "N/A" ) || !strmatch( inputtext, g_houseData[ i ] [ E_PASSWORD ] ) ) ShowPlayerDialog( playerid, DIALOG_HOUSE_PW, DIALOG_STYLE_PASSWORD, "{FFFFFF}House Authentication", ""COL_GREEN"This house is password locked!\n"COL_WHITE"You may only enter this house if you enter the correct password.\n\n"COL_RED"Incorrect Password!", "Enter", "Cancel" );
		else
		{
			if ( !IsPlayerInRangeOfPoint( playerid, 3.0, g_houseData[ i ] [ E_EX ], g_houseData[ i ] [ E_EY ], g_houseData[ i ] [ E_EZ ] ) ) return SendError( playerid, "You are not near the house entrance!" );
			SendServerMessage( playerid, "Password correct. Access has been granted." );
			p_InHouse[ playerid ] = i;
			p_ApartmentEditing{ playerid } = -1;
			SetPlayerPos( playerid, g_houseData[ i ] [ E_TX ], g_houseData[ i ] [ E_TY ], g_houseData[ i ] [ E_TZ ] );
		  	SetPlayerVirtualWorld( playerid, g_houseData[ i ] [ E_WORLD ] );
			SetPlayerInterior( playerid, g_houseData[ i ] [ E_INTERIOR_ID ] );
		}
	}
	/*if ( ( dialogid == DIALOG_VIEW_LEO_TUT ) && response )
	{
		format( szNormalString, 100, "UPDATE `USERS` SET `COP_TUTORIAL`=0 WHERE `ID`=%d'", p_AccountID[ playerid ] );
		mysql_single_query( szNormalString );
		p_CopTutorial{ playerid } = 0;

	    if ( p_Class[ playerid ] != CLASS_POLICE )
			SendServerMessage( playerid, "The law enforcement tutorial will be shown as soon as you spawn with a police class." );
		else
			SpawnPlayer( playerid );
	}*/
	if ( dialogid == DIALOG_FURNITURE )
	{
        if ( p_InHouse[ playerid ] != -1 ) {
       	 	if ( !strmatch( g_houseData[ p_InHouse[ playerid ] ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this house." );
	    } else {
		    if ( p_ApartmentEditing{ playerid } != -1 && GetPlayerInterior( playerid ) == 0 ) {
		    	if ( !IsPlayerInApartmentArea( playerid, p_ApartmentEditing{ playerid } ) ) return SendError( playerid, "You're not inside this apartment!" );
		    	if ( !strmatch( g_apartmentData[ p_ApartmentEditing{ playerid } ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this apartment." );
		    } else return SendError( playerid, "You're not inside any house or not editing any specific apartment." );
	    }

	    if ( response )
	    {
	    	new if_check = ( p_ApartmentEditing{ playerid } != -1 && GetPlayerInterior( playerid ) == 0 );

			switch( listitem )
			{
			    case 0: ShowFurnitureCategory( playerid );
			    case 1: SendServerMessage( playerid, "You are now editing your furniture. Simply drag your mouse over a piece of furniture and click to edit." ), SelectObject( playerid );
				case 2: ShowOwnedFurnitureList( playerid, if_check ? p_ApartmentEditing{ playerid } : p_InHouse[ playerid ], if_check ? true : false );
				case 3:
				{
				    new i = getClosestFurniture( playerid );
				    if ( i == INVALID_OBJECT_ID ) return SendError( playerid, "There are no nearby furniture." );
					p_SelectedFurniture[ playerid ][ 0 ] = i;
					p_SelectedFurniture[ playerid ][ 1 ] = Streamer_GetIntData( STREAMER_TYPE_OBJECT, i, E_STREAMER_MODEL_ID );
					ShowPlayerDialog( playerid, DIALOG_FURNITURE_OPTION, DIALOG_STYLE_LIST, "Furniture", "Use Editor\nEdit Rotation X\nEdit Rotation Y\nEdit Rotation Z\nSell Object", "Select", "Back" );
      			}
      			case 4: ShowPlayerDialog( playerid, DIALOG_TRUNCATE_FURNITURE, DIALOG_STYLE_MSGBOX, "Furniture", ""COL_WHITE"Are you sure you want to truncate your furniture?", "Confirm", "Back" );
			}
	    }
	    else
	    {
	    	if ( p_InHouse[ playerid ] != -1 ) return cmd_h( playerid, "config" );
	    	return cmd_flat( playerid, "config" );
	    }
	}
	if ( dialogid == DIALOG_TRUNCATE_FURNITURE )
	{
        if ( p_InHouse[ playerid ] != -1 ) {
       	 	if ( !strmatch( g_houseData[ p_InHouse[ playerid ] ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this house." );
	    } else {
		    if ( p_ApartmentEditing{ playerid } != -1 && GetPlayerInterior( playerid ) == 0 ) {
		    	if ( !IsPlayerInApartmentArea( playerid, p_ApartmentEditing{ playerid } ) ) return SendError( playerid, "You're not inside this apartment!" );
		    	if ( !strmatch( g_apartmentData[ p_ApartmentEditing{ playerid } ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this apartment." );
		    } else return SendError( playerid, "You're not inside any house or not editing any specific apartment." );
	    }

		ShowPlayerDialog( playerid, DIALOG_FURNITURE, DIALOG_STYLE_LIST, "{FFFFFF}Furniture", "Purchase Furniture\nSelect Furniture Easily\nSelect Furniture Manually\nSelect Furniture Nearest\n"COL_RED"Remove All Furniture", "Confirm", "Back" );
		if ( response )
		{
			if ( IsPlayerInApartmentArea( playerid, p_ApartmentEditing{ playerid } ) ) destroyAllFurniture( p_ApartmentEditing{ playerid }, true );
			else destroyAllFurniture( p_InHouse[ playerid ] );
		}
	}
	if ( dialogid == DIALOG_FURNITURE_CATEGORY )
	{
		if ( !response ) return ShowPlayerDialog( playerid, DIALOG_FURNITURE, DIALOG_STYLE_LIST, "{FFFFFF}Furniture", "Purchase Furniture\nSelect Furniture Easily\nSelect Furniture Manually\nSelect Furniture Nearest\n"COL_RED"Remove All Furniture", "Confirm", "Back" );
		ShowFurnitureList( playerid, listitem );
		p_FurnitureCategory{ playerid } = listitem;
	}
	if ( dialogid == DIALOG_FURNITURE_MAN_SEL )
	{
	    if ( response )
	    {
	        if ( p_InHouse[ playerid ] != -1 ) {
	       	 	if ( !strmatch( g_houseData[ p_InHouse[ playerid ] ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this house." );
		    } else {
			    if ( p_ApartmentEditing{ playerid } != -1 && GetPlayerInterior( playerid ) == 0 ) {
			    	if ( !strmatch( g_apartmentData[ p_ApartmentEditing{ playerid } ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this apartment." );
			    	if ( !IsPlayerInApartmentArea( playerid, p_ApartmentEditing{ playerid } ) ) return SendError( playerid, "You're not inside this apartment!" );
			    } else return SendError( playerid, "You're not inside any house or not editing any specific apartment." );
		    }

		    new is_in_apartment = IsPlayerInApartmentArea( playerid, p_ApartmentEditing{ playerid } );

			for( new i = g_preloadedObjectCount, x = 0, j = Streamer_GetUpperBound( STREAMER_TYPE_OBJECT ); i < j; i++ )
			{
				if ( IsValidDynamicObject( i ) )
				{
					if ( is_in_apartment && GetGVarInt( "fur_a", i ) != p_ApartmentEditing{ playerid } ) continue;
					if ( !is_in_apartment && GetGVarInt( "fur_w", i ) != p_InHouse[ playerid ] + MAX_HOUSES ) continue;

				    if ( x == listitem )
				    {
						p_SelectedFurniture[ playerid ][ 0 ] = i;
						p_SelectedFurniture[ playerid ][ 1 ] = Streamer_GetIntData( STREAMER_TYPE_OBJECT, i, E_STREAMER_MODEL_ID );
						ShowPlayerDialog( playerid, DIALOG_FURNITURE_OPTION, DIALOG_STYLE_LIST, "Furniture", "Use Editor\nEdit Rotation X\nEdit Rotation Y\nEdit Rotation Z\nSell Object", "Select", "Back" );
				        break;
				    }
				    x++;
				}
			}
	    }
	    else ShowPlayerDialog( playerid, DIALOG_FURNITURE, DIALOG_STYLE_LIST, "{FFFFFF}Furniture", "Purchase Furniture\nSelect Furniture Easily\nSelect Furniture Manually\nSelect Furniture Nearest\n"COL_RED"Remove All Furniture", "Confirm", "Back" );
	}
	if ( dialogid == DIALOG_FURNITURE_OPTION )
	{
	    if ( !response ) return ShowPlayerDialog( playerid, DIALOG_FURNITURE, DIALOG_STYLE_LIST, "{FFFFFF}Furniture", "Purchase Furniture\nSelect Furniture Easily\nSelect Furniture Manually\nSelect Furniture Nearest\n"COL_RED"Remove All Furniture", "Confirm", "Back" );
        switch( listitem )
        {
            case 0: EditDynamicObject( playerid, p_SelectedFurniture[ playerid ][ 0 ] );
            case 1..3: p_FurnitureRotAxis{ playerid } = listitem, ShowPlayerDialog( playerid, DIALOG_FURNITURE_ROTATION, DIALOG_STYLE_INPUT, "{FFFFFF}Furniture", "{FFFFFF}Input your axis' value below.", "Confirm", "Back" );
            case 4:
            {
				new
					i = getFurnitureID( p_SelectedFurniture[ playerid ] [ 1 ] ),
					Float: X, Float: Y, Float: Z
				;

		        if ( p_InHouse[ playerid ] != -1 ) {
		       	 	if ( !strmatch( g_houseData[ p_InHouse[ playerid ] ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this house." );
		        	if ( !g_HouseFurnitureCount[ p_InHouse[ playerid ] ] ) return SendError( playerid, "There is no furniture left to sell." );
			    } else {
				    if ( p_ApartmentEditing{ playerid } != -1 && GetPlayerInterior( playerid ) == 0 ) {
				    	if ( !strmatch( g_apartmentData[ p_ApartmentEditing{ playerid } ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this apartment." );
				    	if ( !IsPlayerInApartmentArea( playerid, p_ApartmentEditing{ playerid } ) ) return SendError( playerid, "You're not inside this apartment!" );
		        		if ( !g_ApartmentFurnitureCount[ p_ApartmentEditing{ playerid } ] ) return SendError( playerid, "There is no furniture left to sell." );
				    } else return SendError( playerid, "You're not inside any house or not editing any specific apartment." );
			    }

				if ( i == 0xFF ) return SendError( playerid, "Unable to sell furniture due to an unexpected error (0x8F)." );
				GetDynamicObjectPos( p_SelectedFurniture[ playerid ] [ 0 ], X, Y, Z );
                DestroyDynamicObject( p_SelectedFurniture[ playerid ][ 0 ] );

				format( szNormalString, 100, "DELETE FROM `FURNITURE` WHERE `X`='%f' AND `Y`='%f' AND `Z`='%f'", X, Y, Z ), mysql_single_query( szNormalString );

				if ( !IsPlayerInApartmentArea( playerid, p_ApartmentEditing{ playerid } ) ) g_HouseFurnitureCount[ p_InHouse[ playerid ] ] --;
				else g_ApartmentFurnitureCount[ p_ApartmentEditing{ playerid } ] --;

				new
					iNetProfit = floatround( g_houseFurniture[ i ] [ E_COST ] / 2 );

				GivePlayerCash( playerid, iNetProfit );
				SendClientMessageFormatted( playerid, -1, ""COL_GREY"[FURNITURE]"COL_WHITE" You have successfully sold your "COL_WHITE"%s"COL_WHITE" for "COL_GOLD"%s"COL_WHITE".", g_houseFurniture[ i ] [ E_NAME ], ConvertPrice( iNetProfit ) );
        		ShowPlayerDialog( playerid, DIALOG_FURNITURE, DIALOG_STYLE_LIST, "{FFFFFF}Furniture", "Purchase Furniture\nSelect Furniture Easily\nSelect Furniture Manually\nSelect Furniture Nearest\n"COL_RED"Remove All Furniture", "Confirm", "Back" );
			}
        }
	}
	if ( dialogid == DIALOG_FURNITURE_ROTATION )
	{
		new Float: angle;
	    if ( !response ) return ShowPlayerDialog( playerid, DIALOG_FURNITURE, DIALOG_STYLE_LIST, "{FFFFFF}Furniture", "Purchase Furniture\nSelect Furniture Easily\nSelect Furniture Manually\nSelect Furniture Nearest\n"COL_RED"Remove All Furniture", "Confirm", "Back" );
		if ( sscanf( inputtext, "f", angle ) ) return ShowPlayerDialog( playerid, DIALOG_FURNITURE_ROTATION, DIALOG_STYLE_INPUT, "{FFFFFF}Furniture", "{FFFFFF}Input your axis' value below.\n\n"COL_RED"Invalid Value!", "Confirm", "Back" );

		new Float: rotX, Float: rotY, Float: rotZ, Float: X, Float: Y;
		GetDynamicObjectPos( p_SelectedFurniture[ playerid ] [ 0 ], X, Y, rotZ );
	    GetDynamicObjectRot( p_SelectedFurniture[ playerid ] [ 0 ], rotX, rotY, rotZ );

	    switch( p_FurnitureRotAxis{ playerid } )
	    {
			case 1: SetDynamicObjectRot( p_SelectedFurniture[ playerid ] [ 0 ], angle, rotY, rotZ );
			case 2: SetDynamicObjectRot( p_SelectedFurniture[ playerid ] [ 0 ], rotX, angle, rotZ );
			case 3: SetDynamicObjectRot( p_SelectedFurniture[ playerid ] [ 0 ], rotX, rotY, angle );
	    }

		format( szBigString, sizeof( szBigString ), "UPDATE `FURNITURE` SET `RX`='%f',`RY`='%f',`RZ`='%f' WHERE `X`='%f' AND `Y`='%f'", rotX, rotY, rotZ, X, Y );
		mysql_single_query( szBigString );

		SendServerMessage( playerid, "Furniture has been successfully updated." );
        ShowPlayerDialog( playerid, DIALOG_FURNITURE, DIALOG_STYLE_LIST, "{FFFFFF}Furniture", "Purchase Furniture\nSelect Furniture Easily\nSelect Furniture Manually\nSelect Furniture Nearest\n"COL_RED"Remove All Furniture", "Confirm", "Back" );
	}
	if ( dialogid == DIALOG_FURNITURE_LIST )
	{
	    if ( !response ) return ShowFurnitureCategory( playerid );

		new vip = ( p_VIPLevel[ playerid ] == 0 ? 20 : ( ( p_VIPLevel[ playerid ] + 1 ) * 6 ) + 20 ), totalf;

	    if ( p_InHouse[ playerid ] != -1 ) {
	   	 	if ( !strmatch( g_houseData[ p_InHouse[ playerid ] ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this house." );
			if ( ( totalf = g_HouseFurnitureCount[ p_InHouse[ playerid ] ] ) > vip ) return SendError( playerid, "You have reached the maximum furniture limit." );
	    } else {
		    if ( p_ApartmentEditing{ playerid } != -1 ) {
		    	if ( !strmatch( g_apartmentData[ p_ApartmentEditing{ playerid } ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this apartment." );
				if ( !IsPlayerInApartmentArea( playerid, p_ApartmentEditing{ playerid } ) ) return SendError( playerid, "You're not inside this apartment!" );
				vip += 50; // 50 more slots for Apartments!
				if ( ( totalf = g_ApartmentFurnitureCount[ p_ApartmentEditing{ playerid } ] ) > vip ) return SendError( playerid, "You have reached the maximum furniture limit." );
		    } else return SendError( playerid, "You're not inside any house or not editing any specific apartment." );
	    }


	    for( new i, x = 0; i < sizeof( g_houseFurniture ); i++ )
		{
			if ( p_FurnitureCategory{ playerid } == g_houseFurniture[ i ] [ E_CATEGORY ] )
		 	{
		       	if ( x == listitem )
		      	{
		      		if ( GetPlayerCash( playerid ) < g_houseFurniture[ i ] [ E_COST ] )
				    {
						ShowFurnitureList( playerid, p_FurnitureCategory{ playerid } );
				        return SendError( playerid, "You don't have enough money for this piece of furniture." );
				    }
				    new
						hid = p_InHouse[ playerid ],
						aid = p_ApartmentEditing{ playerid },
						Float: X, Float: Y, Float: Z
					;
					GetXYInFrontOfPlayer( playerid, X, Y, Z, 2.0 );
					GivePlayerCash( playerid, -g_houseFurniture[ i ] [ E_COST ] );

		    		new is_in_apartment = IsPlayerInApartmentArea( playerid, p_ApartmentEditing{ playerid } );

					if ( !is_in_apartment )
						aid = -1, g_HouseFurnitureCount[ hid ] ++;
					else
						hid = -1, g_ApartmentFurnitureCount[ aid ] ++;

					format( szBigString, sizeof( szBigString ), "INSERT INTO `FURNITURE` (`H_ID`,`A_ID`,`OWNER`,`MODEL`,`X`,`Y`,`Z`,`RX`,`RY`,`RZ`) VALUES (%d,%d,%d,%d,'%f','%f','%f','%f','%f','%f')", hid, aid, p_AccountID[ playerid ], g_houseFurniture[ i ] [ E_MODEL ], X, Y, Z, 0, 0, 0 );
					mysql_single_query( szBigString );

					new o = CreateDynamicObject( g_houseFurniture[ i ] [ E_MODEL ], X, Y, Z, 0.0, 0.0, 0.0, !is_in_apartment ? hid + MAX_HOUSES : 0 );
					SetGVarInt( "fur_w", !is_in_apartment ? hid + MAX_HOUSES : 0, o );
					SetGVarInt( "fur_f", i, o );
					SetGVarInt( "fur_a", aid, o );
					SyncObject( playerid );

					SendServerMessage( playerid, "You have purchased a "COL_GREY"%s"COL_WHITE". "COL_ORANGE"[%d/%d]", g_houseFurniture[ i ] [ E_NAME ], totalf, vip );
					ShowFurnitureList( playerid, p_FurnitureCategory{ playerid } );
				 	break;
	      		}
		      	x ++;
			}
		}
	}
	if ( ( dialogid == DIALOG_ONLINE_JOB ) && response )
	{
	 	new
		 	count = 0;

		erase( szLargeString );
		foreach(new pID : Player)
		{
		    if ( JobEquals( pID, listitem ) && p_Class[ pID ] == CLASS_CIVILIAN )
		    {
		        format( szLargeString, sizeof( szLargeString ), "%s%s(%d)\n", szLargeString, ReturnPlayerName( pID ), pID );
		        count++;
		    }
		}
		if ( !count ) szLargeString = ""COL_RED"N/A";

		format( szNormalString, 32, "{FFFFFF}Online %ss", GetJobName( listitem ) );
		ShowPlayerDialog( playerid, DIALOG_ONLINE_JOB_R, DIALOG_STYLE_LIST, szNormalString, szLargeString, "Okay", "Back" );
	}
	if ( ( dialogid == DIALOG_ONLINE_JOB_R ) && !response )  { cmd_playerjobs( playerid, "" ); }
	if ( ( dialogid == DIALOG_HELP ) && response )
	{
		SetPVarInt( playerid, "help_category", listitem );
	    format( szNormalString, sizeof( szNormalString ), "SELECT `SUBJECT`,`ID`,`CATEGORY` FROM `HELP` WHERE `CATEGORY`=%d ORDER BY `SUBJECT` ASC", GetPVarInt( playerid, "help_category" ) );
	    mysql_function_query( dbHandle, szNormalString, true, "OnFetchCategoryResponse", "dd", playerid, GetPVarInt( playerid, "help_category" ) );
	}
	if ( dialogid == DIALOG_HELP_CATEGORY )
	{
		if ( !response )
			return cmd_help( playerid, "" );

		if ( listitem >= 64 )
			return SendError( playerid, "Unable to process request, contact Lorenc in regards to this." );

		new
			digits[ 64 ];

		GetPVarString( playerid, "help_ids", szBigString, sizeof( szBigString ) );
		sscanf( szBigString, "a<i>[64]", digits );

	    //format( szNormalString, 96, "SELECT * FROM `HELP` WHERE `CATEGORY`=%d AND `ID`=%d", GetPVarInt( playerid, "help_category" ), digits[ listitem ] );
	    //mysql_function_query( dbHandle, szNormalString, true, "OnFetchThreadData", "ddd", playerid, GetPVarInt( playerid, "help_category" ), digits[ listitem ] );

		HTTP( playerid, HTTP_GET, sprintf( "sfcnr.com/api/player/help/%d", digits[ listitem ] ), "", "OnHelpHTTPResponse" );
	}
	if ( ( dialogid == DIALOG_HELP_THREAD ) && !response )
	{
	    format( szNormalString, 72, "SELECT `SUBJECT`,`ID`,`CATEGORY` FROM `HELP` WHERE `CATEGORY`=%d ORDER BY `SUBJECT` ASC", GetPVarInt( playerid, "help_category" ) );
	    mysql_function_query( dbHandle, szNormalString, true, "OnFetchCategoryResponse", "dd", playerid, GetPVarInt( playerid, "help_category" ) );
	}
	if ( ( dialogid == DIALOG_HELP_BACK ) && !response ) return cmd_help( playerid, "" );
	if ( ( dialogid == DIALOG_GATE ) && response )
	{
		new
			objectid = GetPVarInt( playerid, "gate_editing" );

		SetPVarInt( playerid, "gate_edititem", listitem );

		if ( listitem == 0 )
		{
			Iter_Remove( gates, objectid );
			DestroyDynamicObject( g_gateData[ objectid ] [ E_OBJECT ] );
			g_gateData[ objectid ] [ E_OBJECT ] = INVALID_OBJECT_ID;
			DeletePVar( playerid, "gate_editing" );
			DeletePVar( playerid, "gate_edititem" );

			SaveToAdminLog( playerid, objectid, "destroyed gate" );
			format( szNormalString, sizeof( szNormalString ), "DELETE FROM `GATES` WHERE ID=%d", objectid );
			mysql_single_query( szNormalString );

			SendClientMessageFormatted( playerid, -1, ""COL_PINK"[GATE]"COL_WHITE" You have removed a gate: "COL_GREY"%s"COL_WHITE".", g_gateData[ objectid ] [ E_NAME ] );
		}
		else if ( listitem < 8 ) ShowPlayerDialog( playerid, DIALOG_GATE_EDIT, DIALOG_STYLE_INPUT, "{FFFFFF}Gate - Edit", ""COL_WHITE"Value to replace with:", "Commit", "Back" );
		else
		{
			SendServerMessage( playerid, "Hit the save icon to update the position of the gate." );
			EditDynamicObject( playerid, g_gateData[ objectid ] [ E_OBJECT ] );
		}
	}
	if ( ( dialogid == DIALOG_GATE_OWNER ) && response )
	{
		SetPVarInt( playerid, "gate_o_edititem", listitem );
		ShowPlayerDialog( playerid, DIALOG_GATE_OWNER_EDIT, DIALOG_STYLE_INPUT, "{FFFFFF}Gate - Edit", ""COL_WHITE"What would you like to change this to?", "Commit", "Back" );
	}
	if ( dialogid == DIALOG_GATE_OWNER_EDIT )
	{
		if ( response )
		{
			new
				gID = GetPVarInt( playerid, "gate_o_editing" );

			switch( GetPVarInt( playerid, "gate_o_edititem" ) )
			{
				case 0:
				{
					if ( strlen( inputtext ) < 3 || strlen( inputtext ) >= 24 )
						return ShowPlayerDialog( playerid, DIALOG_GATE_OWNER_EDIT, DIALOG_STYLE_INPUT, "{FFFFFF}Gate - Edit", ""COL_RED"The name must range between 3 and 24 characters.\n\n"COL_WHITE"What would you like to change this to?", "Commit", "Back" );

					format( g_gateData[ gID ] [ E_NAME ], 24, "%s", inputtext );
				}
				case 1:
				{
					if ( strlen( inputtext ) < 3 || strlen( inputtext ) >= 8 )
				 		return ShowPlayerDialog( playerid, DIALOG_GATE_OWNER_EDIT, DIALOG_STYLE_INPUT, "{FFFFFF}Gate - Edit", ""COL_RED"The password must range between 3 and 8 characters.\n\n"COL_WHITE"What would you like to change this to?", "Commit", "Back" );

					format( g_gateData[ gID ] [ E_PASS ], 8, "%s", inputtext );
				}
			}
			UpdateGateData( gID );
			SyncObject( playerid );
			cmd_gate( playerid, "edit" );
			DeletePVar( playerid, "gate_o_edititem" );
			DeletePVar( playerid, "gate_o_editing" );
			SendServerMessage( playerid, "You have successfully updated this gate." );
		}
		else cmd_gate( playerid, "edit" );
	}
	if ( dialogid == DIALOG_GATE_EDIT )
	{
		new
			gID = GetPVarInt( playerid, "gate_editing" );

		if ( response )
		{
			switch( GetPVarInt( playerid, "gate_edititem" ) )
			{
				case 1:
				{
					new
						pID;

					if ( sscanf( inputtext, #sscanf_u, pID ) )
					{
						SendError( playerid, "This value must be numerical." );
						return ShowPlayerDialog( playerid, DIALOG_GATE_EDIT, DIALOG_STYLE_INPUT, "{FFFFFF}Gate - Edit", ""COL_WHITE"Value to replace with:", "Commit", "Back" );
					}
					else if ( !IsPlayerConnected( pID ) )
					{
						SendError( playerid, "Invalid Player ID." );
						return ShowPlayerDialog( playerid, DIALOG_GATE_EDIT, DIALOG_STYLE_INPUT, "{FFFFFF}Gate - Edit", ""COL_WHITE"Value to replace with:", "Commit", "Back" );
					}
					g_gateData[ gID ] [ E_OWNER ] = p_AccountID[ pID ];
				}
				case 2:
				{
					if ( strlen( inputtext ) < 3 || strlen( inputtext ) >= 24 )
					{
						SendError( playerid, "The name must range between 3 and 24 characters." );
						return ShowPlayerDialog( playerid, DIALOG_GATE_EDIT, DIALOG_STYLE_INPUT, "{FFFFFF}Gate - Edit", ""COL_WHITE"Value to replace with:", "Commit", "Back" );
					}
					format( g_gateData[ gID ] [ E_NAME ], 24, "%s", inputtext );
				}
				case 3:
				{
					if ( strlen( inputtext ) < 3 || strlen( inputtext ) >= 8 )
					{
						SendError( playerid, "The password must range between 3 and 8 characters." );
						return ShowPlayerDialog( playerid, DIALOG_GATE_EDIT, DIALOG_STYLE_INPUT, "{FFFFFF}Gate - Edit", ""COL_WHITE"Value to replace with:", "Commit", "Back" );
					}
					format( g_gateData[ gID ] [ E_PASS ], 8, "%s", inputtext );
				}
				case 4:
				{
					new
						model;

					if ( sscanf( inputtext, "d", model ) )
					{
						SendError( playerid, "This value must be numerical." );
						return ShowPlayerDialog( playerid, DIALOG_GATE_EDIT, DIALOG_STYLE_INPUT, "{FFFFFF}Gate - Edit", ""COL_WHITE"Value to replace with:", "Commit", "Back" );
					}
					g_gateData[ gID ] [ E_MODEL ] = model;
				}
				case 5:
				{
					new
						Float: speed;

					if ( sscanf( inputtext, "f", speed ) )
					{
						SendError( playerid, "This value must be numerical." );
						return ShowPlayerDialog( playerid, DIALOG_GATE_EDIT, DIALOG_STYLE_INPUT, "{FFFFFF}Gate - Edit", ""COL_WHITE"Value to replace with:", "Commit", "Back" );
					}
					g_gateData[ gID ] [ E_SPEED ] = speed;
				}
				case 6:
				{
					new
						Float: range;

					if ( sscanf( inputtext, "f", range ) )
					{
						SendError( playerid, "This value must be numerical." );
						return ShowPlayerDialog( playerid, DIALOG_GATE_EDIT, DIALOG_STYLE_INPUT, "{FFFFFF}Gate - Edit", ""COL_WHITE"Value to replace with:", "Commit", "Back" );
					}
					g_gateData[ gID ] [ E_RANGE ] = range;
				}
				case 7:
				{
					new
						time;

					if ( sscanf( inputtext, "d", time ) )
					{
						SendError( playerid, "This value must be numerical." );
						return ShowPlayerDialog( playerid, DIALOG_GATE_EDIT, DIALOG_STYLE_INPUT, "{FFFFFF}Gate - Edit", ""COL_WHITE"Value to replace with:", "Commit", "Back" );
					}
					else if ( time < 100 || time > 60000 )
					{
						SendError( playerid, "This value must be between 100 and 60000 miliseconds." );
						return ShowPlayerDialog( playerid, DIALOG_GATE_EDIT, DIALOG_STYLE_INPUT, "{FFFFFF}Gate - Edit", ""COL_WHITE"Value to replace with:", "Commit", "Back" );
					}
					g_gateData[ gID ] [ E_TIME ] = time;
				}
			}
			UpdateGateData( gID );
			SyncObject( playerid );
			cmd_editgate( playerid, sprintf( "%d", gID ) );
			SendServerMessage( playerid, "You have successfully updated this gate." );
		}
		else cmd_editgate( playerid, sprintf( "%d", gID ) );
	}
	if ( ( dialogid == DIALOG_VIP ) && response )
	{
		if ( strlen( inputtext ) != 16 )
		{
			cmd_donated( playerid, "" );
			return SendError( playerid, "The transaction ID you entered is invalid." );
		}

		if ( g_redeemVipWait > g_iTime )
		{
			cmd_donated( playerid, "" );
			return SendServerMessage( playerid, "Our anti-exploit system requires you to wait another %d seconds before redeeming.", g_redeemVipWait - g_iTime );
		}

		HTTP( playerid, HTTP_GET, sprintf( "irresistiblegaming.com/donate/validate_code/%s", inputtext ), "", "OnDonationRedemptionResponse" );
		SendServerMessage( playerid, "We're now looking up this transaction. Please wait." );
	}
	if ( dialogid == DIALOG_DONATED )
	{
		szLargeString[ 0 ] = '\0';
		strcat( szLargeString,	""COL_WHITE"Thank you a lot for donating! :D In return for your dignity, you have received Irresistible Coins.\n\n"\
								""COL_GREY" * What do I do with Irresistible Coins?"COL_WHITE" You can claim the V.I.P of your choice via "COL_GREY"/irresistiblecoins market"COL_WHITE".\n" );
		strcat( szLargeString,	""COL_GREY" * How many do I have?"COL_WHITE" You can see how many Irresistible Coins you have via "COL_GREY"/irresistiblecoins"COL_WHITE".\n" \
								""COL_GREY" * I'm unsure, help?"COL_WHITE" If you have any questions, please /ask otherwise enquire Lorenc via the forums!\n\nThank you once again for your contribution to our community! :P"  );
		return ShowPlayerDialog( playerid, DIALOG_FINISHED_DONATING, DIALOG_STYLE_MSGBOX, ""COL_GOLD"Irresistible Gaming Donation", szLargeString, "Got it!", "" );
	}
	if ( dialogid == DIALOG_FINISHED_DONATING ) {
		return ShowPlayerDialog( playerid, DIALOG_LATEST_DONOR, DIALOG_STYLE_MSGBOX, ""COL_GOLD"Irresistible Gaming Donation", ""COL_WHITE"Would you like to be shown as the latest donor?", "Yes", "No" );
	}
	if ( dialogid == DIALOG_LATEST_DONOR ) {
		if ( GetPVarType( playerid, "just_donated" ) != PLAYER_VARTYPE_FLOAT )
			return SendError( playerid, "Seems to be an issue where we couldn't find how much you donated. Report to Lorenc." );

		new
			Float: fAmount = GetPVarFloat( playerid, "just_donated" );

		DeletePVar( playerid, "just_donated" );
		return UpdateGlobalDonated( playerid, fAmount, !response );
	}
	if ( ( dialogid == DIALOG_IC_MARKET ) && response )
	{
		if ( listitem == sizeof( a_vipCoinRequirements ) - 1 )
			return ShowPlayerCoinMarketDialog( playerid, true );

		new
			Float: iCoinRequirement = a_vipCoinRequirements[ sizeof( a_vipCoinRequirements ) - 1 - listitem ];

		p_CoinMarketSecondPage{ playerid } = false;
		p_CoinMarketListitem{ playerid } = listitem;

		if ( listitem != 0 ) // No discount for diamond
			iCoinRequirement *= GetGVarFloat( "vip_discount" );

		return ShowPlayerDialog( playerid, DIALOG_YOU_SURE_VIP, DIALOG_STYLE_MSGBOX, ""COL_GOLD"Irresistible Coin -{FFFFFF} Confirmation", sprintf( ""COL_WHITE"Are you sure that you want to spend %0.2f IC?", iCoinRequirement ), "Yes", "No" );
	}
	if ( dialogid == DIALOG_IC_MARKET_2 )
	{
		if ( ! response )
			return ShowPlayerCoinMarketDialog( playerid );

		new
			Float: iCoinRequirement = 0.0;

		p_CoinMarketSecondPage{ playerid } = true;
		p_CoinMarketListitem{ playerid } = listitem;

		// record coin requirements
		switch( listitem )
		{
			case 0:  iCoinRequirement = 1500.0;
			case 1:  iCoinRequirement = 800.0;
			case 2:  iCoinRequirement = 750.0;
			case 3:  iCoinRequirement = 600.0;
			case 4:	 iCoinRequirement = 600.0;
			case 5:  iCoinRequirement = 500.0;
			case 6:	 iCoinRequirement = 350.0;
			case 7:	 iCoinRequirement = 250.0;
			case 8:	 iCoinRequirement = 100.0;
			case 9:  iCoinRequirement = 50.0;
		}

		// apply discount
		iCoinRequirement *= GetGVarFloat( "vip_discount" );
		return ShowPlayerDialog( playerid, DIALOG_YOU_SURE_VIP, DIALOG_STYLE_MSGBOX, ""COL_GOLD"Irresistible Coin -{FFFFFF} Confirmation", sprintf( ""COL_WHITE"Are you sure that you want to spend %0.2f IC?", iCoinRequirement ), "Yes", "No" );
	}
	if ( dialogid == DIALOG_YOU_SURE_VIP )
	{
		if ( !response )
			return ShowPlayerCoinMarketDialog( playerid, p_CoinMarketSecondPage{ playerid } );

		new
			Float: iCoinRequirement;

		listitem = p_CoinMarketListitem{ playerid };

		if ( ! p_CoinMarketSecondPage{ playerid } )
		{
			new
				iVipLevel = sizeof( a_vipCoinRequirements ) - 1 - listitem;

			if ( ( iCoinRequirement = a_vipCoinRequirements[ iVipLevel ] * ( iVipLevel == VIP_DIAMOND ? 1.0 : GetGVarFloat( "vip_discount" ) ) ) <= p_IrresistibleCoins[ playerid ] )
			{
				// Deduct IC
				p_IrresistibleCoins[ playerid ] -= iCoinRequirement;

				// Set VIP Level
				SetPlayerVipLevel( playerid, iVipLevel );

				// Send message
				SendClientMessageFormatted( playerid, -1, ""COL_GOLD"[VIP PACKAGE]"COL_WHITE" You have redeemed %s V.I.P for %0.0f Irresistible Coins! Congratulations! :D", VIPToString( iVipLevel ), iCoinRequirement );

				// Redirect player
				if ( iVipLevel == VIP_DIAMOND ) {
					ShowPlayerDialog( playerid, DIALOG_DONATED_DIAGOLD, DIALOG_STYLE_INPUT, ""COL_GOLD"Irresistible Gaming Donation", ""COL_WHITE"As you've redeemed Diamond V.I.P, you have the option of gifting Gold VIP to someone.\n\nIf you would like to gift it to yourself, type your name/id or the person you're gifting it to.\n\n"COL_ORANGE"If you just don't know yet, cancel and PM Lorenc on the forum when you make a decision!", "Gift it!", "I'll Think!" );
				}
				else if ( iVipLevel == VIP_PLATINUM ) {
					ShowPlayerDialog( playerid, DIALOG_DONATED_PLATBRONZE, DIALOG_STYLE_INPUT, ""COL_GOLD"Irresistible Gaming Donation", ""COL_WHITE"As you've redeemed Platinum V.I.P, you have the option of gifting Bronze VIP to someone.\n\nIf you would like to gift it to yourself, type your name/id or the person you're gifting it to.\n\n"COL_ORANGE"If you just don't know yet, cancel and PM Lorenc on the forum when you make a decision!", "Gift it!", "I'll Think!" );
				}
				else
				{
					ShowPlayerVipRedeemedDialog( playerid );
				}
				return 1;
			}
			else
			{
				SendError( playerid, "You need around %0.2f coins before you can get this!", iCoinRequirement - p_IrresistibleCoins[ playerid ] );
				return ShowPlayerCoinMarketDialog( playerid, p_CoinMarketSecondPage{ playerid } );
			}
		}
		else
		{
			switch( listitem )
			{
				case 0:
				{
					if ( ( iCoinRequirement = 1500.0 * GetGVarFloat( "vip_discount" ) ) <= p_IrresistibleCoins[ playerid ] )
					{
						p_IrresistibleCoins[ playerid ] -= iCoinRequirement;
		    			AddPlayerNote( playerid, -1, ""COL_GOLD"V.I.P Business (Coke)" #COL_WHITE );
		    			SendClientMessageToAdmins( -1, ""COL_PINK"[DONOR NEEDS HELP]"COL_GREY" %s(%d) needs a VIP Coke Business. (/viewnotes)", ReturnPlayerName( playerid ), playerid );
		    			SendServerMessage( playerid, "You have ordered a "COL_GOLD"V.I.P Coke Business"COL_WHITE" for %0.0f Irresistible Coins!", iCoinRequirement );
		    			SendServerMessage( playerid, "Online admins have been dispatched and you have been noted for assistance. If you see a head admin, ask them to receive your business." );
					}
					else
					{
						SendError( playerid, "You need around %0.2f coins before you can get this!", iCoinRequirement - p_IrresistibleCoins[ playerid ] );
						return ShowPlayerCoinMarketDialog( playerid, true );
					}
				}
				case 1:
				{
					if ( ( iCoinRequirement = 800.0 * GetGVarFloat( "vip_discount" ) ) <= p_IrresistibleCoins[ playerid ] )
					{
						p_IrresistibleCoins[ playerid ] -= iCoinRequirement;
		    			AddPlayerNote( playerid, -1, ""COL_GOLD"V.I.P Business (Meth)" #COL_WHITE );
		    			SendClientMessageToAdmins( -1, ""COL_PINK"[DONOR NEEDS HELP]"COL_GREY" %s(%d) needs a VIP Meth Business. (/viewnotes)", ReturnPlayerName( playerid ), playerid );
		    			SendServerMessage( playerid, "You have ordered a "COL_GOLD"V.I.P Meth Business"COL_WHITE" for %0.0f Irresistible Coins!", iCoinRequirement );
		    			SendServerMessage( playerid, "Online admins have been dispatched and you have been noted for assistance. If you see a head admin, ask them to receive your business." );
					}
					else
					{
						SendError( playerid, "You need around %0.2f coins before you can get this!", iCoinRequirement - p_IrresistibleCoins[ playerid ] );
						return ShowPlayerCoinMarketDialog( playerid, true );
					}
				}
				case 2:
				{
					if ( ( iCoinRequirement = 750.0 * GetGVarFloat( "vip_discount" ) ) <= p_IrresistibleCoins[ playerid ] )
					{
						if ( p_ExtraAssetSlots{ playerid } >= MAX_EXTRA_SLOTS )
						{
							SendError( playerid, "You have reached the limit of additional slots (limit " #MAX_EXTRA_SLOTS ")." );
							return ShowPlayerCoinMarketDialog( playerid, true );
						}

						// Issue coins and increase assets
						p_IrresistibleCoins[ playerid ] -= iCoinRequirement;
						p_ExtraAssetSlots{ playerid } ++;

						// Receipt and message
			    		SendServerMessage( playerid, "You have redeemed an "COL_GOLD"extra house and vehicle slot"COL_WHITE" for %0.0f Irresistible Coins!", iCoinRequirement );
		    			AddPlayerNote( playerid, -1, sprintf( "Bought extra slot, has %d extra", p_ExtraAssetSlots{ playerid } ) );
					}
					else
					{
						SendError( playerid, "You need around %0.2f coins before you can get this!", iCoinRequirement - p_IrresistibleCoins[ playerid ] );
						return ShowPlayerCoinMarketDialog( playerid, true );
					}
				}
				case 3:
				{
					if ( ( iCoinRequirement = 600.0 * GetGVarFloat( "vip_discount" ) ) <= p_IrresistibleCoins[ playerid ] )
					{
						p_IrresistibleCoins[ playerid ] -= iCoinRequirement;
		    			AddPlayerNote( playerid, -1, ""COL_GOLD"V.I.P Vehicle (IC)" #COL_WHITE );
		    			SendClientMessageToAdmins( -1, ""COL_PINK"[DONOR NEEDS HELP]"COL_GREY" %s(%d) needs a VIP vehicle. (/viewnotes)", ReturnPlayerName( playerid ), playerid );
		    			SendServerMessage( playerid, "You have ordered a "COL_GOLD"V.I.P Vehicle"COL_WHITE" for %0.0f Irresistible Coins!", iCoinRequirement );
		    			SendServerMessage( playerid, "Online admins have been dispatched and you have been noted for assistance. If you see a head admin, ask them to receive your vehicle." );
					}
					else
					{
						SendError( playerid, "You need around %0.2f coins before you can get this!", iCoinRequirement - p_IrresistibleCoins[ playerid ] );
						return ShowPlayerCoinMarketDialog( playerid, true );
					}
				}
				case 4:
				{
					if ( ( iCoinRequirement = 600.0 * GetGVarFloat( "vip_discount" ) ) <= p_IrresistibleCoins[ playerid ] )
					{
						p_IrresistibleCoins[ playerid ] -= iCoinRequirement;
		    			AddPlayerNote( playerid, -1, ""COL_GOLD"V.I.P House (IC)" #COL_WHITE );
		    			SendClientMessageToAdmins( -1, ""COL_PINK"[DONOR NEEDS HELP]"COL_GREY" %s(%d) needs a VIP house. (/viewnotes)", ReturnPlayerName( playerid ), playerid );
		    			SendServerMessage( playerid, "You have ordered a "COL_GOLD"V.I.P House"COL_WHITE" for %0.0f Irresistible Coins!", iCoinRequirement );
		    			SendServerMessage( playerid, "Online admins have been dispatched and you have been noted for assistance. If you see a head admin, ask them to receive your house." );
					}
					else
					{
						SendError( playerid, "You need around %0.2f coins before you can get this!", iCoinRequirement - p_IrresistibleCoins[ playerid ] );
						return ShowPlayerCoinMarketDialog( playerid, true );
					}
				}
				case 5:
				{
					if ( ( iCoinRequirement = 500.0 * GetGVarFloat( "vip_discount" ) ) <= p_IrresistibleCoins[ playerid ] )
					{
						p_IrresistibleCoins[ playerid ] -= iCoinRequirement;
		    			AddPlayerNote( playerid, -1, ""COL_GOLD"V.I.P Business (Weed)" #COL_WHITE );
		    			SendClientMessageToAdmins( -1, ""COL_PINK"[DONOR NEEDS HELP]"COL_GREY" %s(%d) needs a VIP Weed Business. (/viewnotes)", ReturnPlayerName( playerid ), playerid );
		    			SendServerMessage( playerid, "You have ordered a "COL_GOLD"V.I.P Weed Business"COL_WHITE" for %0.0f Irresistible Coins!", iCoinRequirement );
		    			SendServerMessage( playerid, "Online admins have been dispatched and you have been noted for assistance. If you see a head admin, ask them to receive your business." );
					}
					else
					{
						SendError( playerid, "You need around %0.2f coins before you can get this!", iCoinRequirement - p_IrresistibleCoins[ playerid ] );
						return ShowPlayerCoinMarketDialog( playerid, true );
					}
				}
				case 6:
				{
					if ( ( iCoinRequirement = 350.0 * GetGVarFloat( "vip_discount" ) ) <= p_IrresistibleCoins[ playerid ] )
					{
						p_IrresistibleCoins[ playerid ] -= iCoinRequirement;
		    			AddPlayerNote( playerid, -1, ""COL_GOLD"Custom Gate (IC)" #COL_WHITE );
		    			SendClientMessageToAdmins( -1, ""COL_PINK"[DONOR NEEDS HELP]"COL_GREY" %s(%d) needs a custom gate. (/viewnotes)", ReturnPlayerName( playerid ), playerid );
		    			SendServerMessage( playerid, "You have ordered a "COL_GOLD"Custom Gate"COL_WHITE" for %0.0f Irresistible Coins!", iCoinRequirement );
		    			SendServerMessage( playerid, "Online admins have been dispatched and you have been noted for assistance. If you see a head admin, ask them to receive your custom gate." );
					}
					else
					{
						SendError( playerid, "You need around %0.2f coins before you can get this!", iCoinRequirement - p_IrresistibleCoins[ playerid ] );
						return ShowPlayerCoinMarketDialog( playerid, true );
					}
				}
				case 7:
				{
					if ( ( iCoinRequirement = 250.0 * GetGVarFloat( "vip_discount" ) ) <= p_IrresistibleCoins[ playerid ] )
					{
						p_IrresistibleCoins[ playerid ] -= iCoinRequirement;
		    			AddPlayerNote( playerid, -1, ""COL_GOLD"V.I.P Garage (IC)" #COL_WHITE );
		    			SendClientMessageToAdmins( -1, ""COL_PINK"[DONOR NEEDS HELP]"COL_GREY" %s(%d) needs a VIP garage. (/viewnotes)", ReturnPlayerName( playerid ), playerid );
		    			SendServerMessage( playerid, "You have ordered a "COL_GOLD"V.I.P Garage"COL_WHITE" for %0.0f Irresistible Coins!", iCoinRequirement );
		    			SendServerMessage( playerid, "Online admins have been dispatched and you have been noted for assistance. If you see a head admin, ask them to receive your garage." );
					}
					else
					{
						SendError( playerid, "You need around %0.2f coins before you can get this!", iCoinRequirement - p_IrresistibleCoins[ playerid ] );
						return ShowPlayerCoinMarketDialog( playerid, true );
					}
				}
				case 8:
				{
					if ( ( iCoinRequirement = 100.0 * GetGVarFloat( "vip_discount" ) ) <= p_IrresistibleCoins[ playerid ] )
					{
				        new
				        	ownerid = INVALID_PLAYER_ID,
				        	vehicleid = GetPlayerVehicleID( playerid ),
				        	buyableid = getVehicleSlotFromID( vehicleid, ownerid ),
				        	modelid = GetVehicleModel( vehicleid )
				        ;

					    if ( !vehicleid ) SendError( playerid, "You need to be in a vehicle to use this command." );
						else if ( buyableid == -1 ) SendError( playerid, "This vehicle isn't a buyable vehicle." );
						else if ( playerid != ownerid ) SendError( playerid, "You are not the owner of this vehicle." );
						else if ( IsBoatVehicle( modelid ) || IsAirVehicle( modelid ) ) SendError( playerid, "You cannot apply gold rims to this type of vehicle." );
						else
						{
	     					if ( AddVehicleComponent( vehicleid, 1080 ) )
	     					{
						        if ( UpdateBuyableVehicleMods( playerid, buyableid ) )
						        {
						        	new
						        		szMods[ MAX_CAR_MODS * 10 ];

									for( new i; i < MAX_CAR_MODS; i++ )
										format( szMods, sizeof( szMods ), "%s%d.", szMods, g_vehicleModifications[ playerid ] [ buyableid ] [ i ] );

									format( szBigString, sizeof( szBigString ), "UPDATE `VEHICLES` SET `MODS`='%s' WHERE `ID`=%d", szMods, g_vehicleData[ playerid ] [ buyableid ] [ E_SQL_ID ] );
									mysql_single_query( szBigString );
						        }

								p_IrresistibleCoins[ playerid ] -= iCoinRequirement;
			    				SendServerMessage( playerid, "You have redeemed "COL_GOLD"Gold Rims"COL_WHITE" on your vehicle for %0.0f Irresistible Coins!", iCoinRequirement );

			    				// Receipt
		    					AddPlayerNote( playerid, -1, sprintf( "Bought gold rims on vehicle #%d", g_vehicleData[ playerid ] [ buyableid ] [ E_SQL_ID ] ) );
						   	}
						   	else SendError( playerid, "We were unable to place gold rims on this vehicle (0xF92D)." );
			    		}
						return ShowPlayerCoinMarketDialog( playerid, true );
					}
					else
					{
						SendError( playerid, "You need around %0.2f coins before you can get this!", iCoinRequirement - p_IrresistibleCoins[ playerid ] );
						return ShowPlayerCoinMarketDialog( playerid, true );
					}
				}
				case 9: ShowPlayerDialog( playerid, DIALOG_CHANGENAME, DIALOG_STYLE_INPUT, "Change your name", ""COL_WHITE"What would you like your new name to be? And also, double check!", "Change", "Back" );
			}
		}
	}
	if ( dialogid == DIALOG_CHANGENAME )
	{
		if ( !response )
			return ShowPlayerCoinMarketDialog( playerid, true );

		static
			Float: iCoinRequirement;

		if ( ( iCoinRequirement = 50.0 * GetGVarFloat( "vip_discount" ) ) <= p_IrresistibleCoins[ playerid ] )
		{
			new
				szName[ 20 ];

			if ( sscanf( inputtext, "s[20]", szName ) ) SendError( playerid, "The name you have input is considered invalid." );
			else if ( !isValidPlayerName( szName ) ) SendError( playerid, "This name consists of invalid characters." );
			else
			{
				return mysql_function_query( dbHandle, sprintf( "SELECT `NAME` FROM `BANS` WHERE `NAME`='%s'", mysql_escape( szName ) ), true, "OnNewNameCheckBanned", "dfs", playerid, iCoinRequirement, szName );
			}
			return ShowPlayerDialog( playerid, DIALOG_CHANGENAME, DIALOG_STYLE_INPUT, "Change your name", ""COL_WHITE"What would you like your new name to be? And also, double check!", "Change", "Back" );
		}
		else
		{
			SendError( playerid, "You need around %0.2f coins before you can get this!", iCoinRequirement - p_IrresistibleCoins[ playerid ] );
			return ShowPlayerCoinMarketDialog( playerid, true );
		}
	}
	if ( dialogid == DIALOG_DONATED_PLATBRONZE )
	{
		if ( response )
		{
			new
				pID;

			if ( sscanf( inputtext, #sscanf_u, pID ) )
			{
				SendError( playerid, "Please enter a player's ID or name." );
				ShowPlayerDialog( playerid, DIALOG_DONATED_PLATBRONZE, DIALOG_STYLE_INPUT, ""COL_GOLD"Irresistible Gaming Donation", ""COL_WHITE"As you've redeemed Platinum V.I.P, you have the option of gifting Bronze VIP to someone.\n\nIf you would like to gift it to yourself, type your name/id or the person you're gifting it to.\n\n"COL_ORANGE"If you just don't know yet, cancel and PM Lorenc on the forum when you make a decision!", "Gift it!", "I'll Think!" );
			}
			else if ( !IsPlayerConnected( pID ) )
			{
				SendError( playerid, "This player is not connected." );
				ShowPlayerDialog( playerid, DIALOG_DONATED_PLATBRONZE, DIALOG_STYLE_INPUT, ""COL_GOLD"Irresistible Gaming Donation", ""COL_WHITE"As you've redeemed Platinum V.I.P, you have the option of gifting Bronze VIP to someone.\n\nIf you would like to gift it to yourself, type your name/id or the person you're gifting it to.\n\n"COL_ORANGE"If you just don't know yet, cancel and PM Lorenc on the forum when you make a decision!", "Gift it!", "I'll Think!" );
			}
			else
			{
				SendClientMessageFormatted( playerid, -1, ""COL_GOLD"[V.I.P]"COL_WHITE" You have gifted Bronze V.I.P to %s(%d)!", ReturnPlayerName( pID ), pID );
				SetPlayerVipLevel( pID, VIP_BRONZE );
				ShowPlayerVipRedeemedDialog( playerid );
			}
		}
		else
		{
	 		AddPlayerNote( playerid, -1, "{CD7F32}Bronze V.I.P" #COL_WHITE );
			SendServerMessage( playerid, "Okay. This has been noted down for your account and will be given to you at a stage that you want, do contact Lorenc though." );
			ShowPlayerVipRedeemedDialog( playerid );
		}
	}
	if ( dialogid == DIALOG_DONATED_DIAGOLD )
	{
		if ( response )
		{
			new
				pID;

			if ( sscanf( inputtext, #sscanf_u, pID ) )
			{
				SendError( playerid, "Please enter a player's ID or name." );
				ShowPlayerDialog( playerid, DIALOG_DONATED_DIAGOLD, DIALOG_STYLE_INPUT, ""COL_GOLD"Irresistible Gaming Donation", ""COL_WHITE"As you've redeemed Diamond V.I.P, you have the option of gifting Gold VIP to someone.\n\nIf you would like to gift it to yourself, type your name/id or the person you're gifting it to.\n\n"COL_ORANGE"If you just don't know yet, cancel and PM Lorenc on the forum when you make a decision!", "Gift it!", "I'll Think!" );
			}
			else if ( !IsPlayerConnected( pID ) )
			{
				SendError( playerid, "This player is not connected." );
				ShowPlayerDialog( playerid, DIALOG_DONATED_DIAGOLD, DIALOG_STYLE_INPUT, ""COL_GOLD"Irresistible Gaming Donation", ""COL_WHITE"As you've redeemed Diamond V.I.P, you have the option of gifting Gold VIP to someone.\n\nIf you would like to gift it to yourself, type your name/id or the person you're gifting it to.\n\n"COL_ORANGE"If you just don't know yet, cancel and PM Lorenc on the forum when you make a decision!", "Gift it!", "I'll Think!" );
			}
			else
			{
				SendClientMessageFormatted( playerid, -1, ""COL_GOLD"[V.I.P]"COL_WHITE" You have gifted Gold V.I.P to %s(%d)!", ReturnPlayerName( pID ), pID );
				SetPlayerVipLevel( pID, VIP_GOLD );
				ShowPlayerVipRedeemedDialog( playerid );
			}
		}
		else
		{
	 		AddPlayerNote( playerid, -1, ""COL_GOLD"Gold V.I.P" #COL_WHITE );
			SendServerMessage( playerid, "Okay. This has been noted down for your account and will be given to you at a stage that you want, do contact Lorenc though." );
			ShowPlayerVipRedeemedDialog( playerid );
		}
	}
	if ( ( dialogid == DIALOG_UNBAN_CLASS ) && response )
	{
		cmd_unbanme( playerid, "" );
		switch( listitem )
		{
			case 0:
			{
				if ( !( p_ArmyBanned{ playerid } >= MAX_CLASS_BAN_WARNS ) )
					return SendError( playerid, "You have nothing to pay as you are not army-banned." );

				if ( GetPlayerCash( playerid ) < 750000 )
					return SendError( playerid, "You are insufficient of funds to cover the unban ($750,000)." );

				p_ArmyBanned{ playerid } = 0;
				GivePlayerCash( playerid, -750000 );
				UpdateServerVariable( "eventbank", GetGVarInt( "eventbank" ) + 250000, 0.0, "", GLOBAL_VARTYPE_INT );

				format( szNormalString, sizeof( szNormalString ), "UPDATE `USERS` SET `ARMY_BAN`=0 WHERE ID=%d", p_AccountID[ playerid ] );
				mysql_single_query( szNormalString );

			    SendClientMessageToAdmins( -1, ""COL_PINK"[ADMIN]"COL_GREY" %s(%d) has paid his un-army-ban.", ReturnPlayerName( playerid ), playerid );
			}
			case 1:
			{
				if ( !( p_CopBanned{ playerid } >= MAX_CLASS_BAN_WARNS ) )
					return SendError( playerid, "You have nothing to pay as you are not cop-banned." );

				if ( GetPlayerCash( playerid ) < 500000 )
					return SendError( playerid, "You are insufficient of funds to cover the unban ($500,000)." );

				p_CopBanned{ playerid } = 0;
				GivePlayerCash( playerid, -500000 );
				UpdateServerVariable( "eventbank", GetGVarInt( "eventbank" ) + 170000, 0.0, "", GLOBAL_VARTYPE_INT );

				format( szNormalString, sizeof( szNormalString ), "UPDATE `USERS` SET `COP_BAN`=0 WHERE ID=%d", p_AccountID[ playerid ] );
				mysql_single_query( szNormalString );

			    SendClientMessageToAdmins( -1, ""COL_PINK"[ADMIN]"COL_GREY" %s(%d) has paid his un-cop-ban.", ReturnPlayerName( playerid ), playerid );
			}
		}
	}
	if ( dialogid == DIALOG_GARAGE_INTERIORS )
	{
	    if ( response )
	    {
	        if ( p_InGarage[ playerid ] == -1 )
				return SendError( playerid, "You're not inside any garage." );

	        if ( g_garageData[ p_InGarage[ playerid ] ] [ E_OWNER_ID ] != p_AccountID[ playerid ] )
				return SendError( playerid, "You are not the owner of this garage." );

			p_ViewingInterior{ playerid } = listitem;
			ShowPlayerDialog( playerid, DIALOG_GARAGE_INT_CONFIRM, DIALOG_STYLE_LIST, "{FFFFFF}Garage Interiors", "Purchase Garage Interior\nPreview Garage Interior", "Select", "Back" );
		}
	}
	if ( dialogid == DIALOG_GARAGE_INT_CONFIRM )
	{
		if ( response )
		{
	        if ( p_InGarage[ playerid ] == -1 )
				return SendError( playerid, "You're not inside any garage." );

	        if ( g_garageData[ p_InGarage[ playerid ] ] [ E_OWNER_ID ] != p_AccountID[ playerid ] )
				return SendError( playerid, "You are not the owner of this garage." );

			new
				intid = p_ViewingInterior{ playerid };

			switch( listitem )
			{
				case 0:
				{
					if ( g_garageInteriorData[ intid ] [ E_PRICE ] > GetPlayerCash( playerid ) )
					{
						ShowPlayerDialog( playerid, DIALOG_GARAGE_INT_CONFIRM, DIALOG_STYLE_LIST, "{FFFFFF}Garage Interiors", "Purchase Garage Interior\nPreview Garage Interior", "Select", "Back" );
						SendError( playerid, "This interior costs "COL_GOLD"%s"COL_WHITE". You don't have this amount.", ConvertPrice( g_garageInteriorData[ intid ] [ E_PRICE ] ) );
					}
					else if ( ArePlayersInGarage( playerid, p_InGarage[ playerid ] ) )
					{
						ShowPlayerDialog( playerid, DIALOG_GARAGE_INT_CONFIRM, DIALOG_STYLE_LIST, "{FFFFFF}Garage Interiors", "Purchase Garage Interior\nPreview Garage Interior", "Select", "Back" );
						SendError( playerid, "You cannot purchase a garage interior if there are people inside the building." );
					}
					else if ( GetPlayerVehiclesInGarage( playerid, p_InGarage[ playerid ], .strict_mode = true ) )
					{
						ShowPlayerDialog( playerid, DIALOG_GARAGE_INT_CONFIRM, DIALOG_STYLE_LIST, "{FFFFFF}Garage Interiors", "Purchase Garage Interior\nPreview Garage Interior", "Select", "Back" );
						SendError( playerid, "You cannot purchase a garage interior if there are vehicles inside the building." );
					}
					else
					{
					    new garageid = p_InGarage[ playerid ];
					    GivePlayerCash( playerid, -( g_garageInteriorData[ intid ] [ E_PRICE ] ) );

					    if ( intid != 0 )
							SendServerMessage( playerid, "You have purchased a %s for "COL_GOLD"%s"COL_WHITE" your garage.", g_garageInteriorData[ intid ] [ E_NAME ], ConvertPrice( g_garageInteriorData[ intid ] [ E_PRICE ] ) );
						else
						    SendServerMessage( playerid, "You have successfully reset your interior to the default interior." );

						pauseToLoad( playerid );

						SetPlayerPos( playerid, g_garageInteriorData[ intid ] [ E_X ], g_garageInteriorData[ intid ] [ E_Y ], g_garageInteriorData[ intid ] [ E_Z ] );
						SetPlayerInterior( playerid, g_garageInteriorData[ intid ] [ E_INTERIOR ] );
					  	SetPlayerVirtualWorld( playerid, g_garageData[ garageid ] [ E_WORLD ] );

						mysql_single_query( sprintf( "UPDATE `GARAGES` SET `INTERIOR`=%d WHERE `ID`=%d", ( g_garageData[ garageid ] [ E_INTERIOR_ID ] = intid ), garageid ) );
					}
				}
				case 1:
				{
					if ( p_WantedLevel[ playerid ] ) {
						ShowPlayerDialog( playerid, DIALOG_GARAGE_INT_CONFIRM, DIALOG_STYLE_LIST, "{FFFFFF}Garage Interiors", "Purchase Garage Interior\nPreview Garage Interior", "Select", "Back" );
						return SendError( playerid, "This feature requires you not to have a wanted level." );
					}
					if ( ArePlayersInGarage( playerid, p_InGarage[ playerid ] ) ) {
						ShowPlayerDialog( playerid, DIALOG_GARAGE_INT_CONFIRM, DIALOG_STYLE_LIST, "{FFFFFF}Garage Interiors", "Purchase Garage Interior\nPreview Garage Interior", "Select", "Back" );
						return SendError( playerid, "You cannot view a garage interior if there are people inside the building." );
					}

					TogglePlayerControllable( playerid, 0 );

					SetPlayerPos( playerid, g_garageInteriorData[ intid ] [ E_X ], g_garageInteriorData[ intid ] [ E_Y ], g_garageInteriorData[ intid ] [ E_Z ] );
					SetPlayerInterior( playerid, g_garageInteriorData[ intid ] [ E_INTERIOR ] );

					InterpolateCameraPos( playerid, g_garageInteriorData[ intid ] [ E_PREVIEW_POS ] [ 0 ], g_garageInteriorData[ intid ] [ E_PREVIEW_POS ] [ 1 ], g_garageInteriorData[ intid ] [ E_PREVIEW_POS ] [ 2 ] + 1.5, g_garageInteriorData[ intid ] [ E_PREVIEW_LOOKAT ] [ 0 ], g_garageInteriorData[ intid ] [ E_PREVIEW_LOOKAT ] [ 1 ], g_garageInteriorData[ intid ] [ E_PREVIEW_LOOKAT ] [ 2 ], 15000, CAMERA_MOVE );
					InterpolateCameraLookAt( playerid, g_garageInteriorData[ intid ] [ E_PREVIEW_LOOKAT ] [ 0 ], g_garageInteriorData[ intid ] [ E_PREVIEW_LOOKAT ] [ 1 ], g_garageInteriorData[ intid ] [ E_PREVIEW_LOOKAT ] [ 2 ], g_garageInteriorData[ intid ] [ E_PREVIEW_POS ] [ 0 ], g_garageInteriorData[ intid ] [ E_PREVIEW_POS ] [ 1 ], g_garageInteriorData[ intid ] [ E_PREVIEW_POS ] [ 2 ] + 1.5, 15000, CAMERA_MOVE );

					SendServerMessage( playerid, "You are now previewing "COL_GREY"%s "COL_GOLD"%s"COL_WHITE". Press your enter key to stop.", g_garageInteriorData[ intid ] [ E_NAME ], ConvertPrice( g_garageInteriorData[ intid ] [ E_PRICE ] ) );
					SetPVarInt( playerid, "viewing_garageints", 1 );
				}
			}
		}
		else ShowPlayerDialog( playerid, DIALOG_GARAGE_INTERIORS, DIALOG_STYLE_LIST, "{FFFFFF}Garage Interiors", szg_garageInteriors, "Select", "Back" );
	}
	if ( dialogid == DIALOG_MODIFY_HITSOUND && response )
	{
		p_HitmarkerSound{ playerid } = listitem;
		SendClientMessageFormatted( playerid, -1, ""COL_GREY"[SERVER]"COL_WHITE" You have changed your hitmarker sound to "COL_GREY"%s"COL_WHITE".", g_HitmarkerSounds[ listitem ] [ E_NAME ] );
		ShowSoundsMenu( playerid );
	}
	if ( dialogid == DIALOG_VIP_NOTE && response )
	{
		SendClientMessageToAdmins( -1, ""COL_PINK"[DONOR NEEDS HELP]"COL_GREY" %s(%d) is requesting help with their VIP asset(s). (/viewnotes)", ReturnPlayerName( playerid ), playerid );
		SendServerMessage( playerid, "All admins online have been informed of your request." );
	}
#if ENABLE_COMPONENTS_SYSTEM == true
	if ( ( dialogid == DIALOG_COMPONENTS_CATEGORY ) && response ) {
		SetPVarInt( playerid, "components_category", listitem );
		return ShowPlayerVehicleComponents( playerid, listitem );
	}
	if ( dialogid == DIALOG_COMPONENTS )
	{
		new
			iComponent = GetPVarInt( playerid, "components_category" );

		if ( response )
		{
			for( new i = 0, x = 0; i < sizeof( g_vehicleComponentsData ); i++ ) if ( g_vehicleComponentsData[ i ] [ E_CATEGORY ] == iComponent )
			{
				if ( listitem == x++ )
				{
				    if ( !IsPlayerInAnyVehicle( playerid ) )
				    	return SendError( playerid, "You need to be in a vehicle to use this command." );

					if ( GetPlayerCash( playerid ) < g_vehicleComponentsData[ i ] [ E_PRICE ] )
						return SendError( playerid, "You need %s to purchase this vehicle component.", ConvertPrice( g_vehicleComponentsData[ i ] [ E_PRICE ] ) );

				    if ( GetPlayerState( playerid ) != PLAYER_STATE_DRIVER )
				    	return SendError( playerid, "You need to be a driver to use this command." );

			        new
			        	ownerid = INVALID_PLAYER_ID,
			        	vehicleid = getVehicleSlotFromID( GetPlayerVehicleID( playerid ), ownerid )
					;

					if ( vehicleid == -1 )
						return SendError( playerid, "This vehicle isn't a buyable vehicle." );

					if ( playerid != ownerid )
						return SendError( playerid, "This vehicle does not belong to you." );

					if ( GetVehicleCustomComponents( ownerid, vehicleid ) >= getPlayerVehicleCapacity( ownerid ) )
						return SendError( playerid, "You cannot purchase more than %d vehicle components.", getPlayerVehicleCapacity( ownerid ) );

					new
						slotid = GetVehicleComponentSlot( ownerid, vehicleid );

					if ( slotid == -1 )
						return SendError( playerid, "You cannot add more than %d components to your vehicle.", MAX_PIMPS );

					// make sure the person is above the limit
					if ( g_vehicleComponentsData[ i ] [ E_LIMIT ] != 0 )
					{
						new
							instances = 0;

						for( new p = 0; p < MAX_PIMPS; p++ )
							if ( g_vehiclePimpData[ playerid ] [ vehicleid ] [ E_CREATED ] [ p ] && g_vehiclePimpData[ playerid ] [ vehicleid ] [ E_MODEL ] [ p ] == g_vehicleComponentsData[ i ] [ E_MODEL_ID ] )
								instances ++;

						if ( instances >= g_vehicleComponentsData[ i ] [ E_LIMIT ] )
							return SendError( playerid, "You can place a %s a maximum of %d time(s).", g_vehicleComponentsData[ i ] [ E_NAME ], g_vehicleComponentsData[ i ] [ E_LIMIT ] );
					}

					new
						Float: X, Float: Y, Float: Z;

					GivePlayerCash( playerid, -g_vehicleComponentsData[ i ] [ E_PRICE ] );

					g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_CREATED ] [ slotid ] = true;
					g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_DISABLED ] [ slotid ] = false;
					g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_MODEL ] [ slotid ] = g_vehicleComponentsData[ i ] [ E_MODEL_ID ];
					g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_X ] [ slotid ] = 0.0;
					g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_Y ] [ slotid ] = 0.0;
					g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_Z ] [ slotid ] = 1.0;
					g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_RX ] [ slotid ] = 0.0;
					g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_RY ] [ slotid ] = 0.0;
					g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_RZ ] [ slotid ] = 0.0;

					format( szNormalString, sizeof( szNormalString ), "INSERT INTO `COMPONENTS` (`VEHICLE_ID`,`MODEL`,`X`,`Y`,`Z`,`RX`,`RY`,`RZ`) VALUES (%d,%d,0.0,0.0,1.0,0.0,0.0,0.0)", g_vehicleData[ ownerid ] [ vehicleid ] [ E_SQL_ID ], g_vehicleComponentsData[ i ] [ E_MODEL_ID ] );
					mysql_function_query( dbHandle, szNormalString, true, "OnPlayerCreateVehicleComponent", "ddd", playerid, vehicleid, slotid );

					GetVehiclePos( g_vehicleData[ ownerid ] [ vehicleid ] [ E_VEHICLE_ID ], X, Y, Z );
					SetVehiclePos( g_vehicleData[ ownerid ] [ vehicleid ] [ E_VEHICLE_ID ], X, Y, Z + 0.05 );

					g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_OBJECT ] [ slotid ] = CreateDynamicObject( g_vehicleComponentsData[ i ] [ E_MODEL_ID ], 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, .worldid = GetVehicleVirtualWorld( g_vehicleData[ ownerid ] [ vehicleid ] [ E_VEHICLE_ID ]) );
					AttachDynamicObjectToVehicle( g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_OBJECT ] [ slotid ], g_vehicleData[ ownerid ] [ vehicleid ] [ E_VEHICLE_ID ], 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 );
					return SendServerMessage( playerid, "You have bought a "COL_GREY"%s"COL_WHITE" for "COL_GOLD"%s"COL_WHITE".", g_vehicleComponentsData[ i ] [ E_NAME ], ConvertPrice( g_vehicleComponentsData[ i ] [ E_PRICE ] ) );
				}
			}
		}
		else
		{
			return cmd_garage( playerid, "vehicle pimp" );
		}
	}
	if ( ( dialogid == DIALOG_COMPONENT_MENU ) && response )
	{
		new
	    	ownerid = INVALID_PLAYER_ID,
	    	vehicleid = getVehicleSlotFromID( GetPlayerVehicleID( playerid ), ownerid )
		;

		if ( vehicleid == -1 )
			return SendError( playerid, "This vehicle isn't a buyable vehicle." );

		if ( playerid != ownerid )
			return SendError( playerid, "This vehicle does not belong to you." );

		for( new i = 0, x = 0; i < MAX_PIMPS; i++ ) if ( g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_CREATED ] [ i ] ) {
			if ( listitem == x++ ) {
				return ShowPlayerVehicleComponentMenu( playerid, ownerid, vehicleid, i );
			}
		}
	}
	if ( ( dialogid == DIALOG_COMPONENT_EDIT ) && response )
	{
		new
	    	ownerid = INVALID_PLAYER_ID,
	    	i = GetPVarInt( playerid, "components_editing" ),
	    	vehicleid = getVehicleSlotFromID( GetPlayerVehicleID( playerid ), ownerid )
		;

		if ( vehicleid == -1 )
			return SendError( playerid, "This vehicle isn't a buyable vehicle." );

		if ( playerid != ownerid )
			return SendError( playerid, "This vehicle does not belong to you." );

		switch( listitem )
		{
			case 0: // Disable
			{
				if ( ( g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_DISABLED ] [ i ] = !g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_DISABLED ] [ i ] ) == false )
				{
					new
						Float: X, Float: Y, Float: Z;

					// Recreate object
					g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_OBJECT ] [ i ] = CreateDynamicObject( g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_MODEL ] [ i ], 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, .worldid = GetVehicleVirtualWorld( g_vehicleData[ ownerid ] [ vehicleid ] [ E_VEHICLE_ID ] ) );

					// Attach object to vehicle
					AttachDynamicObjectToVehicle( g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_OBJECT ] [ i ], g_vehicleData[ ownerid ] [ vehicleid ] [ E_VEHICLE_ID ],
										g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_X ] [ i ], g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_Y ] [ i ], g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_Z ] [ i ],
										g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_RX ] [ i ], g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_RY ] [ i ], g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_RZ ] [ i ] );

					// Reposition vehicle
					GetVehiclePos( g_vehicleData[ ownerid ] [ vehicleid ] [ E_VEHICLE_ID ], X, Y, Z );
					SetVehiclePos( g_vehicleData[ ownerid ] [ vehicleid ] [ E_VEHICLE_ID ], X, Y, Z + 0.05 );

					SendServerMessage( playerid, "You have successfully enabled your vehicle component" );
				}
				else
				{
					DestroyDynamicObject( g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_OBJECT ] [ i ] );
					g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_OBJECT ] [ i ] = -1;
					SendServerMessage( playerid, "You have successfully disabled your vehicle component" );
				}

				mysql_single_query( sprintf( "UPDATE `COMPONENTS` SET `DISABLED`=%d WHERE `ID`=%d", g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_DISABLED ] [ i ], g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_SQL_ID ] [ i ] ) );
				return ShowPlayerVehicleComponentMenu( playerid, ownerid, vehicleid, i );
			}
			case 1: // Edit
			{
				new
					Float: X, Float: Y, Float: Z, Float: Angle;

				GetVehiclePos( g_vehicleData[ ownerid ] [ vehicleid ] [ E_VEHICLE_ID ], X, Y, Z );
				GetVehicleZAngle( g_vehicleData[ ownerid ] [ vehicleid ] [ E_VEHICLE_ID ], Angle );
				DestroyDynamicObject( g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_OBJECT ] [ i ] );

				// printf("Destroyed %d", g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_OBJECT ] [ i ] );

				X += g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_X ] [ i ];
				Y += g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_Y ] [ i ];
				Z += g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_Z ] [ i ];

				new
					iObject = CreateDynamicObject( g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_MODEL ] [ i ], X, Y, Z, g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_RX ] [ i ], g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_RY ] [ i ], g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_RZ ] [ i ] - Angle, .worldid = GetVehicleVirtualWorld( g_vehicleData[ ownerid ] [ vehicleid ] [ E_VEHICLE_ID ] ) );

				// printf("%d = CreateDynamicObject( %d, %f, %f, %f, %f, %f, %f )", iObject, g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_MODEL ] [ i ], X, Y, Z, g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_RX ] [ i ], g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_RY ] [ i ], g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_RZ ] [ i ] - Angle );

				if ( ( g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_OBJECT ] [ i ] = iObject ) ) {
					GetVehiclePos( g_vehicleData[ ownerid ] [ vehicleid ] [ E_VEHICLE_ID ], X, Y, Z );
					SetVehiclePos( g_vehicleData[ ownerid ] [ vehicleid ] [ E_VEHICLE_ID ], X, Y, Z + 0.05 );

					EditDynamicObject( playerid, iObject );
 				}
			}
			case 2: // Pimp
			{
				new
					pimpid;

				for( ; pimpid < sizeof( g_vehicleComponentsData ); pimpid++ )
					if ( g_vehicleComponentsData[ pimpid ] [ E_MODEL_ID ] == g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_MODEL ] [ i ] )
						break;

				if ( g_vehicleComponentsData[ pimpid ] [ E_MODEL_ID ] != g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_MODEL ] [ i ] )
					return SendError( playerid, "You cannot sell this component as it no longer exists." );

				new
					sellPrice = floatround( g_vehicleComponentsData[ pimpid ] [ E_PRICE ] * 0.5 );

				GivePlayerCash( playerid, sellPrice );
				DestroyDynamicObject( g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_OBJECT ] [ i ] );

				g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_OBJECT ] [ i ] = -1;
				g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_CREATED ] [ i ] = false;

				mysql_single_query( sprintf( "DELETE FROM `COMPONENTS` WHERE `ID`=%d", g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_SQL_ID ] [ i ] ) );
				SendServerMessage( playerid, "You have sold your "COL_GREY"%s"COL_WHITE" for "COL_GOLD"%s"COL_WHITE".", g_vehicleComponentsData[ pimpid ] [ E_NAME ], ConvertPrice( sellPrice ) );
			}
		}
	}
	#endif
	if ( ( dialogid == DIALOG_FEEDBACK ) && response )
	{
		if ( ! ( 10 < strlen( inputtext ) <= 512 ) )
		{
			SendError( playerid, "Your feedback must be between 10 and 512 characters long." );
			return ShowPlayerDialog( playerid, DIALOG_FEEDBACK, DIALOG_STYLE_INPUT, ""COL_GOLD"Server Feedback", ""COL_WHITE"Let us know how you think we can make the server better to play! Impactful feedback is rewarded.\n\n    Be as serious and straight forward as you wish. You can rant if you need to. Be impactful.\n\n"COL_RED"Your feedback must be between 10 and 512 characters long.", "Submit", "Close" );
		}

		new
			szFeedback[ 512 ];

		// escape feedback
		mysql_real_escape_string( inputtext, szFeedback );

		// insert into database
		format( szLargeString, sizeof( szLargeString ), "INSERT INTO `FEEDBACK` (`USER_ID`, `FEEDBACK`) VALUES (%d, '%s')", p_AccountID[ playerid ], szFeedback );
		mysql_single_query( szLargeString );

		format( szLargeString, sizeof( szLargeString ), ""COL_GOLD"Thank you for your feedback!"COL_WHITE" If it can make a positive impact on the server then you will be rewarded.\n\nYou can speak as freely as you want. Be vulgar, serious if you need to. It's okay as long as it's constructive.\n\nHere is what you have submitted!\n\n"COL_GREY"%s", szFeedback );
		return ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_MSGBOX, ""COL_GOLD"Server Feedback", szLargeString, "Close", "" );
	}
	if ( ( dialogid == DIALOG_RACE ) && response )
	{
		new
			raceid = GetPVarInt( playerid, "editing_race" );

		if ( ! IsRaceHost( playerid, raceid ) )
			return SendError( playerid, "You are not the host of this lobby." );

		switch ( listitem )
		{
			case 0: ShowPlayerDialog( playerid, DIALOG_RACE_MODE, DIALOG_STYLE_TABLIST, ""COL_GOLD"Race Configuration - Race Mode", ""COL_GREY"Street Race\t"COL_WHITE"Racers must meet the final destination\n"COL_GREY"Outrun"COL_WHITE"\tRacer must outrun everyone by 100 metres", "Select", "Close" );
			case 1: ShowPlayerDialog( playerid, DIALOG_RACE_FEE, DIALOG_STYLE_INPUT, ""COL_GOLD"Race Configuration - Entry Fee", ""COL_WHITE"Specify the required entry fee for this race (minimum $1,000 - max $10,000,000)", "Specify", "Close" );
			case 2: ShowPlayerDialog( playerid, DIALOG_RACE_POS, DIALOG_STYLE_TABLIST_HEADERS, ""COL_GOLD"Race Configuration - Prize Distribution", ""COL_WHITE"1st Position\t"COL_WHITE"2nd Position\t"COL_WHITE"3rd Position\n100%\t0%\t0%\n90%\t5%\t5%\n80%\t10%\t10%\n70%\t15%\t15%\n60%\t20%\t20%\n", "Select", "Close" );
			case 3:
			{
				if ( g_raceData[ raceid ] [ E_MODE ] == RACE_OUTRUN )
					return ShowPlayerDialog( playerid, DIALOG_RACE_DISTANCE, DIALOG_STYLE_INPUT, ""COL_GOLD"Race Configuration - Outrun Distance", ""COL_WHITE"Specify the required outrun distance (minimum 10.0m - max 250.0m)", "Specify", "Close" );

				return ShowPlayerDialog( playerid, DIALOG_RACE_DEST, DIALOG_STYLE_TABLIST_HEADERS, ""COL_GOLD"Race Configuration - Destination", ""COL_WHITE""COL_WHITE"How do you want to set the final destination?\nPreset Destinations\nSelect Using Minimap\nUse Coordinates", "Select", "Back" );
			}
			case 4:
			{
				erase( szLargeString );

				foreach (new i : Player) if ( p_raceLobbyId[ i ] == raceid && g_raceData[ raceid ] [ E_LOBBY_HOST ] != i ) {
					format( szLargeString, sizeof( szLargeString ), "%s%s(%d)\n", szLargeString, ReturnPlayerName( i ), i );
				}

				if ( strlen( szLargeString ) ) {
					return ShowPlayerDialog( playerid, DIALOG_RACE_KICK, DIALOG_STYLE_LIST, ""COL_GOLD"Race Configuration - Player Management", szLargeString, "Kick", "Back" );
				} else {
					SendError( playerid, "There are no racers to show." );
					return ShowRaceConfiguration( playerid, raceid );
				}
			}
		}
	}
	if ( dialogid == DIALOG_RACE_DEST )
	{
		new
			raceid = GetPVarInt( playerid, "editing_race" );

		if ( ! IsRaceHost( playerid, raceid ) )
			return SendError( playerid, "You are not the host of this lobby." );

		if ( ! response )
			return ShowRaceConfiguration( playerid, raceid );

		switch ( listitem )
		{
			case 0: ShowPlayerDialog( playerid, DIALOG_RACE_PRESELECT, DIALOG_STYLE_LIST, ""COL_GOLD"Race Configuration - Destination", "LS Airport\nLS Pier\nLS Grove Street\nLV Airport\nLV Old Strip\nEl Quebrados\nSF Airport\nMount Chilliad\nTierra Robada SF Bridge\nSF Dealership", "Select", "Back" );
			case 1:
			{
				g_raceData[ raceid ] [ E_RACE_FINISH_SET ] = 2;
				g_raceData[ raceid ] [ E_FINISH_POS ] [ 0 ] = 0.0;
				g_raceData[ raceid ] [ E_FINISH_POS ] [ 1 ] = 0.0;
				g_raceData[ raceid ] [ E_FINISH_POS ] [ 2 ] = 0.0;
				return SendServerMessage( playerid, "You are now setting the race destination. Use the MINIMAP to pick the finish position." );
			}
			case 2: ShowPlayerDialog( playerid, DIALOG_RACE_CUSTOM_DEST, DIALOG_STYLE_INPUT, ""COL_GOLD"Race Configuration - Custom Destination", ""COL_WHITE"Please specify the final destination coordinates, seperated by white spaces. E.g 0.0 0.0 0.0", "Set", "Back" );
		}
		return 1;
	}
	if ( dialogid == DIALOG_RACE_CUSTOM_DEST )
	{
		new
			raceid = GetPVarInt( playerid, "editing_race" );

		if ( ! IsRaceHost( playerid, raceid ) )
			return SendError( playerid, "You are not the host of this lobby." );

		if ( ! response )
			return ShowPlayerDialog( playerid, DIALOG_RACE_DEST, DIALOG_STYLE_TABLIST_HEADERS, ""COL_GOLD"Race Configuration - Destination", ""COL_WHITE""COL_WHITE"How do you want to set the final destination?\nPreset Destinations\nSelect Using Minimap\nUse Coordinates", "Select", "Back" );

		new
			Float: X, Float: Y, Float: Z;

		if ( sscanf( inputtext, "fff", X, Y, Z ) ) {
			SendError( playerid, "Make sure coordinates are seperated by white spaces and are numbers (e.g 0.0 0.0 0.0)" );
			return ShowPlayerDialog( playerid, DIALOG_RACE_CUSTOM_DEST, DIALOG_STYLE_INPUT, ""COL_GOLD"Race Configuration - Custom Destination", ""COL_WHITE"Please specify the final destination coordinates, seperated by white spaces. E.g 0.0 0.0 0.0", "Set", "Back" );
		}

		SetRaceDestination( raceid, X, Y, Z );
		SendClientMessageToRace( raceid, COLOR_GREY, "[RACE]"COL_WHITE" %s(%d) has set the race final destination to %0.4f %0.4f %0.4f.", ReturnPlayerName( playerid ), playerid, X, Y, Z );
		return 1;
	}
	if ( dialogid == DIALOG_RACE_PRESELECT )
	{
		new
			raceid = GetPVarInt( playerid, "editing_race" );

		if ( ! IsRaceHost( playerid, raceid ) )
			return SendError( playerid, "You are not the host of this lobby." );

		if ( ! response )
			return ShowPlayerDialog( playerid, DIALOG_RACE_DEST, DIALOG_STYLE_TABLIST_HEADERS, ""COL_GOLD"Race Configuration - Destination", ""COL_WHITE""COL_WHITE"How do you want to set the final destination?\nPreset Destinations\nSelect Using Minimap\nUse Coordinates", "Select", "Back" );

		SetRaceDestination( raceid, g_raceFinalDestinations[ listitem ] [ E_X ], g_raceFinalDestinations[ listitem ] [ E_Y ], g_raceFinalDestinations[ listitem ] [ E_Z ] );
		SendClientMessageToRace( raceid, COLOR_GREY, "[RACE]"COL_WHITE" %s(%d) has set the race final destination to %s.", ReturnPlayerName( playerid ), playerid, g_raceFinalDestinations[ listitem ] [ E_NAME ] );
		return 1;
	}
	if ( dialogid == DIALOG_RACE_KICK )
	{
		new
			raceid = GetPVarInt( playerid, "editing_race" );

		if ( ! IsRaceHost( playerid, raceid ) )
			return SendError( playerid, "You are not the host of this lobby." );

		ShowRaceConfiguration( playerid, raceid );

		if ( ! response )
			return 1;

		new
			x = 0;

		foreach (new i : Player) if ( p_raceLobbyId[ i ] == raceid && g_raceData[ raceid ] [ E_LOBBY_HOST ] != i )
		{
	       	if ( x == listitem )
	      	{
		  		SendClientMessageToRace( raceid, -1, ""COL_GREY"[RACE]"COL_WHITE" %s(%d) has been kicked from the race.", ReturnPlayerName( i ), i );
		  		RemovePlayerFromRace( i );
	      		return 1;
			}
	      	x++;
		}
		return SendError( playerid, "There was an error trying to remove this player from the race." );
	}
	if ( dialogid == DIALOG_RACE_MODE )
	{
		new
			raceid = GetPVarInt( playerid, "editing_race" );

		if ( ! IsRaceHost( playerid, raceid ) )
			return SendError( playerid, "You are not the host of this lobby." );

		if ( response )
		{
			g_raceData[ raceid ] [ E_MODE ] = listitem;
			SendServerMessage( playerid, "You have set the race mode to "COL_GREY"%s"COL_WHITE".", g_raceData[ raceid ] [ E_MODE ] == RACE_STREET_RACE ? ( "Streetrace" ) : ( "Outrun" ) );
		}
		return ShowRaceConfiguration( playerid, raceid );
	}
	if ( dialogid == DIALOG_RACE_DISTANCE )
	{
		new
			raceid = GetPVarInt( playerid, "editing_race" );

		if ( ! IsRaceHost( playerid, raceid ) )
			return SendError( playerid, "You are not the host of this lobby." );

		if ( ! response )
			return ShowRaceConfiguration( playerid, raceid );

		new
			Float: distance;

		if ( sscanf( inputtext, "f", distance ) || ! ( 10.0 <= distance <= 300.0 ) ) {
			SendError( playerid, "Please specify a race distance between 10.0m and 300.0m." );
			return ShowPlayerDialog( playerid, DIALOG_RACE_DISTANCE, DIALOG_STYLE_INPUT, ""COL_GOLD"Race Configuration - Outrun Distance", ""COL_WHITE"Specify the required outrun distance (minimum 10.0m - max 250.0m)", "Specify", "Close" );
		}

		g_raceData[ raceid ] [ E_OUTRUN_DISTANCE ] = distance;
		SendClientMessageToRace( raceid, -1, ""COL_GREY"[RACE]"COL_WHITE" The outrun distance has been set to %0.1f metres.", distance );
		return ShowRaceConfiguration( playerid, raceid );
	}
	if ( dialogid == DIALOG_RACE_FEE )
	{
		new
			raceid = GetPVarInt( playerid, "editing_race" );

		if ( ! IsRaceHost( playerid, raceid ) )
			return SendError( playerid, "You are not the host of this lobby." );

		if ( ! response )
			return ShowRaceConfiguration( playerid, raceid );

		new
			fee;

		if ( sscanf( inputtext, "d", fee ) || ! ( 0 <= fee <= 10000000 ) ) {
			SendError( playerid, "Please specify an entry fee between $0 and $10,000,000." );
			return ShowPlayerDialog( playerid, DIALOG_RACE_FEE, DIALOG_STYLE_INPUT, ""COL_GOLD"Race Configuration - Entry Fee", ""COL_WHITE"Specify the required entry fee for this race (minimum $1,000 - max $10,000,000)", "Specify", "Close" );
		}

		g_raceData[ raceid ] [ E_ENTRY_FEE ] = fee;
		SendClientMessageToRace( raceid, COLOR_GREY, "[RACE]"COL_WHITE" The entry fee for the race has been set to %s.", ConvertPrice( fee ) );
		return ShowRaceConfiguration( playerid, raceid );
	}
	if ( dialogid == DIALOG_RACE_POS )
	{
		new
			raceid = GetPVarInt( playerid, "editing_race" );

		if ( ! IsRaceHost( playerid, raceid ) )
			return SendError( playerid, "You are not the host of this lobby." );

		if ( response )
		{
			static const
				Float: g_prizePoolDistribution[ ] [ 3 ] =
				{
					{ 1.0, 0.0, 0.0 },
					{ 0.9, 0.05, 0.05 },
					{ 0.8, 0.1, 0.1 },
					{ 0.7, 0.15, 0.15 },
					{ 0.6, 0.2, 0.2 }
				}
			;

			// position prize
			g_raceData[ raceid ] [ E_POSITION_PRIZE ] [ 0 ] = g_prizePoolDistribution[ listitem ] [ 0 ];
			g_raceData[ raceid ] [ E_POSITION_PRIZE ] [ 1 ] = g_prizePoolDistribution[ listitem ] [ 1 ];
			g_raceData[ raceid ] [ E_POSITION_PRIZE ] [ 2 ] = g_prizePoolDistribution[ listitem ] [ 2 ];

			// alert
			SendServerMessage( playerid, "The prize pool distribution is now %0.0f%% for 1st, %0.0f%% for 2nd and %0.0f%% for 3rd place.", 100.0 * g_prizePoolDistribution[ listitem ] [ 0 ], 100.0 * g_prizePoolDistribution[ listitem ] [ 1 ], 100.0 * g_prizePoolDistribution[ listitem ] [ 2 ] );
		}
		return ShowRaceConfiguration( playerid, raceid );
	}
	if ( ( dialogid == DIALOG_BUSINESS_TERMINAL ) && response )
	{
		new
			businessid = p_InBusiness[ playerid ];

		if ( p_Class[ playerid ] != CLASS_CIVILIAN || ! Iter_Contains( business, businessid ) || ! IsBusinessAssociate( playerid, businessid ) )
			return SendError( playerid, "You do not have access to this feature." );

		new
			business_type = g_businessData[ businessid ] [ E_INTERIOR_TYPE ];

		switch ( listitem )
		{
			// rename business
			case 0: ShowPlayerDialog( playerid, DIALOG_BUSINESS_NAME, DIALOG_STYLE_INPUT, ""COL_GREY"Business System", sprintf( ""COL_WHITE"The current business name is %s\n\n"COL_WHITE"Enter below the new name for it", g_businessData[ businessid ] [ E_NAME ] ), "Update", "Back" );

			// bank account
			case 1: ShowPlayerDialog( playerid, DIALOG_BUSINESS_WITHDRAW, DIALOG_STYLE_INPUT, ""COL_GREY"Business System", sprintf( ""COL_WHITE"Enter the amount that you are willing to withdraw from your business bank account.\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( g_businessData[ businessid ] [ E_BANK ] ) ), "Withdraw", "Back" );

			// add members
			case 2: ShowBusinessMembers( playerid, businessid );

			// sell stock
			case 3:
			{
				new
					prod = GetProductPrice( business_type, true ), prod_hardened = GetProductPrice( business_type, false );

				format( szBigString, sizeof( szBigString ),
					""COL_WHITE"Your business has %d product\t \nSell Product Locally\t%s%s\nSell Product Nationally\t%s%s",
					g_businessData[ businessid ] [ E_PRODUCT ], prod > g_businessInteriorData[ business_type ] [ E_COST_PRICE ] ? ( COL_GREEN ) : ( COL_RED ),
					ConvertPrice( prod ), prod_hardened > g_businessInteriorData[ business_type ] [ E_COST_PRICE ] ? ( COL_GREEN ) : ( COL_RED ), ConvertPrice( prod_hardened )
				);
				ShowPlayerDialog( playerid, DIALOG_BUSINESS_SELL, DIALOG_STYLE_TABLIST_HEADERS, ""COL_GREY"Business System", szBigString, "Select", "Back" );
			}

			// buy stock
			case 4: ShowPlayerDialog( playerid, DIALOG_BUSINESS_BUY, DIALOG_STYLE_TABLIST_HEADERS, ""COL_GREY"Business System", sprintf( ""COL_WHITE"Your business has %d supplies\t \nBuy Supply\t%s\nSteal Supplies\t"COL_YELLOW"FREE", g_businessData[ businessid ] [ E_SUPPLIES ], ConvertPrice( GetResupplyPrice( business_type ) ) ), "Select", "Back" );

			// upgrade
			case 5: ShowBusinessUpgrades( playerid, businessid );
		}
		return 1;
	}
	if ( dialogid == DIALOG_BUSINESS_UPGRADES )
	{
		new
			businessid = p_InBusiness[ playerid ];

		if ( p_Class[ playerid ] != CLASS_CIVILIAN || ! Iter_Contains( business, businessid ) || ! IsBusinessAssociate( playerid, businessid ) )
			return SendError( playerid, "You do not have access to this feature." );

		if ( ! response )
			return ShowBusinessTerminal( playerid );

		new
			business_type = g_businessData[ businessid ] [ E_INTERIOR_TYPE ];

		switch ( listitem )
		{
			// upgrade car
			case 0:
			{
				szLargeString = ""COL_WHITE"Vehicle\t"COL_WHITE"Cost\n";

				for ( new i = 0; i < sizeof( g_businessCarModelData ); i ++ )
				{
					new vehicle_model_index = g_businessCarModelData[ i ] [ E_ID ], bool: is_unlocked = ( 0 <= vehicle_model_index < MAX_BIZ_VEH_MODELS ) ? ( g_businessVehicleUnlocked[ businessid ] { vehicle_model_index } ) : false;
					format( szLargeString, sizeof( szLargeString ), "%s%s%s\t"COL_GOLD"%s\n", szLargeString, is_unlocked ? ( COL_LGREEN ) : ( "" ), g_businessCarModelData[ i ] [ E_NAME ], ConvertPrice( g_businessCarModelData[ i ] [ E_COST ] ) );
				}

				return ShowPlayerDialog( playerid, DIALOG_BUSINESS_CAR, DIALOG_STYLE_TABLIST_HEADERS, ""COL_GREY"Business System", szLargeString, "Purchase", "Back" );
			}

			// upgrade heli
			case 1:
			{
				szLargeString = ""COL_WHITE"Vehicle\t"COL_WHITE"Cost\n";

				for ( new i = 0; i < sizeof( g_businessAirModelData ); i ++ ) {
					new vehicle_model_index = g_businessAirModelData[ i ] [ E_ID ], bool: is_unlocked = ( 0 <= vehicle_model_index < MAX_BIZ_VEH_MODELS ) ? ( g_businessVehicleUnlocked[ businessid ] { vehicle_model_index } ) : false;
					format( szLargeString, sizeof( szLargeString ), "%s%s%s\t"COL_GOLD"%s\n", szLargeString, is_unlocked ? ( COL_LGREEN ) : ( "" ), g_businessAirModelData[ i ] [ E_NAME ], ConvertPrice( g_businessAirModelData[ i ] [ E_COST ] ) );
				}

				return ShowPlayerDialog( playerid, DIALOG_BUSINESS_HELI, DIALOG_STYLE_TABLIST_HEADERS, ""COL_GREY"Business System", szLargeString, "Purchase", "Back" );
			}

			// upgrade staff
			case 2:
			{
				if ( g_businessData[ businessid ] [ E_UPGRADES ] )
					return ShowBusinessUpgrades( playerid, businessid ), SendError( playerid, "Your business production has been already upgraded." );

				if ( GetPlayerCash( playerid ) < g_businessInteriorData[ business_type ] [ E_UPGRADE_COST ] )
					return ShowBusinessUpgrades( playerid, businessid ), SendError( playerid, "You don't have enough money to upgrade this business (%s).", ConvertPrice( g_businessInteriorData[ business_type ] [ E_UPGRADE_COST ] ) );

				CreateBusinessActors( businessid );
				g_businessData[ businessid ] [ E_UPGRADES ] = 1;
				GivePlayerCash( playerid, - g_businessInteriorData[ business_type ] [ E_UPGRADE_COST ] );
				mysql_single_query( sprintf( "UPDATE `BUSINESSES` SET `UPGRADES`=1 WHERE `ID`=%d", businessid ) );
				return ShowBusinessUpgrades( playerid, businessid ), SendServerMessage( playerid, "You have upgraded business production for "COL_GOLD"%s"COL_WHITE".", ConvertPrice( g_businessInteriorData[ business_type ] [ E_UPGRADE_COST ] ) );
			}

			// upgrade slots
			case 3:
			{
				if ( g_businessData[ businessid ] [ E_EXTRA_MEMBERS ] >= 4 )
					return ShowBusinessUpgrades( playerid, businessid ), SendError( playerid, "You have maximized the number of business member slots." );

				if ( GetPlayerCash( playerid ) < 500000 )
					return ShowBusinessUpgrades( playerid, businessid ), SendError( playerid, "You don't have enough money to buy an additional member slot ($500,000)." );

				GivePlayerCash( playerid, -500000 );
				g_businessData[ businessid ] [ E_EXTRA_MEMBERS ] ++;
				mysql_single_query( sprintf( "UPDATE `BUSINESSES` SET `EXTRA_MEMBERS`=%d WHERE `ID`=%d", g_businessData[ businessid ] [ E_EXTRA_MEMBERS ], businessid ) );
				return ShowBusinessUpgrades( playerid, businessid ), SendServerMessage( playerid, "You have bought an additional member slot for "COL_GOLD"$500,000"COL_WHITE"." );
			}

			// nos
			case 4:
			{
				if ( g_businessData[ businessid ] [ E_CAR_NOS ] )
					return ShowBusinessUpgrades( playerid, businessid ), SendError( playerid, "You have already purchased business car nitrous." );

				if ( GetPlayerCash( playerid ) < 250000 )
					return ShowBusinessUpgrades( playerid, businessid ), SendError( playerid, "You don't have enough money to buy business car nitrous ($250,000)." );

				GivePlayerCash( playerid, -250000 );
				g_businessData[ businessid ] [ E_CAR_NOS ] = true;
				mysql_single_query( sprintf( "UPDATE `BUSINESSES` SET `HAS_NOS`=1 WHERE `ID`=%d", businessid ) );
				return ShowBusinessUpgrades( playerid, businessid ), SendServerMessage( playerid, "You have bought nitrous for "COL_GOLD"$250,000"COL_WHITE"." );
			}

			// rims
			case 5:
			{
				if ( g_businessData[ businessid ] [ E_CAR_RIMS ] )
					return ShowBusinessUpgrades( playerid, businessid ), SendError( playerid, "You have already purchased gold rims for the business vehicle." );

				if ( GetPlayerCash( playerid ) < 250000 )
					return ShowBusinessUpgrades( playerid, businessid ), SendError( playerid, "You don't have enough money to buy gold rims ($250,000)." );

				GivePlayerCash( playerid, -250000 );
				g_businessData[ businessid ] [ E_CAR_RIMS ] = true;
				mysql_single_query( sprintf( "UPDATE `BUSINESSES` SET `HAS_RIMS`=1 WHERE `ID`=%d", businessid ) );
				return ShowBusinessUpgrades( playerid, businessid ), SendServerMessage( playerid, "You have bought gold rims for "COL_GOLD"$250,000"COL_WHITE"." );
			}
		}
		return 1;
	}
	if ( dialogid == DIALOG_BUSINESS_HELI )
	{
		new
			businessid = p_InBusiness[ playerid ];

		if ( p_Class[ playerid ] != CLASS_CIVILIAN || ! Iter_Contains( business, businessid ) || ! IsBusinessAssociate( playerid, businessid ) )
			return SendError( playerid, "You do not have access to this feature." );

		if ( ! response )
			return ShowBusinessUpgrades( playerid, businessid );

		new
			vehicle_model_index = g_businessAirModelData[ listitem ] [ E_ID ];

		if ( vehicle_model_index != -1 && vehicle_model_index < MAX_BIZ_VEH_MODELS && ! g_businessVehicleUnlocked[ businessid ] { vehicle_model_index } )
		{
			if ( GetPlayerCash( playerid ) < g_businessAirModelData[ listitem ] [ E_COST ] )
				return ShowBusinessUpgrades( playerid, businessid ), SendError( playerid, "You cannot afford this vehicle." );

			if ( g_businessAirModelData[ listitem ] [ E_COST ] == 1337 && ! ( p_AccountID[ playerid ] == 314783 || p_AccountID[ playerid ] == 13 || p_AccountID[ playerid ] == 341204 || p_AccountID[ playerid ] == 30 || p_AccountID[ playerid ] == 479950 || p_AccountID[ playerid ] == 25 || p_AccountID[ playerid ] == 1 ) )
				return ShowBusinessUpgrades( playerid, businessid ), SendError( playerid, "You did not contribute enough to the crowdfund to use this feature." );

			g_businessVehicleUnlocked[ businessid ] { vehicle_model_index } = true;
			GivePlayerCash( playerid, -g_businessAirModelData[ listitem ] [ E_COST ] );
			mysql_single_query( sprintf( "INSERT INTO `BUSINESS_VEHICLES` VALUES (%d, %d)", businessid, vehicle_model_index ) );
		}

		g_businessData[ businessid ] [ E_HELI_MODEL_ID ] = g_businessAirModelData[ listitem ] [ E_MODEL ];

		foreach (new p : Player) if ( IsBusinessAssociate( p, businessid ) ) {
			SendClientMessageFormatted( p, COLOR_GREY, "[BUSINESS]"COL_WHITE" %s(%d) has upgraded the business air vehicle to a "COL_GREY"%s"COL_WHITE".", ReturnPlayerName( playerid ), playerid, g_businessAirModelData[ listitem ] [ E_NAME ] );
		}

		mysql_single_query( sprintf( "UPDATE `BUSINESSES` SET `AIR_MODEL`=%d WHERE `ID`=%d", g_businessAirModelData[ listitem ] [ E_MODEL ], businessid ) );
		return ShowBusinessUpgrades( playerid, businessid ), 1;
	}
	if ( dialogid == DIALOG_BUSINESS_CAR )
	{
		new
			businessid = p_InBusiness[ playerid ];

		if ( p_Class[ playerid ] != CLASS_CIVILIAN || ! Iter_Contains( business, businessid ) || ! IsBusinessAssociate( playerid, businessid ) )
			return SendError( playerid, "You do not have access to this feature." );

		if ( ! response )
			return ShowBusinessUpgrades( playerid, businessid );

		new
			vehicle_model_index = g_businessCarModelData[ listitem ] [ E_ID ];

		if ( vehicle_model_index != -1 && vehicle_model_index < MAX_BIZ_VEH_MODELS && ! g_businessVehicleUnlocked[ businessid ] { vehicle_model_index } )
		{
			if ( GetPlayerCash( playerid ) < g_businessCarModelData[ listitem ] [ E_COST ] )
				return ShowBusinessUpgrades( playerid, businessid ), SendError( playerid, "You cannot afford this vehicle." );

			if ( g_businessCarModelData[ listitem ] [ E_COST ] == 1337 && ! ( p_AccountID[ playerid ] == 314783 || p_AccountID[ playerid ] == 13 || p_AccountID[ playerid ] == 341204 || p_AccountID[ playerid ] == 30 || p_AccountID[ playerid ] == 479950 || p_AccountID[ playerid ] == 25 || p_AccountID[ playerid ] == 1 ) )
				return ShowBusinessUpgrades( playerid, businessid ), SendError( playerid, "You did not contribute enough to the crowdfund to use this feature." );

			g_businessVehicleUnlocked[ businessid ] { vehicle_model_index } = true;
			GivePlayerCash( playerid, -g_businessCarModelData[ listitem ] [ E_COST ] );
			mysql_single_query( sprintf( "INSERT INTO `BUSINESS_VEHICLES` VALUES (%d, %d)", businessid, vehicle_model_index ) );
		}

		g_businessData[ businessid ] [ E_CAR_MODEL_ID ] = g_businessCarModelData[ listitem ] [ E_MODEL ];

		foreach (new p : Player) if ( IsBusinessAssociate( p, businessid ) ) {
			SendClientMessageFormatted( p, COLOR_GREY, "[BUSINESS]"COL_WHITE" %s(%d) has upgraded the business car to a "COL_GREY"%s"COL_WHITE".", ReturnPlayerName( playerid ), playerid, g_businessCarModelData[ listitem ] [ E_NAME ] );
		}

		mysql_single_query( sprintf( "UPDATE `BUSINESSES` SET `CAR_MODEL`=%d WHERE `ID`=%d", g_businessCarModelData[ listitem ] [ E_MODEL ], businessid ) );
		return ShowBusinessUpgrades( playerid, businessid ), 1;
	}
	if ( dialogid == DIALOG_BUSINESS_WITHDRAW )
	{
		new
			businessid = p_InBusiness[ playerid ];

		if ( ! Iter_Contains( business, businessid ) || g_businessData[ businessid ] [ E_OWNER_ID ] != p_AccountID[ playerid ] )
			return SendError( playerid, "You must be the owner of the business to use this feature." );

		if ( ! response )
			return ShowBusinessTerminal( playerid );

		new
			iWithdraw;

	    if ( sscanf( inputtext, "d", iWithdraw ) ) SendError( playerid, "Invalid amount specified." );
        else if ( iWithdraw > 99999999 || iWithdraw < 0 ) SendError( playerid, "Invalid amount specified." );
        else if ( iWithdraw > g_businessData[ businessid ] [ E_BANK ] ) SendError( playerid, "The business bank account does not have this much money." );
        else
        {
            g_businessData[ businessid ] [ E_BANK ] -= iWithdraw;
            GivePlayerCash( playerid, iWithdraw );
            UpdateBusinessData( businessid );
            UpdateBusinessProductionLabel( businessid );
            SendServerMessage( playerid, "You have withdrawn %s from your business account.", ConvertPrice( iWithdraw ) );
        }
		return ShowPlayerDialog( playerid, DIALOG_BUSINESS_WITHDRAW, DIALOG_STYLE_INPUT, ""COL_GREY"Business System", sprintf( ""COL_WHITE"Enter the amount that you are willing to withdraw from your business bank account.\n\n"COL_GREY"Current Balance:"COL_WHITE" %s", ConvertPrice( g_businessData[ businessid ] [ E_BANK ] ) ), "Withdraw", "Back" );
	}
	if ( dialogid == DIALOG_BUSINESS_MEMBERS )
	{
		new
			businessid = p_InBusiness[ playerid ];

		if ( ! Iter_Contains( business, businessid ) || g_businessData[ businessid ] [ E_OWNER_ID ] != p_AccountID[ playerid ] )
			return SendError( playerid, "You must be the owner of the business to use this feature." );

		if ( ! response )
			return ShowBusinessTerminal( playerid );

		if ( listitem == 0 )
			return ShowPlayerDialog( playerid, DIALOG_BUSINESS_ADD_MEMBER, DIALOG_STYLE_INPUT, ""COL_GREY"Business System", ""COL_WHITE"Type the name of the player you wish to add as a member.", "Add", "Back" );

	    for( new i, x = 1; i < MAX_BUSINESS_MEMBERS; i ++ )
		{
			if ( g_businessData[ businessid ] [ E_MEMBERS ] [ i ] )
		 	{
		       	if ( x == listitem )
		      	{
		      		// alert player if online
		      		foreach (new p : Player) if ( g_businessData[ businessid ] [ E_MEMBERS ] [ i ] == p_AccountID[ p ] ) {
		      			SendServerMessage( p, "You have been removed as a member of "COL_GREY"%s"COL_WHITE".", g_businessData[ businessid ] [ E_NAME ] );
		      			break;
		      		}

		      		// null entry
		      		g_businessData[ businessid ] [ E_MEMBERS ] [ i ] = 0;

		      		// save
		      		UpdateBusinessData( businessid ), UpdateBusinessTitle( businessid );
		      		SendServerMessage( playerid, "You have removed a member from the business." );
				 	break;
	      		}
		      	x ++;
			}
		}

		ShowBusinessMembers( playerid, businessid );
		return 1;
	}
	if ( dialogid == DIALOG_BUSINESS_ADD_MEMBER )
	{
		new
			businessid = p_InBusiness[ playerid ];

		if ( ! Iter_Contains( business, businessid ) || g_businessData[ businessid ] [ E_OWNER_ID ] != p_AccountID[ playerid ] )
			return SendError( playerid, "You must be the owner of the business to use this feature." );

		if ( ! response )
			return ShowBusinessTerminal( playerid );

		new
			memberid;

		if ( sscanf( inputtext, #sscanf_u, memberid ) ) SendError( playerid, "Specify a name or id of the player you wish to add as a business member." );
		else if ( ! IsPlayerConnected( memberid ) || IsPlayerNPC( memberid ) ) SendError( playerid, "The player specified is not connected." );
		else if ( p_OwnedBusinesses[ memberid ] >= getPlayerBusinessCapacity( memberid ) )  SendError( playerid, "This player cannot be added to any more businesses." );
		else
		{
			new
				slotid = -1;

			// get slot for new member anyway
			for ( new x = 0; x < MAX_BUSINESS_MEMBERS; x ++ ) if ( g_businessData[ businessid ] [ E_MEMBERS ] [ x ] == 0 ) {
				slotid = x;
				break;
			}

			// proceed
			if ( slotid == -1 ) SendError( playerid, "The business has reached the maximum number of members." );
			else if ( IsBusinessAssociate( memberid, businessid ) ) SendError( playerid, "This member is already apart of your organization." );
			else
			{
				new
					current_members = GetBusinessAssociates( businessid ) - 1; // not including owner

				if ( current_members >= 4 + g_businessData[ businessid ] [ E_EXTRA_MEMBERS ] )
					return SendError( playerid, "You must pay to add more than %d members.", 4 + g_businessData[ businessid ] [ E_EXTRA_MEMBERS ] );

				// add member in
				p_OwnedBusinesses[ memberid ] ++;
				g_businessData[ businessid ] [ E_MEMBERS ] [ slotid ] = p_AccountID[ memberid ];

				// alert and save
				foreach (new i : Player) if ( IsBusinessAssociate( i, businessid ) ) {
					SendClientMessageFormatted( i, -1, ""COL_GREY"[BUSINESS]"COL_WHITE" %s(%d) has been added as a member to "COL_GREY"%s"COL_WHITE".", ReturnPlayerName( memberid ), memberid, g_businessData[ businessid ] [ E_NAME ] );
				}

		     	UpdateBusinessData( businessid ), UpdateBusinessTitle( businessid );
				return ShowBusinessMembers( playerid, businessid );
			}
		}
		return ShowPlayerDialog( playerid, DIALOG_BUSINESS_ADD_MEMBER, DIALOG_STYLE_INPUT, ""COL_GREY"Business System", ""COL_WHITE"Type the name of the player you wish to add as a member.", "Add", "Back" );
	}
	if ( dialogid == DIALOG_BUSINESS_NAME )
	{
		new
			businessid = p_InBusiness[ playerid ];

		if ( p_Class[ playerid ] != CLASS_CIVILIAN || ! Iter_Contains( business, businessid ) || ! IsBusinessAssociate( playerid, businessid ) )
			return SendError( playerid, "You do not have access to this feature." );

		if ( ! response )
			return ShowBusinessTerminal( playerid );

		if ( textContainsIP( inputtext ) )
			return SendError( playerid, "We do not condone advertising." );

		if ( ! ( 3 <= strlen( inputtext ) <= 32 ) ) {
			SendError( playerid, "Please make sure your business name is between 3 and 32 characters." );
		} else {
			format( g_businessData[ businessid ] [ E_NAME ], 32, "%s", inputtext );
			UpdateBusinessData( businessid ), UpdateBusinessTitle( businessid );
			SendServerMessage( playerid, "The business name has now been set to "COL_GREY"%s"COL_WHITE".", g_businessData[ businessid ] [ E_NAME ] );
		}
		return ShowPlayerDialog( playerid, DIALOG_BUSINESS_NAME, DIALOG_STYLE_INPUT, ""COL_GREY"Business System", sprintf( ""COL_WHITE"The current business name is %s\n\n"COL_WHITE"Enter below the new name for it", g_businessData[ businessid ] [ E_NAME ] ), "Update", "Back" );
	}
	if ( dialogid == DIALOG_BUSINESS_SELL )
	{
		new
			businessid = p_InBusiness[ playerid ];

		if ( p_Class[ playerid ] != CLASS_CIVILIAN || ! Iter_Contains( business, businessid ) || ! IsBusinessAssociate( playerid, businessid ) )
			return SendError( playerid, "You do not have access to this feature." );

		if ( ! response )
			return ShowBusinessTerminal( playerid );

		new
			current_product_levels = g_businessData[ businessid ] [ E_PRODUCT ];

		if ( current_product_levels - MAX_DROPS < 0 )
			return SendError( playerid, "Your business needs %d more product to allow for distribution.", MAX_DROPS - current_product_levels );

		if ( g_businessData[ businessid ] [ E_EXPORT_STARTED ] )
			return SendError( playerid, "Product exporting has already started for the business." );

	   	// destroy preexisting shit incase
	   	StopBusinessExportMission( businessid );

		// update product levels
		g_businessData[ businessid ] [ E_EXPORTED_AMOUNT ] = 0;
		g_businessData[ businessid ] [ E_PRODUCT ] -= MAX_DROPS;
		UpdateBusinessProductionLabel( businessid );

	   	// create a new export mission
		switch ( listitem )
		{
			case 0:
			{
				g_businessData[ businessid ] [ E_EXPORT_STARTED ] = 1;
				g_businessData[ businessid ] [ E_EXPORT_VALUE ] = GetProductPrice( g_businessData[ businessid ] [ E_INTERIOR_TYPE ], .hardened = true );
				SetRandomDropoffLocation( playerid, businessid, .heli = false );
				return 1;
			}

			case 1:
			{
				g_businessData[ businessid ] [ E_EXPORT_STARTED ] = 2;
				g_businessData[ businessid ] [ E_EXPORT_VALUE ] = GetProductPrice( g_businessData[ businessid ] [ E_INTERIOR_TYPE ], .hardened = false );
				SetRandomDropoffLocation( playerid, businessid, .heli = true );
				return 1;
			}
		}
		return 1;
	}
	if ( ( dialogid == DIALOG_BUSINESS_BUY ) && response )
	{
		new
			businessid = p_InBusiness[ playerid ];

		if ( p_Class[ playerid ] != CLASS_CIVILIAN || ! Iter_Contains( business, businessid ) || ! IsBusinessAssociate( playerid, businessid ) )
			return SendError( playerid, "You do not have access to this feature." );

		new
			business_type = g_businessData[ businessid ] [ E_INTERIOR_TYPE ];

		// check we havent breached any limits
		if ( g_businessData[ businessid ] [ E_SUPPLIES ] >= g_businessInteriorData[ business_type ] [ E_MAX_SUPPLIES ] )
			return ShowBusinessTerminal( playerid ), SendError( playerid, "The business met the limit of %d supplies.", g_businessInteriorData[ business_type ] [ E_MAX_SUPPLIES ] );

		if ( g_businessInteriorData[ business_type ] [ E_PRODUCTION_TIME ] > g_iTime )
			return ShowBusinessTerminal( playerid ), SendError( playerid, "You cannot resupply the business as it is currently in its production phase." );

		switch ( listitem )
		{
			case 0:
			{
				// buy with cash
				new
					price = GetResupplyPrice( business_type );

				if ( GetPlayerCash( playerid ) < price  )
					return ShowBusinessTerminal( playerid ), SendError( playerid, "You don't have enough money to resupply your business." );

				if ( g_businessData[ businessid ] [ E_PRODUCT ] >= g_businessInteriorData[ business_type ] [ E_MAX_SUPPLIES ] * 3 )
					return ShowBusinessTerminal( playerid ), SendError( playerid, "Your business has too much product that has not been exported yet." );

				if ( g_businessData[ businessid ] [ E_EXPORT_STARTED ] )
					return SendError( playerid, "Supplies cannot be purchased when you have begun an exporting mission." );

				// commence
				GivePlayerCash( playerid, -price );
				g_businessData[ businessid ] [ E_SUPPLIES ] ++;

				// alert and redirect
				SendServerMessage( playerid, "You have bought business supplies for "COL_GOLD"%s"COL_WHITE". "COL_ORANGE"(%d/%d)", ConvertPrice( price ), g_businessData[ businessid ] [ E_SUPPLIES ],  g_businessInteriorData[ business_type ] [ E_MAX_SUPPLIES ] );

				// start prod if viable
				StartBusinessDrugProduction( businessid );
			}
			case 1:
			{
				ShowBusinessTerminal( playerid );
				SendError( playerid, "This feature is currently under construction." );
			}
		}
		return ShowPlayerDialog( playerid, DIALOG_BUSINESS_BUY, DIALOG_STYLE_TABLIST_HEADERS, ""COL_GREY"Business System", sprintf( ""COL_WHITE"Your business has %d supplies\t \nBuy Supply\t%s\nSteal Supplies\t"COL_YELLOW"FREE", g_businessData[ businessid ] [ E_SUPPLIES ], ConvertPrice( GetResupplyPrice( business_type ) ) ), "Select", "Back" ), 1;
	}
	return 1;
}

stock StartBusinessDrugProduction( businessid )
{
	if ( ! Iter_Contains( business, businessid ) )
		return;

	new
		business_type = g_businessData[ businessid ] [ E_INTERIOR_TYPE ];

	// only if the stock is maxed
	if ( g_businessData[ businessid ] [ E_SUPPLIES ] >= g_businessInteriorData[ business_type ] [ E_MAX_SUPPLIES ] )
	{
		if ( g_businessData[ businessid ] [ E_UPGRADES ] ) {
			g_businessData[ businessid ] [ E_PROD_TIMESTAMP ] = g_iTime + 1800 * g_businessInteriorData[ business_type ] [ E_PRODUCTION_TIME ]; // doubles time necessary
		} else {
			g_businessData[ businessid ] [ E_PROD_TIMESTAMP ] = g_iTime + 3600 * g_businessInteriorData[ business_type ] [ E_PRODUCTION_TIME ];
		}

		UpdateBusinessProductionLabel( businessid );
		UpdateBusinessData( businessid );

		// alert players
		foreach (new i : Player) if ( IsBusinessAssociate( i, businessid ) ) {
			SendClientMessageFormatted( i, -1, ""COL_GREY"[BUSINESS]"COL_WHITE" Supply levels for "COL_GREY"%s"COL_WHITE" have replenished. Production will commence.", g_businessData[ businessid ] [ E_NAME ] );
		}
	}
}

public OnPlayerClickMap(playerid, Float:fX, Float:fY, Float:fZ)
{
	new
		raceid = GetPVarInt( playerid, "editing_race" );

	if ( IsRaceHost( playerid, raceid ) )
	{
		if ( g_raceData[ raceid ] [ E_RACE_FINISH_SET ] == 2 )
		{
			new
				Float: nodeX, Float: nodeY, Float: nodeZ,
				nodeid = NearestNodeFromPoint( fX, fY, fZ )
			;

			GetNodePos( nodeid, nodeX, nodeY, nodeZ );

			// set destination
			SetRaceDestination( raceid, nodeX, nodeY, nodeZ + 1.0 );

			// alert
			ShowRaceConfiguration( playerid, raceid );
			SendServerMessage( playerid, "You have selected the final destination for the race, use "COL_GREY"/race start"COL_WHITE" to begin." );
		}
	}
	return 1;
}

stock ShowPlayerVipRedeemedDialog( playerid )
{
	szLargeString[ 0 ] = '\0';
	strcat( szLargeString,	""COL_WHITE"You've just blew quite a bit of Irresistible Coins for your V.I.P, so congratulations! :D\n\n"\
							""COL_GREY" * What are the commands?"COL_WHITE" Use /vipcmds to view a detailed list of VIP commands.\n"\
							""COL_GREY" * What did I receive?"COL_WHITE" Check through your V.I.P package contents via our site (forum -> announcements board).\n" );
	strcat( szLargeString,	""COL_GREY" * How to redeem my houses/vehicles?"COL_WHITE" You will be announced to the admins and noted down for assistance, so please wait!\n"\
							""COL_GREY" * I'm unsure, help?"COL_WHITE" If you have any questions, please /ask otherwise enquire Lorenc via the forums!\n\nThanks for choosing to spend your Irresistible Coins, enjoy what you've got! :P"  );
	ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_MSGBOX, ""COL_GOLD"Irresistible Gaming Donation", szLargeString, "Got it!", "" );
}

thread OnFetchCategoryResponse( playerid, category )
{
	new
		rows, fields, i = 0;

	cache_get_data( rows, fields );
	if ( rows )
	{
		new
			szCategory[ 64 ];

		erase( szLargeString );
		erase( szBigString );

		while( i < rows )
		{
			cache_get_field_content( i, "SUBJECT", szCategory );
			format( szLargeString, sizeof( szLargeString ), "%s%s\n", szLargeString, szCategory );

			cache_get_field_content( i, "ID", szCategory );
			format( szBigString, sizeof( szBigString ), "%s %d", szBigString, strval( szCategory ) );

			i++;
		}

		SetPVarString( playerid, "help_ids", szBigString );
		ShowPlayerDialog( playerid, DIALOG_HELP_CATEGORY, DIALOG_STYLE_LIST, "{FFFFFF}Help Topics", szLargeString, "Select", "Back" );
	}
	else ShowPlayerDialog( playerid, DIALOG_HELP_BACK, DIALOG_STYLE_LIST, "{FFFFFF}Help Topics", "{FF0000}There are no threads available.", "Close", "Back" );
	return 1;
}

/*public OnFetchThreadData( playerid, category, thread );
public OnFetchThreadData( playerid, category, thread )
{
	new
		rows, fields;

	cache_get_data( rows, fields );
	if ( rows )
	{
		static
	        RegEx: rCIP,
			szSubject[ 64 ],
			szContent[ 2048 ]
		;

		cache_get_field_content( 0, "CONTENT", szContent, dbHandle, sizeof( szContent ) );
		cache_get_field_content( 0, "SUBJECT", szSubject );

		strins( szSubject, "{FFFFFF}", 0 );
		strins( szContent, "{FFFFFF}", 0 );


	    if ( !rCIP )
	  		rCIP = regex_build( "(?i)<[^>]*>" );

		regex_replace_exid( szContent, rCIP, "&nbsp;", szContent, sizeof( szContent ) );
		strreplace( szContent, "&nbsp;", "" );
		strreplace( szContent, "&amp;", "" );
		strreplace( szContent, "&#39;", "" );

		ShowPlayerDialog( playerid, DIALOG_HELP_THREAD, DIALOG_STYLE_MSGBOX, szSubject, szContent, "Close", "Back" );
	}
	else ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_LIST, "{FFFFFF}Help Topics", "{FFFFFF}An error has occurred. Try again later.", "Okay", "" );
	return 1;
}*/

public OnHelpHTTPResponse( index, response_code, data[ ] )
{
    if ( response_code == 200 ) //Did the request succeed?
		ShowPlayerDialog( index, DIALOG_HELP_THREAD, DIALOG_STYLE_MSGBOX, "{FFFFFF}Help Topics", data, "Close", "Back" );
	else
		ShowPlayerDialog( index, DIALOG_NULL, DIALOG_STYLE_LIST, "{FFFFFF}Help Topics", "{FFFFFF}An error has occurred. Try again later.", "Okay", "" );
	return 1;
}

stock IsBoatVehicle(value)
{
	static const valid_values[6] = {
		29425665, -2143286272, 0, 0, 0, 32
	};

	if (430 <= value <= 595) {
		value -= 430;
		return (valid_values[value >>> 5] & (1 << (value & 31))) || false;
	}
	return false;
}

stock IsAirVehicle(value)
{
	static const valid_values[6] = {
		1073742081, 135268352, -1073676096, 192, 262408, 98305
	};

	if (417 <= value <= 593) {
		value -= 417;
		return (valid_values[value >>> 5] & (1 << (value & 31))) || false;
	}
	return false;
}

stock IsBikeVehicle(value)
{
	static const valid_values[5] = {
		1105921, 1610612738, 1536, 0, 1056
	};

	if (448 <= value <= 586) {
		value -= 448;
		return (valid_values[value >>> 5] & (1 << (value & 31))) || false;
	}
	return false;
}

stock IsTrailerVehicle(model) {
	static const valid_values[6] = {
		32769, 0, 0, 0, 270532608, 112640
	};

	if (435 <= model <= 611) {
		model -= 435;
		return (valid_values[model >>> 5] & (1 << (model & 31))) || false;
	}
	return false;
}

stock IsLowriderVehicle(model)
{
	static const valid_values[6] = {
		1, 0, 0, 469762048, 201326592, 24
	};

	if (412 <= model <= 576) {
		model -= 412;
		return (valid_values[model >>> 5] & (1 << (model & 31))) || false;
	}
	return false;
}

function gps_Update( playerid )
{
	if ( !IsPlayerInAnyVehicle( playerid ) )
	{
		p_GPSLocation	[ playerid ] = 0;
		p_GPSToggled	{ playerid } = false;
		DestroyDynamicObject( p_GPSObject[ playerid ] );
		KillTimer( p_GPSTimer[ playerid ] );
		p_GPSTimer[ playerid ] = 0xFF;
	  	p_GPSObject[ playerid ] = INVALID_OBJECT_ID;
	  	TextDrawHideForPlayer( playerid, p_GPSInformation[ playerid ] );
	  	SendServerMessage( playerid, "You have de-activated your GPS." );
	  	return 0;
	}

	static
	    Float: fRY, Float: fRZ, Float: fAZ,
	    Float: X, Float: Y, Float: Z, v, string[ 100 ], Float: pos
	;
	pos = GetPlayerDistanceFromPoint( playerid, g_gpsData[ p_GPSLocation[ playerid ] ] [ E_X ], g_gpsData[ p_GPSLocation[ playerid ] ] [ E_Y ], g_gpsData[ p_GPSLocation[ playerid ] ] [ E_Z ]);
	format( string, sizeof( string ), "~g~Location:~w~ %s~n~~g~Distance:~w~ %0.2fm", g_gpsData[ p_GPSLocation[ playerid ] ] [ E_NAME ], pos );
	TextDrawSetString( p_GPSInformation[ playerid ], string );
	v = GetPlayerVehicleID( playerid );
	GetVehiclePos( v, X, Y, Z );
	GetVehicleZAngle( v, fAZ );

	fRY = floatsqroot( floatpower( ( g_gpsData[ p_GPSLocation[ playerid ] ] [ E_X ] - X ), 2.0 ) + floatpower( ( g_gpsData[ p_GPSLocation[ playerid ] ] [ E_Y ] - Y ), 2.0 ) );
	fRY = floatabs( atan2( fRY, Z - g_gpsData[ p_GPSLocation[ playerid ] ] [ E_Z ] ) );
	fRZ = atan2(g_gpsData[ p_GPSLocation[ playerid ] ] [ E_Y ] - Y, g_gpsData[ p_GPSLocation[ playerid ] ] [ E_X ] - X) + 180;

    AttachDynamicObjectToVehicle( p_GPSObject[ playerid ], v, 0.0, 0.0, 1.5, 0.0, fRY, fRZ + (-fAZ) );
	return 1;
}

public OnPlayerClickPlayer(playerid, clickedplayerid, source)
{
	return 1;
}

/////////////////////////
//      Functions      //
/////////////////////////

stock SetServerRule( rule[ ], value[ ] )
{
	new string[ 80 ];
	format( string, sizeof( string ), "%s %s", rule, value );
	SendRconCommand( string );
}

/*stock ReturnPlayerName( playerid )
{
	GetPlayerName( playerid, szSmallString, MAX_PLAYER_NAME );
	if ( !IsPlayerConnected( playerid ) ) szSmallString = "No-one";
	return szSmallString;
}*/

stock SetPlayerPosToPrison( playerid )
{
	static const
		Float: sf_JailSpawnPoints[ ][ 3 ] =
		{
			{ 215.5644, 110.7332, 999.0156 },
			{ 219.4913, 110.9124, 999.0156 },
			{ 223.4386, 111.0879, 999.0156 },
			{ 227.4427, 111.2414, 999.0156 }
		},

		Float: lv_JailSpawnPoints[ ] [ 3 ] =
		{
			{ 198.6733, 162.2922, 1003.0300 },
			{ 197.4023, 174.4845, 1003.0234 },
			{ 193.2059, 174.6152, 1003.0234 }
		},

		Float: ls_JailSpawnPoints[ ] [ 3 ] =
		{
			{ 264.3201, 86.4325, 1001.0391 },
			{ 264.3130, 81.8108, 1001.0391 },
			{ 264.5371, 77.7982, 1001.0391 }
		},

		Float: alctrazSpawnPoints[ ] [ 3 ] =
		{
			{ -2008.7112, 1876.0122, 21.7957 },
			{ -2062.8308, 1878.9573, 21.7957 },
			{ -2112.6472, 1907.8503, 21.7957 },
			{ -2040.2295, 1918.9410, 21.7957 }
		},

		Float: loadingHeight = 0.50
	;

	new
		iRandom;

	jailDoors				( playerid, false, true );
    SetPlayerFacingAngle 	( playerid, 0.0 );
	TogglePlayerControllable( playerid, 0 );
 	SetPlayerVirtualWorld 	( playerid, 30 );
	SetTimerEx 				( "ope_Unfreeze", 5000, false, "d", playerid );
	p_inAlcatraz 			{ playerid } = false;

	if ( p_JailTime[ playerid ] > 600 )
	{
	    iRandom = random( sizeof( alctrazSpawnPoints ) );
	    SetPlayerPos 			( playerid, alctrazSpawnPoints[ iRandom ][ 0 ], alctrazSpawnPoints[ iRandom ][ 1 ], alctrazSpawnPoints[ iRandom ][ 2 ] + loadingHeight );
	 	SetPlayerInterior		( playerid, 0 );
	 	SetPlayerVirtualWorld 	( playerid, 0 );
		p_AlcatrazEscapeTS 		[ playerid ] = g_iTime + ALCATRAZ_TIME_PAUSE;
		p_inAlcatraz 			{ playerid } = true;
		return 1;
	}

	switch( getClosestPoliceStation( playerid ) )
	{
		case CITY_LV:
		{
		    iRandom = random( sizeof( lv_JailSpawnPoints ) );
		    SetPlayerPos( playerid, lv_JailSpawnPoints[ iRandom ][ 0 ], lv_JailSpawnPoints[ iRandom ][ 1 ], lv_JailSpawnPoints[ iRandom ][ 2 ] + loadingHeight );
		 	SetPlayerInterior( playerid, 3 );
		}
		case CITY_LS:
		{
		    iRandom = random( sizeof( ls_JailSpawnPoints ) );
		    SetPlayerPos( playerid, ls_JailSpawnPoints[ iRandom ][ 0 ], ls_JailSpawnPoints[ iRandom ][ 1 ], ls_JailSpawnPoints[ iRandom ][ 2 ] + loadingHeight );
		 	SetPlayerInterior( playerid, 6 );
		}
		default:
		{
		    iRandom = random( sizeof( sf_JailSpawnPoints ) );
		    SetPlayerPos( playerid, sf_JailSpawnPoints[ iRandom ][ 0 ], sf_JailSpawnPoints[ iRandom ][ 1 ], sf_JailSpawnPoints[ iRandom ][ 2 ] + loadingHeight );
		 	SetPlayerInterior( playerid, 10 );
		}
	}
    return 1;
}

stock JailPlayer( playerid, seconds, admin = 0 )
{
	if ( playerid == INVALID_PLAYER_ID )
		return 0;

	static
	    Query[ 72 ], Float: armour
	;

	// Neccessary Checks
	if ( IsPlayerInMethlab( playerid ) )
		haltMethamphetamine( playerid, GetPlayerMethLabVehicle( playerid ) );

	// Neccessary Functions
	KillTimer 				( p_JailTimer[ playerid ] );
	KillTimer 				( p_CuffAbuseTimer[ playerid ] );
    TextDrawSetString		( p_JailTimeTD[ playerid ], "_" );
	TextDrawShowForPlayer	( playerid, p_JailTimeTD[ playerid ] );

	// External Variables to Jail (resetting)
	p_TicketIssuer		[ playerid ] = INVALID_PLAYER_ID; // Reset Tickets
	p_TicketTimestamp	[ playerid ] = 0; // Reset Tickets
	p_Cuffed			{ playerid } = false;
	p_Detained 			{ playerid } = false;
	p_InfectedHIV 		{ playerid } = false;
	Delete3DTextLabel	( p_DetainedLabel[ playerid ] );
	p_DetainedLabel		[ playerid ] = Text3D: INVALID_3DTEXT_ID;
	p_DetainedBy		[ playerid ] = INVALID_PLAYER_ID;

	// Primary Jail Variables
	p_Jailed			{ playerid } = true;
	p_JailTime			[ playerid ] = seconds;
	p_AdminJailed		{ playerid } = admin;
	p_JailTimer			[ playerid ] = SetTimerEx( "Unjail", 950, true, "d", playerid );

	CancelEdit 					( playerid );
	RemovePlayerStolensFromHands( playerid );
	StopPlayerUsingSlotMachine 	( playerid );
	RemoveEquippedOre			( playerid );
	ClearPlayerWantedLevel 		( playerid );
    ResetPlayerWeapons			( playerid );
	UntiePlayer					( playerid );
	jailDoors 					( playerid, false, true );
	SetPlayerPosToPrison 		( playerid );

	// External Functions
	SetPlayerSpecialAction		( playerid, SPECIAL_ACTION_NONE );
	ClearAnimations 			( playerid );
	RemovePlayerAttachedObject	( playerid, 2 );
    SetPlayerHealth				( playerid, INVALID_PLAYER_ID );

    if ( !IsPlayerAdminJailed( playerid ) )
    {
		if ( p_MetalMelter[ playerid ] )
			ShowPlayerHelpDialog( playerid, 4000, "You can break yourself out of prison with ~p~/breakout." );
		else
			ShowPlayerHelpDialog( playerid, 4000, "You can buy metal melters at Supa Save or a 24/7 store." );
    }

	format( Query, sizeof( Query ), "UPDATE `USERS` SET JAIL_TIME=%d,JAIL_ADMIN=%d WHERE `ID`=%d", seconds, admin, p_AccountID[ playerid ] );
	mysql_single_query( Query );

    if ( GetPlayerArmour( playerid, armour ) && armour )
    	SetPlayerArmour( playerid, 0.0 );
	return 1;
}

function Unjail( playerid )
{
    static
	    Query[ 64 ];

	if ( !IsPlayerConnected( playerid ) ) return KillTimer( p_JailTimer[ playerid ] ), 0;

    p_JailTime[ playerid ] --;

    format( Query, sizeof( Query ), "Time Remaining:~n~%d seconds", p_JailTime[ playerid ] );
	TextDrawSetString( p_JailTimeTD[ playerid ], Query );

    if ( p_JailTime[ playerid ] < 1 )
	   	CallLocalFunction( "OnPlayerUnjailed", "dd", playerid, 0 );

    return 1;
}

stock SavePlayerData( playerid, bool: logout = false )
{
    static
		Query[ 950 ];

	if ( IsPlayerNPC( playerid ) )
		return 0;

    if ( p_PlayerLogged{ playerid } )
    {
    	new
    		bool: bQuitToAvoid = false;

		if ( IsPlayerCuffed( playerid ) || IsPlayerTazed( playerid ) || IsPlayerTied( playerid ) || p_LeftCuffed{ playerid } || p_QuitToAvoidTimestamp[ playerid ] > g_iTime )
			bQuitToAvoid = true;

		new
			gangid = -1;

		if ( logout )
			printf ("[%s][0] has the gang id of %d", ReturnPlayerName( playerid ), p_GangID[ playerid ] );

		if ( 0 <= p_GangID[ playerid ] < MAX_GANGS && Iter_Contains( gangs, p_GangID[ playerid ] ) )
			gangid = g_gangData[ p_GangID[ playerid ] ] [ E_SQL_ID ];

        format( Query, sizeof( Query ), "UPDATE `USERS` SET `SCORE`=%d,`CASH`=%d,`ADMINLEVEL`=%d,`BANKMONEY`=%d,`OWNEDHOUSES`=%d,`KILLS`=%d,`DEATHS`=%d,`VIP_PACKAGE`=%d,`XP`=%d,`OWNEDCARS`=%d,`LASTLOGGED`=%d,`VIP_EXPIRE`=%d,`LAST_SKIN`=%d,`BURGLARIES`=%d,`UPTIME`=%d,`ARRESTS`=%d,`CITY`=%d,`METH`=%d,`SODA`=%d,`ACID`=%d,`GAS`=%d,",
                                       	GetPlayerScore( playerid ), 	GetPlayerCash( playerid ),		p_AdminLevel[ playerid ],
                                       	p_BankMoney[ playerid ], 		p_OwnedHouses[ playerid ], 		p_Kills[ playerid ],
										p_Deaths[ playerid ], 			p_VIPLevel[ playerid ], 		p_XP[ playerid ],
										p_OwnedVehicles[ playerid ], 	g_iTime, 						p_VIPExpiretime[ playerid ],
										p_LastSkin[ playerid ], 		p_Burglaries[ playerid ], 		p_Uptime[ playerid ],
									 	p_Arrests[ playerid ],			p_SpawningCity{ playerid },		p_Methamphetamine{ playerid },
									 	p_CausticSoda{ playerid },		p_MuriaticAcid{ playerid }, 	p_HydrogenChloride{ playerid } );

		format( Query, sizeof( Query ), "%s`VIPWEP1`=%d,`VIPWEP2`=%d,`VIPWEP3`=%d,`MUTE_TIME`=%d,`WANTEDLVL`=%d,`ROBBERIES`=%d,`PING_IMMUNE`=%d,`FIRES`=%d,`CONTRACTS`=%d,`JOB`=%d,`JAIL_TIME`=%d,`ROPES`=%d,`C4`=%d,`MELTERS`=%d,`SCISSORS`=%d,`FOILS`=%d,`PINS`=%d,`BOUNTY`=%d,`WEED`=%d,`IS_CUFFED`=%d,`DRILL`=%d,",
										Query,                          p_VIPWep1{ playerid },          p_VIPWep2{ playerid },
										p_VIPWep3{ playerid },          p_MutedTime[ playerid ],        p_WantedLevel[ playerid ],
										p_Robberies[ playerid ],        p_PingImmunity{ playerid },     p_Fires[ playerid ],
										p_HitsComplete[ playerid ],     p_Job{ playerid },              p_JailTime[ playerid ],
										p_Ropes[ playerid ],			p_C4Amount[ playerid ], 		p_MetalMelter[ playerid ],
										p_Scissors[ playerid ], 		p_AntiEMP[ playerid ], 			p_BobbyPins[ playerid ],
										p_ContractedAmount[ playerid ],	p_WeedGrams[ playerid ],		logout ? ( bQuitToAvoid ? 1 : 0 ) : 0,
										p_drillStrength[ playerid ] );

		format( Query, sizeof( Query ), "%s`BLEW_JAILS`=%d,`BLEW_VAULT`=%d,`VEHICLES_JACKED`=%d,`METH_YIELDED`=%d,`LAST_IP`='%s',`VIP_JOB`=%d,`TRUCKED`=%d,`COINS`=%f,`GANG_ID`=%d,`HOUSE_ID`=%d,`RANK`=%f,`ONLINE`=%d,`HIT_SOUND`=%d,`EXTRA_SLOTS`=%d,`BUSINESS_ID`=%d WHERE `ID`=%d",
										Query,
										p_JailsBlown[ playerid ], 		p_BankBlown[ playerid ], 			p_CarsJacked[ playerid ],
										p_MethYielded[ playerid ],		mysql_escape( ReturnPlayerIP( playerid ) ),
										p_VIPJob{ playerid },			p_TruckedCargo[ playerid ],			p_IrresistibleCoins[ playerid ],
										gangid,							p_HouseSpawnLocation[ playerid ], 	p_IrresistiblePoints[ playerid ],
										!logout,						p_HitmarkerSound{ playerid },		p_ExtraAssetSlots{ playerid },
										p_BusinessSpawnLocation[ playerid ], p_AccountID[ playerid ] );


		if ( logout )
			printf ("[%s][1] Exited Server With Gang ID %d, save len %d", ReturnPlayerName( playerid ), gangid, strlen( Query ) );

		mysql_single_query( Query );

        if ( logout )
			 p_PlayerLogged{ playerid } = false;
    }
    return 1;
}

stock initializeTextDraws( )
{
	// reset blackjack data
    for ( new i = 0; i < MAX_BLACKJACK_TABLES; i ++ ) {
        for ( new x = 0; x < MAX_BLACKJACK_CARDS; x ++ ) {
            g_blackjackDealerCards[ i ] [ x ] = Text: INVALID_TEXT_DRAW;
            for ( new p = 0; p < MAX_BLACKJACK_PLAYERS; p ++ ) {
                g_blackjackPlayerCards[ i ] [ x ] [ p ] = Text: INVALID_TEXT_DRAW;
                g_blackjackSlotData[ i ] [ p ] = -1;
            }
        }
    }

	g_NotManyPlayersTD = TextDrawCreate(322.000000, 12.000000, "Coin generation increased by 5x as there aren't many players online!");
	TextDrawAlignment(g_NotManyPlayersTD, 2);
	TextDrawBackgroundColor(g_NotManyPlayersTD, 0);
	TextDrawFont(g_NotManyPlayersTD, 1);
	TextDrawLetterSize(g_NotManyPlayersTD, 0.149999, 0.799999);
	TextDrawColor(g_NotManyPlayersTD, -16776961);
	TextDrawSetOutline(g_NotManyPlayersTD, 1);
	TextDrawSetProportional(g_NotManyPlayersTD, 1);

	g_TopDonorTD = TextDrawCreate(320.000000, 2.000000, "Top Donor Lorenc - $0.00, ~w~~h~~h~Latest Donor Lorenc - $0.00");
	TextDrawAlignment(g_TopDonorTD, 2);
	TextDrawBackgroundColor(g_TopDonorTD, 0);
	TextDrawFont(g_TopDonorTD, 1);
	TextDrawLetterSize(g_TopDonorTD, 0.139999, 0.799999);
	TextDrawColor(g_TopDonorTD, -2347265);
	TextDrawSetOutline(g_TopDonorTD, 1);
	TextDrawSetProportional(g_TopDonorTD, 1);

	g_SlotMachineBoxTD[ 0 ] = TextDrawCreate(220.000000, 322.000000, "_");
	TextDrawBackgroundColor(g_SlotMachineBoxTD[ 0 ], 255);
	TextDrawLetterSize(g_SlotMachineBoxTD[ 0 ], 0.500000, 7.000000);
	TextDrawUseBox(g_SlotMachineBoxTD[ 0 ], 1);
	TextDrawBoxColor(g_SlotMachineBoxTD[ 0 ], 112);
	TextDrawTextSize(g_SlotMachineBoxTD[ 0 ], 430.000000, 3.000000);

	g_SlotMachineBoxTD[ 1 ] = TextDrawCreate(220.000000, 306.000000, "_");
	TextDrawBackgroundColor(g_SlotMachineBoxTD[ 1 ], 255);
	TextDrawLetterSize(g_SlotMachineBoxTD[ 1 ], 0.500000, 1.400000);
	TextDrawUseBox(g_SlotMachineBoxTD[ 1 ], 1);
	TextDrawBoxColor(g_SlotMachineBoxTD[ 1 ], 238);
	TextDrawTextSize(g_SlotMachineBoxTD[ 1 ], 430.000000, -18.000000);

	g_currentXPTD = TextDrawCreate(529.000000, 405.000000, "Current XP");
	TextDrawBackgroundColor(g_currentXPTD, 255);
	TextDrawFont(g_currentXPTD, 3);
	TextDrawLetterSize(g_currentXPTD, 0.230000, 1.000000);
	TextDrawColor(g_currentXPTD, -1);
	TextDrawSetOutline(g_currentXPTD, 1);
	TextDrawSetProportional(g_currentXPTD, 1);

	g_CurrentRankTD = TextDrawCreate(529.000000, 375.000000, "Current Rank");
	TextDrawBackgroundColor(g_CurrentRankTD, 255);
	TextDrawFont(g_CurrentRankTD, 3);
	TextDrawLetterSize(g_CurrentRankTD, 0.230000, 1.000000);
	TextDrawColor(g_CurrentRankTD, -1);
	TextDrawSetOutline(g_CurrentRankTD, 1);
	TextDrawSetProportional(g_CurrentRankTD, 1);

	g_CurrentCoinsTD = TextDrawCreate(529.000000, 348.000000, "Total Coins");
	TextDrawBackgroundColor(g_CurrentCoinsTD, 255);
	TextDrawFont(g_CurrentCoinsTD, 3);
	TextDrawLetterSize(g_CurrentCoinsTD, 0.230000, 1.000000);
	TextDrawColor(g_CurrentCoinsTD, -1);
	TextDrawSetOutline(g_CurrentCoinsTD, 1);
	TextDrawSetProportional(g_CurrentCoinsTD, 1);

	g_DoubleXPTD = TextDrawCreate(516.000000, 423.500000, "x2");
	TextDrawBackgroundColor(g_DoubleXPTD, 255);
	TextDrawFont(g_DoubleXPTD, 3);
	TextDrawLetterSize(g_DoubleXPTD, 0.230000, 1.000000);
	TextDrawColor(g_DoubleXPTD, -1);
	TextDrawSetOutline(g_DoubleXPTD, 1);
	TextDrawSetProportional(g_DoubleXPTD, 1);

	p_VehiclePreviewCloseTD = TextDrawCreate(191.000000, 319.000000, "Press your ESCAPE KEY to close the preview.");
	TextDrawBackgroundColor(p_VehiclePreviewCloseTD, 255);
	TextDrawFont(p_VehiclePreviewCloseTD, 2);
	TextDrawLetterSize(p_VehiclePreviewCloseTD, 0.259999, 1.399999);
	TextDrawColor(p_VehiclePreviewCloseTD, -1);
	TextDrawSetOutline(p_VehiclePreviewCloseTD, 1);
	TextDrawSetProportional(p_VehiclePreviewCloseTD, 1);

	g_VehiclePreviewBoxTD = TextDrawCreate(500.000000, 150.000000, "__");
	TextDrawBackgroundColor(g_VehiclePreviewBoxTD, 255);
	TextDrawLetterSize(g_VehiclePreviewBoxTD, 0.500000, 17.000000);
	TextDrawColor(g_VehiclePreviewBoxTD, -1);
	TextDrawUseBox(g_VehiclePreviewBoxTD, 1);
	TextDrawBoxColor(g_VehiclePreviewBoxTD, 112);
	TextDrawTextSize(g_VehiclePreviewBoxTD, 139.000000, 50.000000);

	g_VehiclePreviewTxtTD = TextDrawCreate(130.000000, 135.000000, "Vehicle Preview");
	TextDrawBackgroundColor(g_VehiclePreviewTxtTD, 255);
	TextDrawFont(g_VehiclePreviewTxtTD, 0);
	TextDrawLetterSize(g_VehiclePreviewTxtTD, 0.720000, 2.000000);
	TextDrawColor(g_VehiclePreviewTxtTD, -1);
	TextDrawSetOutline(g_VehiclePreviewTxtTD, 1);
	TextDrawSetProportional(g_VehiclePreviewTxtTD, 1);
	TextDrawSetSelectable(g_VehiclePreviewTxtTD, 0);

	g_ProgressBoxTD = TextDrawCreate(250.000000, 220.000000, "_");
	TextDrawBackgroundColor(g_ProgressBoxTD, 255);
	TextDrawFont(g_ProgressBoxTD, 1);
	TextDrawLetterSize(g_ProgressBoxTD, 0.500000, 1.000000);
	TextDrawColor(g_ProgressBoxTD, -1);
	TextDrawSetOutline(g_ProgressBoxTD, 0);
	TextDrawSetProportional(g_ProgressBoxTD, 1);
	TextDrawSetShadow(g_ProgressBoxTD, 1);
	TextDrawUseBox(g_ProgressBoxTD, 1);
	TextDrawBoxColor(g_ProgressBoxTD, 255);
	TextDrawTextSize(g_ProgressBoxTD, 390.000000, 10.000000);

	g_AdminLogTD = TextDrawCreate(150.000000, 360.000000, "_");
	TextDrawBackgroundColor(g_AdminLogTD, 255);
	TextDrawFont(g_AdminLogTD, 1);
	TextDrawLetterSize(g_AdminLogTD, 0.210000, 1.000000);
	TextDrawColor(g_AdminLogTD, -16289537);
	TextDrawSetOutline(g_AdminLogTD, 1);
	TextDrawSetProportional(g_AdminLogTD, 1);

	g_AnimationTD = TextDrawCreate(220.000000, 141.000000, "PRESS ~r~~h~~k~~PED_SPRINT~~W~ TO STOP THE ANIMATION");
	TextDrawBackgroundColor(g_AnimationTD, 80);
	TextDrawFont(g_AnimationTD, 3);
	TextDrawLetterSize(g_AnimationTD, 0.310000, 1.200000);
	TextDrawColor(g_AnimationTD, -1);
	TextDrawSetOutline(g_AnimationTD, 1);
	TextDrawSetProportional(g_AnimationTD, 1);
	TextDrawUseBox(g_AnimationTD, 1);
	TextDrawBoxColor(g_AnimationTD, 117);
	TextDrawTextSize(g_AnimationTD, 418.000000, 0.000000);

    g_AchievementTD[ 0 ] = TextDrawCreate(250.000000, 120.000000, "_");
	TextDrawBackgroundColor(g_AchievementTD[ 0 ], 255);
	TextDrawFont(g_AchievementTD[ 0 ], 1);
	TextDrawLetterSize(g_AchievementTD[ 0 ], 0.500000, 6.000001);
	TextDrawColor(g_AchievementTD[ 0 ], -1);
	TextDrawSetOutline(g_AchievementTD[ 0 ], 0);
	TextDrawSetProportional(g_AchievementTD[ 0 ], 1);
	TextDrawSetShadow(g_AchievementTD[ 0 ], 1);
	TextDrawUseBox(g_AchievementTD[ 0 ], 1);
	TextDrawBoxColor(g_AchievementTD[ 0 ], 80);
	TextDrawTextSize(g_AchievementTD[ 0 ], 403.000000, 4.000000);

	g_AchievementTD[ 1 ] = TextDrawCreate(250.000000, 120.000000, "_");
	TextDrawBackgroundColor(g_AchievementTD[ 1 ], 255);
	TextDrawFont(g_AchievementTD[ 1 ], 1);
	TextDrawLetterSize(g_AchievementTD[ 1 ], 0.500000, 1.300000);
	TextDrawColor(g_AchievementTD[ 1 ], -1);
	TextDrawSetOutline(g_AchievementTD[ 1 ], 0);
	TextDrawSetProportional(g_AchievementTD[ 1 ], 1);
	TextDrawSetShadow(g_AchievementTD[ 1 ], 1);
	TextDrawUseBox(g_AchievementTD[ 1 ], 1);
	TextDrawBoxColor(g_AchievementTD[ 1 ], 128);
	TextDrawTextSize(g_AchievementTD[ 1 ], 403.000000, 4.000000);

	g_AchievementTD[ 2 ] = TextDrawCreate(250.000000, 137.000000, "_");
	TextDrawBackgroundColor(g_AchievementTD[ 2 ], 255);
	TextDrawFont(g_AchievementTD[ 2 ], 1);
	TextDrawLetterSize(g_AchievementTD[ 2 ], 0.500000, -0.699999);
	TextDrawColor(g_AchievementTD[ 2 ], -1);
	TextDrawSetOutline(g_AchievementTD[ 2 ], 0);
	TextDrawSetProportional(g_AchievementTD[ 2 ], 1);
	TextDrawSetShadow(g_AchievementTD[ 2 ], 1);
	TextDrawUseBox(g_AchievementTD[ 2 ], 1);
	TextDrawBoxColor(g_AchievementTD[ 2 ], 255);
	TextDrawTextSize(g_AchievementTD[ 2 ], 403.000000, 4.000000);

	g_AchievementTD[ 3 ] = TextDrawCreate(266.000000, 121.000000, "]_ACHIEVEMENT UNLOCKED_]");
	TextDrawBackgroundColor(g_AchievementTD[ 3 ], 255);
	TextDrawFont(g_AchievementTD[ 3 ], 2);
	TextDrawLetterSize(g_AchievementTD[ 3 ], 0.210000, 1.100000);
	TextDrawColor(g_AchievementTD[ 3 ], -65281);
	TextDrawSetOutline(g_AchievementTD[ 3 ], 0);
	TextDrawSetProportional(g_AchievementTD[ 3 ], 1);
	TextDrawSetShadow(g_AchievementTD[ 3 ], 1);

   	g_WorldDayTD = TextDrawCreate(501.000000, 6.000000, "Monday");
	TextDrawBackgroundColor(g_WorldDayTD, 255);
	TextDrawFont(g_WorldDayTD, 3);
	TextDrawLetterSize(g_WorldDayTD, 0.519998, 1.499999);
	TextDrawSetOutline(g_WorldDayTD, 2);
	TextDrawSetProportional(g_WorldDayTD, 1);

	g_MotdTD = TextDrawCreate(320.000000, 426.000000, "_");
	TextDrawAlignment(g_MotdTD, 2);
	TextDrawBackgroundColor(g_MotdTD, 117);
	TextDrawFont(g_MotdTD, 1);//1
	TextDrawLetterSize(g_MotdTD, 0.300000, 1.300000);
	TextDrawColor(g_MotdTD, -1);
	TextDrawSetOutline(g_MotdTD, 1);
	TextDrawSetProportional(g_MotdTD, 1);

	g_ClassBoxTD = TextDrawCreate(28.000000, 159.000000, "_");
	TextDrawBackgroundColor(g_ClassBoxTD, 255);
	TextDrawFont(g_ClassBoxTD, 1);
	TextDrawLetterSize(g_ClassBoxTD, 0.500000, 18.000000);
	TextDrawColor(g_ClassBoxTD, -1);
	TextDrawSetOutline(g_ClassBoxTD, 0);
	TextDrawSetProportional(g_ClassBoxTD, 1);
	TextDrawSetShadow(g_ClassBoxTD, 1);
	TextDrawUseBox(g_ClassBoxTD, 1);
	TextDrawBoxColor(g_ClassBoxTD, 149);
	TextDrawTextSize(g_ClassBoxTD, 190.000000, 0.000000);

	g_ClassBoxTD1 = TextDrawCreate(22.000000, 151.000000, "_");
	TextDrawBackgroundColor(g_ClassBoxTD1, 255);
	TextDrawFont(g_ClassBoxTD1, 1);
	TextDrawLetterSize(g_ClassBoxTD1, 0.500000, 19.900003);
	TextDrawColor(g_ClassBoxTD1, -1);
	TextDrawSetOutline(g_ClassBoxTD1, 0);
	TextDrawSetProportional(g_ClassBoxTD1, 1);
	TextDrawSetShadow(g_ClassBoxTD1, 1);
	TextDrawUseBox(g_ClassBoxTD1, 1);
	TextDrawBoxColor(g_ClassBoxTD1, 149);
	TextDrawTextSize(g_ClassBoxTD1, 197.000000, 0.000000);

	g_ObjectLoadTD = TextDrawCreate(320.000000, 148.000000, "Loading Objects...~n~Please Wait...");
	TextDrawAlignment(g_ObjectLoadTD, 2);
	TextDrawBackgroundColor(g_ObjectLoadTD, 80);
	TextDrawFont(g_ObjectLoadTD, 2);
	TextDrawLetterSize(g_ObjectLoadTD, 0.400000, 2.000000);
	TextDrawColor(g_ObjectLoadTD, -1);
	TextDrawSetOutline(g_ObjectLoadTD, 1);
	TextDrawSetProportional(g_ObjectLoadTD, 1);
	TextDrawUseBox(g_ObjectLoadTD, 1);
	TextDrawBoxColor(g_ObjectLoadTD, 117);
	TextDrawTextSize(g_ObjectLoadTD, 0.000000, 180.000000);

	g_WebsiteTD = TextDrawCreate(33.000000, 427.000000, "www.IrresistibleGaming.com");
	TextDrawBackgroundColor(g_WebsiteTD, 255);
	TextDrawFont(g_WebsiteTD, 1);
	TextDrawLetterSize(g_WebsiteTD, 0.220000, 1.200000);
	TextDrawColor(g_WebsiteTD, 1289224191);
	TextDrawSetOutline(g_WebsiteTD, 1);
	TextDrawSetProportional(g_WebsiteTD, 1);

	g_MovieModeTD[ 0 ] = TextDrawCreate(507.000000, 386.000000, "_");
	TextDrawBackgroundColor(g_MovieModeTD[ 0 ], 255);
	TextDrawFont(g_MovieModeTD[ 0 ], 1);
	TextDrawLetterSize(g_MovieModeTD[ 0 ], 0.500000, 4.799999);
	TextDrawColor(g_MovieModeTD[ 0 ], -1);
	TextDrawSetOutline(g_MovieModeTD[ 0 ], 0);
	TextDrawSetProportional(g_MovieModeTD[ 0 ], 1);
	TextDrawSetShadow(g_MovieModeTD[ 0 ], 1);
	TextDrawUseBox(g_MovieModeTD[ 0 ], 1);
	TextDrawBoxColor(g_MovieModeTD[ 0 ], 80);
	TextDrawTextSize(g_MovieModeTD[ 0 ], 620.000000, 0.000000);

	g_MovieModeTD[ 1 ] = TextDrawCreate(516.000000, 398.000000, "San Fierro");
	TextDrawBackgroundColor(g_MovieModeTD[ 1 ], 255);
	TextDrawFont(g_MovieModeTD[ 1 ], 3);
	TextDrawLetterSize(g_MovieModeTD[ 1 ], 0.529999, 2.299999);
	TextDrawColor(g_MovieModeTD[ 1 ], -2347265);
	TextDrawSetOutline(g_MovieModeTD[ 1 ], 1);
	TextDrawSetProportional(g_MovieModeTD[ 1 ], 1);

	g_MovieModeTD[ 2 ] = TextDrawCreate(530.000000, 414.000000, "Cops and Robbers");
	TextDrawBackgroundColor(g_MovieModeTD[ 2 ], 255);
	TextDrawFont(g_MovieModeTD[ 2 ], 0);
	TextDrawLetterSize(g_MovieModeTD[ 2 ], 0.310000, 1.100000);
	TextDrawColor(g_MovieModeTD[ 2 ], -1);
	TextDrawSetOutline(g_MovieModeTD[ 2 ], 1);
	TextDrawSetProportional(g_MovieModeTD[ 2 ], 1);

	g_MovieModeTD[ 3 ] = TextDrawCreate(507.000000, 398.000000, "_");
	TextDrawBackgroundColor(g_MovieModeTD[ 3 ], 255);
	TextDrawFont(g_MovieModeTD[ 3 ], 1);
	TextDrawLetterSize(g_MovieModeTD[ 3 ], 0.500000, -0.400000);
	TextDrawColor(g_MovieModeTD[ 3 ], -1);
	TextDrawSetOutline(g_MovieModeTD[ 3 ], 0);
	TextDrawSetProportional(g_MovieModeTD[ 3 ], 1);
	TextDrawSetShadow(g_MovieModeTD[ 3 ], 1);
	TextDrawUseBox(g_MovieModeTD[ 3 ], 1);
	TextDrawBoxColor(g_MovieModeTD[ 3 ], 255);
	TextDrawTextSize(g_MovieModeTD[ 3 ], 620.000000, 0.000000);

	g_MovieModeTD[ 4 ] = TextDrawCreate(515.000000, 385.000000, "www.IrresistibleGaming.com");
	TextDrawBackgroundColor(g_MovieModeTD[ 4 ], 255);
	TextDrawFont(g_MovieModeTD[ 4 ], 1);
	TextDrawLetterSize(g_MovieModeTD[ 4 ], 0.200000, 1.000000);
	TextDrawColor(g_MovieModeTD[ 4 ], 13434879);
	TextDrawSetOutline(g_MovieModeTD[ 4 ], 1);
	TextDrawSetProportional(g_MovieModeTD[ 4 ], 1);

	g_MovieModeTD[ 5 ] = TextDrawCreate(507.000000, 386.000000, "_");
	TextDrawBackgroundColor(g_MovieModeTD[ 5 ], 255);
	TextDrawFont(g_MovieModeTD[ 5 ], 1);
	TextDrawLetterSize(g_MovieModeTD[ 5 ], 0.500000, 0.799999);
	TextDrawColor(g_MovieModeTD[ 5 ], -1);
	TextDrawSetOutline(g_MovieModeTD[ 5 ], 0);
	TextDrawSetProportional(g_MovieModeTD[ 5 ], 1);
	TextDrawSetShadow(g_MovieModeTD[ 5 ], 1);
	TextDrawUseBox(g_MovieModeTD[ 5 ], 1);
	TextDrawBoxColor(g_MovieModeTD[ 5 ], 128);
	TextDrawTextSize(g_MovieModeTD[ 5 ], 620.000000, 0.000000);

	/* ** Gangzone Allocation ** */
	for( new i; i < sizeof( g_gangzoneData ); i++ )
	{
	    g_gangzoneID[ i ] = GangZoneCreate( g_gangzoneData[ i ] [ E_MIN_X ], g_gangzoneData[ i ] [ E_MIN_Y ], g_gangzoneData[ i ] [ E_MAX_X ], g_gangzoneData[ i ] [ E_MAX_Y ] );

	  	g_ZoneOwnerTD[ i ] = TextDrawCreate( 86.000000, 296.000000, "Loading!" );
		TextDrawAlignment			( g_ZoneOwnerTD[ i ], 2 );
		TextDrawBackgroundColor		( g_ZoneOwnerTD[ i ], 255 );
		TextDrawFont				( g_ZoneOwnerTD[ i ], 1 );
		TextDrawLetterSize			( g_ZoneOwnerTD[ i ], 0.250000, 1.200000 );
		TextDrawColor				( g_ZoneOwnerTD[ i ], -1 );
		TextDrawSetOutline			( g_ZoneOwnerTD[ i ], 1 );
	}

	/* ** Player TextDraws ** */
	for(new playerid; playerid != MAX_PLAYERS; playerid ++)
	{
		if ( playerid < MAX_ROULETTE_TABLES ) {
			g_rouletteNumberBG[ playerid ] = TextDrawCreate(285.000000, 23.000000, "ld_roul:roulbla");
			TextDrawBackgroundColor(g_rouletteNumberBG[ playerid ], 255);
			TextDrawFont(g_rouletteNumberBG[ playerid ], 4);
			TextDrawLetterSize(g_rouletteNumberBG[ playerid ], 0.500000, 1.000000);
			TextDrawColor(g_rouletteNumberBG[ playerid ], -1);
			TextDrawSetOutline(g_rouletteNumberBG[ playerid ], 0);
			TextDrawSetProportional(g_rouletteNumberBG[ playerid ], 1);
			TextDrawSetShadow(g_rouletteNumberBG[ playerid ], 1);
			TextDrawUseBox(g_rouletteNumberBG[ playerid ], 1);
			TextDrawBoxColor(g_rouletteNumberBG[ playerid ], 255);
			TextDrawTextSize(g_rouletteNumberBG[ playerid ], 60.000000, 60.000000);

			g_rouletteNumberTD[ playerid ] = TextDrawCreate(314.000000, 25.000000, "35");
			TextDrawAlignment(g_rouletteNumberTD[ playerid ], 2);
			TextDrawBackgroundColor(g_rouletteNumberTD[ playerid ], 255);
			TextDrawFont(g_rouletteNumberTD[ playerid ], 1);
			TextDrawLetterSize(g_rouletteNumberTD[ playerid ], 0.800000, 4.000000);
			TextDrawColor(g_rouletteNumberTD[ playerid ], -1);
			TextDrawSetOutline(g_rouletteNumberTD[ playerid ], 0);
			TextDrawSetProportional(g_rouletteNumberTD[ playerid ], 1);
			TextDrawSetShadow(g_rouletteNumberTD[ playerid ], 1);
		}

		if ( playerid < MAX_MACHINES ) {
			p_SlotMachineFigureTD[ playerid ] = TextDrawCreate(324.000000, 307.000000, "$20,000");
			TextDrawAlignment(p_SlotMachineFigureTD[ playerid ], 2);
			TextDrawBackgroundColor(p_SlotMachineFigureTD[ playerid ], 255);
			TextDrawFont(p_SlotMachineFigureTD[ playerid ], 3);
			TextDrawLetterSize(p_SlotMachineFigureTD[ playerid ], 0.250000, 1.100000);
			TextDrawColor(p_SlotMachineFigureTD[ playerid ], -1);
			TextDrawSetOutline(p_SlotMachineFigureTD[ playerid ], 1);
			TextDrawSetProportional(p_SlotMachineFigureTD[ playerid ], 1);

			g_SlotMachineOneTD[ playerid ] = TextDrawCreate(222.000000, 324.000000, "ld_slot:bar1_o");
			TextDrawBackgroundColor(g_SlotMachineOneTD[ playerid ], 255);
			TextDrawFont(g_SlotMachineOneTD[ playerid ], 4);
			TextDrawLetterSize(g_SlotMachineOneTD[ playerid ], 0.500000, 0.399999);
			TextDrawColor(g_SlotMachineOneTD[ playerid ], -1);
			TextDrawSetOutline(g_SlotMachineOneTD[ playerid ], 0);
			TextDrawSetProportional(g_SlotMachineOneTD[ playerid ], 1);
			TextDrawSetShadow(g_SlotMachineOneTD[ playerid ], 1);
			TextDrawUseBox(g_SlotMachineOneTD[ playerid ], 1);
			TextDrawBoxColor(g_SlotMachineOneTD[ playerid ], 255);
			TextDrawTextSize(g_SlotMachineOneTD[ playerid ], 66.000000, 77.000000);

			g_SlotMachineTwoTD[ playerid ] = TextDrawCreate(292.000000, 324.000000, "ld_slot:bar1_o");
			TextDrawBackgroundColor(g_SlotMachineTwoTD[ playerid ], 255);
			TextDrawFont(g_SlotMachineTwoTD[ playerid ], 4);
			TextDrawLetterSize(g_SlotMachineTwoTD[ playerid ], 0.500000, 0.399999);
			TextDrawColor(g_SlotMachineTwoTD[ playerid ], -1);
			TextDrawSetOutline(g_SlotMachineTwoTD[ playerid ], 0);
			TextDrawSetProportional(g_SlotMachineTwoTD[ playerid ], 1);
			TextDrawSetShadow(g_SlotMachineTwoTD[ playerid ], 1);
			TextDrawUseBox(g_SlotMachineTwoTD[ playerid ], 1);
			TextDrawBoxColor(g_SlotMachineTwoTD[ playerid ], 255);
			TextDrawTextSize(g_SlotMachineTwoTD[ playerid ], 66.000000, 77.000000);

			g_SlotMachineThreeTD[ playerid ] = TextDrawCreate(362.000000, 324.000000, "ld_slot:bar1_o");
			TextDrawBackgroundColor(g_SlotMachineThreeTD[ playerid ], 255);
			TextDrawFont(g_SlotMachineThreeTD[ playerid ], 4);
			TextDrawLetterSize(g_SlotMachineThreeTD[ playerid ], 0.500000, 0.399999);
			TextDrawColor(g_SlotMachineThreeTD[ playerid ], -1);
			TextDrawSetOutline(g_SlotMachineThreeTD[ playerid ], 0);
			TextDrawSetProportional(g_SlotMachineThreeTD[ playerid ], 1);
			TextDrawSetShadow(g_SlotMachineThreeTD[ playerid ], 1);
			TextDrawUseBox(g_SlotMachineThreeTD[ playerid ], 1);
			TextDrawBoxColor(g_SlotMachineThreeTD[ playerid ], 255);
			TextDrawTextSize(g_SlotMachineThreeTD[ playerid ], 66.000000, 77.000000);
		}

		if ( playerid < MAX_BLACKJACK_TABLES ) {
			initializeBlackjackTextdraws( playerid );
		}

		p_ProgressBoxOutsideTD[ playerid ] = TextDrawCreate(252.000000, 222.000000, "_");
		TextDrawBackgroundColor(p_ProgressBoxOutsideTD[ playerid ], 255);
		TextDrawFont(p_ProgressBoxOutsideTD[ playerid ], 1);
		TextDrawLetterSize(p_ProgressBoxOutsideTD[ playerid ], 0.359999, 0.599999);
		TextDrawColor(p_ProgressBoxOutsideTD[ playerid ], -1);
		TextDrawSetOutline(p_ProgressBoxOutsideTD[ playerid ], 0);
		TextDrawSetProportional(p_ProgressBoxOutsideTD[ playerid ], 1);
		TextDrawSetShadow(p_ProgressBoxOutsideTD[ playerid ], 1);
		TextDrawUseBox(p_ProgressBoxOutsideTD[ playerid ], 1);
		TextDrawBoxColor(p_ProgressBoxOutsideTD[ playerid ], -154);
		TextDrawTextSize(p_ProgressBoxOutsideTD[ playerid ], 388.000000, 14.000000);

		p_ProgressBoxTD[ playerid ] = TextDrawCreate(252.000000, 222.000000, "_");
		TextDrawBackgroundColor(p_ProgressBoxTD[ playerid ], 255);
		TextDrawFont(p_ProgressBoxTD[ playerid ], 1);
		TextDrawLetterSize(p_ProgressBoxTD[ playerid ], 0.559999, 0.599999);
		TextDrawColor(p_ProgressBoxTD[ playerid ], -1);
		TextDrawSetOutline(p_ProgressBoxTD[ playerid ], 0);
		TextDrawSetProportional(p_ProgressBoxTD[ playerid ], 1);
		TextDrawSetShadow(p_ProgressBoxTD[ playerid ], 1);
		TextDrawUseBox(p_ProgressBoxTD[ playerid ], 1);
		TextDrawBoxColor(p_ProgressBoxTD[ playerid ], -1);
		TextDrawTextSize(p_ProgressBoxTD[ playerid ], 378.000000, 14.000000);

		p_ProgressTitleTD[ playerid ] = TextDrawCreate(320.000000, 205.000000, "____");
		TextDrawAlignment(p_ProgressTitleTD[ playerid ], 2);
		TextDrawBackgroundColor(p_ProgressTitleTD[ playerid ], 255);
		TextDrawFont(p_ProgressTitleTD[ playerid ], 0);
		TextDrawLetterSize(p_ProgressTitleTD[ playerid ], 0.559999, 1.700000);
		TextDrawColor(p_ProgressTitleTD[ playerid ], -1);
		TextDrawSetOutline(p_ProgressTitleTD[ playerid ], 1);
		TextDrawSetProportional(p_ProgressTitleTD[ playerid ], 1);

		p_AchievementTD[ playerid ] = TextDrawCreate(325.000000, 137.000000, "_");
		TextDrawAlignment(p_AchievementTD[ playerid ], 2);
		TextDrawBackgroundColor(p_AchievementTD[ playerid ], 80);
		TextDrawFont(p_AchievementTD[ playerid ], 1);
		TextDrawLetterSize(p_AchievementTD[ playerid ], 0.209999, 1.000000);
		TextDrawColor(p_AchievementTD[ playerid ], -1);
		TextDrawSetOutline(p_AchievementTD[ playerid ], 1);
		TextDrawSetProportional(p_AchievementTD[ playerid ], 1);

	    p_FireDistance1[ playerid ] = TextDrawCreate(26.000000, 182.000000, "_");
		TextDrawBackgroundColor(p_FireDistance1[ playerid ], 255);
		TextDrawFont(p_FireDistance1[ playerid ], 2);
		TextDrawLetterSize(p_FireDistance1[ playerid ], 0.210000, 1.200000);
		TextDrawColor(p_FireDistance1[ playerid ], -1);
		TextDrawSetOutline(p_FireDistance1[ playerid ], 1);
		TextDrawSetProportional(p_FireDistance1[ playerid ], 1);

		p_FireDistance2[ playerid ] = TextDrawCreate(26.000000, 236.000000, "_");
		TextDrawBackgroundColor(p_FireDistance2[ playerid ], 255);
		TextDrawFont(p_FireDistance2[ playerid ], 2);
		TextDrawLetterSize(p_FireDistance2[ playerid ], 0.209999, 1.200000);
		TextDrawColor(p_FireDistance2[ playerid ], -1);
		TextDrawSetOutline(p_FireDistance2[ playerid ], 1);
		TextDrawSetProportional(p_FireDistance2[ playerid ], 1);

		p_GPSInformation[ playerid ] = TextDrawCreate(26.000000, 200.000000, "~g~Location:~w~ No-where~n~~g~Distance:~w~ 0.0m");
		TextDrawBackgroundColor(p_GPSInformation[ playerid ], 255);
		TextDrawFont(p_GPSInformation[ playerid ], 2);
		TextDrawLetterSize(p_GPSInformation[ playerid ], 0.209999, 1.099999);
		TextDrawColor(p_GPSInformation[ playerid ], -1);
		TextDrawSetOutline(p_GPSInformation[ playerid ], 1);
		TextDrawSetProportional(p_GPSInformation[ playerid ], 1);
		TextDrawSetSelectable(p_GPSInformation[ playerid ], 0);

		p_TruckingTD[ playerid ] = TextDrawCreate(26.000000, 220.000000, "~b~Location:~w~ No-where~n~~b~Distance:~w~ 0.0m");
		TextDrawBackgroundColor(p_TruckingTD[ playerid ], 255);
		TextDrawFont(p_TruckingTD[ playerid ], 2);
		TextDrawLetterSize(p_TruckingTD[ playerid ], 0.210000, 1.100000);
		TextDrawColor(p_TruckingTD[ playerid ], -1);
		TextDrawSetOutline(p_TruckingTD[ playerid ], 1);
		TextDrawSetProportional(p_TruckingTD[ playerid ], 1);
		TextDrawSetSelectable(p_TruckingTD[ playerid ], 0);

		p_ClassInfoTD[ playerid ] = TextDrawCreate(33.000000, 184.000000, "~g~~h~CLASS INFORMATION:");
		TextDrawBackgroundColor(p_ClassInfoTD[ playerid ], 255);
		TextDrawFont(p_ClassInfoTD[ playerid ], 2);
		TextDrawLetterSize(p_ClassInfoTD[ playerid ], 0.200000, 1.100000);
		TextDrawColor(p_ClassInfoTD[ playerid ], -1);
		TextDrawSetOutline(p_ClassInfoTD[ playerid ], 0);
		TextDrawSetProportional(p_ClassInfoTD[ playerid ], 1);
		TextDrawSetShadow(p_ClassInfoTD[ playerid ], 1);

		p_ClassTitleTD[ playerid ] = TextDrawCreate(33.000000, 163.000000, "~g~~h~CLASS NAME:");
		TextDrawBackgroundColor(p_ClassTitleTD[ playerid ], 255);
		TextDrawFont(p_ClassTitleTD[ playerid ], 2);
		TextDrawLetterSize(p_ClassTitleTD[ playerid ], 0.200000, 1.100000);
		TextDrawColor(p_ClassTitleTD[ playerid ], -1);
		TextDrawSetOutline(p_ClassTitleTD[ playerid ], 0);
		TextDrawSetProportional(p_ClassTitleTD[ playerid ], 1);
		TextDrawSetShadow(p_ClassTitleTD[ playerid ], 1);

		p_JailTimeTD[ playerid ] = TextDrawCreate(328.000000, 24.000000, "Time Remaining:~n~250 seconds");
		TextDrawAlignment(p_JailTimeTD[ playerid ], 2);
		TextDrawBackgroundColor(p_JailTimeTD[ playerid ], 85);
		TextDrawFont(p_JailTimeTD[ playerid ], 1);
		TextDrawLetterSize(p_JailTimeTD[ playerid ], 0.329999, 1.500000);
		TextDrawColor(p_JailTimeTD[ playerid ], -1);
		TextDrawSetOutline(p_JailTimeTD[ playerid ], 1);
		TextDrawSetProportional(p_JailTimeTD[ playerid ], 1);

		p_TrackPlayerTD[ playerid ] = TextDrawCreate(571.000000, 258.000000, "Loading~n~~w~NaN.0m");
		TextDrawAlignment(p_TrackPlayerTD[ playerid ], 2);
		TextDrawBackgroundColor(p_TrackPlayerTD[ playerid ], 80);
		TextDrawFont(p_TrackPlayerTD[ playerid ], 1);
		TextDrawLetterSize(p_TrackPlayerTD[ playerid ], 0.260000, 1.100000);
		TextDrawColor(p_TrackPlayerTD[ playerid ], COLOR_RED);
		TextDrawSetOutline(p_TrackPlayerTD[ playerid ], 1);
		TextDrawSetProportional(p_TrackPlayerTD[ playerid ], 1);
		TextDrawSetSelectable(p_TrackPlayerTD[ playerid ], 0);

		p_HelpBoxTD[ playerid ] = TextDrawCreate(30.000000, 161.000000, "... Loading Help ...");
		TextDrawBackgroundColor(p_HelpBoxTD[ playerid ], 255);
		TextDrawFont(p_HelpBoxTD[ playerid ], 1);
		TextDrawLetterSize(p_HelpBoxTD[ playerid ], 0.219999, 1.200000);
		TextDrawColor(p_HelpBoxTD[ playerid ], -1);
		TextDrawSetOutline(p_HelpBoxTD[ playerid ], 0);
		TextDrawSetProportional(p_HelpBoxTD[ playerid ], 1);
		TextDrawSetShadow(p_HelpBoxTD[ playerid ], 1);
		TextDrawUseBox(p_HelpBoxTD[ playerid ], 1);
		TextDrawBoxColor(p_HelpBoxTD[ playerid ], 117);
		TextDrawTextSize(p_HelpBoxTD[ playerid ], 170.000000, 0.000000);
		TextDrawSetSelectable(p_HelpBoxTD[ playerid ], 0);
	}
}

stock initializePlayerTextDraws( playerid )
{
    p_DamageTD[ playerid ] = CreatePlayerTextDraw(playerid, 357.000000, 208.000000, "~r~~h~300.24 DAMAGE");
	PlayerTextDrawBackgroundColor(playerid, p_DamageTD[ playerid ], 255);
	PlayerTextDrawFont(playerid, p_DamageTD[ playerid ], 3);
	PlayerTextDrawLetterSize(playerid, p_DamageTD[ playerid ], 0.400000, 1.000000);
	PlayerTextDrawColor(playerid, p_DamageTD[ playerid ], -1);
	PlayerTextDrawSetOutline(playerid, p_DamageTD[ playerid ], 1);
	PlayerTextDrawSetProportional(playerid, p_DamageTD[ playerid ], 1);

	p_LocationTD[ playerid ] = CreatePlayerTextDraw( playerid, 86.000000, 322.000000, "Loading..." );
	PlayerTextDrawAlignment( playerid, p_LocationTD[ playerid ], 2 );
	PlayerTextDrawBackgroundColor( playerid, p_LocationTD[ playerid ], 255 );
	PlayerTextDrawFont( playerid, p_LocationTD[ playerid ], 1 );
	PlayerTextDrawLetterSize( playerid, p_LocationTD[ playerid ], 0.240000, 1.299999 );
	PlayerTextDrawSetOutline( playerid, p_LocationTD[ playerid ], 1 );
	PlayerTextDrawColor( playerid, p_LocationTD[ playerid ], -1 );
	PlayerTextDrawSetProportional( playerid, p_LocationTD[ playerid ], 1 );

	p_ExperienceTD[ playerid ] = CreatePlayerTextDraw( playerid, 529.000000, 414.000000, "00000000" );
	PlayerTextDrawBackgroundColor( playerid, p_ExperienceTD[ playerid ], 144 );
	PlayerTextDrawFont( playerid, p_ExperienceTD[ playerid ], 3 );
	PlayerTextDrawLetterSize( playerid, p_ExperienceTD[ playerid ], 0.569999, 2.199999 );
	PlayerTextDrawColor( playerid, p_ExperienceTD[ playerid ], COLOR_GOLD );
	PlayerTextDrawSetOutline( playerid, p_ExperienceTD[ playerid ], 1 );
	PlayerTextDrawSetProportional( playerid, p_ExperienceTD[ playerid ], 1 );

	p_ExperienceAwardTD[ playerid ] = CreatePlayerTextDraw( playerid, 338.000000, 149.000000, "+20 XP" );
	PlayerTextDrawAlignment( playerid, p_ExperienceAwardTD[ playerid ], 2 );
	PlayerTextDrawBackgroundColor( playerid, p_ExperienceAwardTD[ playerid ], 144 );
	PlayerTextDrawFont( playerid, p_ExperienceAwardTD[ playerid ], 3 );
	PlayerTextDrawLetterSize( playerid, p_ExperienceAwardTD[ playerid ], 0.409999, 1.600000 );
	PlayerTextDrawColor( playerid, p_ExperienceAwardTD[ playerid ], COLOR_GOLD );
	PlayerTextDrawSetOutline( playerid, p_ExperienceAwardTD[ playerid ], 1 );
	PlayerTextDrawSetProportional( playerid, p_ExperienceAwardTD[ playerid ], 1 );
	PlayerTextDrawSetSelectable( playerid, p_ExperienceAwardTD[ playerid ], 0 );

	p_WantedLevelTD[ playerid ] = CreatePlayerTextDraw( playerid, 555.000000, 124.000000, "_" );
	PlayerTextDrawAlignment( playerid, p_WantedLevelTD[ playerid ], 2 );
	PlayerTextDrawBackgroundColor( playerid, p_WantedLevelTD[ playerid ], 255 );
	PlayerTextDrawFont( playerid, p_WantedLevelTD[ playerid ], 2 );
	PlayerTextDrawLetterSize( playerid, p_WantedLevelTD[ playerid ], 0.280000, 1.299999 );
	PlayerTextDrawColor( playerid, p_WantedLevelTD[ playerid ], -1872621313 );
	PlayerTextDrawSetOutline( playerid, p_WantedLevelTD[ playerid ], 1 );
	PlayerTextDrawSetProportional( playerid, p_WantedLevelTD[ playerid ], 1 );
	PlayerTextDrawSetSelectable( playerid, p_WantedLevelTD[ playerid ], 0 );

	p_CoinsTD[ playerid ] = CreatePlayerTextDraw( playerid, 529.000000, 360.000000, "000000.0" );
	PlayerTextDrawBackgroundColor( playerid, p_CoinsTD[ playerid ], 255 );
	PlayerTextDrawFont( playerid, p_CoinsTD[ playerid ], 3 );
	PlayerTextDrawLetterSize( playerid, p_CoinsTD[ playerid ], 0.320000, 1.299998 );
	PlayerTextDrawColor( playerid, p_CoinsTD[ playerid ], COLOR_GOLD );
	PlayerTextDrawSetOutline( playerid, p_CoinsTD[ playerid ], 1 );
	PlayerTextDrawSetProportional( playerid, p_CoinsTD[ playerid ], 1 );

	p_PlayerRankTD[ playerid ] = CreatePlayerTextDraw( playerid, 603.000000, 386.000000, "RANK" );
	PlayerTextDrawBackgroundColor( playerid, p_PlayerRankTD[ playerid ], 0 );
	PlayerTextDrawFont( playerid, p_PlayerRankTD[ playerid ], 5 );
	PlayerTextDrawLetterSize( playerid, p_PlayerRankTD[ playerid ], 0.519999, 4.000000 );
	PlayerTextDrawColor( playerid, p_PlayerRankTD[ playerid ], -1027424001 );
	PlayerTextDrawSetOutline( playerid, p_PlayerRankTD[ playerid ], 0 );
	PlayerTextDrawSetProportional( playerid, p_PlayerRankTD[ playerid ], 1 );
	PlayerTextDrawSetShadow( playerid, p_PlayerRankTD[ playerid ], 1 );
	PlayerTextDrawUseBox( playerid, p_PlayerRankTD[ playerid ], 1 );
	PlayerTextDrawBoxColor( playerid, p_PlayerRankTD[ playerid ], 0 );
	PlayerTextDrawTextSize( playerid, p_PlayerRankTD[ playerid ], 19.000000, 19.000000 );
	PlayerTextDrawSetPreviewModel( playerid, p_PlayerRankTD[ playerid ], 19782 );
	PlayerTextDrawSetPreviewRot( playerid, p_PlayerRankTD[ playerid ], 90.000000, 0.000000, 90.000000, 0.600000 );

	p_PlayerRankTextTD[ playerid ] = CreatePlayerTextDraw( playerid, 529.000000, 386.000000, "Silver-1" );
	PlayerTextDrawBackgroundColor( playerid, p_PlayerRankTextTD[ playerid ], 255 );
	PlayerTextDrawFont( playerid, p_PlayerRankTextTD[ playerid ], 3 );
	PlayerTextDrawLetterSize( playerid, p_PlayerRankTextTD[ playerid ], 0.379999, 1.899999 );
	PlayerTextDrawColor( playerid, p_PlayerRankTextTD[ playerid ], -1027424001 );
	PlayerTextDrawSetOutline( playerid, p_PlayerRankTextTD[ playerid ], 1 );
	PlayerTextDrawSetProportional( playerid, p_PlayerRankTextTD[ playerid ], 1 );

	p_RobberyRiskTD[ playerid ] = CreatePlayerTextDraw(playerid, 320.000000, 294.000000, "clerk feels very threatened");
	PlayerTextDrawAlignment(playerid, p_RobberyRiskTD[ playerid ], 2);
	PlayerTextDrawBackgroundColor(playerid, p_RobberyRiskTD[ playerid ], 255);
	PlayerTextDrawFont(playerid, p_RobberyRiskTD[ playerid ], 3);
	PlayerTextDrawLetterSize(playerid, p_RobberyRiskTD[ playerid ], 0.200000, 0.900000);
	PlayerTextDrawColor(playerid, p_RobberyRiskTD[ playerid ], -1);
	PlayerTextDrawSetOutline(playerid, p_RobberyRiskTD[ playerid ], 1);
	PlayerTextDrawSetProportional(playerid, p_RobberyRiskTD[ playerid ], 1);
	PlayerTextDrawSetSelectable(playerid, p_RobberyRiskTD[ playerid ], 0);

	p_RobberyAmountTD[ playerid ] = CreatePlayerTextDraw(playerid, 320.000000, 280.000000, "Robbed ~g~~h~$1,800");
	PlayerTextDrawAlignment(playerid, p_RobberyAmountTD[ playerid ], 2);
	PlayerTextDrawBackgroundColor(playerid, p_RobberyAmountTD[ playerid ], 255);
	PlayerTextDrawFont(playerid, p_RobberyAmountTD[ playerid ], 3);
	PlayerTextDrawLetterSize(playerid, p_RobberyAmountTD[ playerid ], 0.340000, 1.300000);
	PlayerTextDrawColor(playerid, p_RobberyAmountTD[ playerid ], -1);
	PlayerTextDrawSetOutline(playerid, p_RobberyAmountTD[ playerid ], 1);
	PlayerTextDrawSetProportional(playerid, p_RobberyAmountTD[ playerid ], 1);
	PlayerTextDrawSetSelectable(playerid, p_RobberyAmountTD[ playerid ], 0);
}

stock SendClientMessageToGang( gangid, colour, format[ ], va_args<> ) // Conversion to foreach 14 stuffed the define, not sure how...
{
    static
		out[ 144 ];

    va_format( out, sizeof( out ), format, va_start<3> );

	foreach(new i : Player)
	{
	    if ( ( p_GangID[ i ] == gangid || p_ViewingGangTalk[ i ] == gangid ) && p_Class[ i ] == CLASS_CIVILIAN )
			SendClientMessage( i, colour, out );
	}
	return 1;
}

stock SendGlobalMessage( colour, format[ ], va_args<> )
{
    static
		out[ 144 ];

    va_format( out, sizeof( out ), format, va_start<2> );
	SendClientMessageToAll( colour, out );

	strreplace( out, #COL_LRED, 	"**" );
	strreplace( out, #COL_ORANGE,	"**" );
	strreplace( out, #COL_GOLD, 	"**" );
	strreplace( out, #COL_GREEN, 	"" );
	strreplace( out, #COL_BLUE, 	"**" );
	strreplace( out, #COL_PINK, 	"**" );
	strreplace( out, #COL_GREY,		"**" );
	strreplace( out, #COL_WHITE, 	"**" );
	DCC_SendChannelMessage( discordGeneralChan, out );
	return 1;
}

stock SetPlayerRandomSpawn( playerid )
{
	if ( p_LeftPaintball{ playerid } == true )
	{
		SetPlayerArmour( playerid, 0.0 );
	    SetPlayerPos( playerid, -2172.2017, 252.1113, 35.3388 );
	    p_LeftPaintball{ playerid } = false;
	    return 1;
	}

	if ( p_ApartmentSpawnLocation[ playerid ] != -1 )
	{
	    new Float: Z = 17.03 + ( p_ApartmentSpawnLocation[ playerid ] * 5.447 );
		pauseToLoad( playerid );
	    SetPlayerPos( playerid, -1955.0114, 1360.8344, Z );
	    SetPlayerInterior( playerid, 0 );
	    SetPlayerFacingAngle( playerid, 180.0 );
		return 1;
	}

	if ( p_BusinessSpawnLocation[ playerid ] != -1 )
	{
		new
			businessid = p_BusinessSpawnLocation[ playerid ], type = g_businessData[ businessid ] [ E_INTERIOR_TYPE ];

		p_InHouse[ playerid ] = -1;
		p_InBusiness[ playerid ] = businessid;
		p_ApartmentEditing{ playerid } = -1;

		pauseToLoad( playerid );
		SetPlayerPos( playerid, g_businessInteriorData[ type ] [ E_X ], g_businessInteriorData[ type ] [ E_Y ], g_businessInteriorData[ type ] [ E_Z ] );
		SetPlayerInterior( playerid, g_businessData[ businessid ] [ E_INTERIOR_TYPE ] + 20 );
	  	SetPlayerVirtualWorld( playerid, g_businessData[ businessid ] [ E_WORLD ] );
		return 1;
	}

 	if ( p_HouseSpawnLocation[ playerid ] != -1 )
	{
	    new
	    	ID = p_HouseSpawnLocation[ playerid ];

	    if ( IsHouseOnFire( ID ) ) SendServerMessage( playerid, "The house you were to be spawned at is on fire therefore normal spawning has been applied." );
	    else
	    {
			p_InHouse[ playerid ] = ID;
			p_InBusiness[ playerid ] = -1;
			p_ApartmentEditing{ playerid } = -1;
			//pauseToLoad( playerid );
		    SetPlayerPos( playerid, g_houseData[ ID ] [ E_TX ], g_houseData[ ID ] [ E_TY ], g_houseData[ ID ] [ E_TZ ] + 1 );
			SetPlayerVirtualWorld( playerid, g_houseData[ ID ] [ E_WORLD ] );
			SetPlayerInterior( playerid, g_houseData[ ID ] [ E_INTERIOR_ID ] );
			return 1;
		}
	}

	new
		city = p_SpawningCity{ playerid };

	if ( p_Class[ playerid ] == CLASS_FIREMAN )
		return SetPlayerPos( playerid, g_FiremanSpawns[ city ] [ RANDOM_SPAWN_X ], g_FiremanSpawns[ city ] [ RANDOM_SPAWN_Y ], g_FiremanSpawns[ city ] [ RANDOM_SPAWN_Z ] ), 	SetPlayerInterior( playerid, g_FiremanSpawns[ city ] [ RANDOM_SPAWN_INTERIOR ] ),	SetPlayerVirtualWorld( playerid, g_FiremanSpawns[ city ] [ RANDOM_SPAWN_WORLD ] ), SetPlayerFacingAngle( playerid, g_FiremanSpawns[ city ] [ RANDOM_SPAWN_A ] ), 1;

	if ( p_Class[ playerid ] == CLASS_MEDIC )
		return SetPlayerPos( playerid, g_MedicSpawns[ city ] [ RANDOM_SPAWN_X ], g_MedicSpawns[ city ] [ RANDOM_SPAWN_Y ], g_MedicSpawns[ city ] [ RANDOM_SPAWN_Z ] ), 			SetPlayerInterior( playerid, g_MedicSpawns[ city ] [ RANDOM_SPAWN_INTERIOR ] ),		SetPlayerVirtualWorld( playerid, g_MedicSpawns[ city ] [ RANDOM_SPAWN_WORLD ] ), SetPlayerFacingAngle( playerid, g_MedicSpawns[ city ] [ RANDOM_SPAWN_A ] ), 1;

	// if ( p_inMayor{ playerid } == true )
	//	return SetPlayerPos( playerid, g_MayorSpawns[ city ] [ RANDOM_SPAWN_X ], g_MayorSpawns[ city ] [ RANDOM_SPAWN_Y ], g_MayorSpawns[ city ] [ RANDOM_SPAWN_Z ] ), 			SetPlayerInterior( playerid, g_MayorSpawns[ city ] [ RANDOM_SPAWN_INTERIOR ] ),		SetPlayerVirtualWorld( playerid, g_MayorSpawns[ city ] [ RANDOM_SPAWN_WORLD ] ), SetPlayerFacingAngle( playerid, g_MayorSpawns[ city ] [ RANDOM_SPAWN_A ] ), 1;

	if ( p_inArmy{ playerid } == true )
		return SetPlayerPos( playerid, g_ArmySpawns[ city ] [ RANDOM_SPAWN_X ], g_ArmySpawns[ city ] [ RANDOM_SPAWN_Y ], g_ArmySpawns[ city ] [ RANDOM_SPAWN_Z ] ), 			SetPlayerInterior( playerid, g_ArmySpawns[ city ] [ RANDOM_SPAWN_INTERIOR ] ),		SetPlayerVirtualWorld( playerid, g_ArmySpawns[ city ] [ RANDOM_SPAWN_WORLD ] ), SetPlayerFacingAngle( playerid, g_ArmySpawns[ city ] [ RANDOM_SPAWN_A ] ), 1;

	if ( p_inCIA{ playerid } == true || p_inFBI{ playerid } == true )
		return SetPlayerPos( playerid, g_CIASpawns[ city ] [ RANDOM_SPAWN_X ], g_CIASpawns[ city ] [ RANDOM_SPAWN_Y ], g_CIASpawns[ city ] [ RANDOM_SPAWN_Z ] ), 				SetPlayerInterior( playerid, g_CIASpawns[ city ] [ RANDOM_SPAWN_INTERIOR ] ),		SetPlayerVirtualWorld( playerid, g_CIASpawns[ city ] [ RANDOM_SPAWN_WORLD ] ), SetPlayerFacingAngle( playerid, g_CIASpawns[ city ] [ RANDOM_SPAWN_A ] ), 1;

	if ( p_Class[ playerid ] == CLASS_POLICE )
		return SetPlayerPos( playerid, g_PoliceSpawns[ city ] [ RANDOM_SPAWN_X ], g_PoliceSpawns[ city ] [ RANDOM_SPAWN_Y ], g_PoliceSpawns[ city ] [ RANDOM_SPAWN_Z ] ), 		SetPlayerInterior( playerid, g_PoliceSpawns[ city ] [ RANDOM_SPAWN_INTERIOR ] ),	SetPlayerVirtualWorld( playerid, g_PoliceSpawns[ city ] [ RANDOM_SPAWN_WORLD ] ), SetPlayerFacingAngle( playerid, g_PoliceSpawns[ city ] [ RANDOM_SPAWN_A ] ), 1;

	if ( p_Class[ playerid ] == CLASS_CIVILIAN )
	{
		new
			r;

		switch( city )
		{
			case CITY_SF:
			{
				r = random( sizeof( g_SanFierroSpawns ) );
				SetPlayerFacingAngle( playerid, g_SanFierroSpawns[ r ] [ RANDOM_SPAWN_A ] );
				SetPlayerInterior	( playerid, g_SanFierroSpawns[ r ] [ RANDOM_SPAWN_INTERIOR ] );
				SetPlayerPos		( playerid, g_SanFierroSpawns[ r ] [ RANDOM_SPAWN_X ], g_SanFierroSpawns[ r ] [ RANDOM_SPAWN_Y ], g_SanFierroSpawns[ r ] [ RANDOM_SPAWN_Z ] );
			}
			case CITY_LV:
			{
				r = random( sizeof( g_LasVenturasSpawns ) );
				SetPlayerFacingAngle( playerid, g_LasVenturasSpawns[ r ] [ RANDOM_SPAWN_A ] );
				SetPlayerInterior	( playerid, g_LasVenturasSpawns[ r ] [ RANDOM_SPAWN_INTERIOR ] );
				SetPlayerPos		( playerid, g_LasVenturasSpawns[ r ] [ RANDOM_SPAWN_X ], g_LasVenturasSpawns[ r ] [ RANDOM_SPAWN_Y ], g_LasVenturasSpawns[ r ] [ RANDOM_SPAWN_Z ] );
			}
			case CITY_LS:
			{
				r = random( sizeof( g_LosSantosSpawns ) );
				SetPlayerFacingAngle( playerid, g_LosSantosSpawns[ r ] [ RANDOM_SPAWN_A ] );
				SetPlayerInterior	( playerid, g_LosSantosSpawns[ r ] [ RANDOM_SPAWN_INTERIOR ] );
				SetPlayerPos		( playerid, g_LosSantosSpawns[ r ] [ RANDOM_SPAWN_X ], g_LosSantosSpawns[ r ] [ RANDOM_SPAWN_Y ], g_LosSantosSpawns[ r ] [ RANDOM_SPAWN_Z ] );
			}
		}
	}
	return 1;
}

stock initializeCheckpoints( )
{
	g_Checkpoints[ CP_BOMB_SHOP ] = CreateDynamicCP( -1923.7546, 303.3475, 41.0469, 2.0, 0, -1, -1, 100.0 );
	g_Checkpoints[ CP_DROP_OFF_COP ] = CreateDynamicCP( -1577.0952, 683.9492, 7.2440, 3.0, 0, -1, -1, 100.0 );
	g_Checkpoints[ CP_BANK_MENU ] = CreateDynamicCP( -1405.0657, 831.0966, 984.7126, 1.0, -1, -1, -1, 100.0 );
	g_Checkpoints[ CP_COUNTRY_BANK_MENU ] = CreateDynamicCP( 2156.1299, 1640.2460, 1041.6124, 1.0, -1, -1, -1, 100.0 );
	g_Checkpoints[ CP_CHANGE_JOB ] = CreateDynamicCP( 361.8525, 173.6031, 1008.3828, 1.0, -1, -1, -1, 50.0 );
	g_Checkpoints[ CP_HOSPITAL ] = CreateDynamicCP( -2647.5007, 659.0084, 970.4332, 2.0, -1, -1, -1, 100.0 );
    g_Checkpoints[ CP_PAINTBALL ] = CreateDynamicCP( -2172.2017, 252.1113, 35.3388, 1.0, -1, -1, -1, 100.0 );
	g_Checkpoints[ CP_DROP_OFF_FBI ] = CreateDynamicCP( -2446.6785, 522.9684, 30.2548, 3.0, -1, -1, -1, 100.0 );
	g_Checkpoints[ CP_LUMBERJACK ] = CreateDynamicCP( -2323.5676, -97.2582, 35.3078, 1.0, -1, -1, -1, 100.0 );
	g_Checkpoints[ CP_FIGHTSTYLE ] = CreateDynamicCP( 768.2576, -22.8351, 1000.5859, 2.0, -1, -1, -1, 25.0 );
	g_Checkpoints[ CP_VEHDEALER ] = CreateDynamicCP( -1867.9092, -646.3469, 1002.1284, 1.0, -1, -1, -1, 25.0 );
	g_Checkpoints[ CP_247_MENU ] = CreateDynamicCP( -29.0409, -184.7446, 1003.5469, 1.0, -1, -1, -1, 25.0 );
	g_Checkpoints[ CP_AMMUNATION_0 ] = CreateDynamicCP( 296.3782, -38.4512, 1001.5156, 1.0, -1, -1, -1, 20.0 );
	g_Checkpoints[ CP_AMMUNATION_1 ] = CreateDynamicCP( 295.4524, -80.7487, 1001.5156, 1.0, -1, -1, -1, 20.0 );
	g_Checkpoints[ CP_AMMUNATION_2 ] = CreateDynamicCP( 312.8432, -166.1419, 999.6010, 1.0, -1, -1, -1, 20.0 );
	g_Checkpoints[ CP_DROP_OFF_HELI ] = CreateDynamicCP( -1651.6956, 700.8394, 38.2422, 5.0, -1, -1, -1, 50.0 );
	g_Checkpoints[ CP_PAWNSHOP ] = CreateDynamicCP( 1333.0847, -1080.0726, 968.0430, 1.0, -1, -1, -1, 20.0 );
	g_Checkpoints[ CP_REFILL_AMMO ] = CreateDynamicCP( -1615.2600, 685.5120, 7.1875, 1.0, -1, -1, -1, 20.0 );
	g_Checkpoints[ CP_REFILL_AMMO_LS ] = CreateDynamicCP( -1615.2600, 685.5120, 7.1875, 1.0, -1, -1, -1, 20.0 );
	g_Checkpoints[ CP_DROP_OFF_FC ] = CreateDynamicCP( -211.6869, 979.3518, 19.3237, 3.0, -1, -1, -1, 100.0 );
	g_Checkpoints[ CP_DROP_OFF_DILLIMORE ] = CreateDynamicCP( 614.2876, -588.6716, 17.2330, 3.0, -1, -1, -1, 100.0 );
	g_Checkpoints[ CP_DROP_OFF_DIABLO ] = CreateDynamicCP( -433.3666, 2255.6064, 42.4297, 3.0, -1, -1, -1, 100.0 );
	g_Checkpoints[ CP_DROP_OFF_QUBRADOS ] = CreateDynamicCP( -1400.0497, 2647.2358, 55.6875, 3.0, -1, -1, -1, 100.0 );
	g_Checkpoints[ CP_BIZ_TERMINAL_COKE ] = CreateDynamicCP( 2563.5728, -1310.5925, 1143.7242, 1.0, -1, -1, -1, 30.0 );
	g_Checkpoints[ CP_BIZ_TERMINAL_METH ] = CreateDynamicCP( 2034.0669, 1001.6073, 1510.2416, 1.0, -1, -1, -1, 30.0 );
	g_Checkpoints[ CP_BIZ_TERMINAL_WEED ] = CreateDynamicCP( -1742.9982, -1377.3049, 5874.1333, 1.0, -1, -1, -1, 30.0 );
	g_Checkpoints[ CP_BIZ_TERMINAL_WEAP ] = CreateDynamicCP( -4236.8457, 211.4772, 1304.2739, 1.0, -1, -1, -1, 30.0 );

	// Out of SF
	CreateDynamic3DTextLabel("[DROP OFF]", COLOR_GOLD,  -211.6869, 979.3518, 19.3237, 50.0);
	CreateDynamic3DTextLabel("[DROP OFF]", COLOR_GOLD,  614.2876, -588.6716, 17.2330, 50.0);
	CreateDynamic3DTextLabel("[DROP OFF]", COLOR_GOLD,  -433.3666, 2255.6064, 42.4297, 50.0);
	CreateDynamic3DTextLabel("[DROP OFF]", COLOR_GOLD,  -1400.0497, 2647.2358, 55.6875, 50.0);

	#if ENABLE_CITY_LV == true
	g_Checkpoints[ CP_BOMB_SHOP_LV ] = CreateDynamicCP( 1998.7263, 2298.5562, 10.8203, 2.0, 0, -1, -1, 100.0 );
	g_Checkpoints[ CP_DROP_OFF_COP_LV ] = CreateDynamicCP( 2225.6753, 2457.2388, -7.4531, 3.0, 0, -1, -1, 100.0 );
	g_Checkpoints[ CP_HOSPITAL_LV ] = CreateDynamicCP( 1607.2659, 1815.2485, 10.8203, 2.0, -1, -1, -1, 100.0 );
	g_Checkpoints[ CP_DROP_OFF_FBI_LV ] = CreateDynamicCP( 948.6036, 1811.2720, 8.6484, 3.0, -1, -1, -1, 100.0 );
	g_Checkpoints[ CP_FIGHTSTYLE_LV ] = CreateDynamicCP( 766.8416, -62.1872, 1000.6563, 2.0, -1, -1, -1, 25.0 );
	g_Checkpoints[ CP_VEHDEALER_2 ] = CreateDynamicCP( -126.2794, 117.3427, 1004.7233, 1.0, -1, -1, -1, 25.0 );
	g_Checkpoints[ CP_REFILL_AMMO_LV ] = CreateDynamicCP( 2251.9438, 2488.7981, 10.9908, 1.0, -1, -1, -1, 20.0 );
	CreateDynamic3DTextLabel("[PURCHASE VEHICLE]", COLOR_GOLD, -126.2794, 117.3427, 1004.7233, 20.0);
	CreateDynamic3DTextLabel("[DROP OFF]", COLOR_GOLD, 2225.6753, 2457.2388, -7.4531, 20.0);
	CreateDynamic3DTextLabel("[DROP OFF]", COLOR_GOLD, 948.6036, 1811.2720, 8.6484, 20.0);
	CreateDynamic3DTextLabel("[LEARN FIGHT STYLES]", COLOR_GOLD, 766.8416, -62.1872, 1000.6563, 15.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, 9);
	CreateDynamic3DTextLabel("[BOMB SHOP]", COLOR_GOLD, 1998.7263, 2298.5562, 10.8203, 20.0);
	CreateDynamic3DTextLabel("[HOSPITAL]", COLOR_GOLD, 1607.2659, 1815.2485, 10.8203, 20.0);
	CreateDynamic3DTextLabel("[REFILL AMMO]", COLOR_GOLD, 2251.9438, 2488.7981, 10.9908, 20.0);
	#endif

	#if ENABLE_CITY_LS
	g_Checkpoints[ CP_BOMB_SHOP_LS ] = CreateDynamicCP( 1911.2462, -1775.8755, 13.3828, 2.0, 0, -1, -1, 100.0 );
	g_Checkpoints[ CP_HOSPITAL1_LS ] = CreateDynamicCP( 1172.0767, -1323.3257, 15.4029, 1.0, -1, -1, -1, 100.0 );
	g_Checkpoints[ CP_HOSPITAL2_LS ] = CreateDynamicCP( 2034.0677, -1401.6699, 17.2938, 1.0, -1, -1, -1, 100.0 );
	g_Checkpoints[ CP_HOSPITAL_FC ] = CreateDynamicCP( -320.2127, 1048.2339, 20.3403, 1.0, -1, -1, -1, 100.0 );
	g_Checkpoints[ CP_DROP_OFF_COP_LS ] = CreateDynamicCP( 1569.0277, -1694.1566, 5.8906, 3.0, 0, -1, -1, 100.0 );
	g_Checkpoints[ CP_DROP_OFF_FBI_LS ] = CreateDynamicCP( 1516.6716, -1458.9398, 9.5000, 3.0, -1, -1, -1, 100.0 );
	g_Checkpoints[ CP_FIGHTSTYLE_LS ] = CreateDynamicCP( 772.0868, 12.6397, 1000.6996, 1.0, -1, -1, -1, 25.0 );
	g_Checkpoints[ CP_BANK_MENU_LS ] = CreateDynamicCP( 2136.4946, 1226.1787, 1017.1369, 1.0, -1, -1, -1, 25.0 );
	g_Checkpoints[ CP_VEHDEALER_3 ] = CreateDynamicCP( 540.7507, -1299.1378, 17.2859, 1.0, -1, -1, -1, 25.0 );
	g_Checkpoints[ CP_REFILL_AMMO_LS ] = CreateDynamicCP( 1579.5439, -1635.5166, 13.5609, 1.0, -1, -1, -1, 20.0 );
	CreateDynamic3DTextLabel("[PURCHASE VEHICLE]", COLOR_GOLD, 540.7507, -1299.1378, 17.2859, 20.0);
	CreateDynamic3DTextLabel("[BANK MENU]", COLOR_GOLD, 2136.4946, 1226.1787, 1017.1369, 20.0);
	CreateDynamic3DTextLabel("[DROP OFF]", COLOR_GOLD, 1569.0277, -1694.1566, 5.8906, 20.0);
	CreateDynamic3DTextLabel("[DROP OFF]", COLOR_GOLD, 1516.6716, -1458.9398, 9.5000, 20.0);
	CreateDynamic3DTextLabel("[LEARN FIGHT STYLES]", COLOR_GOLD, 772.0868, 12.6397, 1000.6996, 15.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, 10);
	CreateDynamic3DTextLabel("[BOMB SHOP]", COLOR_GOLD, 1911.2462, -1775.8755, 13.3828, 20.0);
	CreateDynamic3DTextLabel("[HOSPITAL]", COLOR_GOLD, 1172.0767, -1323.3257, 15.4029, 20.0);
	CreateDynamic3DTextLabel("[HOSPITAL]", COLOR_GOLD, 2034.0677, -1401.6699, 17.2938, 20.0);
	CreateDynamic3DTextLabel("[HOSPITAL]", COLOR_GOLD,  -320.2127, 1048.2339, 20.3403, 20.0);
	CreateDynamic3DTextLabel("[REFILL AMMO]", COLOR_GOLD, 1579.5439, -1635.5166, 13.5609, 20.0);
	#endif

	CreateDynamic3DTextLabel("[REFILL AMMO]", COLOR_GOLD, -1615.2600, 685.5120, 7.1875, 20.0);
	CreateDynamic3DTextLabel("[PAWNSHOP]", COLOR_GOLD, 1333.0847, -1080.0726, 968.0430, 20.0);
	CreateDynamic3DTextLabel("[SHOP]", COLOR_GOLD, -29.0409,-184.7446,1003.5469, 20.0);
	CreateDynamic3DTextLabel("[BANK MENU]", COLOR_GOLD, -1405.0657, 831.0966, 984.7126, 20.0);
	CreateDynamic3DTextLabel("[BANK MENU]", COLOR_GOLD, 2156.1299, 1640.2460, 1041.6124, 20.0);
	CreateDynamic3DTextLabel("[DROP OFF]", COLOR_GOLD, -1577.0952, 683.9492, 7.2440, 20.0);
	CreateDynamic3DTextLabel("[DROP OFF]", COLOR_GOLD, -2446.6785, 522.9684, 30.2548, 20.0);
	CreateDynamic3DTextLabel("[DROP OFF]", COLOR_GOLD,  -1651.6956, 700.8394, 38.2422, 50.0);
	CreateDynamic3DTextLabel("[BOMB SHOP]", COLOR_GOLD, -1923.7546, 303.3475, 41.0469, 20.0);
	CreateDynamic3DTextLabel("[GUN STORE]", COLOR_GOLD, 296.3782, -38.4512, 1001.5156, 20.0);
	CreateDynamic3DTextLabel("[GUN STORE]", COLOR_GOLD, 295.4524, -80.7487, 1001.5156, 20.0);
	CreateDynamic3DTextLabel("[GUN STORE]", COLOR_GOLD, 312.8432, -166.1419, 999.6010, 20.0);
	CreateDynamic3DTextLabel("[MAIN DESK]", COLOR_GOLD, 361.8525, 173.6031, 1008.3828, 20.0);
	CreateDynamic3DTextLabel("[HOSPITAL]", COLOR_GOLD, -2647.5007, 659.0084, 970.4332, 20.0);
	CreateDynamic3DTextLabel("[PAINTBALL]", COLOR_GOLD, -2172.2017, 252.1113, 35.3388, 20.0);
	CreateDynamic3DTextLabel("[GUN REDEEM]\n"COL_WHITE"/vipgun", COLOR_GOLD, -1945.9280, 830.0893, 1214.2678, 20.0);
	CreateDynamic3DTextLabel("[GUN REDEEM]\n"COL_WHITE"/vipgun", COLOR_GOLD, -1966.1765, 851.0482, 1214.2678, 20.0);
	CreateDynamic3DTextLabel("[LUMBERJACK JOB]", COLOR_GOLD, -2323.5676, -97.2582, 35.3078, 20.0);
	CreateDynamic3DTextLabel("[LEARN FIGHT STYLES]", COLOR_GOLD, 768.2576, -22.8351, 1000.5859, 15.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, 8 );
	CreateDynamic3DTextLabel("[PURCHASE VEHICLE]", COLOR_GOLD, -1867.9092, -646.3469, 1002.1284, 20.0);
	CreateDynamic3DTextLabel("[BUSINESS TERMINAL]", COLOR_GOLD, 2563.5728, -1310.5925, 1143.7242, 20.0);
	CreateDynamic3DTextLabel("[BUSINESS TERMINAL]", COLOR_GOLD, 2034.0669, 1001.6073, 1510.2416, 20.0);
	CreateDynamic3DTextLabel("[BUSINESS TERMINAL]", COLOR_GOLD, -1742.9982, -1377.3049, 5874.1333, 20.0);
	CreateDynamic3DTextLabel("[BUSINESS TERMINAL]", COLOR_GOLD, -4236.8457, 211.4772, 1304.2739, 20.0);
}

stock DestroyAllPlayerC4s( playerid, bool: resetc4 = false )
{
	for( new i; i < MAX_C4; i++ )
	{
	    if ( g_C4Data[ playerid ] [ i ] [ E_SET ] == true )
	    {
	    	Delete3DTextLabel( g_C4Data[ playerid ] [ i ] [ E_LABEL ] );
	        DestroyDynamicObject( g_C4Data[ playerid ] [ i ] [ E_OBJECT ] );
	        g_C4Data[ playerid ] [ i ] [ E_VEHICLE ] = -100;
	  		g_C4Data[ playerid ] [ i ] [ E_WORLD ] = 0;
			g_C4Data[ playerid ] [ i ] [ E_INTERIOR ] = 0;
			g_C4Data[ playerid ] [ i ] [ E_SET ] = false;
	    }
	}
	if ( resetc4 ) p_C4Amount[ playerid ] = 0;
}

stock ExplodePlayerC4s( playerid, start=0, end=MAX_C4 )
{
	if ( IsPlayerInEvent( playerid ) || IsPlayerInPaintBall( playerid ) || p_Class[ playerid ] == CLASS_POLICE )
		return 0;

	new
		Float: X, Float: Y, Float: Z, Float: Angle;

	for( new i = start; i < end; i++ )
	{
	    if ( g_C4Data[ playerid ] [ i ] [ E_SET ] == false ) continue;
		g_C4Data[ playerid ] [ i ] [ E_SET ] = false;

		new
			vehicleid = g_C4Data[ playerid ] [ i ] [ E_VEHICLE ] - 100;

		if ( IsValidVehicle( vehicleid ) )
		{
			// Physics
            SetVehicleAngularVelocity( vehicleid, ( random( 20 ) - 10 ) * 0.05, ( random( 20 ) - 10 ) * 0.05, ( random( 20 ) - 10 ) * 0.008 );
            GetVehicleVelocity( vehicleid, X, Y, Z );
            SetVehicleVelocity( vehicleid, X, Y, Z + ( random( 15 ) * 0.0008 ) );
        	SetVehicleHealth( vehicleid, 0.0 );
        	GetVehiclePos( vehicleid, X, Y, Z );
        	GetVehicleZAngle( vehicleid, Angle );
		    X += ( 2.0 * floatsin( -Angle, degrees ) );
		    Y += ( 2.0 * floatcos( -Angle, degrees ) );
		}
		else GetDynamicObjectPos( g_C4Data[ playerid ] [ i ] [ E_OBJECT ], X, Y, Z );

		if ( IsPointToPoint( 10.0, X, Y, Z, -2038.6539, 1840.0137, 21.7857 ) )
		{
			if ( g_iTime > g_alcatrazTimestamp )
			{
				g_alcatrazTimestamp = g_iTime + 300;

				GivePlayerScore( playerid, 3 );
				GivePlayerWantedLevel( playerid, 24 );
				Achievement::HandleJailBlown( playerid );

				SendGlobalMessage( -1, ""COL_GREY"[SERVER]"COL_WHITE" %s(%d) has destroyed the "COL_GREY"Alcatraz gate{FFFFFF}!", ReturnPlayerName( playerid ), playerid );
				massUnjailPlayers( CITY_SF, .alcatraz = true );
			}
		}

		for( new j = 0; j < MAX_CITIES; j++ )
		{
			// Blow Bank Vault
			if ( IsPointToPoint( 5.0, X, Y, Z, g_bankvaultData[ j ] [ E_EXPLODE_POS ] [ 0 ], g_bankvaultData[ j ] [ E_EXPLODE_POS ] [ 1 ], g_bankvaultData[ j ] [ E_EXPLODE_POS ] [ 2 ] ) && !g_bankvaultData[ j ] [ E_DISABLED ] && g_C4Data[ playerid ] [ i ] [ E_WORLD ] == g_bankvaultData[ j ] [ E_WORLD ] )
			{
				if ( g_iTime > g_bankvaultData[ j ] [ E_TIMESTAMP ] )
				{
					g_bankvaultData[ j ] [ E_TIMESTAMP_CLOSE ]	= g_iTime + 120;
			    	g_bankvaultData[ j ] [ E_TIMESTAMP ] 		= g_iTime + 300;
			    	g_bankvaultData[ j ] [ E_DISABLED ] 		= true;

					MoveDynamicObject( g_bankvaultData[ j ] [ E_OBJECT ], g_bankvaultData[ j ] [ E_OPEN_POS ] [ 0 ], g_bankvaultData[ j ] [ E_OPEN_POS ] [ 1 ], g_bankvaultData[ j ] [ E_OPEN_POS ] [ 2 ], 2.0, g_bankvaultData[ j ] [ E_OPEN_ROT ] [ 0 ], g_bankvaultData[ j ] [ E_OPEN_ROT ] [ 1 ], g_bankvaultData[ j ] [ E_OPEN_ROT ] [ 2 ] );

					GivePlayerScore( playerid, 3 );
					GivePlayerWantedLevel( playerid, 24 );
					Achievement::HandleBankBlown( playerid );

					SendGlobalMessage( -1, ""COL_GREY"[SERVER]"COL_WHITE" %s(%d) has destroyed the "COL_GREY"%s Bank Vault{FFFFFF}!", ReturnPlayerName( playerid ), playerid, returnCityName( g_bankvaultData[ j ] [ E_CITY ] ) );
					break;
				}
			}

			// Blow Jails
			if ( IsPointToPoint( g_jailData[ j ] [ E_RADIUS ], X, Y, Z, g_jailData[ j ] [ E_EXPLODE1_POS ] [ 0 ], g_jailData[ j ] [ E_EXPLODE1_POS ] [ 1 ], g_jailData[ j ] [ E_EXPLODE1_POS ] [ 2 ] ) || IsPointToPoint( g_jailData[ j ] [ E_RADIUS ], X, Y, Z, g_jailData[ j ] [ E_EXPLODE2_POS ] [ 0 ], g_jailData[ j ] [ E_EXPLODE2_POS ] [ 1 ], g_jailData[ j ] [ E_EXPLODE2_POS ] [ 2 ] ) && !g_jailData[ j ] [ E_BOMBED ] )
			{
				if ( g_iTime > g_jailData[ j ] [ E_TIMESTAMP ] )
				{
			    	g_jailData[ j ] [ E_BOMBED ] = true;
			    	g_jailData[ j ] [ E_TIMESTAMP ] = g_iTime + 300;

					GivePlayerScore( playerid, 3 );
				    GivePlayerWantedLevel( playerid, 24 );
				    Achievement::HandleJailBlown( playerid );

					SendGlobalMessage( -1, ""COL_GREY"[SERVER]"COL_WHITE" %s(%d) has exploded the "COL_GREY"%s Jail{FFFFFF} and has freed its prisoners.", ReturnPlayerName( playerid ), playerid, returnCityName( g_jailData[ j ] [ E_CITY ] ) );
				    massUnjailPlayers( g_jailData[ j ] [ E_CITY ] );
				    break;
				}
			}
		}

		if ( GetPVarInt( playerid, "C4WantedCD" ) < g_iTime && p_Class[ playerid ] != CLASS_POLICE ) {
			GivePlayerWantedLevel( playerid, 6 );
			SetPVarInt( playerid, "C4WantedCD", g_iTime + 30 );
		}

		CreateExplosionEx( X, Y, Z, 0, 10.0, g_C4Data[ playerid ] [ i ] [ E_WORLD ], g_C4Data[ playerid ] [ i ] [ E_INTERIOR ], playerid );
	    g_C4Data[ playerid ] [ i ] [ E_VEHICLE ] = -100;
	  	Delete3DTextLabel( g_C4Data[ playerid ] [ i ] [ E_LABEL ] );
		DestroyDynamicObject( g_C4Data[ playerid ] [ i ] [ E_OBJECT ] );
	}
	return 1;
}

stock hasC4Planted( playerid )
{
	for( new iC4 = 0; iC4 < MAX_C4; iC4++ )
	    if ( g_C4Data[ playerid ] [ iC4 ] [ E_SET ] )
		    return true;

	return false;
}

function RestoreHealthAfterBrokenOut( playerid ) return SetPlayerHealth( playerid, 100.0 );

stock IsPlayerInPoliceCar( playerid )
{
	new model = GetVehicleModel( GetPlayerVehicleID( playerid ) );
	if ( model == 425 || model == 520|| model == 497 || model == 470 || model == 432 || model == 428 || model == 523 || model == 427 || model == 490 || model >= 596 && model <= 599 || model == 601 ) return true;
	return false;
}

stock GivePlayerWantedLevel( playerid, wantedlevel, bool:loadingstats = false )
{
	static
		szWanted[ 12 ];

	if ( !IsPlayerConnected( playerid ) )
	    return 0;

	if ( IsPlayerSecurityDriver( playerid ) )
		return SetPlayerColor( playerid, COLOR_SECURITY );

	if ( IsPlayerJailed( playerid ) )
	{
		SendClientMessageFormatted( playerid, -1, ""COL_GOLD"[WANTED LEVEL]{FFFFFF} As you're jailed, wanted levels will not append.", wantedlevel, p_WantedLevel[ playerid ] );
		return 1;
	}

	if ( wantedlevel == 0 )
		return 0;

    if ( ( p_WantedLevel[ playerid ] += wantedlevel ) < 0 )
    	p_WantedLevel[ playerid ] = 0; // Negative wanted level?

    if ( ( wantedlevel < 0 && p_WantedLevel[ playerid ] < 6 ) || wantedlevel > 0 )
		SetPlayerWantedLevel( playerid, p_WantedLevel[ playerid ] );

	if ( p_WantedLevel[ playerid ] )
	{
		SetPlayerColor( playerid, COLOR_WANTED2 );
		if ( IsPlayerSpawned( playerid ) )
		{
			format( szWanted, sizeof( szWanted ), "] %d ]", p_WantedLevel[ playerid ] );
			PlayerTextDrawSetString( playerid, p_WantedLevelTD[ playerid ], szWanted );
			if ( !p_inMovieMode{ playerid } ) PlayerTextDrawShow( playerid, p_WantedLevelTD[ playerid ] );
		}
	}
	else SetPlayerColorToTeam( playerid ), PlayerTextDrawHide( playerid, p_WantedLevelTD[ playerid ] ), Uncuff( playerid );

	if ( p_WantedLevel[ playerid ] > 5 )		SetPlayerColor( playerid, COLOR_WANTED6 );
	if ( p_WantedLevel[ playerid ] > 11 )	SetPlayerColor( playerid, COLOR_WANTED12 );
	if ( p_WantedLevel[ playerid ] > 90 ) 	printf( "[wanted_level] %s - %d", ReturnPlayerName( playerid ), p_WantedLevel[ playerid ] );
	if ( IsPlayerAdminOnDuty( playerid ) ) 	SetPlayerColor( playerid, COLOR_PINK );

	/*if ( p_WantedLevel[ playerid ] > 2000 ) // 8hska7082bmahu
	{
		p_WantedLevel[ playerid ] = 2000;
		SendClientMessageFormatted( playerid, -1, ""COL_GOLD"[WANTED LEVEL]{FFFFFF} Your wanted level has reached its maximum. Further wanted levels will not append.", wantedlevel, p_WantedLevel[ playerid ] );

		format( szBigString, 256, "[0xA1] %s(%d) :: %d :: %d\r\n", ReturnPlayerName( playerid ), playerid, p_WantedLevel[ playerid ], g_iTime );
	    AddFileLogLine( "security.txt", szBigString );
		return 1;
	}*/

	if ( !loadingstats ) SendClientMessageFormatted( playerid, -1, ""COL_GOLD"[CRIME]{FFFFFF} Your wanted level has been modified by %d! Wanted level: %d", wantedlevel, p_WantedLevel[ playerid ] );
	else SendClientMessageFormatted( playerid, -1, ""COL_GOLD"[RESUME]{FFFFFF} Your wanted level has been set to %d as you are resuming your life.", p_WantedLevel[ playerid ] );
	return 1;
}

stock ClearPlayerWantedLevel( playerid )
{
	PlayerTextDrawHide( playerid, p_WantedLevelTD[ playerid ] );
    p_WantedLevel[ playerid ] = 0;
	SetPlayerWantedLevel( playerid, 0 );
	SetPlayerColorToTeam( playerid );
}

stock GivePlayerCash( playerid, money, bool: force_save = false )
{
    p_Cash[ playerid ] += money;
    ResetPlayerMoney( playerid );
    GivePlayerMoney( playerid, p_Cash[ playerid ] );
	autosaveStart( playerid, force_save ); // auto-save
}

stock SetPlayerCash( playerid, money )
{
    p_Cash[ playerid ] = money;
    ResetPlayerMoney( playerid );
    GivePlayerMoney( playerid, p_Cash[ playerid ] );
}

stock ResetPlayerCash( playerid )
{
    p_Cash[ playerid ] = 0;
    ResetPlayerMoney( playerid );
    GivePlayerMoney( playerid, p_Cash[ playerid ] );
}

stock IsWeaponBanned( weaponid ) {
	return 0 <= weaponid < MAX_WEAPONS && ( weaponid == 35 || weaponid == 36 || weaponid == 37 || weaponid == 38 || weaponid == 39 || weaponid == 44 || weaponid == 45 );
}

stock GivePlayerScore( playerid, score, Float: multiplier = 0.75 )
{
	if ( IsPlayerAdminOnDuty( playerid ) )
		return 0;

	new
		gangid = p_GangID[ playerid ];

	if ( gangid != INVALID_GANG_ID )
		SaveGangData( gangid ), g_gangData[ gangid ] [ E_SCORE ] += score;

	GivePlayerXP( playerid, score * 10 );
	GivePlayerIrresistiblePoints( playerid, score < 0 ? ( score * 1.0 ) : ( score * multiplier ) );

	return SetPlayerScore( playerid, GetPlayerScore( playerid ) + score );
}

stock AdvancedBan( playerid, szBannedBy[ ], szReason[ ], szIP[ ], lol_time=0 )
{
	static
		szPlayerNameBanned[ MAX_PLAYER_NAME ]
	;
	GetPlayerName( playerid, szPlayerNameBanned, MAX_PLAYER_NAME );

	format( szNormalString, sizeof( szNormalString ), "SELECT `NAME` FROM `BANS` WHERE `NAME` = '%s' LIMIT 0,1", mysql_escape( szPlayerNameBanned ) );
	mysql_function_query( dbHandle, szNormalString, true, "OnAdvanceBanCheck", "isssi", playerid, szBannedBy, szReason, szIP, lol_time );
}

thread OnAdvanceBanCheck( playerid, szBannedBy[ ], szReason[ ], szIP[ ], lol_time )
{
	static
	    szPlayerNameBanned[ MAX_PLAYER_NAME ], szSerial[ 41 ],
		fields, rows
	;

	gpci( playerid, szSerial, sizeof( szSerial ) );
	GetPlayerName( playerid, szPlayerNameBanned, MAX_PLAYER_NAME );
	cache_get_data( rows, fields );

	if ( rows )
	{
		SendClientMessageToAdmins( -1, ""COL_PINK"[ADMIN]"COL_GREY" Edited ban entry for %s to "#SERVER_NAME".", szPlayerNameBanned );
		format( szBigString, 72, "UPDATE `BANS` SET `SERVER`=0 WHERE `NAME`='%s'", mysql_escape( szPlayerNameBanned ) );
		mysql_single_query( szBigString );
	}
	else
	{
		new
			enabled = IsProxyEnabledForPlayer( playerid );

		if ( !enabled )
		{
			format( szLargeString, sizeof( szLargeString ), "INSERT INTO `BANS`(`NAME`,`IP`,`REASON`,`BANBY`,`DATE`,`EXPIRE`,`SERVER`,`SERIAL`) VALUES ('%s','%s','%s','%s',%d,%d,0,'%s')", mysql_escape( szPlayerNameBanned ), mysql_escape( szIP ), mysql_escape( szReason ), mysql_escape( szBannedBy ), g_iTime, lol_time, mysql_escape( szSerial ) );
		}
		else
		{
			// include country why not
			format( szLargeString, sizeof( szLargeString ), "INSERT INTO `BANS`(`NAME`,`IP`,`REASON`,`BANBY`,`DATE`,`EXPIRE`,`SERVER`,`SERIAL`,`COUNTRY`) VALUES ('%s','%s','%s','%s',%d,%d,0,'%s','%s')", mysql_escape( szPlayerNameBanned ), mysql_escape( szIP ), mysql_escape( szReason ), mysql_escape( szBannedBy ), g_iTime, lol_time, mysql_escape( szSerial ), mysql_escape( GetPlayerCountryCode( playerid ) ) );
		}

		mysql_single_query( szLargeString );
	}
	return KickPlayerTimed( playerid ), 1;
}

stock IsNumeric(const str[ ])
{
    new len = strlen(str);

    if (!len) return false;
    for(new i; i < len; i++)
    {
        if (!('0' <= str[i] <= '9')) return false;
    }
    return true;
}

stock AddFileLogLine( file[ ], input[ ] )
{
    new
		File: fHandle
	;
    fHandle = fopen(file, io_append);
    fwrite(fHandle, input);
    fclose(fHandle);
    return 1;
}

new svApartments = -1;

stock loadApartmentsFromDatabase( )
{
	new
	    szQuery[ 45 ],
	    loadingTick = GetTickCount( )
	;

	for( new i; i < sizeof( g_apartmentData ); i++ )
	{
	    format( szQuery, sizeof( szQuery ), "SELECT * FROM `APARTMENTS` WHERE `ID`=%d LIMIT 0,1", i );
	    mysql_function_query( dbHandle, szQuery, true, "OnApartmentLoad", "i", i );
	}
	printf( "[FLATS]: %d apartments have been loaded. (Tick: %dms)", svApartments, GetTickCount( ) - loadingTick );
}

thread OnApartmentLoad( )
{
	new
		rows, fields, i = -1, aID,
		Field[ 5 ],
	    loadingTick = GetTickCount( )
	;

	cache_get_data( rows, fields );
	if ( rows )
	{
		while( ++i < rows )
		{
			cache_get_field_content( i, "ID", Field ),			aID = strval( Field );
			cache_get_field_content( i, "OWNER", g_apartmentData[ aID ] [ E_OWNER ], dbHandle, 24 );
			cache_get_field_content( i, "NAME", g_apartmentData[ aID ] [ E_NAME ], dbHandle, 30 );
			cache_get_field_content( i, "LOCKED", Field ), g_apartmentData[ aID ] [ E_LOCKED ] = strval( Field );
			g_apartmentData[ aID ] [ E_CREATED ] = true;
		}
	}
	printf( "[FLATS]: %d apartments have been loaded. (Tick: %dms)", i, GetTickCount( ) - loadingTick );
	return 1;
}

thread OnHouseLoad( )
{
	new
		rows, fields, i = -1, hID,
		Field[ 30 ],
		szString[ 40 ],
	    loadingTick = GetTickCount( )
	;

	cache_get_data( rows, fields );
	if ( rows )
	{
		while( ++i < rows )
		{
			cache_get_field_content( i, "ID", Field ),			hID = strval( Field );
			cache_get_field_content( i, "PASSWORD", g_houseData[ hID ] [ E_PASSWORD ], dbHandle, 5 );
			cache_get_field_content( i, "NAME", g_houseData[ hID ] [ E_HOUSE_NAME ], dbHandle, 30 );
			cache_get_field_content( i, "OWNER", g_houseData[ hID ] [ E_OWNER ], dbHandle, 24 );
			cache_get_field_content( i, "COST", Field ),      	g_houseData[ hID ] [ E_COST ] = strval( Field );
			cache_get_field_content( i, "EX", Field ),         	g_houseData[ hID ] [ E_EX ] = floatstr( Field );
			cache_get_field_content( i, "EY", Field ),         	g_houseData[ hID ] [ E_EY ] = floatstr( Field );
			cache_get_field_content( i, "EZ", Field ),         	g_houseData[ hID ] [ E_EZ ] = floatstr( Field );
			cache_get_field_content( i, "TX", Field ),         	g_houseData[ hID ] [ E_TX ] = floatstr( Field );
			cache_get_field_content( i, "TY", Field ),         	g_houseData[ hID ] [ E_TY ] = floatstr( Field );
			cache_get_field_content( i, "TZ", Field ),         	g_houseData[ hID ] [ E_TZ ] = floatstr( Field );
			cache_get_field_content( i, "INTERIOR", Field ),	g_houseData[ hID ] [ E_INTERIOR_ID ] = strval( Field );
			cache_get_field_content( i, "WEAPONS", szString ), 	sscanf( szString, "p<.>e<ddddddd>", g_HouseWeapons[ hID ] );
			cache_get_field_content( i, "AMMO", szString ),   	sscanf( szString, "p<.>e<ddddddd>", g_HouseWeaponAmmo[ hID ] );

			g_houseData[ hID ] [ E_WORLD ] = ( hID + MAX_HOUSES );
			g_houseData[ hID ] [ E_MAP_ICON ] = strmatch( g_houseData[ hID ] [ E_OWNER ], "No-one" ) ? CreateDynamicMapIcon( g_houseData[ hID ] [ E_EX ], g_houseData[ hID ] [ E_EY ], g_houseData[ hID ] [ E_EZ ], 31, 0, -1, -1, -1, HOUSE_MAPICON_RADIUS ) : INVALID_OBJECT_ID;
			g_houseData[ hID ] [ E_CHECKPOINT ] [ 0 ] = CreateDynamicCP( g_houseData[ hID ] [ E_EX ], g_houseData[ hID ] [ E_EY ], g_houseData[ hID ] [ E_EZ ], 1.0, -1, 0, -1, 100.0 );
			g_houseData[ hID ] [ E_CHECKPOINT ] [ 1 ] = CreateDynamicCP( g_houseData[ hID ] [ E_TX ], g_houseData[ hID ] [ E_TY ], g_houseData[ hID ] [ E_TZ ], 1.0, g_houseData[ hID ] [ E_WORLD ], g_houseData[ hID ] [ E_INTERIOR_ID ], -1, 100.0 );
	        format( szBigString, sizeof( szBigString ), ""COL_GOLD"House:"COL_WHITE" %s(%d)\n"COL_GOLD"Owner:"COL_WHITE" %s\n"COL_GOLD"Price:"COL_WHITE" %s", g_houseData[ hID ] [ E_HOUSE_NAME ], hID, g_houseData[ hID ] [ E_OWNER ], ConvertPrice( g_houseData[ hID ] [ E_COST ] ) );
	        g_houseData[ hID ] [ E_LABEL ] [ 0 ] = CreateDynamic3DTextLabel( szBigString, COLOR_WHITE, g_houseData[ hID ] [ E_EX ], g_houseData[ hID ] [ E_EY ], g_houseData[ hID ] [ E_EZ ], 20.0 );
			g_houseData[ hID ] [ E_LABEL ] [ 1 ] = CreateDynamic3DTextLabel( "[EXIT]", COLOR_GOLD, g_houseData[ hID ] [ E_TX ], g_houseData[ hID ] [ E_TY ], g_houseData[ hID ] [ E_TZ ], 20.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, g_houseData[ hID ] [ E_WORLD ] );
			g_houseData[ hID ] [ E_CREATED ] = true;
		}
	}
	printf( "[HOUSES]: %d houses have been loaded. (Tick: %dms)", i, GetTickCount( ) - loadingTick );

	// Make Lorenc the owner of unowned VIP houses
	for( new houseid = 0; houseid < MAX_HOUSES; houseid ++ ) if ( g_houseData[ houseid ] [ E_CREATED ] ) {
		if ( strmatch( g_houseData[ houseid ] [ E_OWNER ], "No-one" ) && g_houseData[ houseid ] [ E_COST ] < 10000 )
			SetHouseOwner( houseid, "Lorenc" );
	}

	// The server crashes when the fires aren't correctly loaded.
	CreateFire( );
	return 1;
}

stock CreateHouse( cost, Float: eX, Float: eY, Float: eZ, Float: tX = H_DEFAULT_X, Float: tY = H_DEFAULT_Y, Float: tZ = H_DEFAULT_Z, interior = 2 )
{
	new
	    hID
	;

	for( hID = 0; hID < MAX_HOUSES; hID++ )
	    if ( !g_houseData[ hID ] [ E_CREATED ] ) break;

	if ( hID >= MAX_HOUSES )
	    return -1;

	if ( g_houseData[ hID ] [ E_CREATED ] )
	    return -1;

	g_houseData[ hID ] [ E_COST ] = cost;
	g_houseData[ hID ] [ E_EX ] = eX;
	g_houseData[ hID ] [ E_EY ] = eY;
	g_houseData[ hID ] [ E_EZ ] = eZ;
	g_houseData[ hID ] [ E_TX ] = tX;
	g_houseData[ hID ] [ E_TY ] = tY;
	g_houseData[ hID ] [ E_TZ ] = tZ;
	g_houseData[ hID ] [ E_INTERIOR_ID ] = interior;
	g_houseData[ hID ] [ E_WORLD ] = ( hID + MAX_HOUSES );
	g_houseData[ hID ] [ E_MAP_ICON ] = CreateDynamicMapIcon( eX, eY, eZ, 31, 0, -1, -1, -1, HOUSE_MAPICON_RADIUS );
	g_houseData[ hID ] [ E_CHECKPOINT ] [ 0 ] = CreateDynamicCP( eX, eY, eZ, 1.0, -1, 0, -1, 100.0 );
	g_houseData[ hID ] [ E_CHECKPOINT ] [ 1 ] = CreateDynamicCP( tX, tY, tZ, 1.0, g_houseData[ hID ] [ E_WORLD ], g_houseData[ hID ] [ E_INTERIOR_ID ], -1, 100.0 );
	format( g_houseData[ hID ] [ E_HOUSE_NAME ], 5, "Home" );
	format( g_houseData[ hID ] [ E_PASSWORD ], 4, "N/A" );
	format( g_houseData[ hID ] [ E_OWNER ], 7, "No-one" );

	for( new i; i < MAX_HOUSE_WEAPONS; i++ )
	    g_HouseWeapons[ hID ] [ i ] = 0, g_HouseWeaponAmmo[ hID ] [ i ] = -1;

	format( szBigString, sizeof( szBigString ), ""COL_GOLD"House:"COL_WHITE" %s(%d)\n"COL_GOLD"Owner:"COL_WHITE" %s\n"COL_GOLD"Price:"COL_WHITE" %s", g_houseData[ hID ] [ E_HOUSE_NAME ], hID, g_houseData[ hID ] [ E_OWNER ], ConvertPrice( cost ) );
    g_houseData[ hID ] [ E_LABEL ] [ 0 ] = CreateDynamic3DTextLabel( szBigString, COLOR_WHITE, eX, eY, eZ, 20.0 );
	g_houseData[ hID ] [ E_LABEL ] [ 1 ] = CreateDynamic3DTextLabel( "[EXIT]", COLOR_GOLD, tX, tY, tZ, 20.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, g_houseData[ hID ] [ E_WORLD ] );

	g_houseData[ hID ] [ E_CREATED ] = true;
	format( szBigString, sizeof( szBigString ), "INSERT INTO `HOUSES` VALUES (%d,'Home','No-one',%d,%f,%f,%f,%f,%f,%f,%d,'N/A','0.0.0.0.0.0.0.','-1.-1.-1.-1.-1.-1.-1.')", hID, cost, eX, eY, eZ, tX, tY, tZ, interior );
	mysql_single_query( szBigString );

	print( "- Created another house." );

	return ( hID );
}


stock DestroyHouse( houseid )
{
	if ( houseid == -1 )
		return 0;
	if ( g_houseData[ houseid ] [ E_CREATED ] == false )
	    return 0;

	new
	    query[ 40 ],
		playerid = GetPlayerIDFromName( g_houseData[ houseid ] [ E_OWNER ] )
	;

	if ( IsPlayerConnected( playerid ) )
	{
	    SendClientMessage( playerid, -1, ""COL_PINK"[HOUSE]"COL_WHITE" One of your houses has been destroyed.");
		p_OwnedHouses[ playerid ] --;
		if ( p_HouseSpawnLocation[ playerid ] == houseid ) p_HouseSpawnLocation[ playerid ] = -1;
	}
	format( query, sizeof( query ), "DELETE FROM HOUSES WHERE ID=%d", houseid );
	mysql_single_query( query );

    destroyAllFurniture( houseid );
	g_houseData[ houseid ] [ E_HOUSE_NAME ] [ 0 ] = '\0';
	g_houseData[ houseid ] [ E_OWNER ] [ 0 ] = '\0';
	DestroyDynamicMapIcon( g_houseData[ houseid ] [ E_MAP_ICON ] );
	DestroyDynamicCP( g_houseData[ houseid ] [ E_CHECKPOINT ] [ 0 ] );
	DestroyDynamicCP( g_houseData[ houseid ] [ E_CHECKPOINT ] [ 1 ] );
	DestroyDynamic3DTextLabel( g_houseData[ houseid ] [ E_LABEL ] [ 0 ] );
	DestroyDynamic3DTextLabel( g_houseData[ houseid ] [ E_LABEL ] [ 1 ] );
	g_houseData[ houseid ] [ E_CREATED ] = false;
	return 1;
}

stock SetHouseForAuction( ID )
{
	if ( ID == -1 )
		return 0;

	if ( g_houseData[ ID ] [ E_CREATED ] == false )
	    return 0;

	new
	    query[ 128 ],
		player = GetPlayerIDFromName( g_houseData[ ID ] [ E_OWNER ] )
	;

	if ( IsPlayerConnected( player ) )
	{
	    SendClientMessage( player, -1, ""COL_PINK"[HOUSE]"COL_WHITE" One of your houses has been taken for auction.");
		p_OwnedHouses[ player ] --;
		if ( p_HouseSpawnLocation[ player ] == ID ) p_HouseSpawnLocation[ player ] = -1;
	}
	for( new i; i < MAX_HOUSE_WEAPONS; i++ ) { g_HouseWeapons[ ID ] [ i ] = 0, g_HouseWeaponAmmo[ ID ] [ i ] = -1; }
	format( g_houseData[ ID ] [ E_PASSWORD ], 4, "N/A" );
	format( g_houseData[ ID ] [ E_OWNER ], 7, "No-one" );
	format( g_houseData[ ID ] [ E_HOUSE_NAME ], 5, "Home" );
	g_houseData[ ID ] [ E_TX ] = g_houseInteriors[ 0 ] [ E_EX ];
	g_houseData[ ID ] [ E_TY ] = g_houseInteriors[ 0 ] [ E_EY ];
	g_houseData[ ID ] [ E_TZ ] = g_houseInteriors[ 0 ] [ E_EZ ];
	g_houseData[ ID ] [ E_INTERIOR_ID ] = 2;
	destroyAllFurniture( ID );
	format( query, sizeof( query ), "UPDATE HOUSES SET OWNER='No-one',PASSWORD='N/A',NAME='Home',TX=%f,TY=%f,TZ=%f,INTERIOR=%d WHERE ID=%d", g_houseData[ ID ] [ E_TX ], g_houseData[ ID ] [ E_TY ], g_houseData[ ID ] [ E_TZ ], g_houseData[ ID ] [ E_INTERIOR_ID ], ID );
    mysql_single_query( query );
	format( szBigString, sizeof( szBigString ), ""COL_GOLD"House:"COL_WHITE" Home(%d)\n"COL_GOLD"Owner:"COL_WHITE" No-one\n"COL_GOLD"Price:"COL_WHITE" %s", ID, ConvertPrice( g_houseData[ ID ] [ E_COST ] ) );
	UpdateDynamic3DTextLabelText( g_houseData[ ID ] [ E_LABEL ] [ 0 ], COLOR_WHITE, szBigString);
	DestroyDynamic3DTextLabel( g_houseData[ ID ] [ E_LABEL ] [ 1 ] );
	g_houseData[ ID ] [ E_LABEL ] [ 1 ] = CreateDynamic3DTextLabel( "[EXIT]", COLOR_GOLD, g_houseData[ ID ] [ E_TX ], g_houseData[ ID ] [ E_TY ], g_houseData[ ID ] [ E_TZ ], 20.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, g_houseData[ ID ] [ E_WORLD ] );
	DestroyDynamicCP( g_houseData[ ID ] [ E_CHECKPOINT ] [ 1 ] );
	g_houseData[ ID ] [ E_CHECKPOINT ] [ 1 ] = CreateDynamicCP( g_houseData[ ID ] [ E_TX ], g_houseData[ ID ] [ E_TY ], g_houseData[ ID ] [ E_TZ ], 1.0, g_houseData[ ID ] [ E_WORLD ], g_houseData[ ID ] [ E_INTERIOR_ID ], -1, 50.0 );
	DestroyDynamicMapIcon( g_houseData[ ID ] [ E_MAP_ICON ] );
	g_houseData[ ID ] [ E_MAP_ICON ] = CreateDynamicMapIcon( g_houseData[ ID ] [ E_EX ], g_houseData[ ID ] [ E_EY ], g_houseData[ ID ] [ E_EZ ], 31, 0, -1, -1, -1, HOUSE_MAPICON_RADIUS );
	return 1;
}

stock SetHouseOwner( houseid, szOwner[ MAX_PLAYER_NAME ] )
{
	if ( houseid == -1 || g_houseData[ houseid ] [ E_CREATED ] == false || isnull( szOwner ) )
		return 0;

	new
		query[ 128 ]
	;
	format( g_houseData[ houseid ] [ E_OWNER ], 24, "%s", szOwner );

	format( query, sizeof( query ), "UPDATE HOUSES SET OWNER='%s' WHERE ID=%d", mysql_escape( szOwner ), houseid );
	mysql_single_query( query );

	DestroyDynamicMapIcon( g_houseData[ houseid ] [ E_MAP_ICON ] );
	format( szBigString, sizeof( szBigString ), ""COL_GOLD"House:"COL_WHITE" Home(%d)\n"COL_GOLD"Owner:"COL_WHITE" %s\n"COL_GOLD"Price:"COL_WHITE" %s", houseid, g_houseData[ houseid ] [ E_OWNER ], ConvertPrice( g_houseData[ houseid ] [ E_COST ] ) );
 	UpdateDynamic3DTextLabelText( g_houseData[ houseid ] [ E_LABEL ] [ 0 ], COLOR_WHITE, szBigString);
	return 1;
}

stock GetPlayerOwnedApartments( playerid )
{
	for( new i; i < sizeof( g_apartmentData ); i++ ) if ( g_apartmentData[ i ] [ E_CREATED ] )
	{
		if ( strmatch( g_apartmentData[ i ][ E_OWNER ], ReturnPlayerName( playerid ) ) )
		    return 1;
	}
	return 0;
}

stock GetPlayerOwnedHouses( playerid )
{
	new count = 0;
	for( new i; i < MAX_HOUSES; i++ )
	{
		if ( g_houseData[ i ] [ E_CREATED ] == true && strmatch( g_houseData[ i ][ E_OWNER ], ReturnPlayerName( playerid ) ) )
		{
		    count ++;
		}
	}
	return count;
}

stock GetPlayerOwnedBusinesses( playerid )
{
	new
		count = 0;

	foreach (new businessid : business) if ( IsBusinessAssociate( playerid, businessid ) ) {
		count ++;
	}
	return count;
}

stock GetPlayerIDFromName( pName[ ] )
{
    foreach(new i : Player)
    {
        if ( strmatch( pName, ReturnPlayerName( i ) ) )
			return i;
    }
    return INVALID_PLAYER_ID;
}

stock GetPlayerIDFromAccountID( iAccountID )
{
    foreach(new i : Player)
    {
        if ( p_AccountID[ i ] == iAccountID )
			return i;
    }
    return INVALID_PLAYER_ID;
}

stock SetPlayerColorToTeam( playerid )
{
	if ( IsPlayerSecurityDriver( playerid ) ) return SetPlayerColor( playerid, COLOR_SECURITY );
	if ( p_AdminOnDuty{ playerid } ) return SetPlayerColor( playerid, COLOR_PINK );

	switch( p_Class[ playerid ] )
	{
	    case CLASS_POLICE:
	    {
	    	SetPlayerColor( playerid, COLOR_POLICE );
			if ( p_inFBI{ playerid } ) SetPlayerColor( playerid, COLOR_FBI );
			if ( p_inCIA{ playerid } ) SetPlayerColor( playerid, COLOR_CIA );
			if ( p_inArmy{ playerid } ) SetPlayerColor( playerid, COLOR_ARMY );
			// if ( p_inMayor{ playerid } ) SetPlayerColor( playerid, COLOR_MAYOR );
	    }
	    case CLASS_FIREMAN: SetPlayerColor( playerid, COLOR_FIREMAN );
	    case CLASS_MEDIC: 	SetPlayerColor( playerid, COLOR_MEDIC );
	    default:
	    {
	    	SetPlayerColor( playerid, COLOR_DEFAULT );
		    if ( p_GangID[ playerid ] != INVALID_GANG_ID ) 	SetPlayerColor( playerid, g_gangData[ p_GangID[ playerid ] ] [ E_COLOR ] );
			if ( p_WantedLevel[ playerid ] > 1 )			SetPlayerColor( playerid, COLOR_WANTED2 );
			if ( p_WantedLevel[ playerid ] > 5 )			SetPlayerColor( playerid, COLOR_WANTED6 );
			if ( p_WantedLevel[ playerid ] > 11 )			SetPlayerColor( playerid, COLOR_WANTED12 );
		}
	}
	return 1;
}

stock GivePlayerXP( playerid, amount )
{
	if ( p_PlayerLogged{ playerid } == true )
	{
	    new string[ 20 ];
	    if ( amount < 0 ) format( string, sizeof( string ), "~r~%d XP", amount );
		else {
	    	if ( IsDoubleXP( ) ) amount *= 2;
			format( string, sizeof( string ), "+%d XP", amount );
		}
		p_XP[ playerid ] += amount;
	    PlayerTextDrawSetString( playerid, p_ExperienceAwardTD[ playerid ], string );
	    PlayerTextDrawShow( playerid, p_ExperienceAwardTD[ playerid ] );
		p_ExperienceHideTimer[ playerid ] = SetTimerEx( "ExperienceTD_hide", 3500, false, "d", playerid );
		if ( p_XP[ playerid ] > 99999999 ) p_XP[ playerid ] = 99999999;
		autosaveStart( playerid ); // auto-save
		return 1;
	}
	return 0;
}

function ExperienceTD_hide( playerid ) return PlayerTextDrawHide( playerid, p_ExperienceAwardTD[ playerid ] );

stock IsPlayerFBI( playerid )
{
	new
		skinid = GetPlayerSkin( playerid );

	switch( skinid ) {
	    case 286, 71, 285: {
			if ( IsPlayerSpawned( playerid ) && p_PlayerSettings[ playerid ] { SETTING_VIPSKIN } && p_VIPLevel[ playerid ] && p_LastSkin[ playerid ] == skinid ) {
				return false;
			}
	    	return true;
	    }
	}
	return false;
}

/*stock IsPlayerMayor( playerid )
{
	new
		skinid = GetPlayerSkin( playerid );

	switch( skinid ) {
	    case 187, 148: {
			if ( IsPlayerSpawned( playerid ) && p_PlayerSettings[ playerid ] { SETTING_VIPSKIN } && p_VIPLevel[ playerid ] && p_LastSkin[ playerid ] == skinid ) {
				return false;
			}
	    	return true;
	    }
	}
	return false;
}*/

stock IsPlayerCIA( playerid )
{
	new
		skinid = GetPlayerSkin( playerid );

	switch( skinid ) {
	    case 303 .. 305: {
			if ( IsPlayerSpawned( playerid ) && p_PlayerSettings[ playerid ] { SETTING_VIPSKIN } && p_VIPLevel[ playerid ] && p_LastSkin[ playerid ] == skinid ) {
				return false;
			}
	    	return true;
	    }
	}
	return false;
}

stock IsPlayerPolice( playerid )
{
	new
		skinid = GetPlayerSkin( playerid );

	switch( skinid ) {
   	    case 265, 266, 267, 306, 307, 280, 281, 284: {
			if ( IsPlayerSpawned( playerid ) && p_PlayerSettings[ playerid ] { SETTING_VIPSKIN } && p_VIPLevel[ playerid ] && p_LastSkin[ playerid ] == skinid ) {
				return false;
			}
	    	return true;
	    }
   	}
	return false;
}

stock IsPlayerMedic( playerid )
{
	new
		skinid = GetPlayerSkin( playerid );

	switch( skinid ) {
	    case 274 .. 276, 308: {
			if ( IsPlayerSpawned( playerid ) && p_PlayerSettings[ playerid ] { SETTING_VIPSKIN } && p_VIPLevel[ playerid ] && p_LastSkin[ playerid ] == skinid ) {
				return false;
			}
	    	return true;
	    }
	}
	return false;
}

stock IsPlayerFireman( playerid )
{
	new
		skinid = GetPlayerSkin( playerid );

	switch( skinid ) {
	    case 277, 278, 279: {
			if ( IsPlayerSpawned( playerid ) && p_PlayerSettings[ playerid ] { SETTING_VIPSKIN } && p_VIPLevel[ playerid ] && p_LastSkin[ playerid ] == skinid ) {
				return false;
			}
	    	return true;
	    }
	}
	return false;
}

stock CreateBribe( Float: fX, Float: fY, Float: fZ, iExistingID = -1 )
{
	new
		bID = iExistingID != ITER_NONE ? iExistingID : Iter_Free(BribeCount);

	if ( Iter_Contains( BribeCount, iExistingID ) )
		bID = ITER_NONE; // In the unlikelihood...

	if ( bID != -1 )
	{
	    Iter_Add(BribeCount, bID);
	    g_bribeData[ bID ] [ E_X ] = fX;
	    g_bribeData[ bID ] [ E_Y ] = fY;
	    g_bribeData[ bID ] [ E_Z ] = fZ;
	    g_bribeData[ bID ] [ E_PICKUP ] [ 0 ] = CreateDynamicPickup( 1247,  15, fX, fY, fZ );
	    g_bribeData[ bID ] [ E_PICKUP ] [ 1 ] = CreateDynamicPickup( 19300, 14, fX, fY, fZ );
	    g_bribeData[ bID ] [ E_LABEL ] 		  = CreateDynamic3DTextLabel( sprintf( "Bribe(%d)", bID ), COLOR_GOLD, fX, fY, fZ, 15.0 );

	    if ( iExistingID == -1 )
			mysql_single_query( sprintf( "INSERT INTO `BRIBES` VALUES (%d,%f,%f,%f)", bID, fX, fY, fZ ) );
	}
	return bID;
}

stock DestroyBribe( bID )
{
	if ( bID == -1 || !Iter_Contains( BribeCount, bID ) )
	    return 0;

	new
	    query[ 40 ]
	;
	Iter_Remove(BribeCount, bID);
	DestroyDynamic3DTextLabel( g_bribeData[ bID ] [ E_LABEL ] );
	DestroyDynamicPickup( g_bribeData[ bID ] [ E_PICKUP ] [ 0 ] );
	DestroyDynamicPickup( g_bribeData[ bID ] [ E_PICKUP ] [ 1 ] );
 	g_bribeData[ bID ] [ E_TIMESTAMP ] = -1;
	format( query, sizeof( query ), "DELETE FROM `BRIBES` WHERE `ID`=%d", bID );
	mysql_single_query( query );
	return 1;
}

thread OnBribeLoad( )
{
	new
		rows, fields, i = -1,
	    loadingTick = GetTickCount( )
	;

	cache_get_data( rows, fields );
	if ( rows )
	{
		while( ++i < rows )
		{
			CreateBribe(
				cache_get_field_content_float( i, "X", dbHandle ),
				cache_get_field_content_float( i, "Y", dbHandle ),
				cache_get_field_content_float( i, "Z", dbHandle ),
				cache_get_field_content_int( i, "ID", dbHandle )
			);
		}
	}
	printf( "[BRIBES]: %d bribes have been loaded. (Tick: %dms)", i, GetTickCount( ) - loadingTick );
	return 1;
}

stock PutPlayerInEmptyVehicleSeat( vehicleid, playerid )
{
	new
		vModel = GetVehicleModel( vehicleid ),
	    bool: bNonAvailable[ 16 char ],
	    seats = 0xF
	;

	if ( !IsValidVehicle( vehicleid ) )
	    return -1;

	if ( vModel == 425 || vModel == 481 || vModel == 520 || vModel == 519 || vModel == 509 || vModel == 510 || vModel == 476 )
		return -1;

	foreach(new iPlayer : Player)
	{
		if ( IsPlayerInVehicle( iPlayer, vehicleid ) )
		{
			new iVehicle = GetPlayerVehicleSeat( iPlayer );
			seats = GetVehicleSeatCount( GetVehicleModel( iVehicle ) );

   			if ( seats == 0xF )
	   			return -1; // Just so the player aint bugged.

			if ( iVehicle >= 0 && iVehicle <= seats ) bNonAvailable{ iVehicle } = true;
		}
	}
	for( new i = 1; i < sizeof( bNonAvailable ); i++ )
	{
	    if ( !bNonAvailable{ i } ) {
			SetPlayerVirtualWorld( playerid, GetVehicleVirtualWorld( vehicleid ) );
			SetPlayerInterior( playerid, 0 ); // All vehicles are in interior ID 0, unless a stupid did this :|
			PutPlayerInVehicle( playerid, vehicleid, i );
			break;
		}
	}
	return seats;
}

stock GetVehicleSeatCount(iModel)
{
    if (400 <= iModel <= 611)
    {
        static
            s_MaxPassengers[] =
            {
                271782163, 288428337, 288559891, -2146225407, 327282960, 271651075, 268443408, 286339857, 319894289, 823136512, 805311233,
                285414161, 286331697, 268513553, 18026752, 286331152, 286261297, 286458129, 856765201, 286331137, 856690995, 269484528,
                51589393, -15658689, 322109713, -15527663, 65343
            }
        ;
        return ((s_MaxPassengers[(iModel -= 400) >>> 3] >>> ((iModel & 7) << 2)) & 0xF);
    }
    return 0xF;
}

stock strreplacechar(string[], oldchar, newchar)
{
	new matches;
	if (ispacked(string)) {
		if (newchar == '\0') {
			for(new i; string{i} != '\0'; i++) {
				if (string{i} == oldchar) {
					strdel(string, i, i + 1);
					matches++;
				}
			}
		} else {
			for(new i; string{i} != '\0'; i++) {
				if (string{i} == oldchar) {
					string{i} = newchar;
					matches++;
				}
			}
		}
	} else {
		if (newchar == '\0') {
			for(new i; string[i] != '\0'; i++) {
				if (string[i] == oldchar) {
					strdel(string, i, i + 1);
					matches++;
				}
			}
		} else {
			for(new i; string[i] != '\0'; i++) {
				if (string[i] == oldchar) {
					string[i] = newchar;
					matches++;
				}
			}
		}
	}
	return matches;
}

stock CreateRobberyCheckpoint( szName[ 32 ], iRobValue, Float: fX, Float: fY, Float: fZ, Float: rotation, ... )
{
	new
		Float: offsetX, Float: offsetY
	;

	for( new i = 6; i < numargs( ); i++ )
    {
    	new rID = Iter_Free(RobberyCount);

		if ( rID != ITER_NONE )
		{
			new
				worldid = getarg( i );

			Iter_Add(RobberyCount, rID);

			g_robberyData[ rID ] [ E_SAFE ] = CreateDynamicObject( 2003, fX, fY, fZ, 0, 0, rotation, worldid );

			offsetX = 0.5 * floatsin( -( rotation + 124 ), degrees );
			offsetY = 0.5 * floatcos( -( rotation + 124 ), degrees );

			// SAFE DOOR
			g_robberyData[ rID ] [ E_DOOR_X ] = fX + offsetX;
			g_robberyData[ rID ] [ E_DOOR_Y ] = fY + offsetY;
			g_robberyData[ rID ] [ E_DOOR_Z ] = fZ;
			g_robberyData[ rID ] [ E_DOOR_ROT ] = rotation;

			g_robberyData[ rID ] [ E_SAFE_DOOR ] = CreateDynamicObject( 2004, fX + offsetX, fY + offsetY, fZ, 0, 0, rotation, worldid );

			SetDynamicObjectMaterial( g_robberyData[ rID ] [ E_SAFE ], 5, 1829, "kbmiscfrn2", "man_mny1", 0 );
			SetDynamicObjectMaterial( g_robberyData[ rID ] [ E_SAFE_DOOR ], 2, 0, "none", "none", -1 );

			CreateDynamic3DTextLabel( sprintf( "%s\n"COL_WHITE"Left ALT To Crack Safe", szName ), COLOR_GREY, fX, fY, fZ, 15.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, .testlos = 0, .worldid = worldid );
		    format( g_robberyData[ rID ] [ E_NAME ], 32, "%s", szName );

		    g_robberyData[ rID ] [ E_WORLD ] 		= worldid;
		    g_robberyData[ rID ] [ E_ROB_VALUE ] 	= iRobValue;
		    g_robberyData[ rID ] [ E_ROBBED ] 		= false;
		    g_robberyData[ rID ] [ E_STATE ] 		= STATE_NONE;
		    g_robberyData[ rID ] [ E_ROBTIMER ] 	= 0xFFFF;
		    g_robberyData[ rID ] [ E_DRILL_PLACER ] = INVALID_PLAYER_ID;
		    g_robberyData[ rID ] [ E_DRILL_EFFECT ] = INVALID_OBJECT_ID;
		    g_robberyData[ rID ] [ E_MULTIPLIER ] 	= 1.0;

			if ( getarg( i ) == -1 ) break; // Save your breath, wanna waste my time?
		}
   	}
}

stock GetXYInFrontOfSafe( robberyid, &Float: X, &Float: Y, &Float: Z, Float: distance = 1.25 )
{
	static
		Float: iFloat;

	GetDynamicObjectPos( g_robberyData[ robberyid ] [ E_SAFE ], X, Y, Z );
	GetDynamicObjectRot( g_robberyData[ robberyid ] [ E_SAFE ], iFloat, iFloat, iFloat );

	X += distance * -floatsin( -iFloat, degrees );
	Y += distance * -floatcos( -iFloat, degrees );
}

stock AttachToRobberySafe( robberyid, playerid, type )
{
	if ( !IsPlayerConnected( playerid ) )
		return 0xFFFF; // Not connected

	if (!Iter_Contains(RobberyCount, robberyid))
		return 0xAA; // Invalid Robbery

	if ( ( g_robberyData[ robberyid ] [ E_C4_SLOT ] == true && type == ROBBERY_TYPE_DRILL ) || ( g_robberyData[ robberyid ] [ E_DRILL_PLACER ] != INVALID_PLAYER_ID && type == ROBBERY_TYPE_C4 ) )
		return 0x1B; // Is occupied?

	if ( g_robberyData[ robberyid ] [ E_ROBBED ] || g_robberyData[ robberyid ] [ E_OPEN ] || g_robberyData[ robberyid ] [ E_ROBTIMER ] != 0xFFFF )
		return 0x2C; // It's been robbed/opened!

	if ( p_Class[ playerid ] == CLASS_POLICE )
		return 0xBB; // Not civilian

	if ( IsPlayerAttachedObjectSlotUsed( playerid, 0 ) || g_robberyData[ robberyid ] [ E_STATE ] )
		return 0xBC; // Currently picking/being robbed/being picked

	static
		Float: fX, Float: fY, Float: fZ,
		Float: offsetX, Float: offsetY, Float: rotation
	;

	GetDynamicObjectPos( g_robberyData[ robberyid ] [ E_SAFE ], fX, fY, fZ );
	GetDynamicObjectRot( g_robberyData[ robberyid ] [ E_SAFE ], rotation, rotation, rotation );

	if ( g_Debugging )
	{
		printf("[DEBUG] [ROBBERY] [%d] AttachToRobberySafe( %d, %d, %d ) { open : %d, robbed : %d, c4: %d, drill : %d, dplacer : %d, deffect : %d, replenish : %d, raw ts : %d, current ts : %d, name : %s, velocity : %f, state : %d }",
				robberyid, robberyid, playerid, type,
				g_robberyData[ robberyid ] [ E_OPEN ], g_robberyData[ robberyid ] [ E_ROBBED ], g_robberyData[ robberyid ] [ E_C4 ],
				g_robberyData[ robberyid ] [ E_DRILL ], g_robberyData[ robberyid ] [ E_DRILL_PLACER ], g_robberyData[ robberyid ] [ E_DRILL_EFFECT ], g_robberyData[ robberyid ] [ E_ROB_TIME ] - g_iTime,
				g_robberyData[ robberyid ] [ E_ROB_TIME ], g_iTime, g_robberyData[ robberyid ] [ E_NAME ], g_robberyData[ robberyid ] [ E_VELOCITY ], g_robberyData[ robberyid ] [ E_STATE ] );
	}

	// trigger the robbery bot
	TriggerRobberyForClerks( playerid, robberyid );

	// start the drill/c4
	switch( type )
	{
		case ROBBERY_TYPE_DRILL:
		{
			if ( p_drillStrength[ playerid ] <= 0 )
				return 0xA1;

			if ( g_robberyData[ robberyid ] [ E_DRILL_PLACER ] != INVALID_PLAYER_ID || IsValidDynamicObject( g_robberyData[ robberyid ] [ E_DRILL ] ) )
				return 0x2B; // Valid drill/driller already on?

			// DRILL
			offsetX = 0.8 * floatsin( -( rotation + 200 ), degrees );
			offsetY = 0.8 * floatcos( -( rotation + 200 ), degrees );

			g_robberyData[ robberyid ] [ E_DRILL_PLACER ] = playerid;
			g_robberyData[ robberyid ] [ E_DRILL ] = CreateDynamicObject( 341, fX + offsetX, fY + offsetY, fZ, 0, 24.0, rotation + 90, g_robberyData[ robberyid ] [ E_WORLD ] );

			offsetX = -1.4 * floatsin( -( rotation + 170 ), degrees );
			offsetY = -1.4 * floatcos( -( rotation + 170 ), degrees );
			g_robberyData[ robberyid ] [ E_DRILL_EFFECT ] = CreateDynamicObject( 18718, fX + offsetX, fY + offsetY, fZ, 90, 0, rotation, g_robberyData[ robberyid ] [ E_WORLD ] );

			g_robberyData[ robberyid ] [ E_ROBTIMER ] = SetTimerEx( "onSafeBust", 15000, false, "dddd", playerid, robberyid, type, 0 );

			p_drillStrength[ playerid ] -= 10;
			return 1;
		}

		case ROBBERY_TYPE_C4:
		{
			if ( g_robberyData[ robberyid ] [ E_C4_SLOT ] == false )
			{
				// slot 1 = orignally 185 degrees
				offsetX = 0.35 * floatsin( -( rotation + 180 ), degrees );
				offsetY = 0.35 * floatcos( -( rotation + 180 ), degrees );
				//case 0: g_robberyData[ robberyid ] [ E_C4 ] [ 0 ] = CreateDynamicObject( 363, fX + offsetX, fY + offsetY, fZ + 0.18534, 0, 0, rotation, g_robberyData[ robberyid ] [ E_WORLD ] );
				//case 1: g_robberyData[ robberyid ] [ E_C4 ] [ 1 ] = CreateDynamicObject( 363, fX + offsetX, fY + offsetY, fZ + 0.44483, 0, 90, rotation, g_robberyData[ robberyid ] [ E_WORLD ] );
				//case 2: g_robberyData[ robberyid ] [ E_C4 ] [ 2 ] = CreateDynamicObject( 363, fX + offsetX, fY + offsetY, fZ - 0.06090, 0, 90, rotation, g_robberyData[ robberyid ] [ E_WORLD ] );
				g_robberyData[ robberyid ] [ E_C4 ] = CreateDynamicObject( 363, fX + offsetX, fY + offsetY, fZ + 0.18534, 0, 0, rotation, g_robberyData[ robberyid ] [ E_WORLD ] );
				g_robberyData[ robberyid ] [ E_C4_SLOT ] = true;
				g_robberyData[ robberyid ] [ E_ROBTIMER ] = SetTimerEx( "onSafeBust", 960, false, "dddd", playerid, robberyid, type, 0 );
				return 1;
			}
		}
	}
	return -1;
}

stock getClosestRobberySafe( playerid, &Float: dis = 99999.99 )
{
	new
		Float: dis2,
		object = INVALID_OBJECT_ID,
		Float: X, Float: Y, Float: Z,
		world = GetPlayerVirtualWorld( playerid )
	;
	foreach(new i : RobberyCount)
	{
		if ( g_robberyData[ i ] [ E_WORLD ] != -1 && g_robberyData[ i ] [ E_WORLD ] != world ) continue;
		GetDynamicObjectPos( g_robberyData[ i ] [ E_SAFE ], X, Y, Z );
    	dis2 = GetPlayerDistanceFromPoint( playerid, X, Y, Z );
    	if ( dis2 < dis && dis2 != -1.00 ) {
    	    dis = dis2;
    	    object = i;
		}
	}
	return object;
}

stock RemoveRobberyAttachments( robberyid )
{
	if (!Iter_Contains(RobberyCount, robberyid))
		return; // Invalid Robbery

	DestroyDynamicObject( g_robberyData[ robberyid ] [ E_DRILL ] );
	DestroyDynamicObject( g_robberyData[ robberyid ] [ E_DRILL_EFFECT ] );
	DestroyDynamicObject( g_robberyData[ robberyid ] [ E_C4 ] );
	g_robberyData[ robberyid ] [ E_C4_SLOT ] = false;
	g_robberyData[ robberyid ] [ E_C4 ] = INVALID_OBJECT_ID;
	g_robberyData[ robberyid ] [ E_DRILL ] = INVALID_OBJECT_ID;
	g_robberyData[ robberyid ] [ E_DRILL_PLACER ] = INVALID_PLAYER_ID;
	g_robberyData[ robberyid ] [ E_DRILL_EFFECT ] = INVALID_OBJECT_ID;

	if ( g_Debugging )
	{
		printf("[DEBUG] [ROBBERY] [%d] RemoveRobberyAttachments { open : %d, robbed : %d, c4: %d, drill : %d, dplacer : %d, deffect : %d, replenish : %d, raw ts : %d, current ts : %d, name : %s, velocity : %f, state : %d }",
				robberyid,
				g_robberyData[ robberyid ] [ E_OPEN ], g_robberyData[ robberyid ] [ E_ROBBED ], g_robberyData[ robberyid ] [ E_C4 ],
				g_robberyData[ robberyid ] [ E_DRILL ], g_robberyData[ robberyid ] [ E_DRILL_PLACER ], g_robberyData[ robberyid ] [ E_DRILL_EFFECT ], g_robberyData[ robberyid ] [ E_ROB_TIME ] - g_iTime,
				g_robberyData[ robberyid ] [ E_ROB_TIME ], g_iTime, g_robberyData[ robberyid ] [ E_NAME ], g_robberyData[ robberyid ] [ E_VELOCITY ], g_robberyData[ robberyid ] [ E_STATE ] );
	}
}

stock createRobberyLootInstance( playerid, robberyid, type )
{
	if (!Iter_Contains(RobberyCount, robberyid))
		return; // Invalid Robbery

	static
		Float: fX, Float: fY, Float: fZ;

	GetDynamicObjectPos( g_robberyData[ robberyid ] [ E_SAFE ], fX, fY, fZ );

	if ( ( p_Robberies[ playerid ] <= 10 ? 0 : random( 101 ) ) < 80 )
	{
		new
			Float: iLoot = float( RandomEx( 1000, g_robberyData[ robberyid ] [ E_ROB_VALUE ] ) );

		if ( type == ROBBERY_TYPE_C4 ) iLoot *= 0.50; // Loose 50% because of impact

		// Apply multiplier
		iLoot *= g_robberyData[ robberyid ] [ E_MULTIPLIER ];
		g_robberyData[ robberyid ] [ E_MULTIPLIER ] = 1.0;

		DestroyDynamicObject( g_robberyData[ robberyid ] [ E_SAFE_MONEY ] );
		g_robberyData[ robberyid ] [ E_SAFE_MONEY ] = CreateDynamicObject( 2005, fX, fY, fZ - 0.1, 0, 0, g_robberyData[ robberyid ] [ E_DOOR_ROT ], g_robberyData[ robberyid ] [ E_WORLD ] );
	 	SetDynamicObjectMaterial( g_robberyData[ robberyid ] [ E_SAFE_MONEY ], 2, 0, "none", "none", -1 );
		g_robberyData[ robberyid ] [ E_SAFE_LOOT ] = floatround( iLoot );
	}
	else
	{
		if ( IsPlayerConnected( playerid ) && p_Class[ playerid ] != CLASS_POLICE )
		{
		    new
				szLocation[ MAX_ZONE_NAME ],
				id = p_LastEnteredEntrance[ playerid ]
			;

			if ( id != -1 ) // Sometimes the player isn't even inside a home.
				GetZoneFromCoordinates( szLocation, g_entranceData[ id ] [ E_EX ], g_entranceData[ id ] [ E_EY ], g_entranceData[ id ] [ E_EZ ] );

			if ( GetPlayerInterior( playerid ) != 0 )
		    	SendClientMessageToCops( -1, ""COL_BLUE"[ROBBERY]"COL_WHITE" %s has failed robbing %s near %s, suspect is bound to leave any time now.", ReturnPlayerName( playerid ), g_robberyData[ robberyid ] [ E_NAME ], szLocation );
			else
				SendClientMessageToCops( -1, ""COL_BLUE"[ROBBERY]"COL_WHITE" %s has failed robbing %s, suspect is bound to leave any time now.", ReturnPlayerName( playerid ), g_robberyData[ robberyid ] [ E_NAME ] );

			SendClientMessage( playerid, -1, ""COL_GREY"[SERVER]"COL_WHITE" No loot, and the alarm went off. Cops have been alerted." );
			GivePlayerWantedLevel( playerid, 6 );
			CreateCrimeReport( playerid );
		}
		g_robberyData[ robberyid ] [ E_ROB_TIME ] = g_iTime + MAX_ROBBERY_WAIT;
		g_robberyData[ robberyid ] [ E_ROBBED ] = true;
	}

	if ( g_Debugging )
	{
		printf("[DEBUG] [ROBBERY] [%d] createRobberyLootInstance( %d, %d, %d ) { open : %d, robbed : %d, c4: %d, drill : %d, dplacer : %d, deffect : %d, replenish : %d, raw ts : %d, current ts : %d, name : %s, velocity : %f, state : %d }",
				robberyid, playerid, robberyid, type,
				g_robberyData[ robberyid ] [ E_OPEN ], g_robberyData[ robberyid ] [ E_ROBBED ], g_robberyData[ robberyid ] [ E_C4 ],
				g_robberyData[ robberyid ] [ E_DRILL ], g_robberyData[ robberyid ] [ E_DRILL_PLACER ], g_robberyData[ robberyid ] [ E_DRILL_EFFECT ], g_robberyData[ robberyid ] [ E_ROB_TIME ] - g_iTime,
				g_robberyData[ robberyid ] [ E_ROB_TIME ], g_iTime, g_robberyData[ robberyid ] [ E_NAME ], g_robberyData[ robberyid ] [ E_VELOCITY ], g_robberyData[ robberyid ] [ E_STATE ] );
	}
}

public onSafeBust( playerid, robberyid, type, index )
{
	new
		bConnected = IsPlayerConnected( playerid );

	switch( type )
	{
		case ROBBERY_TYPE_C4:
		{
			if ( index < 3 )
			{
				if ( bConnected ) {
					PlayerPlaySound( playerid, 1056, g_robberyData[ robberyid ] [ E_DOOR_X ], g_robberyData[ robberyid ] [ E_DOOR_Y ], g_robberyData[ robberyid ] [ E_DOOR_Z ] );
	        		GameTextForPlayer( playerid, "~r~Fall back!~n~c4 in detonation!", 4000, 3 );
	        	}
				g_robberyData[ robberyid ] [ E_ROBTIMER ] = SetTimerEx( "onSafeBust", 960, false, "dddd", playerid, robberyid, type, index + 1 );
			}
			else
			{
				if ( bConnected ) {
        			GameTextForPlayer( playerid, "~g~We're in!", 4000, 3 );
					PlayerPlaySound( playerid, 1057, g_robberyData[ robberyid ] [ E_DOOR_X ], g_robberyData[ robberyid ] [ E_DOOR_Y ], g_robberyData[ robberyid ] [ E_DOOR_Z ] );
				}

				g_robberyData[ robberyid ] [ E_STATE ]    = STATE_NONE;
				g_robberyData[ robberyid ] [ E_ROBTIMER ] = 0xFFFF;

				RemoveRobberyAttachments( robberyid );
				ControlRobberySafe( robberyid, true );
				createRobberyLootInstance( playerid, robberyid, type );

				CreateExplosionEx( g_robberyData[ robberyid ] [ E_DOOR_X ], g_robberyData[ robberyid ] [ E_DOOR_Y ], g_robberyData[ robberyid ] [ E_DOOR_Z ], 12, 0.0, g_robberyData[ robberyid ] [ E_WORLD ], -1 );
			}
		}

		case ROBBERY_TYPE_DRILL, ROBBERY_TYPE_LABOR:
		{
			g_robberyData[ robberyid ] [ E_STATE ]    = STATE_NONE;
			g_robberyData[ robberyid ] [ E_ROBTIMER ] = 0xFFFF;
			RemoveRobberyAttachments( robberyid );
			ControlRobberySafe( robberyid, true );
			createRobberyLootInstance( playerid, robberyid, type );
			if ( type == ROBBERY_TYPE_LABOR ) SetTimerEx( "handlePlayerRobbery", 1350, false, "ddd", playerid, KEY_WALK, KEY_SPRINT );
		}
	}

	if ( g_Debugging )
	{
		printf("[DEBUG] [ROBBERY] [%d] onSafeBust( %d, %d, %d, %d ) { open : %d, robbed : %d, c4: %d, drill : %d, dplacer : %d, deffect : %d, replenish : %d, raw ts : %d, current ts : %d, name : %s, velocity : %f, state : %d }",
				robberyid, playerid, robberyid, type, index,
				g_robberyData[ robberyid ] [ E_OPEN ], g_robberyData[ robberyid ] [ E_ROBBED ], g_robberyData[ robberyid ] [ E_C4 ],
				g_robberyData[ robberyid ] [ E_DRILL ], g_robberyData[ robberyid ] [ E_DRILL_PLACER ], g_robberyData[ robberyid ] [ E_DRILL_EFFECT ], g_robberyData[ robberyid ] [ E_ROB_TIME ] - g_iTime,
				g_robberyData[ robberyid ] [ E_ROB_TIME ], g_iTime, g_robberyData[ robberyid ] [ E_NAME ], g_robberyData[ robberyid ] [ E_VELOCITY ], g_robberyData[ robberyid ] [ E_STATE ] );
	}
}

stock ControlRobberySafe( rID, bool: open )
{
	static
		Float: Z;

	if (Iter_Contains(RobberyCount, rID))
	{
		GetDynamicObjectPos( g_robberyData[ rID ] [ E_SAFE_DOOR ], Z, Z, Z );

		if ( g_robberyData[ rID ] [ E_OPEN ] == true && open == true )
		{
			printf("[GM:WARNING] Safe %d was stopped from opening twice.", rID );
			return;
		}
		g_robberyData[ rID ] [ E_VELOCITY ] = 0.0; // Always will need this reset.

		if ( open )
		{
			// Must close it
			SetDynamicObjectPos( g_robberyData[ rID ] [ E_SAFE_DOOR ], g_robberyData[ rID ] [ E_DOOR_X ], g_robberyData[ rID ] [ E_DOOR_Y ], Z );
			SetDynamicObjectRot( g_robberyData[ rID ] [ E_SAFE_DOOR ], 0.0, 0.0, g_robberyData[ rID ] [ E_DOOR_ROT ] );
			SetTimerEx( "physicsOnSafeOpen", 30, false, "d", rID );
		}
		else
		{
			SetDynamicObjectPos( g_robberyData[ rID ] [ E_SAFE_DOOR ], g_robberyData[ rID ] [ E_DOOR_X ], g_robberyData[ rID ] [ E_DOOR_Y ], Z );
			SetDynamicObjectRot( g_robberyData[ rID ] [ E_SAFE_DOOR ], 0.0, 0.0, g_robberyData[ rID ] [ E_DOOR_ROT ] );
			g_robberyData[ rID ] [ E_OPEN ] = false;
		}

		if ( g_Debugging )
		{
			new robberyid = rID; printf("[DEBUG] [ROBBERY] [%d] ControlRobberySafe( %d, %d ) { open : %d, robbed : %d, c4: %d, drill : %d, dplacer : %d, deffect : %d, replenish : %d, raw ts : %d, current ts : %d, name : %s, velocity : %f, state : %d }",
					robberyid, rID, open,
					g_robberyData[ robberyid ] [ E_OPEN ], g_robberyData[ robberyid ] [ E_ROBBED ], g_robberyData[ robberyid ] [ E_C4 ],
					g_robberyData[ robberyid ] [ E_DRILL ], g_robberyData[ robberyid ] [ E_DRILL_PLACER ], g_robberyData[ robberyid ] [ E_DRILL_EFFECT ], g_robberyData[ robberyid ] [ E_ROB_TIME ] - g_iTime,
					g_robberyData[ robberyid ] [ E_ROB_TIME ], g_iTime, g_robberyData[ robberyid ] [ E_NAME ], g_robberyData[ robberyid ] [ E_VELOCITY ], g_robberyData[ robberyid ] [ E_STATE ] );
		}
	}
}

function physicsOnSafeOpen( rID )
{
	static
		Float: rZ;

	if ( g_robberyData[ rID ] [ E_VELOCITY ] >= 9.25 ) {
		g_robberyData[ rID ] [ E_OPEN ] = true;
		g_robberyData[ rID ] [ E_VELOCITY ] = 0.0;
		return 1;
	}

	g_robberyData[ rID ] [ E_VELOCITY ] += 120.0 / 300.0;
	GetDynamicObjectRot( g_robberyData[ rID ] [ E_SAFE_DOOR ], rZ, rZ, rZ );
	SetDynamicObjectRot( g_robberyData[ rID ] [ E_SAFE_DOOR ], 0.0, 0.0, rZ - g_robberyData[ rID ] [ E_VELOCITY ] );

	return SetTimerEx( "physicsOnSafeOpen", 30, false, "d", rID );
}

stock setSafeReplenished( rID )
{
	static
		Float: Z;

	if (Iter_Contains(RobberyCount, rID))
	{
		DestroyDynamicObject( g_robberyData[ rID ] [ E_SAFE_MONEY ] );

		g_robberyData[ rID ] [ E_ROBBED ] 		= false;
		g_robberyData[ rID ] [ E_ROBTIMER ] 	= 0xFFFF;
		g_robberyData[ rID ] [ E_DRILL_PLACER ] = INVALID_PLAYER_ID;
		g_robberyData[ rID ] [ E_DRILL_EFFECT ] = INVALID_OBJECT_ID;
		g_robberyData[ rID ] [ E_ROB_TIME ] 	= -1;
		g_robberyData[ rID ] [ E_ROBBED ] 		= false;
		g_robberyData[ rID ] [ E_STATE ] 		= STATE_NONE;
		g_robberyData[ rID ] [ E_OPEN ] 		= false;
		g_robberyData[ rID ] [ E_SAFE_MONEY ] 	= 0xFFFF;
		g_robberyData[ rID ] [ E_SAFE_LOOT ] 	= 0;

		StopDynamicObject( g_robberyData[ rID ] [ E_SAFE_DOOR ] );
		GetDynamicObjectPos( g_robberyData[ rID ] [ E_SAFE_DOOR ], Z, Z, Z );
		SetDynamicObjectPos( g_robberyData[ rID ] [ E_SAFE_DOOR ], g_robberyData[ rID ] [ E_DOOR_X ], g_robberyData[ rID ] [ E_DOOR_Y ], Z );
		SetDynamicObjectRot( g_robberyData[ rID ] [ E_SAFE_DOOR ], 0.0, 0.0, g_robberyData[ rID ] [ E_DOOR_ROT ] );

		if ( g_Debugging )
		{
			new robberyid = rID; printf("[DEBUG] [ROBBERY] [%d] setSafeReplenished( %d ) { open : %d, robbed : %d, c4: %d, drill : %d, dplacer : %d, deffect : %d, replenish : %d, raw ts : %d, current ts : %d, name : %s, velocity : %f, state : %d }",
					robberyid, rID,
					g_robberyData[ robberyid ] [ E_OPEN ], g_robberyData[ robberyid ] [ E_ROBBED ], g_robberyData[ robberyid ] [ E_C4 ],
					g_robberyData[ robberyid ] [ E_DRILL ], g_robberyData[ robberyid ] [ E_DRILL_PLACER ], g_robberyData[ robberyid ] [ E_DRILL_EFFECT ], g_robberyData[ robberyid ] [ E_ROB_TIME ] - g_iTime,
					g_robberyData[ robberyid ] [ E_ROB_TIME ], g_iTime, g_robberyData[ robberyid ] [ E_NAME ], g_robberyData[ robberyid ] [ E_VELOCITY ], g_robberyData[ robberyid ] [ E_STATE ] );
		   	//SendClientMessageToAdmins( -1, ""COL_ORANGE"[DEBUG]"COL_GREY" Robbery "COL_GREY"%s(%d)"COL_GREY" has been replenished!", g_robberyData[ rID ] [ E_NAME ], rID );
		}
	   	return 1;
	}
	printf( "[WARNING] Invalid safe %d is being set for replenishment.", rID );
	return 0;
}

stock haltRobbery( rID )
{
	KillTimer( g_robberyData[ rID ] [ E_ROBTIMER ] );

	g_robberyData[ rID ] [ E_ROBTIMER ] = 0xFFFF;

	RemoveRobberyAttachments( rID );

	if ( g_Debugging )
	{
		printf("[DEBUG] [ROBBERY] [%d] haltRobbery( %d ) { open : %d, robbed : %d, c4: %d, drill : %d, dplacer : %d, deffect : %d, replenish : %d, raw ts : %d, current ts : %d, name : %s, velocity : %f, state : %d }",
				robberyid, rID,
				g_robberyData[ robberyid ] [ E_OPEN ], g_robberyData[ robberyid ] [ E_ROBBED ], g_robberyData[ robberyid ] [ E_C4 ],
				g_robberyData[ robberyid ] [ E_DRILL ], g_robberyData[ robberyid ] [ E_DRILL_PLACER ], g_robberyData[ robberyid ] [ E_DRILL_EFFECT ], g_robberyData[ robberyid ] [ E_ROB_TIME ] - g_iTime,
				g_robberyData[ robberyid ] [ E_ROB_TIME ], g_iTime, g_robberyData[ robberyid ] [ E_NAME ], g_robberyData[ robberyid ] [ E_VELOCITY ], g_robberyData[ robberyid ] [ E_STATE ] );
	}
}

stock truncateDrills( playerid )
{
	foreach(new i : RobberyCount)
	{
		if ( g_robberyData[ i ] [ E_DRILL_PLACER ] == playerid )
			haltRobbery( i );
	}
}

stock IsPointToPoint(Float: fRadius, Float: fX1, Float: fY1, Float: fZ1, Float: fX2, Float: fY2, Float: fZ2)
    return ((-fRadius < floatabs(fX2 - fX1) < fRadius) && (-fRadius < floatabs(fY2 - fY1) < fRadius) && (-fRadius < floatabs(fZ2 - fZ1) < fRadius));

stock CreateBuyableVehicle( playerid, Model, Color1, Color2, Float: X, Float: Y, Float: Z, Float: Angle, Cost )
{
	new
		vID,
	    szString[ 300 ],
	    iCar = INVALID_VEHICLE_ID
	;

	if ( playerid != INVALID_PLAYER_ID && !IsPlayerConnected( playerid ) )
	    return INVALID_PLAYER_ID;

	for( vID = 0; vID < MAX_BUYABLE_VEHICLES; vID++ )
		if ( !g_vehicleData[ playerid ] [ vID ] [ E_CREATED ] ) break;

	if ( vID >= MAX_BUYABLE_VEHICLES )
		return -1;

	if ( g_vehicleData[ playerid ] [ vID ] [ E_CREATED ] )
	    return -1;

	if ( vID != -1 )
	{
		strcpy( g_vehicleData[ playerid ] [ vID ] [ E_PLATE ], "SF-CNR" );
		g_vehicleData[ playerid ] [ vID ] [ E_LOCKED ] = false;
		g_vehicleData[ playerid ] [ vID ] [ E_X ] = X;
		g_vehicleData[ playerid ] [ vID ] [ E_Y ] = Y;
		g_vehicleData[ playerid ] [ vID ] [ E_Z ] = Z;
		g_vehicleData[ playerid ] [ vID ] [ E_ANGLE ] = Angle;
		g_vehicleData[ playerid ] [ vID ] [ E_PRICE ] = Cost;
		g_vehicleData[ playerid ] [ vID ] [ E_COLOR ] [ 0 ] = Color1;
		g_vehicleData[ playerid ] [ vID ] [ E_COLOR ] [ 1 ] = Color2;
		g_vehicleData[ playerid ] [ vID ] [ E_CREATED ] = true;
		g_vehicleData[ playerid ] [ vID ] [ E_PRICE ] = Cost;
		g_vehicleData[ playerid ] [ vID ] [ E_MODEL ] = Model;
		g_vehicleData[ playerid ] [ vID ] [ E_PAINTJOB ] = 3;
		g_vehicleData[ playerid ] [ vID ] [ E_GARAGE ] = -1;
		g_vehicleData[ playerid ] [ vID ] [ E_OWNER_ID ] = p_AccountID[ playerid ];
		ResetBuyableVehicleMods( playerid, vID );
		iCar = CreateVehicle( Model, X, Y, Z, Angle, Color1, Color2, 999999999 );
		g_adminSpawnedCar{ iCar } = false;
		//GetVehicleParamsEx( iCar, engine, lights, alarm, doors, bonnet, boot, objective );
		//SetVehicleParamsEx( iCar, VEHICLE_PARAMS_OFF, lights, alarm, doors, bonnet, boot, objective );
		SetVehicleNumberPlate( iCar, "SF-CNR" );
		g_vehicleData[ playerid ] [ vID ] [ E_VEHICLE_ID ] = iCar;
		g_buyableVehicle{ iCar } = true;
		format( szString, sizeof( szString ), "INSERT INTO `VEHICLES` (`MODEL`,`LOCKED`,`X`,`Y`,`Z`,`ANGLE`,`COLOR1`,`COLOR2`,`PRICE`,`OWNER`,`PLATE`,`PAINTJOB`,`MODS`) VALUES (%d,0,%f,%f,%f,%f,%d,%d,%d,%d,'SF-CNR',3,'0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.')", Model, X, Y, Z, Angle, Color1, Color2, Cost, g_vehicleData[ playerid ] [ vID ] [ E_OWNER_ID ] );
		mysql_function_query( dbHandle, szString, true, "OnPlayerCreateBuyableVehicle", "dd", playerid, vID );

		p_OwnedVehicles[ playerid ] ++; // Append value
	}
	return vID;
}

thread OnPlayerCreateBuyableVehicle( playerid, slot )
{
	g_vehicleData[ playerid ] [ slot ] [ E_SQL_ID ] = cache_insert_id( );
	return 1;
}

stock ResetBuyableVehicleMods( playerid, id, fordestroy=1 )
{
	if ( id < 0 || id > MAX_BUYABLE_VEHICLES )
	    return;

	if ( !g_vehicleData[ playerid ] [ id ] [ E_CREATED ] )
	    return;

	for( new i = 0; i < MAX_CAR_MODS; i++ )
	{
		if ( !fordestroy && IsValidVehicle( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ] ) ) {
	        if ( isLegalCarMod( GetVehicleModel( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ] ), g_vehicleModifications[ playerid ] [ id ] [ i ] ) )
	            RemoveVehicleComponent( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], g_vehicleModifications[ playerid ] [ id ] [ i ] );
		}
		g_vehicleModifications[ playerid ] [ id ] [ i ] = 0;
	}

	format( szNormalString, sizeof( szNormalString ), "UPDATE `VEHICLES` SET `MODS`='0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.' WHERE `ID`=%d", g_vehicleData[ playerid ] [ id ] [ E_SQL_ID ] );
	mysql_single_query( szNormalString );
}

stock DestroyBuyableVehicle( playerid, vID, bool: db_remove = true )
{
	if ( vID < 0 || vID > MAX_BUYABLE_VEHICLES )
	    return 0;

	if ( playerid == INVALID_PLAYER_ID )
		return INVALID_PLAYER_ID;

	if ( !g_vehicleData[ playerid ] [ vID ] [ E_CREATED ] )
	    return 0;

	new
	    query[ 40 ]
	;

	if ( db_remove )
	{
	    SendClientMessage( playerid, -1, ""COL_PINK"[VEHICLE]"COL_WHITE" One of your vehicles has been destroyed.");
		p_OwnedVehicles[ playerid ] --;

		format( query, sizeof( query ), "DELETE FROM `VEHICLES` WHERE `ID`=%d", g_vehicleData[ playerid ] [ vID ] [ E_SQL_ID ] );
		mysql_single_query( query );

    	ResetBuyableVehicleMods( playerid, vID );
	}

#if ENABLE_COMPONENTS_SYSTEM == true
	// Reset vehicle component data
	DestroyVehicleCustomComponents( playerid, vID, db_remove );
#endif

	// Reset vehicle data
	g_vehicleData[ playerid ] [ vID ] [ E_OWNER_ID ] = 0;
	g_vehicleData[ playerid ] [ vID ] [ E_LOCKED ] = false;
	g_vehicleData[ playerid ] [ vID ] [ E_CREATED ] = false;
	g_buyableVehicle{ g_vehicleData[ playerid ] [ vID ] [ E_VEHICLE_ID ] } = false;
	DestroyVehicle( g_vehicleData[ playerid ] [ vID ] [ E_VEHICLE_ID ] );
    g_vehicleData[ playerid ] [ vID ] [ E_VEHICLE_ID ] = INVALID_VEHICLE_ID;
	return 1;
}

stock RespawnBuyableVehicle( samp_veh_id, occupantid = INVALID_PLAYER_ID )
{
	new playerid, id;
	new gravy = getVehicleSlotFromID( samp_veh_id, playerid, id );

	if ( gravy == -1 )
		return INVALID_VEHICLE_ID;

	if ( id == -1 && !g_vehicleData[ playerid ] [ id ] [ E_CREATED ] )
	    return INVALID_VEHICLE_ID;

	if ( !IsValidVehicle( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ] ) )
	    return INVALID_VEHICLE_ID; // If it aint working.

	new
		Float: beforeAngle,
		Float: Health,
		newVeh = INVALID_VEHICLE_ID
	;

	GetVehicleZAngle( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], beforeAngle );
	GetVehicleDamageStatus( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], panels, doors, lights, tires ); // Can't do this to restore health.
	GetVehicleHealth( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], Health );

	if ( ( newVeh = CreateVehicle( g_vehicleData[ playerid ] [ id ] [ E_MODEL ], g_vehicleData[ playerid ] [ id ] [ E_X ], g_vehicleData[ playerid ] [ id ] [ E_Y ], g_vehicleData[ playerid ] [ id ] [ E_Z ], g_vehicleData[ playerid ] [ id ] [ E_ANGLE ], g_vehicleData[ playerid ] [ id ] [ E_COLOR ] [ 0 ], g_vehicleData[ playerid ] [ id ] [ E_COLOR ] [ 1 ], 999999999 ) ) == INVALID_VEHICLE_ID ) {
	    printf( "[ERROR] CreateVehicle(%d, %f, %f, %f, %f, %d, %d, %d);", g_vehicleData[ playerid ] [ id ] [ E_MODEL ], g_vehicleData[ playerid ] [ id ] [ E_X ], g_vehicleData[ playerid ] [ id ] [ E_Y ], g_vehicleData[ playerid ] [ id ] [ E_Z ], g_vehicleData[ playerid ] [ id ] [ E_ANGLE ], g_vehicleData[ playerid ] [ id ] [ E_COLOR ] [ 0 ], g_vehicleData[ playerid ] [ id ] [ E_COLOR ] [ 1 ], 999999999 );
		return SendError( playerid, "Couldn't update vehicle due to a unknown error." );
	}

	// Reset special data
    ResetVehicleMethlabData( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], true );

    // Destroy vehicle
	DestroyVehicle( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ] );
	g_buyableVehicle{ g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ] } = false;
	g_buyableVehicle{ newVeh } = true;
 	g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ] = newVeh;

	// Restore old data
	SetVehicleNumberPlate( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], g_vehicleData[ playerid ] [ id ] [ E_PLATE ] );
	ChangeVehiclePaintjob( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], g_vehicleData[ playerid ] [ id ] [ E_PAINTJOB ] );
	for( new i = 0; i < MAX_CAR_MODS; i++ ) {
	    if ( g_vehicleModifications[ playerid ] [ id ] [ i ] >= 1000 && g_vehicleModifications[ playerid ] [ id ] [ i ] < 1193 )
	    {
	        if ( isLegalCarMod( GetVehicleModel( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ] ), g_vehicleModifications[ playerid ] [ id ] [ i ] ) )
	            AddVehicleComponent( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], g_vehicleModifications[ playerid ] [ id ] [ i ] );
			else
			    g_vehicleModifications[ playerid ] [ id ] [ i ] = 0;
	    }
	}

	UpdateVehicleDamageStatus( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], panels, doors, lights, tires );
	SetVehicleHealth( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], Health );

	if ( g_vehicleData[ playerid ] [ id ] [ E_GARAGE ] != -1 ) {
		LinkVehicleToInterior( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], g_garageInteriorData[ g_garageData[ g_vehicleData[ playerid ] [ id ] [ E_GARAGE ] ] [ E_INTERIOR_ID ] ] [ E_INTERIOR ] );
		SetVehicleVirtualWorld( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], g_garageData[ g_vehicleData[ playerid ] [ id ] [ E_GARAGE ] ] [ E_WORLD ] );
	}

	if ( occupantid != INVALID_PLAYER_ID ) // So nothing bugs with /v color
	{
	    new Float: X, Float: Y, Float: Z;
	    SyncSpectation( playerid ); // Bug?
	    GetPlayerPos( occupantid, X, Y, Z );
	    SetVehiclePos( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], X, Y, Z + 1 );
	    LinkVehicleToInterior( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], GetPlayerInterior( playerid ) );
	    SetVehicleVirtualWorld( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], GetPlayerVirtualWorld( playerid ) );
	    SetTimerEx( "timedUpdates_RBV", 50, false, "ddf", occupantid, g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], beforeAngle );
	}

#if ENABLE_COMPONENTS_SYSTEM == true
	// Replace components
	ReplaceVehicleCustomComponents( playerid, id );
#endif

	if ( !g_vehicleData[ playerid ] [ id ] [ E_OWNER_ID ] ) {
		GetVehicleParamsEx( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], engine, lights, alarm, doors, bonnet, boot, objective );
		SetVehicleParamsEx( g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ], VEHICLE_PARAMS_OFF, lights, alarm, doors, bonnet, boot, objective );
	}

	return g_vehicleData[ playerid ] [ id ] [ E_VEHICLE_ID ];
}

function timedUpdates_RBV( playerid, vehicleid, Float: angle ) {
	if ( vehicleid != INVALID_VEHICLE_ID )
		SetVehicleZAngle( vehicleid, angle );
}

stock SaveVehicleData( playerid, vID )
{
	if ( vID == -1 )
	    return 0;

	new
		szPlate[ 32 ];

	// Plate System
	if ( isnull( g_vehicleData[ playerid ] [ vID ] [ E_PLATE ] ) )
		szPlate = "SF-CNR";
	else
		strcat( szPlate, g_vehicleData[ playerid ] [ vID ] [ E_PLATE ] );

	// Begin Saving
	format( szLargeString, sizeof( szLargeString ), "UPDATE `VEHICLES` SET `MODEL`=%d,`LOCKED`=%d,`X`=%f,`Y`=%f,`Z`=%f,`ANGLE`=%f,`COLOR1`=%d,`COLOR2`=%d,`PRICE`=%d,`PAINTJOB`=%d,`OWNER`=%d,`PLATE`='%s',`GARAGE`=%d WHERE `ID`=%d",
	    g_vehicleData[ playerid ] [ vID ] [ E_MODEL ], g_vehicleData[ playerid ] [ vID ] [ E_LOCKED ], g_vehicleData[ playerid ] [ vID ] [ E_X ], g_vehicleData[ playerid ] [ vID ] [ E_Y ], g_vehicleData[ playerid ] [ vID ] [ E_Z ],
	    g_vehicleData[ playerid ] [ vID ] [ E_ANGLE ], g_vehicleData[ playerid ] [ vID ] [ E_COLOR ] [ 0 ], g_vehicleData[ playerid ] [ vID ] [ E_COLOR ] [ 1 ], g_vehicleData[ playerid ] [ vID ] [ E_PRICE ], g_vehicleData[ playerid ] [ vID ] [ E_PAINTJOB ],
		g_vehicleData[ playerid ] [ vID ] [ E_OWNER_ID ], mysql_escape( szPlate ), g_vehicleData[ playerid ] [ vID ] [ E_GARAGE ],
		g_vehicleData[ playerid ] [ vID ] [ E_SQL_ID ] );

	mysql_single_query( szLargeString );
	return 1;
}

stock dischargeVehicles( playerid )
{
	if ( p_OwnedVehicles[ playerid ] )
	{
		for( new v; v < MAX_BUYABLE_VEHICLES; v++ )
	 		DestroyBuyableVehicle( playerid, v, .db_remove = false );
	}
	return 1;
}

thread OnVehicleLoad( playerid )
{
	if ( !IsPlayerConnected( playerid ) )
		return 0;

	new
		rows, fields, i = -1, vID,
		Query[ 76 ]
	;

	cache_get_data( rows, fields );
	if ( rows )
	{
		while( ++i < rows )
		{
			for( vID = 0; vID < MAX_BUYABLE_VEHICLES; vID++ )
				if ( !g_vehicleData[ playerid ] [ vID ] [ E_CREATED ] ) break;

			if ( vID >= MAX_BUYABLE_VEHICLES )
				continue;

			if ( g_vehicleData[ playerid ] [ vID ] [ E_CREATED ] )
			    continue;

			cache_get_field_content( i, "PLATE", g_vehicleData[ playerid ] [ vID ] [ E_PLATE ], dbHandle, 32 );
			cache_get_field_content( i, "MODS", Query ), sscanf( Query, "p<.>e<ddddddddddddddd>", g_vehicleModifications[ playerid ] [ vID ] );

			g_vehicleData[ playerid ] [ vID ] [ E_SQL_ID ] 		= cache_get_field_content_int( i, "ID", dbHandle );
			g_vehicleData[ playerid ] [ vID ] [ E_OWNER_ID ] 	= cache_get_field_content_int( i, "OWNER", dbHandle );
			g_vehicleData[ playerid ] [ vID ] [ E_MODEL ] 		= cache_get_field_content_int( i, "MODEL", dbHandle );
			g_vehicleData[ playerid ] [ vID ] [ E_LOCKED ] 		= !!cache_get_field_content_int( i, "LOCKED", dbHandle );
			g_vehicleData[ playerid ] [ vID ] [ E_X ] 			= cache_get_field_content_float( i, "X", dbHandle );
			g_vehicleData[ playerid ] [ vID ] [ E_Y ] 			= cache_get_field_content_float( i, "Y", dbHandle );
			g_vehicleData[ playerid ] [ vID ] [ E_Z ] 			= cache_get_field_content_float( i, "Z", dbHandle );
			g_vehicleData[ playerid ] [ vID ] [ E_ANGLE ] 		= cache_get_field_content_float( i, "ANGLE", dbHandle );
			g_vehicleData[ playerid ] [ vID ] [ E_COLOR ] [ 0 ] = cache_get_field_content_int( i, "COLOR1", dbHandle );
			g_vehicleData[ playerid ] [ vID ] [ E_COLOR ] [ 1 ] = cache_get_field_content_int( i, "COLOR2", dbHandle );
			g_vehicleData[ playerid ] [ vID ] [ E_PRICE ] 		= cache_get_field_content_int( i, "PRICE", dbHandle );
			g_vehicleData[ playerid ] [ vID ] [ E_PAINTJOB ] 	= cache_get_field_content_int( i, "PAINTJOB", dbHandle );
			g_vehicleData[ playerid ] [ vID ] [ E_GARAGE ] 		= cache_get_field_content_int( i, "GARAGE", dbHandle );

			new iVehicle = CreateVehicle( g_vehicleData[ playerid ] [ vID ] [ E_MODEL ], g_vehicleData[ playerid ] [ vID ] [ E_X ], g_vehicleData[ playerid ] [ vID ] [ E_Y ], g_vehicleData[ playerid ] [ vID ] [ E_Z ], g_vehicleData[ playerid ] [ vID ] [ E_ANGLE ], g_vehicleData[ playerid ] [ vID ] [ E_COLOR ] [ 0 ], g_vehicleData[ playerid ] [ vID ] [ E_COLOR ] [ 1 ], 999 );
		    g_vehicleData[ playerid ] [ vID ] [ E_VEHICLE_ID ] = iVehicle;

			if ( iVehicle != INVALID_VEHICLE_ID ) {
				if ( g_vehicleData[ playerid ] [ vID ] [ E_GARAGE ] != -1 ) {
					LinkVehicleToInterior( g_vehicleData[ playerid ] [ vID ] [ E_VEHICLE_ID ], g_garageInteriorData[ g_garageData[ g_vehicleData[ playerid ] [ vID ] [ E_GARAGE ] ] [ E_INTERIOR_ID ] ] [ E_INTERIOR ] );
					SetVehicleVirtualWorld( g_vehicleData[ playerid ] [ vID ] [ E_VEHICLE_ID ], g_garageData[ g_vehicleData[ playerid ] [ vID ] [ E_GARAGE ] ] [ E_WORLD ] );
				}

				SetVehicleNumberPlate( g_vehicleData[ playerid ] [ vID ] [ E_VEHICLE_ID ], g_vehicleData[ playerid ] [ vID ] [ E_PLATE ] );
				ChangeVehiclePaintjob( g_vehicleData[ playerid ] [ vID ] [ E_VEHICLE_ID ], g_vehicleData[ playerid ] [ vID ] [ E_PAINTJOB ] );
				for( new x = 0; x < MAX_CAR_MODS; x++ )
				{
					if ( g_vehicleModifications[ playerid ] [ vID ] [ x ] >= 1000 && g_vehicleModifications[ playerid ] [ vID ] [ x ] < 1193 )
					{
					    if ( isLegalCarMod( GetVehicleModel( g_vehicleData[ playerid ] [ vID ] [ E_VEHICLE_ID ] ), g_vehicleModifications[ playerid ] [ vID ] [ x ] ) )
					        AddVehicleComponent( g_vehicleData[ playerid ] [ vID ] [ E_VEHICLE_ID ], g_vehicleModifications[ playerid ] [ vID ] [ x ] );
						else
						    g_vehicleModifications[ playerid ] [ vID ] [ x ] = 0;
					}
				}
				g_adminSpawnedCar{ g_vehicleData[ playerid ] [ vID ] [ E_VEHICLE_ID ] } = false;
				g_buyableVehicle{ g_vehicleData[ playerid ] [ vID ] [ E_VEHICLE_ID ] } = true;
			}

		    g_vehicleData[ playerid ] [ vID ] [ E_CREATED ] = true;

			// Load vehicle components
			format( szNormalString, sizeof( szNormalString ), "SELECT * FROM `COMPONENTS` WHERE `VEHICLE_ID`=%d", g_vehicleData[ playerid ] [ vID ] [ E_SQL_ID ] );
			mysql_function_query( dbHandle, szNormalString, true, "OnVehicleComponentsLoad", "dd", playerid, vID );
		}

		p_OwnedVehicles[ playerid ] = rows;
	}
	return 1;
}

stock GetXYInFrontOfPlayer(playerid, &Float:x, &Float:y, &Float:z, Float:distance)
{
	new Float: a;
    GetPlayerPos(playerid, x, y, z);
    GetPlayerFacingAngle(playerid, a);
    if (GetPlayerVehicleID( playerid ))
    {
    	GetVehicleZAngle(GetPlayerVehicleID( playerid ), a);
 	}
 	x += (distance * floatsin(-a, degrees));
	y += (distance * floatcos(-a, degrees));
}

stock getRoadBlockSlot( )
{
	for( new i; i < MAX_ROADBLOCKS; i++ )
	{
	    if ( !g_roadblockData[ i ] [ E_CREATED ] )
	        return i;
	}
	return -1;
}

stock destroyRoadBlockStrip( rbid )
{
	if ( rbid == -1 && !g_roadblockData[ rbid ] [ E_CREATED ] )
	    return 0;

	DestroyDynamicObject( g_roadblockData[ rbid ] [ E_OBJECT_ID ] );
	DestroyDynamic3DTextLabel( g_roadblockData[ rbid ] [ E_LABEL ] );

	g_roadblockData[ rbid ] [ E_CREATED ] 	= false;
	g_roadblockData[ rbid ] [ E_LABEL ] 	= Text3D: 0xFFFF;
	g_roadblockData[ rbid ] [ E_OBJECT_ID ] = INVALID_OBJECT_ID;
	return 1;
}

stock createRoadBlockStrip( playerid, type )
{
	new
 		ID = getRoadBlockSlot( ),
		Float: X, Float: Y, Float: Z, Float: Degree
	;

	if ( ID != -1 )
	{
	    GetXYInFrontOfPlayer( playerid, X, Y, Z, 2.0 );
		GetPlayerFacingAngle( playerid, Degree );

		DestroyDynamicObject( g_roadblockData[ ID ] [ E_OBJECT_ID ] );
		DestroyDynamic3DTextLabel( g_roadblockData[ ID ] [ E_LABEL ] );

		g_roadblockData[ ID ] [ E_OBJECT_ID ] = CreateDynamicObject( g_roadblockObjectData[ type ] [ E_MODEL ], X, Y, Z - g_roadblockObjectData[ type ] [ E_OFFSET ], 0, 0, Degree + 180.0 );
		g_roadblockData[ ID ] [ E_LABEL ] = CreateDynamic3DTextLabel( sprintf( "%s(%d)\n"COL_GREY"Placed by %s!", g_roadblockObjectData[ type ] [ E_NAME ], ID, ReturnPlayerName( playerid ) ), COLOR_GOLD, X, Y, Z, 20.0 );
		g_roadblockData[ ID ] [ E_CREATED ] = true;

		SyncObject( playerid );
	}
	return ID;
}

stock ChangeVehicleModel( vehicleid, objectid, Float: offset = 0.0 )
{
	new
		iObject
	;
	iObject = CreateDynamicObject( objectid, 0.0, 0.0, 0.0, 0, 0, 0 );
	AttachDynamicObjectToVehicle( iObject, vehicleid, 0, 0, 0, 0, 0, 0 + offset );
	LinkVehicleToInterior( vehicleid, 12 );
}

stock SetObjectFacePoint(iObjectID, Float: fX, Float: fY, Float: fOffset, bool: bDynamic = false )
{
    new
        Float: fOX,
        Float: fOY,
        Float: fRZ
    ;
    if ( bDynamic )
    {
	    if (GetDynamicObjectPos(iObjectID, fOX, fOY, fRZ))
	    {
	        fRZ = atan2(fY - fOY, fX - fOX) - 90.0;

	        GetDynamicObjectRot(iObjectID, fX, fY, fOX);
	        SetDynamicObjectRot(iObjectID, fX, fY, fRZ + fOffset);
	    }
	}
	else
	{
	    if (GetObjectPos(iObjectID, fOX, fOY, fRZ))
	    {
	        fRZ = atan2(fY - fOY, fX - fOX) - 90.0;

	        GetObjectRot(iObjectID, fX, fY, fOX);
	        SetObjectRot(iObjectID, fX, fY, fRZ + fOffset);
	    }
	}
}

stock destroySpikeStrip( i )
{
	if ( i == -1 )
	    return 0;

	DestroyDynamicArea			( g_spikestripData[ i ] [ E_SPHERE ] );
	DestroyDynamicObject		( g_spikestripData[ i ] [ E_OBJECT_ID ] );
	DestroyDynamic3DTextLabel	( g_spikestripData[ i ] [ E_LABEL ] );

	g_spikestripData[ i ] [ E_SPHERE ]		= 0xFFFF;
	g_spikestripData[ i ] [ E_OBJECT_ID ]	= INVALID_OBJECT_ID;
	g_spikestripData[ i ] [ E_LABEL ]		= Text3D: 0xFFFF;

	Iter_Remove(SpikeStrip, i);
	return 1;
}

stock CreateSpikeStrip( playerid, Float: X, Float: Y, Float: Z, Float: Angle )
{
	new
		bVehicle = IsPlayerInAnyVehicle( playerid ),
		i = Iter_Free(SpikeStrip)
	;

	if ( i != ITER_NONE )
	{
		DestroyDynamicArea			( g_spikestripData[ i ] [ E_SPHERE ] );
		DestroyDynamicObject		( g_spikestripData[ i ] [ E_OBJECT_ID ] );
		DestroyDynamic3DTextLabel	( g_spikestripData[ i ] [ E_LABEL ] );

		g_spikestripData[ i ] [ E_LABEL ] = CreateDynamic3DTextLabel( sprintf( "Spike Strip(%d)\n"COL_GREY"Placed by %s!", i, ReturnPlayerName( playerid ) ), COLOR_GOLD, X, Y, Z, 20.0 );
	    g_spikestripData[ i ] [ E_OBJECT_ID ] = CreateDynamicObject( 2899, X, Y, Z - ( bVehicle ? 0.6 : 0.9 ), 0, 0, Angle - 90.0);
		g_spikestripData[ i ] [ E_SPHERE ] = CreateDynamicCircle( X, Y, 4.0 );

	    if ( !bVehicle )
	    	SyncObject( playerid ); // Shows the object instantly.

	    Iter_Add(SpikeStrip, i);
	}
  	return i;
}

stock encode_tires( tires1, tires2, tires3, tires4 )
	return tires1 | (tires2 << 1) | (tires3 << 2) | (tires4 << 3);

stock TimeConvert( seconds )
{
	static
	    szTime[ 32 ]
	;
 	format( szTime, sizeof( szTime ), "%02d:%02d", floatround( seconds / 60 ), seconds - floatround( ( seconds / 60 ) * 60 ) );
	return szTime;
}

stock getRandomCreatedHouse( fire_mode = 0 )
{
	new
		iRandom, count
	;
	for( new i; i < MAX_HOUSES; i++ )
	{
	    if ( g_houseData[ i ] [ E_CREATED ] == true ) count ++;
	}
	redo_random_hcount:
	iRandom = random( count );
	if ( !g_houseData[ iRandom ] [ E_CREATED ] ) goto redo_random_hcount;
	if ( fire_mode )
	{
		static
			szCity[ MAX_ZONE_NAME ];

        for( new h; h < sizeof( g_fireData ); h ++ ) {
            if ( g_fireData[ h ] [ E_CREATED ] ) {
	        	if ( g_fireData[ h ] [ E_HOUSE ] == iRandom ) { goto redo_random_hcount; }
			}
		}

		// Avoid Hills
		if ( g_houseData[ iRandom ] [ E_EZ ] > 300.0 ) goto redo_random_hcount;
		if ( g_houseData[ iRandom ] [ E_COST ] < 500000 ) goto redo_random_hcount;

		// San Fierro only
		Get2DCity( szCity, g_houseData[ iRandom ] [ E_EX ], g_houseData[ iRandom ] [ E_EY ], g_houseData[ iRandom ] [ E_EZ ] );
		if ( !strmatch( szCity, "San Fierro" ) ) goto redo_random_hcount;
	}
	return iRandom;
}

stock SetPlayerFacePoint(playerid, Float: fX, Float: fY, Float: offset = 0.0)
{
    static
        Float: X,
        Float: Y,
        Float: Z,
        Float: face
    ;
    if (GetPlayerPos(playerid, X, Y, Z))
    {
        face = atan2(fY - Y, fX - X) - 90.0;
        SetPlayerFacingAngle(playerid, face + offset);
    }
}

stock GetClosestPlayer( playerid, &Float: distance = FLOAT_INFINITY ) {
    new
    	iCurrent = INVALID_PLAYER_ID,
        Float: fX, Float: fY,  Float: fZ, Float: fTmp,
        world = GetPlayerVirtualWorld( playerid )
    ;

    if ( GetPlayerPos( playerid, fX, fY, fZ ) )
    {
		foreach(new i : Player)
		{
			if ( i != playerid )
			{
		        if ( GetPlayerState( i ) != PLAYER_STATE_SPECTATING && GetPlayerVirtualWorld( i ) == world )
		        {
		            if ( 0.0 < ( fTmp = GetDistanceFromPlayerSquared( i, fX, fY, fZ ) ) < distance ) // Y_Less mentioned there's no need to sqroot
		            {
		                distance = fTmp;
		                iCurrent = i;
		            }
		        }
			}
	    }
    }
    return iCurrent;
}

stock GetClosestPlayerEx( playerid, classid, &Float: distance = FLOAT_INFINITY ) {
    new
    	iCurrent = INVALID_PLAYER_ID,
        Float: fX, Float: fY,  Float: fZ, Float: fTmp,
        world = GetPlayerVirtualWorld( playerid )
    ;

    if ( GetPlayerPos( playerid, fX, fY, fZ ) )
    {
		foreach(new i : Player)
		{
			if ( i != playerid )
			{
		        if ( GetPlayerState( i ) != PLAYER_STATE_SPECTATING && GetPlayerVirtualWorld( i ) == world && p_Class[ i ] == classid )
		        {
		            if ( 0.0 < ( fTmp = GetPlayerDistanceFromPoint( i, fX, fY, fZ ) ) < distance )
		            {
		                distance = fTmp;
		                iCurrent = i;
		            }
		        }
			}
	    }
    }
    return iCurrent;
}

stock GetClosestVehicle(playerid, except = INVALID_VEHICLE_ID, &Float: distance = Float: 0x7F800000) {
    new
    	i,
        Float: X,
        Float: Y,
        Float: Z
    ;
    if (GetPlayerPos(playerid, X, Y, Z)) {
        new
            Float: dis,
            closest = INVALID_VEHICLE_ID
        ;
        while(i != MAX_VEHICLES) {
            if (0.0 < (dis = GetVehicleDistanceFromPoint(++i, X, Y, Z)) < distance && i != except) {
                distance = dis;
                closest = i;
            }
        }
        return closest;
    }
    return INVALID_VEHICLE_ID;
}

stock textContainsIP(const string[])
{
    static
        RegEx:rCIP
    ;

    if ( !rCIP )
    {
        rCIP = regex_build("(.*?)([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})(.*?)");
    }

    return regex_match_exid(string, rCIP);
}

stock textContainsURL(const string[])
{
    static
        RegEx:rCIP
    ;

    if ( !rCIP )
    {
        rCIP = regex_build("([\\w-]*://)?([\\w-]+\\.)+([\\w-]+)(/[^\\s]*)*");
    }

    return regex_match_exid(string, rCIP);
}

stock isValidPlayerName( szName[ ] )
{
	strreplacechar( szName, '\\', '-' );
	//strreplacechar( szName, '.', '-' );
	strreplacechar( szName, '/', '-' );

	if ( strmatch( szName, SECURE_TRUCK_DRIVER_NAME ) )
		return false;

	if( !( 2 < strlen( szName ) < MAX_PLAYER_NAME ) )
		return false;

	return regex_match( szName, "^[a-zA-Z0-9@=_\\[\\]\\.\\(\\)\\$]+$" );
}

stock ReturnWeaponName(weaponid, bool:vipgun=false)
{
	static wname[24];
	switch(weaponid) {
	    case 0: wname = "Fist";
		case 18: wname = "Molotovs";
		case 40: wname = "Detonator";
		case 44: wname = "Nightvision Goggles";
		case 45: wname = "Thermal Goggles";
		case 51: wname = "Explosion";
		case 53: wname = "Drowned";
		case 54: wname = "Collision";
		default: GetWeaponName(weaponid, wname, sizeof(wname));
	}
	if ( weaponid == 0 && vipgun == true ) wname = "Nothing";
	return wname;
}

stock ReturnGangName( i )
{
	static
		szGang[ 30 ];
	if ( i == INVALID_GANG_ID || !Iter_Contains( gangs, i ) ) szGang = "Unoccupied";
	else format( szGang, sizeof( szGang ), "%s", g_gangData[ i ] [ E_NAME ] );
	return szGang;
}

stock IsPlayerInArea( playerid, Float: minx, Float: maxx, Float: miny, Float: maxy )
{
	static
		Float: X, Float: Y, Float: Z;

	if ( GetPlayerPos( playerid, X, Y, Z ) )
		return ( X > minx && X < maxx && Y > miny && Y < maxy );

	return 0;
}

stock IsPlayerInArea3D( playerid, Float: minx, Float: maxx, Float: miny, Float: maxy, Float: minz, Float: maxz )
{
	static Float: X, Float: Y, Float: Z;
	GetPlayerPos( playerid, X, Y, Z );
	return ( X > minx && X < maxx && Y > miny && Y < maxy && Z > minz && Z < maxz );
}

stock IsPointInArea( Float: X, Float: Y, Float: Z, Float: minx, Float: maxx, Float: miny, Float: maxy, Float: minz, Float: maxz )
 	return ( X > minx && X < maxx && Y > miny && Y < maxy && Z > minz && Z < maxz );

stock GetPlayersInGangZone( z, g, &is_afk = 0, &in_air = 0 )
{
	new
	    count = 0, Float: Z
	;

	foreach(new i : Player)
	{
		if ( p_Class[ i ] == CLASS_CIVILIAN && p_GangID[ i ] == g && IsPlayerInArea( i, g_gangzoneData[ z ] [ E_MIN_X ], g_gangzoneData[ z ] [ E_MAX_X ], g_gangzoneData[ z ] [ E_MIN_Y ], g_gangzoneData[ z ] [ E_MAX_Y ] ) && GetPlayerState( i ) != PLAYER_STATE_SPECTATING )
		{
            if ( IsPlayerAFK( i ) )
            {
            	is_afk++;
            	continue;
            }
            if ( GetPlayerPos( i, Z, Z, Z ) && Z >= 300.0 )
            {
            	in_air++;
            	continue;
            }
            count++;
		}
	}
	return count;
}

stock CreateGang( szName[ ], playerid )
{
	if ( !IsPlayerConnected( playerid ) )
		return -1;

	new
	    ID = Iter_Free(gangs)
	;

	if ( ID != ITER_NONE )
	{
		new
			color = g_gangColors[ random( sizeof( g_gangColors ) ) ];

		format( g_gangData[ ID ] [ E_NAME ], 30, "%s", szName );

	    g_gangData[ ID ] [ E_LEADER ] 			= p_AccountID[ playerid ];
	    g_gangData[ ID ] [ E_KILLS ] 			= 1;
	    g_gangData[ ID ] [ E_DEATHS ] 			= 1;
	    g_gangData[ ID ] [ E_SCORE ] 			= 0;
	    g_gangData[ ID ] [ E_BANK ] 			= 0;
	    g_gangData[ ID ] [ E_COLOR ]        	= color;
		g_gangData[ ID ] [ E_INVITE_ONLY ] 		= false;
		g_gangData[ ID ] [ E_JOIN_MSG ] [ 0 ] 	= '\0';

		for ( new i = 0; i < MAX_COLEADERS; i ++ )
			g_gangData[ ID ] [ E_COLEADER ] [ i ] = 0;

	    p_GangID[ playerid ] = ID;

	    if ( p_WantedLevel[ playerid ] == 0 && p_AdminOnDuty{ playerid } == false )
	    	SetPlayerColor( playerid, g_gangData[ ID ] [ E_COLOR ] );

	    SendClientMessageToGang( ID, g_gangData[ p_GangID[ playerid ] ] [ E_COLOR ], "[GANG]{FFFFFF} You have created the gang: %s(%d)", szName, ID );

		// Insert gang to db
		mysql_function_query( dbHandle, sprintf( "INSERT INTO `GANGS`(`NAME`,`LEADER`,`COLOR`) VALUES ('%s', %d, %d)", g_gangData[ ID ] [ E_NAME ], p_AccountID[ playerid ], color ), true, "OnGangAdded", "d", ID );

		// Insert into iterator
	    Iter_Add(gangs, ID);
	}
	return ID;
}

thread OnGangAdded( gangid )
{
	g_gangData[ gangid ] [ E_SQL_ID ] = cache_insert_id( );
	return 1;
}

thread OnGangLoad( playerid )
{
	new
		rows, fields, i;

	cache_get_data( rows, fields );

	if ( rows )
	{
		new
			gang_sql_id = cache_get_field_content_int( 0, "ID" ),
			id = Iter_Free(gangs)
		;

		// Check again if the gang exists
		foreach (new g : gangs) if ( gang_sql_id == g_gangData[ g ] [ E_SQL_ID ] ) {
			p_GangID[ playerid ] = g;
			SendServerMessage( playerid, "[DEBUG] The server has found your gang, %s, as a duplicate (id %d)", g_gangData[ id ] [ E_NAME ], gang_sql_id );
			printf( "[gang debug] found duplicate gang for gang id %d (User : %s)", g, ReturnPlayerName( playerid ) );
			return InformGangConnectMessage( playerid, g ), 1;
		}

		if ( id != -1 )
		{
			// Load data into variables
			cache_get_field_content( 0, "NAME", g_gangData[ id ] [ E_NAME ], dbHandle, 30 );
			cache_get_field_content( 0, "JOIN_MSG", g_gangData[ id ] [ E_JOIN_MSG ], dbHandle, 96 );
			g_gangData[ id ] [ E_SQL_ID ] = gang_sql_id;
			g_gangData[ id ] [ E_LEADER ] = cache_get_field_content_int( 0, "LEADER", dbHandle );
			g_gangData[ id ] [ E_COLOR ] = cache_get_field_content_int( 0, "COLOR", dbHandle );
			g_gangData[ id ] [ E_KILLS ] = cache_get_field_content_int( 0, "KILLS", dbHandle );
			g_gangData[ id ] [ E_BANK ] = cache_get_field_content_int( 0, "BANK", dbHandle );
			g_gangData[ id ] [ E_DEATHS ] = cache_get_field_content_int( 0, "DEATHS", dbHandle );
			g_gangData[ id ] [ E_SCORE ] = cache_get_field_content_int( 0, "SCORE", dbHandle );
			g_gangData[ id ] [ E_INVITE_ONLY ] = !!cache_get_field_content_int( 0, "INVITE_ONLY", dbHandle );

			// Set to '\0' instead of null
			if ( ismysqlnull( g_gangData[ id ] [ E_JOIN_MSG ] ) ) {
				g_gangData[ id ] [ E_JOIN_MSG ] [ 0 ] = '\0';
			}

			// Throw the user in
			p_GangID[ playerid ] = id;

			// Load coleaders
			format( szNormalString, sizeof( szNormalString ), "SELECT `USER_ID` FROM `GANG_COLEADERS` WHERE `GANG_ID`=%d LIMIT 0,%d", g_gangData[ id ] [ E_SQL_ID ], MAX_COLEADERS );
			mysql_function_query( dbHandle, szNormalString, true, "OnGangColeaderLoad", "d", id );

			// Declare saved gang
			Iter_Add(gangs, id);

			// Message player
			SendServerMessage( playerid, "[DEBUG] The server has added your gang, %s, in (id %d)", g_gangData[ id ] [ E_NAME ], gang_sql_id );
			InformGangConnectMessage( playerid, id );
		}
		else {
			SendServerMessage( playerid, "Had an issue loading your gang. Contact Lorenc (0x92F)." );
			printf("[EXCEPTION] Had an issue loading a gang row id %d", i );
		}
	}
	else
	{
		p_GangID[ playerid ] = -1;
	}
	return 1;
}

thread OnGangColeaderLoad( gangid ) {

	new
		rows, fields;

	cache_get_data( rows, fields );

	if ( rows ) {
		for( new i = 0; i < rows; i ++ ) if ( i < MAX_COLEADERS ) {
			g_gangData[ gangid ] [ E_COLEADER ] [ i ] = cache_get_field_content_int( i, "USER_ID", dbHandle );
		}
	}
}

stock InformGangConnectMessage( playerid, gangid )
{
	if ( ! strlen( g_gangData[ gangid ] [ E_JOIN_MSG ] ) ) {
  		SendClientMessageFormatted( playerid, g_gangData[ gangid ] [ E_COLOR ], "[GANG]"COL_GREY" %s has been loaded into the server.", g_gangData[ gangid ] [ E_NAME ] );
	} else {
  		SendClientMessageFormatted( playerid, g_gangData[ gangid ] [ E_COLOR ], "[GANG]"COL_GREY" %s", g_gangData[ gangid ] [ E_JOIN_MSG ] );
	}
	return 1;
}

stock DestroyGang( gangid )
{
	if ( !Iter_Contains( gangs, gangid ) )
		return;

 	// Do SQL operations
 	mysql_single_query( sprintf( "DELETE FROM `GANGS` WHERE `ID`=%d", g_gangData[ gangid ] [ E_SQL_ID ] ) );
 	mysql_single_query( sprintf( "DELETE FROM `GANG_COLEADERS` WHERE `ID`=%d", g_gangData[ gangid ] [ E_SQL_ID ] ) );
 	mysql_single_query( sprintf( "UPDATE `USERS` SET `GANG_ID`=-1 WHERE `GANG_ID`=%d", g_gangData[ gangid ] [ E_SQL_ID ] ) );

 	// Disconnect current users
 	foreach(new i : Player) if ( p_GangID[ i ] == gangid ) {
 		p_GangID[ i ] = INVALID_GANG_ID;
 	}

	// Reset gang data
	g_gangData[ gangid ] [ E_SQL_ID ] 			= 0;
    g_gangData[ gangid ] [ E_LEADER ] 			= 0;
 	g_gangData[ gangid ] [ E_COLOR ]       	 	= COLOR_GANGZONE;
 	g_gangData[ gangid ] [ E_NAME ] [ 0 ]   	= '\0';
 	g_gangData[ gangid ] [ E_BANK ] 			= 0;
	g_gangData[ gangid ] [ E_INVITE_ONLY ] 		= false;
	g_gangData[ gangid ] [ E_JOIN_MSG ] [ 0 ] 	= '\0';

	// Reset coleaders
	for ( new i = 0; i < MAX_COLEADERS; i ++ )
		g_gangData[ gangid ] [ E_COLEADER ] [ i ] = 0;

 	// Free iterator id
 	Iter_Remove( gangs, gangid );

 	// Empty out the turfs
 	for( new z; z < sizeof( g_gangzoneData ); z++ )
 	{
 		if ( g_gangzoneData[ z ] [ E_GANG_OWNER ] == gangid )
 		{
 			g_gangzoneData[ z ] [ E_COLOR ] = COLOR_GANGZONE;
 			g_gangzoneData[ z ] [ E_GANG_OWNER ] = INVALID_GANG_ID;
			GangZoneShowForAll( g_gangzoneID[ z ], COLOR_GANGZONE );
 		}
 	}
}

stock SaveGangData( gangid )
{
	if ( gangid == INVALID_GANG_ID )
		return;

	format( szBigString, sizeof( szBigString ), "UPDATE `GANGS` SET `NAME`='%s',`LEADER`=%d,`COLOR`=%d,`KILLS`=%d,`DEATHS`=%d,`SCORE`=%d,`BANK`=%d WHERE `ID`=%d",
		mysql_escape( g_gangData[ gangid ] [ E_NAME ] ), g_gangData[ gangid ] [ E_LEADER ], g_gangData[ gangid ] [ E_COLOR ], g_gangData[ gangid ] [ E_KILLS ], g_gangData[ gangid ] [ E_DEATHS ], g_gangData[ gangid ] [ E_SCORE ], g_gangData[ gangid ] [ E_BANK ], g_gangData[ gangid ] [ E_SQL_ID ] );

	mysql_single_query( szBigString );
}

stock IsPlayerGangLeader( playerid, gangid, only_leader = 0 ) {

	if ( g_gangData[ gangid ] [ E_LEADER ] == p_AccountID[ playerid ] )
		return true;

	// Reset coleaders
	if ( only_leader == 0 ) {
		for ( new i = 0; i < MAX_COLEADERS; i ++ ) {
			if ( g_gangData[ gangid ] [ E_COLEADER ] [ i ] == p_AccountID[ playerid ] )
				return true;
		}
	}
	return false;
}

stock DisconnectFromGang( playerid )
{
	new
		gangid = p_GangID[ playerid ];

	p_GangID[ playerid ] = INVALID_GANG_ID;

	if ( gangid == INVALID_GANG_ID )
		return 0;

	if ( ! Iter_Contains( gangs, gangid ) )
		return 0;

	// if ( !g_gangData[ gangid ] [ E_SAVED ] )
	// 	return RemovePlayerFromGang( playerid, GANG_LEAVE_QUIT );
	new
		members = GetOnlineGangMembers( gangid, playerid );

	printf("Gang id %d has currently %d members online", g_gangData[ gangid ] [ E_SQL_ID ], members );
	if ( members <= 0 )
	{
		// print
		printf("Removed Gang From Cache Gang Id %d Since No Ppl", g_gangData[ gangid ] [ E_SQL_ID ] );
	 	// Free iterator id
	 	Iter_Remove( gangs, gangid );

	 	// Empty out the turfs
	 	for( new z; z < sizeof( g_gangzoneData ); z++ )
	 	{
	 		if ( g_gangzoneData[ z ] [ E_GANG_OWNER ] == gangid )
	 		{
	 			g_gangzoneData[ z ] [ E_COLOR ] = COLOR_GANGZONE;
	 			g_gangzoneData[ z ] [ E_GANG_OWNER ] = INVALID_GANG_ID;
				GangZoneShowForAll( g_gangzoneID[ z ], COLOR_GANGZONE );
	 		}
	 	}
	}
	return 1;
}

stock RemovePlayerFromGang( playerid, E_GANG_LEAVE_REASON: reason = GANG_LEAVE_UNKNOWN, otherid = INVALID_PLAYER_ID )
{
	new
		gangid = p_GangID[ playerid ];

 	p_GangID[ playerid ] = INVALID_GANG_ID;

	if ( !Iter_Contains( gangs, gangid ) )
		return 0;

	SetPlayerColorToTeam( playerid );

 	if ( g_gangData[ gangid ] [ E_LEADER ] == p_AccountID[ playerid ] )
 	{
 		new
 			selected_coleader = -1;

 		for ( new i = 0; i < MAX_COLEADERS; i ++ ) if ( g_gangData[ gangid ] [ E_COLEADER ] [ i ] ) {
 			selected_coleader = i;
 			break;
 		}

 		// Coleader exists?
 		if ( selected_coleader != -1 )
 		{
	 		g_gangData[ gangid ] [ E_LEADER ] = g_gangData[ gangid ] [ E_COLEADER ] [ selected_coleader ];
	 		g_gangData[ gangid ] [ E_COLEADER ] [ selected_coleader ] = 0;

			SendClientMessageToGang( gangid, g_gangData[ gangid ] [ E_COLOR ], "[GANG]{FFFFFF} The co-leader of the gang has been selected as the gang leader (acc id %d).", selected_coleader );
 		}
 		else
 		{
			// Set invalid player to allow for check
	 		g_gangData[ gangid ] [ E_LEADER ] = -1;

	 		// Look for leader substitute
		 	foreach(new memberid : Player)
		 	{
				if ( p_GangID[ memberid ] == gangid )
				{
					// Update color gang
					SetGangColorsToGang( gangid );
				    g_gangData[ gangid ] [ E_LEADER ] = p_AccountID[ memberid ];
					SendClientMessageToGang( gangid, g_gangData[ gangid ] [ E_COLOR ], "[GANG]{FFFFFF} %s(%d) has been selected as the gang leader.", ReturnPlayerName( memberid ), memberid );
					break;
				}
		 	}

		 	// Cannot find any leader, so destroy
		 	if ( g_gangData[ gangid ] [ E_LEADER ] == -1 )
		 	{
		 		// Warn gang owner about gang
		 	    SendClientMessage( playerid, g_gangData[ gangid ] [ E_COLOR ], "[GANG]{FFFFFF} There was nobody online that could be a leader for this gang therefore it has been deleted from the server." );

		 		// Destroy gang internally
		 		DestroyGang( gangid );
		 		return 1;
		 	}
 		}
	}

	// reset the coleader
	for ( new i = 0; i < MAX_COLEADERS; i++ ) if ( g_gangData[ gangid ] [ E_COLEADER ] [ i ] == p_AccountID[ playerid ] ) {
 		g_gangData[ gangid ] [ E_COLEADER ] [ i ] = 0;
 	}

 	// wouldn't make sense to keep the coleader in any gang
 	mysql_single_query( sprintf( "DELETE FROM `GANG_COLEADERS` WHERE `USER_ID`=%d", p_AccountID[ playerid ] ) );
 	mysql_single_query( sprintf( "UPDATE `USERS` SET `GANG_ID`=-1 WHERE `ID`=%d", p_AccountID[ playerid ] ) );

 	printf("[%s] Gang ID after leaving is %d", ReturnPlayerName( playerid ), p_GangID[ playerid ] );

	// Alter the gang & players
	if ( Iter_Contains( gangs, gangid ) )
	{
		SaveGangData( gangid );
		CallLocalFunction( "OnPlayerLeaveGang", "ddd", playerid, gangid, _: reason );

		switch( reason )
		{
		    case GANG_LEAVE_KICK:
		    	SendClientMessageFormatted( playerid, g_gangData[ gangid ] [ E_COLOR ], "[GANG]{FFFFFF} %s(%d) has been kicked from the gang by %s(%d)!", ReturnPlayerName( playerid ), playerid, ReturnPlayerName( otherid ), otherid );

		    case GANG_LEAVE_UNKNOWN, GANG_LEAVE_QUIT:
		    	SendClientMessageFormatted( playerid, g_gangData[ gangid ] [ E_COLOR ], "[GANG]{FFFFFF} %s(%d) has left the gang!", ReturnPlayerName( playerid ), playerid );
		}
	}
	return 1;
}

stock HexToInt(string[]) // By DracoBlue
{
	if ( isnull( string ) )
		return 0;

  	new
  		cur = 1,
  		res = 0
  	;

	for( new i; string[ i ] != EOS; ++i )
	{
		string[ i ] = ( 'a' <= string[ i ] <= 'z' ) ? ( string[ i ] += 'A' - 'a' ) : ( string[ i ] );
	}

  	for( new i = strlen( string ); i > 0; i-- )
  	{
  	  	res += string[ i - 1 ] < 58 ? ( cur * ( string[ i - 1 ] - 48 ) ) : ( cur * ( string[ i - 1 ] - 65 + 10 ) );
    	cur *= 16;
  	}
  	return res;
}

stock ReturnGangNameColor( g )
{
	static
	    szColor[ 14 ];

	switch( g )
	{
		case 0:  szColor = "Yellow Green";
		case 1:  szColor = "Green";
		case 2:  szColor = "Blue Green";
		case 3:  szColor = "Blue";
		case 4:  szColor = "Blue Violet";
		case 5: szColor = "Violet";
		case 6: szColor = "Red Violet";
		default: szColor = "-??-";
	}
	return szColor;
}

stock gangNameExists( szName[ ] )
{
	foreach(new i : gangs)
	{
	    if ( strmatch( g_gangData[ i ] [ E_NAME ], szName ) ) return true;
	}
	return false;
}

stock SetGangColorsToGang( gangid )
{
	foreach(new i : Player)
	{
	    for( new x; x < sizeof( g_gangzoneData ); x++ )
	    {
	        GangZoneHideForPlayer( i, g_gangzoneID[ x ] );
	        GangZoneShowForPlayer( i, g_gangzoneID[ x ], g_gangzoneData[ x ] [ E_COLOR ] );
	    }

	    if ( p_GangID[ i ] == gangid && p_WantedLevel[ i ] <= 0 && p_Class[ i ] == CLASS_CIVILIAN )
	    {
	        SetPlayerColor( i, g_gangData[ gangid ] [ E_COLOR ] );
	    }
	}
}

stock isHex(str[])
{
    new
        i,
        cur;
    if (str[0] == '0' && (str[1] == 'x' || str[1] == 'X')) i = 2;
    while (str[i])
    {
        cur = str[i++];
        if (!(('0' <= cur <= '9') || ('A' <= cur <= 'F') || ('a' <= cur <= 'f'))) return 0;
    }
    return 1;
}

stock IsWeaponInAnySlot( playerid, weaponid )
{
    new
        szWeapon, szAmmo;

    GetPlayerWeaponData( playerid, GetWeaponSlot( weaponid ), szWeapon, szAmmo );
    return ( szWeapon == weaponid && szAmmo > 0 );
}

#if !defined __WEAPONDAMAGEINC__
stock GetWeaponSlot(weaponid)
{
    switch(weaponid)
    {
        case WEAPON_BRASSKNUCKLE:
            return 0;
        case WEAPON_GOLFCLUB .. WEAPON_CHAINSAW:
            return 1;
        case WEAPON_COLT45 .. WEAPON_DEAGLE:
            return 2;
        case WEAPON_SHOTGUN .. WEAPON_SHOTGSPA:
            return 3;
        case WEAPON_UZI, WEAPON_MP5, WEAPON_TEC9:
            return 4;
        case WEAPON_AK47, WEAPON_M4:
            return 5;
        case WEAPON_RIFLE, WEAPON_SNIPER:
            return 6;
        case WEAPON_ROCKETLAUNCHER .. WEAPON_MINIGUN:
            return 7;
        case WEAPON_GRENADE .. WEAPON_MOLTOV, WEAPON_SATCHEL:
            return 8;
        case WEAPON_SPRAYCAN .. WEAPON_CAMERA:
            return 9;
        case WEAPON_DILDO .. WEAPON_FLOWER:
            return 10;
        case 44, 45, WEAPON_PARACHUTE:
            return 11;
        case WEAPON_BOMB:
            return 12;
    }
    return -1;
}
#endif

stock textContainsBadTextdrawLetters( const string[ ] )
{
	for( new i, j = strlen( string ); i < j; i++ )
	{
	    if ( string[ i ] == '.' || string[ i ] == '*' || string[ i ] == '^' || string[ i ] == '~' )
	        return true;
	}
	return false;
}

/*stock BanPlayerISP( playerid ) {
	if ( !IsPlayerConnected( playerid ) )
	    return;

	format( szLargeString, sizeof( szLargeString ), "INSERT INTO `MEGABAN`(`ISP`) VALUES ('%s')", mysql_escape( GetPlayerISP( playerid ) ) );
	mysql_single_query( szLargeString );

	if ( IsPlayerConnected( playerid ) )
		Kick( playerid );
}*/

stock IsValidSkin( skinid )
{
	if ( skinid == 74 || skinid > 311 || skinid < 0 )
	    return 0;

	return 1;
}

stock IsPlayerInCar( playerid )
{
    static
		g_CarVehicles[ 93 ] =
		{
			400,401,402,404,405,410,411,412,415,418,419,420,421,422,424,426,429,434,436,
			438,439,442,445,451,458,466,467,470,474,475,477,478,480,480,480,480,489,490,
			491,492,494,496,500,501,502,503,504,505,506,507,516,517,518,526,527,529,533,
			534,535,536,540,541,542,543,545,546,547,549,550,551,555,558,559,560,561,562,
			565,566,567,575,576,580,585,587,589,596,597,598,600,602,603,604,605
		}
	;
	for( new i; i < sizeof( g_CarVehicles ); i++ )
	{
	    if ( GetVehicleModel( GetPlayerVehicleID( playerid ) ) == g_CarVehicles[ i ] )
	        return 1;
	}
	return 0;
}

stock mysql_escape( string[ ] )
{
	static
	    szEscaped[ 256 ];

	if ( strlen( string ) >= 256 ) {
		printf("BUFFER OVERFLOW: %s", string);
	}

	mysql_real_escape_string( string, szEscaped );
	return szEscaped;
}

CreateNavigation( const szName[ 24 ], Float: X, Float: Y, Float: Z, city )
{
	new
	    ID = 0xFF
	;

	for( new i; i < sizeof( g_gpsData ); i++ )
	{
		if ( !g_gpsData[ i ] [ E_CREATED ] ) {
		    ID = i;
		    break;
		}
	}

	if ( ID == 0xFF )
	    return 0;

	format( g_gpsData[ ID ] [ E_NAME ], 24, "%s", szName );
    g_gpsData[ ID ] [ E_CREATED ] = true;
    g_gpsData[ ID ] [ E_X ] = X;
    g_gpsData[ ID ] [ E_Y ] = Y;
    g_gpsData[ ID ] [ E_Z ] = Z;
    g_gpsData[ ID ] [ E_CITY ] = city;
    return 1;
}

stock GetDayToString( day )
{
	static
	    string[ 10 ];

	switch( day )
	{
		case 0: string = "Monday";
		case 1: string = "Tuesday";
		case 2: string = "Wednesday";
		case 3: string = "Thursday";
		case 4: string = "Friday";
		case 5: string = "Saturday";
		case 6: string = "Sunday";
		default: string = "Bugged";
	}
	return string;
}

stock VIPToString( viplvl )
{
	static
		string[ 9 ];

	switch( viplvl )
	{
	    case VIP_DIAMOND: string = "Diamond";
	    case VIP_PLATINUM: string = "Platinum";
	    case VIP_GOLD: string = "Gold";
		case VIP_BRONZE: string = "Bronze";
		case VIP_REGULAR: string = "Regular";
		default: string = "N/A";
	}
	return string;
}

stock CreateATM( Float: X, Float: Y, Float: Z, Float: rX, Float: offset = 180.0 )
{
	new ID = -1;
	for( new i; i < sizeof( g_atmData ); i ++ )
	{
	    if ( g_atmData[ i ] [ E_CREATED ] == false ) {
	        ID = i;
	        break;
		}
	}
	if ( ID == -1 ) return ID;

	rX = rX - offset;

	new
		Float: nX = X + 1.0 * -floatsin( -rX, degrees ),
		Float: nY = Y + 1.0 * -floatcos( -rX, degrees )
	;

	g_atmData[ ID ] [ E_HEALTH ] = 100.0;
	g_atmData[ ID ] [ E_CREATED ] = true;
	g_atmData[ ID ] [ E_CHECKPOINT ] = CreateDynamicCP( nX, nY, Z, 1.0 , -1, -1, -1, 100.0 );
	g_atmData[ ID ] [ E_OBJECT ] = CreateDynamicObject( 19324, X, Y, Z, 0.0, 0.0, rX, -1, -1, -1, 100.0 );
	g_atmData[ ID ] [ E_LABEL ] = CreateDynamic3DTextLabel( "[ATM]\n"COL_GREY"100%", COLOR_GOLD, nX, nY, Z, 20.0 );
	return ID;
}


Float:DistanceCameraTargetToLocation(Float:CamX, Float:CamY, Float:CamZ, Float:ObjX, Float:ObjY, Float:ObjZ, Float:FrX, Float:FrY, Float:FrZ) {

    new Float:TGTDistance;

    TGTDistance = floatsqroot((CamX - ObjX) * (CamX - ObjX) + (CamY - ObjY) * (CamY - ObjY) + (CamZ - ObjZ) * (CamZ - ObjZ));

    new Float:tmpX, Float:tmpY, Float:tmpZ;

    tmpX = FrX * TGTDistance + CamX;
    tmpY = FrY * TGTDistance + CamY;
    tmpZ = FrZ * TGTDistance + CamZ;

    return floatsqroot((tmpX - ObjX) * (tmpX - ObjX) + (tmpY - ObjY) * (tmpY - ObjY) + (tmpZ - ObjZ) * (tmpZ - ObjZ));
}

stock Float:GetPointAngleToPoint(Float:x2, Float:y2, Float:X, Float:Y) {

  new Float:DX, Float:DY;
  new Float:angle;

  DX = floatabs(floatsub(x2,X));
  DY = floatabs(floatsub(y2,Y));

  if (DY == 0.0 || DX == 0.0) {
    if (DY == 0 && DX > 0) angle = 0.0;
    else if (DY == 0 && DX < 0) angle = 180.0;
    else if (DY > 0 && DX == 0) angle = 90.0;
    else if (DY < 0 && DX == 0) angle = 270.0;
    else if (DY == 0 && DX == 0) angle = 0.0;
  }
  else {
    angle = atan(DX/DY);

    if (X > x2 && Y <= y2) angle += 90.0;
    else if (X <= x2 && Y < y2) angle = floatsub(90.0, angle);
    else if (X < x2 && Y >= y2) angle -= 90.0;
    else if (X >= x2 && Y > y2) angle = floatsub(270.0, angle);
  }

  return floatadd(angle, 90.0);
}

stock GetXYInFrontOfPoint(&Float:x, &Float:y, Float:angle, Float:distance) {
    x += (distance * floatsin(-angle, degrees));
    y += (distance * floatcos(-angle, degrees));
}

stock IsPlayerAimingAt(playerid, Float:x, Float:y, Float:z, Float:radius)
{
    new   Float:camera_x;
    new   Float:camera_y;
    new   Float:camera_z;
    new   Float:vector_x;
    new   Float:vector_y;
    new   Float:vector_z;

    GetPlayerCameraPos(playerid, camera_x, camera_y, camera_z);
    GetPlayerCameraFrontVector(playerid, vector_x, vector_y, vector_z);

    new Float:vertical, Float:horizontal;

    switch (GetPlayerWeapon( playerid )) {
        case 34,35,36:
        {
            if (DistanceCameraTargetToLocation(camera_x, camera_y, camera_z, x, y, z, vector_x, vector_y, vector_z) < radius) return true;
            return false;
        }
        case 30,31: {vertical = 4.0; horizontal = -1.6;}
        case 33: {vertical = 2.7; horizontal = -1.0;}
        default: {vertical = 6.0; horizontal = -2.2;}
    }
    new Float:angle = GetPointAngleToPoint(0, 0, floatsqroot(vector_x*vector_x+vector_y*vector_y), vector_z) - 270.0;
    new Float:resize_x, Float:resize_y, Float:resize_z = floatsin(angle+vertical, degrees);
    GetXYInFrontOfPoint(resize_x, resize_y, GetPointAngleToPoint(0, 0, vector_x, vector_y)+horizontal, floatcos(angle+vertical, degrees));

    if (DistanceCameraTargetToLocation(camera_x, camera_y, camera_z, x, y, z, resize_x, resize_y, resize_z) < radius) return true;
    return false;
}

stock CreateFire( )
{
	static string[ 6 ];
	if ( fire_toggled )
	{
	    for( new i; i < sizeof( g_fireData ); i ++ )
	    {
			if ( g_fireData[ i ] [ E_CREATED ] == true )
			{
			    g_fireData[ i ] [ E_CREATED ] = false;
			    g_fireData[ i ] [ E_HOUSE ] = -1;
			    DestroyDynamicObject( g_fireData[ i ] [ E_OBJECT ] );
			    g_fireData[ i ] [ E_OBJECT ] = INVALID_OBJECT_ID;
			    DestroyDynamic3DTextLabel( g_fireData[ i ] [ E_LABEL ] );
			    g_fireData[ i ] [ E_LABEL ] = Text3D: 0xFFFF;
			}
	    }
	    fire_toggled = false;
	    CreateFire( );
	}
	else
	{
	    for( new i, house; i < sizeof( g_fireData ); i ++ )
	    {
			house = getRandomCreatedHouse( 1 );
			g_fireData[ i ] [ E_HEALTH ] = 100.0 + fRandomEx( 1, 25 );
			g_fireData[ i ] [ E_HOUSE ] = house;
			g_fireData[ i ] [ E_CREATED ] = true;
			format( string, sizeof( string ), "%0.1f", g_fireData[ i ] [ E_HEALTH ] );
			g_fireData[ i ] [ E_LABEL ] = CreateDynamic3DTextLabel( string, COLOR_YELLOW, g_houseData[ house ] [ E_EX ], g_houseData[ house ] [ E_EY ], g_houseData[ house ] [ E_EZ ] + 0.5, 20.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, -1 );
			g_fireData[ i ] [ E_OBJECT ] = CreateDynamicObject( 18691, g_houseData[ house ] [ E_EX ], g_houseData[ house ] [ E_EY ], g_houseData[ house ] [ E_EZ ] - 2.3, 0.0, 0.0, 0.0 );
		}
	    fire_toggled = true;
	}
	return 1;
}

stock IsHouseOnFire( houseid )
{
	if ( houseid < 0 || houseid > MAX_HOUSES )
	    return 0;

	if ( g_houseData[ houseid ] [ E_CREATED ] == false )
	    return 0;

	for( new i, Float: X, Float: Y, Float: Z; i < sizeof( g_fireData ); i++ )
	{
	    if ( g_fireData[ i ] [ E_CREATED ] )
	    {
		    GetDynamicObjectPos( g_fireData[ i ] [ E_OBJECT ], X, Y, Z ); // Z is unused due to the object.
		    if ( g_houseData[ houseid ] [ E_EX ] == X && g_houseData[ houseid ] [ E_EY ] == Y )
		    {
		        return 1;
		    }
		}
	}
	return 0;
}

stock ShowAchievement( playerid, achievement[ ], score = -1 )
{
	if ( score != -1 ) {
		GivePlayerScore( playerid, score );
	}
	KillTimer( p_AchievementTimer[ playerid ] );
	p_AchievementTimer[ playerid ] = 0xFF;
	TextDrawSetString( p_AchievementTD[ playerid ], achievement );
	TextDrawShowForPlayer( playerid, p_AchievementTD[ playerid ] );
	TextDrawShowForPlayer( playerid, g_AchievementTD[ 0 ] );
	TextDrawShowForPlayer( playerid, g_AchievementTD[ 1 ] );
	TextDrawShowForPlayer( playerid, g_AchievementTD[ 2 ] );
	TextDrawShowForPlayer( playerid, g_AchievementTD[ 3 ] );
	PlayerPlaySound( playerid, 1183, 0, 0, 0 );
	p_AchievementTimer[ playerid ] = SetTimerEx( "Achievement_Hide", 10000, false, "d", playerid );
}

function Achievement_Hide( playerid ) {
	TextDrawHideForPlayer( playerid, p_AchievementTD[ playerid ] );
	TextDrawHideForPlayer( playerid, g_AchievementTD[ 0 ] );
	TextDrawHideForPlayer( playerid, g_AchievementTD[ 1 ] );
	TextDrawHideForPlayer( playerid, g_AchievementTD[ 2 ] );
	TextDrawHideForPlayer( playerid, g_AchievementTD[ 3 ] );
    p_AchievementTimer[ playerid ] = 0xFF;
	StopSound( playerid );
    return 1;
}

stock SyncObject( playerid, Float: offsetX = 0.005, Float: offsetY = 0.005, Float: offsetZ = 0.005 )
{
	static
		Float: X, Float: Y, Float: Z;

	if ( GetPlayerPos( playerid, X, Y, Z ) )
		SetPlayerPos( playerid, X + offsetX, Y + offsetY, Z + offsetZ );
}

CreateLumberjackTree( Float: X, Float: Y, Float: Z )
{
	new ID = -1;
	for( new i; i < MAX_TREES; i++ )
	{
	    if ( !g_treeData[ i ] [ E_CREATED ] )
	    {
	        ID = i;
	        break;
	    }
	}

	if ( ID != -1 )
	{
	    g_treeData[ ID ] [ E_CREATED ] = true;
	    g_treeData[ ID ] [ E_CUT ] = false;
	    g_treeData[ ID ] [ E_CHOPPED ] = false;
	    g_treeData[ ID ] [ E_X ] = X;
	    g_treeData[ ID ] [ E_Y ] = Y;
	    g_treeData[ ID ] [ E_Z ] = Z;
	    g_treeData[ ID ] [ E_OBJECT ] = CreateDynamicObject( 618, X, Y, Z, 0.0, 0.0, 0.0 );
	    g_treeData[ ID ] [ E_HEALTH ] = 100.0;
		g_treeData[ ID ] [ E_LABEL ] = CreateDynamic3DTextLabel( "100.0", COLOR_YELLOW, X, Y, Z + 0.5, 10.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, -1 );
	}
	return ID;
}

CreateWeedPlant( Float: X, Float: Y, Float: Z, Float: rX, Float: rY, Float: rZ )
{
	new ID = -1;
	for( new i; i < MAX_WEED; i++ )
	{
	    if ( !g_weedData[ i ] [ E_CREATED ] ) {
			ID = i;
			break;
		}
	}
	if ( ID != -1 )
	{
		g_weedData[ ID ] [ E_CREATED ] = true;
		g_weedData[ ID ] [ E_OBJECT ] = CreateDynamicObject( 822, X, Y, Z, rX, rY, rZ );
		g_weedData[ ID ] [ E_CUT ] = false;
		g_weedData[ ID ] [ E_X ] = X;
		g_weedData[ ID ] [ E_Y ] = Y;
		g_weedData[ ID ] [ E_Z ] = Z;
	}
	return ID;
}

stock RenewWeed( )
{
    for( new i; i < MAX_WEED; i++ )
	{
	    if ( g_weedData[ i ] [ E_CREATED ] == true && g_weedData[ i ] [ E_CUT ] == true )
	    {
	        StopDynamicObject( g_weedData[ i ] [ E_OBJECT ] );
           	MoveDynamicObject( g_weedData[ i ] [ E_OBJECT ], g_weedData[ i ] [ E_X ], g_weedData[ i ] [ E_Y ], g_weedData[ i ] [ E_Z ], 0.75 );
			g_weedData[ i ] [ E_CREATED ] = true;
		    g_weedData[ i ] [ E_CUT ] = false;
			//DestroyDynamicObject( g_weedData[ i ] [ E_OBJECT ] );
			//g_treeData[ i ] [ E_OBJECT ] = CreateDynamicObject( 822, g_weedData[ i ] [ E_X ], g_weedData[ i ] [ E_Y ], g_weedData[ i ] [ E_Z ], g_weedData[ i ] [ E_RX ], g_weedData[ i ] [ E_RY ], 0.0 );
		}
	}
}

stock AddAdminLogLineFormatted( format[ ], va_args<> )
{
    static
		out[ sizeof( log__Text[ ] ) ];

    va_format( out, sizeof( out ), format, va_start<1> );
    return AddAdminLogLine( out );
}

stock AddAdminLogLine( szMessage[ sizeof( log__Text[ ] ) ] )
{
	for( new iPos = 0; iPos < sizeof( log__Text ) - 1; iPos++ )
		memcpy( log__Text[ iPos ], log__Text[ iPos + 1 ], 0, sizeof( log__Text[ ] ) * 4 );

	strcpy( log__Text[ 4 ], szMessage );
	DCC_SendChannelMessage( discordAdminChan, szMessage );

	format( szLargeString, 500,	"%s~n~%s~n~%s~n~%s~n~%s", log__Text[ 0 ], log__Text[ 1 ], log__Text[ 2 ], log__Text[ 3 ], log__Text[ 4 ] );
	return TextDrawSetString( g_AdminLogTD, szLargeString );
}

stock SaveToAdminLogFormatted( playerid, id, format[ ], va_args<> )
{
    static
		out[ sizeof( log__Text[ ] ) ];

    va_format( out, sizeof( out ), format, va_start<3> );
    return SaveToAdminLog( playerid, id, out );
}

stock SaveToAdminLog( playerid, id, message[ ] )
{
	if ( id ) {
		format( szBigString, sizeof( szBigString ),"INSERT INTO `ADMIN_LOG` (`USER_ID`, `ACTION`, `ACTION_ID`) VALUES (%d, '%s', %d)", p_AccountID[ playerid ], mysql_escape( message ), id );
	} else {
		format( szBigString, sizeof( szBigString ),"INSERT INTO `ADMIN_LOG` (`USER_ID`, `ACTION`) VALUES (%d, '%s')", p_AccountID[ playerid ], mysql_escape( message ) );
	}
	mysql_single_query( szBigString );
	return 1;
}


stock SyncSpectation( playerid, playerstate = -1 )
{
	if ( playerstate == -1 )
		playerstate = GetPlayerState( playerid );

	if ( IsPlayerConnected( playerid ) )
	{
	    if ( p_beingSpectated[ playerid ] )
	    {
	        if ( playerstate == PLAYER_STATE_DRIVER || playerstate == PLAYER_STATE_PASSENGER )
	        {
                foreach(new i : Player) {
	                if ( p_Spectating{ i } && p_whomSpectating[ i ] == playerid ) {
						SetPlayerInterior( i, GetPlayerInterior( playerid ) );
						SetPlayerVirtualWorld( i, GetPlayerVirtualWorld( playerid ) );
						PlayerSpectateVehicle( i, GetPlayerVehicleID( playerid ) );
	                }
				}
	        }
	        else
			{
                foreach(new i : Player) {
	                if ( p_Spectating{ i } && p_whomSpectating[ i ] == playerid ) {
						SetPlayerInterior( i, GetPlayerInterior( playerid ) );
						SetPlayerVirtualWorld( i, GetPlayerVirtualWorld( playerid ) );
						PlayerSpectatePlayer( i, playerid );
	                }
				}
			}
	    }
	}
	return 1;
}

stock CutSpectation( playerid )
{
	if ( playerid < 0 || playerid > MAX_PLAYERS ) return 0;
	foreach(new i : Player) {
		if ( p_Spectating{ i } && p_whomSpectating[ i ] == playerid ) {
			p_whomSpectating[ i ] = INVALID_PLAYER_ID;
			TogglePlayerSpectating( i, 0 );
			p_Spectating{ i } = false;
			SendServerMessage( i, "Spectation has been closed." );
	  	}
	}
	p_beingSpectated[ playerid ] = false;
	return 1;
}

stock CreateLoopingAnimation( playerid, animlib[ ], animname[ ], Float:Speed, looping, lockx, locky, lockz, lp, specialaction=0 )
{
	if ( !IsPlayerConnected( playerid ) )		return 0;
//	else if ( p_InAnimation{ playerid } )        return SendError( playerid, "You cannot use this command since you're playing an animation." );
	else if ( IsPlayerInAnyVehicle( playerid ) )	return SendError( playerid, "You cannot use this command inside a vehicle." );
	else if ( !IsPlayerSpawned( playerid ) ) 	return SendError( playerid, "You cannot use this command since you're not spawned." );
//	else if ( IsPlayerJailed( playerid ) ) 		return SendError( playerid, "You cannot use this command since you're jailed." );
	else if ( IsPlayerTazed( playerid ) ) 		return SendError( playerid, "You cannot use this command since you're tazed." );
	else if ( IsPlayerDetained( playerid ) ) 	return SendError( playerid, "You cannot use this command since you're detained." );
	else if ( IsPlayerCuffed( playerid ) ) 		return SendError( playerid, "You cannot use this command since you're cuffed." );
	else if ( IsPlayerTied( playerid ) ) 		return SendError( playerid, "You cannot use this command since you're tied." );
	else if ( IsPlayerKidnapped( playerid ) ) 	return SendError( playerid, "You cannot use this command since you're kidnapped." );
	else if ( IsPlayerGettingBlowed( playerid ) )return SendError( playerid, "You cannot use this command since you're getting blowed." );
	else if ( IsPlayerBlowingCock( playerid ) ) 	return SendError( playerid, "You cannot use this command since you're giving oral sex." );
	else if ( IsPlayerInWater( playerid ) )      return SendError( playerid, "You cannot use this command since you're in water." );
	else if ( IsPlayerMining( playerid ) ) 		return SendError( playerid, "You cannot use this command since you're mining." );
	else if ( IsPlayerInEvent( playerid ) ) 		return SendError( playerid, "You cannot use this command since you're in an event." );
    else if ( GetPlayerAnimationIndex( playerid ) == 1660 ) return SendError( playerid, "You cannot use this command since you're using a vending machine." );
	else if ( IsPlayerAttachedObjectSlotUsed( playerid, 0 ) ) return SendError( playerid, "You cannot use this command since you're robbing." );
	else if ( IsPlayingAnimation( playerid, "ROB_BANK", "CAT_Safe_Rob" ) ) return SendError( playerid, "You cannot use this command since you're robbing." );
	else if ( IsPlayingAnimation( playerid, "GANGS", "smkcig_prtl" ) ) return SendError( playerid, "You cannot use this command since you're smoking." );
	else if ( IsPlayerAttachedObjectSlotUsed( playerid, 3 ) ) return SendError( playerid, "You cannot use this command since you're holding a stolen good." );
	else if ( GetPlayerState( playerid ) == PLAYER_STATE_ENTER_VEHICLE_DRIVER || GetPlayerState( playerid ) == PLAYER_STATE_ENTER_VEHICLE_PASSENGER ) return SendError( playerid, "You cannot use this command since you're entering a vehicle." );
    else if ( GetPlayerState( playerid ) == PLAYER_STATE_EXIT_VEHICLE ) return SendError( playerid, "You cannot use this command since you're exiting a vehicle." );
	else
	{
		SetPlayerSpecialAction( playerid, 0 );
	    if ( specialaction == 0 ) {
			ApplyAnimation( playerid, animlib, "null", 0.0, 0, 0, 0, 0, 0 );
		    ApplyAnimation( playerid, animlib, animname, Speed, looping, lockx, locky, lockz, lp );
		} else {
            SetPlayerSpecialAction( playerid, specialaction );
		}

		if ( looping ) // Animations that must be played once.
		{
	    	p_InAnimation{ playerid } = true;
			if ( !p_inMovieMode{ playerid } ) TextDrawShowForPlayer( playerid, g_AnimationTD );
		}
	}
	return 1;
}

stock PreloadAnimationLibrary( playerid, animlib[ ] )
	return ApplyAnimation( playerid, animlib, "null", 0.0, 0, 0, 0, 0, 0 );

stock secondstotime(seconds, const delimiter[] = ", ", start = 0, end = -1)
{
    static const times[] = {
        1,
        60,
        3600,
        86400,
        604800,
        2419200,
        29030400
    };



    static const names[][] = {
        "second",
        "minute",
        "hour",
        "day",
        "week",
        "month",
        "year"
    };

    static string[128];

    if (!seconds)
    {
    	string = "N/A";
    	return string;
    }

    erase(string);

    for(new i = start != 0 ? start : (sizeof(times) - 1); i != end; i--)
    {
        if (seconds / times[i])
        {
            if (string[0])
            {
                format(string, sizeof(string), "%s%s%d %s%s", string, delimiter, (seconds / times[i]), names[i], ((seconds / times[i]) == 1) ? ("") : ("s"));
            }
            else
            {
                format(string, sizeof(string), "%d %s%s", (seconds / times[i]), names[i], ((seconds / times[i]) == 1) ? ("") : ("s"));
            }
            seconds -= ((seconds / times[i]) * times[i]);
        }
    }
    return string;
}

stock IsVehicleOccupied( vehicleid, bool: include_vehicle_interior = false ) {
	if ( !IsValidVehicle( vehicleid ) )
		return false;

	new
		iModel = GetVehicleModel( vehicleid );

	foreach(new i : Player) {
	    if ( GetPlayerVehicleID( i ) == vehicleid )
	    	return true;

	    if ( include_vehicle_interior ) {
			new
				iWorld = GetPlayerVirtualWorld( i );

			if ( IsPlayerSpawned( i ) && ( ( iWorld - VW_METH ) == vehicleid && iModel == 508 ) || ( ( iWorld - VW_SHAMAL ) == vehicleid && iModel == 519 ) )
				return true;
	    }
	}
	return false;
}

stock ConvertPrice( iValue, iCashSign = 1 )
{
	static
		szNum[ 32 ]
	;
	format( szNum, sizeof( szNum ), "%d", iValue < 0 ? -iValue : iValue );

    for( new i = strlen( szNum ) - 3; i > 0; i -= 3 ) {
        strins( szNum, ",", i, sizeof( szNum ) );
    }

	if ( iCashSign )	 strins( szNum, "$", 0 );
    if ( iValue < 0 ) strins( szNum, "-", 0, sizeof( szNum ) );

    return szNum;
}

stock RedirectAmmunation( playerid, listitem, custom_title[ ] = "{FFFFFF}Ammu-Nation", custom_dialogid = DIALOG_AMMU_BUY, Float: custom_multplier = 1.0, bool: unlimited_ammo = false )
{
	new
		szString[ 420 ];

	szString = ! unlimited_ammo ? ( ""COL_WHITE"Weapon\t"COL_WHITE"Ammo\t"COL_WHITE"Price\n" ) : ( ""COL_WHITE"Weapon\t"COL_WHITE"Price\n" );

	for( new i; i < sizeof( g_AmmunationWeapons ); i++ ) if ( g_AmmunationWeapons[ i ] [ E_MENU ] == listitem )
	{
	   	if ( ! unlimited_ammo ) // Other multipliers will not specify ammo
	   		format( szString, sizeof( szString ), "%s%s\t%d\t"COL_GOLD"%s\n", szString, g_AmmunationWeapons[ i ] [ E_NAME ], g_AmmunationWeapons[ i ] [ E_AMMO ], ConvertPrice( floatround( g_AmmunationWeapons[ i ] [ E_PRICE ] * custom_multplier ) ) );
		else
			format( szString, sizeof( szString ), "%s%s\t"COL_GOLD"%s\n", szString, g_AmmunationWeapons[ i ] [ E_NAME ], ConvertPrice( floatround( g_AmmunationWeapons[ i ] [ E_PRICE ] * custom_multplier ) ) );
	}
    ShowPlayerDialog( playerid, custom_dialogid, DIALOG_STYLE_TABLIST_HEADERS, custom_title, szString, "Purchase", "Back" );
    return 1;
}

stock ShowAmmunationMenu( playerid, custom_title[ ] = "{FFFFFF}Ammu-Nation", custom_dialogid = DIALOG_AMMU )
{
	static
		szString[ 60 ];

	if ( !szString[ 0 ] )
	{
	    for( new i; i < sizeof( g_AmmunitionCategory ); i++ )
	    {
	        format( szString, sizeof( szString ), "%s%s\n", szString, g_AmmunitionCategory[ i ] );
	    }
	}
	return ShowPlayerDialog( playerid, custom_dialogid, DIALOG_STYLE_LIST, custom_title, szString, "Select", "Cancel" );
}

stock apartment_CallElevator( level )
{
	new Float: Z, Float: LastZ;

	if ( level >= MAX_AFLOORS )
	    return -1; // Invalid Floor

	switch( level ) {
	    case 0:     Z = 8.36;
	    case 1:     Z = 17.03;
	    default:    Z = 17.03 + ( ( level - 1 ) * 5.447 );
	}

	GetDynamicObjectPos( g_apartmentElevatorDoor1[ g_apartmentElevatorLevel ], LastZ, LastZ, LastZ );
	MoveDynamicObject( g_apartmentElevatorDoor1[ g_apartmentElevatorLevel ], -1955.05, 1361.64, LastZ, 5.0 );
	MoveDynamicObject( g_apartmentElevatorDoor2[ g_apartmentElevatorLevel ], -1955.05, 1361.64, LastZ, 5.0 );

	DestroyDynamicObject( g_apartmentElevatorGate ), g_apartmentElevatorGate = INVALID_OBJECT_ID;
	g_apartmentElevatorGate = CreateDynamicObject( 19304, -1955.08, 1363.74, LastZ, 0.00, 0.00, 0.00 );
 	SetObjectInvisible( g_apartmentElevatorGate ); // Just looks ugly...
	MoveDynamicObject( g_apartmentElevatorGate, -1955.08, 1363.74, Z, 7.0 );

	MoveDynamicObject( g_apartmentElevator, -1955.09, 1365.51, Z, 7.0 );

	g_apartmentElevatorLevel = level; // For the last level.
	return 1;
}

stock randarg( ... )
	return getarg( random( numargs( ) ) );

stock RemovePlayerWeapon(playerid, ...)
{
    new iArgs = numargs();
    while(--iArgs)
    {
        SetPlayerAmmo(playerid, getarg(iArgs), 0);
    }
}

stock ShowHouseWeaponStorage( playerid )
{
	if ( !IsPlayerConnected( playerid ) )
	    return 0;

    new id = p_InHouse[ playerid ];
	if ( id == -1 ) return SendError( playerid, "You're not inside any house." );
	if ( !strmatch( g_houseData[ id ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) return SendError( playerid, "You are not the owner of this house." );
    szLargeString[ 0 ] = '\0';
    for( new i = 0; i < MAX_HOUSE_WEAPONS; i++ )
    {
		if ( g_HouseWeapons[ id ] [ i ] != 0 )
			format( szLargeString, sizeof( szLargeString ), "%s%s%s(%d)\n", szLargeString, i > 2 ? (""#COL_GOLD"") : ("{FFFFFF}"), ReturnWeaponName( g_HouseWeapons[ id ] [ i ] ), g_HouseWeaponAmmo[ id ] [ i ] );
		else
			strcat( szLargeString, i > 2 ? ( ""COL_GOLD"Empty\n" ) : ( ""COL_WHITE"Empty\n" ) );

	}
	ShowPlayerDialog( playerid, DIALOG_HOUSE_WEAPONS, DIALOG_STYLE_LIST, "{FFFFFF}House Weapon Storage", szLargeString, "Withdraw", "Back" );
	return 1;
}

stock SaveHouseWeaponStorage( houseid )
{
	new szWeapon[ 21 ], szAmmo[ 50 ];
    for( new i; i < MAX_HOUSE_WEAPONS; i++ )
    {
        format( szWeapon, sizeof( szWeapon ), "%s%d.", szWeapon, g_HouseWeapons[ houseid ] [ i ] );
        format( szAmmo, sizeof( szAmmo ), "%s%d.", szAmmo, g_HouseWeaponAmmo[ houseid ] [ i ] );
	}
	format( szBigString, sizeof( szBigString ), "UPDATE `HOUSES` SET `WEAPONS`='%s',`AMMO`='%s' WHERE `ID`=%d", szWeapon, szAmmo, houseid );
	mysql_single_query( szBigString );
	return 1;
}

stock IsMeleeWeapon(value) {
	static const valid_values[2] = {
		65535, 28928
	};
	if (0 <= value <= 46) {
		return (valid_values[value >>> 5] & (1 << (value & 31))) || false;
	}
	return false;
}

stock iswheelmodel(modelid) {
    new wheelmodels[17] = {1025,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1096,1097,1098};
    for(new I; I < sizeof wheelmodels; I++) {
        if (modelid == wheelmodels[I])
            return true;
    }
    return false;
}

stock IllegalCarNitroIde(carmodel) {

    new illegalvehs[29] = { 581, 523, 462, 521, 463, 522, 461, 448, 468, 586, 509, 481, 510, 472, 473, 493, 595, 484, 430, 453, 452, 446, 454, 590, 569, 537, 538, 570, 449 };
	for(new I; I < sizeof illegalvehs; I++) {
        if (carmodel == illegalvehs[I])
            return true;
    }
    return false;
}

stock isLegalCarMod(vehicleide, componentid) {

    new modok = false;

    // stereo, hydraulics & nos (1x 2x 3x) are special.
    if ( (iswheelmodel(componentid)) || (componentid == 1086) || (componentid == 1087) || ((componentid >= 1008) && (componentid <= 1010))) {

        new nosblocker = IllegalCarNitroIde(vehicleide);

        if (!nosblocker)
            modok = true;

    } else {

        // check if the specified model CAN use this particular mod.
        for(new I; I < sizeof g_aLegalModifications; I++) {

            if (g_aLegalModifications[I][0] == vehicleide) { // first is car IDE

                for(new J = 1; J < 22; J++) { // start with 1
                    if (g_aLegalModifications[I][J] == componentid)
                        modok = true;
                }

            }

        }

    }
    return modok;
}

stock UpdateBuyableVehicleMods( playerid, v )
{
	if ( v < 0 || v > MAX_BUYABLE_VEHICLES ) return 0;
	if ( !g_vehicleData[ playerid ] [ v ] [ E_CREATED ] ) return 0;
	new vehicleid = g_vehicleData[ playerid ] [ v ] [ E_VEHICLE_ID ];
	if ( !IsValidVehicle( vehicleid ) ) return 0;

	for( new i; i < MAX_CAR_MODS; i++ )
    	if ( ( g_vehicleModifications[ playerid ] [ v ] [ i ] = GetVehicleComponentInSlot( vehicleid, i ) ) < 1000 ) g_vehicleModifications[ playerid ] [ v ] [ i ] = 0;

	return 1;
}

thread OnFurnitureLoad( )
{
	new
		rows, fields, i = -1, hID, aID,
	    Field[ 12 ], // 00000.00000
		Float: g_FurnitureData[ 6 ], // Loading stuff,
		g_FurnitureModel,
	    loadingTick = GetTickCount( )
	;

	cache_get_data( rows, fields );
	if ( rows )
	{
		while( ++i < rows )
		{
			cache_get_field_content( i, "H_ID", Field ),	hID = strval( Field );
			cache_get_field_content( i, "A_ID", Field ),	aID = strval( Field );
		    cache_get_field_content( i, "MODEL", Field ),  	g_FurnitureModel = strval( Field );
		    cache_get_field_content( i, "X", Field ),     	g_FurnitureData[ 0 ] = floatstr( Field );
		    cache_get_field_content( i, "Y", Field ),       g_FurnitureData[ 1 ] = floatstr( Field );
		    cache_get_field_content( i, "Z", Field ),       g_FurnitureData[ 2 ] = floatstr( Field );
		    cache_get_field_content( i, "RX", Field ),      g_FurnitureData[ 3 ] = floatstr( Field );
		    cache_get_field_content( i, "RY", Field ),      g_FurnitureData[ 4 ] = floatstr( Field );
		    cache_get_field_content( i, "RZ", Field ),      g_FurnitureData[ 5 ] = floatstr( Field );
		  	new iObjectID = CreateDynamicObject( g_FurnitureModel, g_FurnitureData[ 0 ], g_FurnitureData[ 1 ], g_FurnitureData[ 2 ], g_FurnitureData[ 3 ], g_FurnitureData[ 4 ], g_FurnitureData[ 5 ], hID + MAX_HOUSES );
			SetGVarInt( "fur_w", hID + MAX_HOUSES, iObjectID );
			SetGVarInt( "fur_f", getFurnitureID( g_FurnitureModel ), iObjectID );
			SetGVarInt( "fur_a", aID, iObjectID );
			if ( aID == -1 ) g_HouseFurnitureCount[ hID ] ++;
			else g_ApartmentFurnitureCount[ aID ] ++;
		}
	}
	printf( "[FURNITURE]: %d objects have been loaded. (Tick: %dms)", i, GetTickCount( ) - loadingTick );
	return 1;
}

stock isFurnitureObject( modelid )
{
	for( new i = 0; i < sizeof( g_houseFurniture ); i++ )
		if ( g_houseFurniture[ i ] [ E_MODEL ] == modelid )
		    return true;

	return false;
}

stock destroyAllFurniture( houseid, bool: apartment=false )
{
	if ( houseid == -1 )
		return 0;

	if ( g_houseData[ houseid ] [ E_CREATED ] == false )
	    return 0;

	for( new i = g_preloadedObjectCount, j = Streamer_GetUpperBound( STREAMER_TYPE_OBJECT ); i < j; i++ ) if ( IsValidDynamicObject( i ) )
	{
		if ( apartment && GetGVarInt( "fur_a", i ) != houseid ) continue;
		if ( !apartment && GetGVarInt( "fur_w", i ) != houseid + MAX_HOUSES ) continue;
		DestroyDynamicObject( i );
		DeleteGVar( "fur_w", i );
		DeleteGVar( "fur_f", i );
		DeleteGVar( "fur_a", i );
	}

	// df6f242
	if ( apartment == false )
		g_HouseFurnitureCount[ houseid ] = 0;
	else
		g_ApartmentFurnitureCount[ houseid ] = 0;

	format( szNormalString, sizeof( szNormalString ), "DELETE FROM `FURNITURE` WHERE %s=%d", apartment == true ? ("`A_ID`") : ("`H_ID`"), houseid );
	mysql_single_query( szNormalString );
	return 1;
}

stock getFurnitureID( modelid )
{
	for( new i = 0; i < sizeof( g_houseFurniture ); i++ )
		if ( modelid == g_houseFurniture[ i ] [ E_MODEL ] ) return i;

	return 0xFF;
}

stock ShowOwnedFurnitureList( playerid, houseid, bool: apartment = false )
{
	new count = 0, j = Streamer_GetUpperBound( STREAMER_TYPE_OBJECT );
	erase( szLargeString );
	printf("Preloaded objects %d | upperbound %d", g_preloadedObjectCount, j );
	for( new i = g_preloadedObjectCount; i < j; i++ ) if ( IsValidDynamicObject( i ) )
	{
		if ( apartment == true && GetGVarInt( "fur_a", i ) != houseid ) continue;
		if ( apartment == false && ( GetGVarInt( "fur_w", i ) - MAX_HOUSES ) != houseid ) continue;
		count++;
		format( szLargeString, sizeof( szLargeString ), "%s%s\n", szLargeString, g_houseFurniture[ GetGVarInt( "fur_f", i ) ] [ E_NAME ] );
	}

	if ( !count )
		SendError( playerid, "You don't own any furniture." ), ShowPlayerDialog( playerid, DIALOG_FURNITURE, DIALOG_STYLE_LIST, "{FFFFFF}Furniture", "Purchase Furniture\nSelect Furniture Easily\nSelect Furniture Manually\nSelect Furniture Nearest\n"COL_RED"Remove All Furniture", "Confirm", "Back" );
	else
		ShowPlayerDialog( playerid, DIALOG_FURNITURE_MAN_SEL, DIALOG_STYLE_LIST, "Furniture", szLargeString, "Select", "Back" );
}

stock ShowFurnitureCategory( playerid )
{
	static
	    szCategory[ 148 ];

	if ( szCategory[ 0 ] == '\0' )
	{
	    for( new i = 0; i < sizeof( g_furnitureCategory ); i++ )
	        format( szCategory, sizeof( szCategory ), "%s%s\n", szCategory, g_furnitureCategory[ i ] );
	}
	ShowPlayerDialog( playerid, DIALOG_FURNITURE_CATEGORY, DIALOG_STYLE_LIST, "Furniture", szCategory, "Select", "Back" );
	return 1;
}

stock ShowFurnitureList( playerid, category )
{
	szLargeString = ""COL_WHITE"Furniture\t"COL_WHITE"Cost\n";

    for( new i = 0; i < sizeof( g_houseFurniture ); i++ ) if ( g_houseFurniture[ i ] [ E_CATEGORY ] == category )
		format( szLargeString, sizeof( szLargeString ), "%s%s\t"COL_GOLD"%s\n", szLargeString, g_houseFurniture[ i ] [ E_NAME ], ConvertPrice( g_houseFurniture[ i ] [ E_COST ] ) );

	ShowPlayerDialog( playerid, DIALOG_FURNITURE_LIST, DIALOG_STYLE_TABLIST_HEADERS, "Furniture", szLargeString, "Select", "Back" );
}

stock IsPaintJobVehicle(value) {
    static const valid_values[3] = {
        1, 3670016, 806680576
    };
    if (483 <= value <= 576) {
        value -= 483;
        return (valid_values[value >>> 5] & (1 << (value & 31))) || false;
    }
    return false;
}

stock IsVehicleUpsideDown(vehicleid)
{
    new
        Float: q_W,
        Float: q_X,
        Float: q_Y,
        Float: q_Z
    ;
    GetVehicleRotationQuat(vehicleid, q_W, q_X, q_Y, q_Z);
    return (120.0 < atan2(2.0 * ((q_Y * q_Z) + (q_X * q_W)), (-(q_X * q_X) - (q_Y * q_Y) + (q_Z * q_Z) + (q_W * q_W))) > -120.0);
}

stock ShowProgressBar( playerid, title[ ], pID, update = 1000, color, params = 0 )
{
	if ( !IsPlayerConnected( playerid ) )
	    return 0;

	if ( p_ProgressStarted{ playerid } )
	{
    	StopProgressBar( playerid );
		p_CancelProgress{ playerid } = true; // Cancel.
		//SendClientMessageFormatted( playerid, COLOR_PINK, "RESTARTING PROGRESS %d (params [OLD:%d,NEW:%d]", pID, GetPVarInt( playerid, "progress_lastparams" ), params );
		CallLocalFunction( "OnPlayerProgressUpdate", "ddd", playerid, GetPVarInt( playerid, "progress_lastid" ), GetPVarInt( playerid, "progress_lastparams" ) );
		return ShowProgressBar( playerid, title, pID, update, color, params ), 1;
	}

    if ( p_ProgressUpdateTimer[ playerid ] != 0xFFFF ) {
 		KillTimer( p_ProgressUpdateTimer[ playerid ] );
		p_ProgressUpdateTimer[ playerid ] = 0xFFFF;
    }

	p_ProgressStarted{ playerid } = true;
    p_ProgressStatus[ playerid ]  = 249.0;

    TextDrawHideForPlayer( playerid, g_ProgressBoxTD );
    TextDrawHideForPlayer( playerid, p_ProgressBoxOutsideTD[ playerid ] );
    TextDrawHideForPlayer( playerid, p_ProgressBoxTD[ playerid ] );
    TextDrawHideForPlayer( playerid, p_ProgressTitleTD[ playerid ] );

	TextDrawTextSize( p_ProgressBoxTD[ playerid ], p_ProgressStatus[ playerid ], 14.000000 );
	TextDrawSetString( p_ProgressTitleTD[ playerid ], title );
	TextDrawBoxColor( p_ProgressBoxTD[ playerid ], color );
	TextDrawBoxColor( p_ProgressBoxOutsideTD[ playerid ], ( color & 0xFFFFFF00 ) | ( 0x66 & ( ( color & 0x000000FF ) / 2 ) ) );

    TextDrawShowForPlayer( playerid, g_ProgressBoxTD );
    TextDrawShowForPlayer( playerid, p_ProgressBoxOutsideTD[ playerid ] );
    TextDrawShowForPlayer( playerid, p_ProgressBoxTD[ playerid ] );
    TextDrawShowForPlayer( playerid, p_ProgressTitleTD[ playerid ] );

    SetPVarInt( playerid, "progress_lastparams", params );
    SetPVarInt( playerid, "progress_lastid", 	 pID );

    KillTimer( p_ProgressUpdateTimer[ playerid ] );
	p_ProgressUpdateTimer[ playerid ] = SetTimerEx( "ProgressBar_Update", update, false, "dddd", playerid, pID, update, params );
	return 1;
}

stock StopProgressBar( playerid )
{
	KillTimer( p_ProgressUpdateTimer[ playerid ] );

	p_ProgressUpdateTimer	[ playerid ] = 0xFFFF;
	p_ProgressStarted		{ playerid } = false;
    p_ProgressStatus		[ playerid ] = 249.0;

    TextDrawHideForPlayer( playerid, g_ProgressBoxTD );
    TextDrawHideForPlayer( playerid, p_ProgressBoxOutsideTD[ playerid ] );
    TextDrawHideForPlayer( playerid, p_ProgressBoxTD[ playerid ] );
    TextDrawHideForPlayer( playerid, p_ProgressTitleTD[ playerid ] );

	return ClearAnimations( playerid ), 1;
}

function ProgressBar_Update( playerid, progressid, tickrate, params )
{
	if ( !IsPlayerConnected( playerid ) || !IsPlayerSpawned( playerid ) || p_ProgressStarted{ playerid } == false )
	{
    	StopProgressBar( playerid );
		p_CancelProgress{ playerid } = true; // Cancel.
		//SendClientMessageFormatted( playerid, COLOR_ORANGE, "STOPPING PROGRESS %d", progressid );
		CallLocalFunction( "OnPlayerProgressUpdate", "ddd", playerid, progressid, params );
	    return 0;
	}

	p_ProgressStatus[ playerid ] += 13.0;
	if ( p_ProgressStatus[ playerid ] >= 388 ) p_ProgressStatus[ playerid ] = 388;

	TextDrawTextSize( p_ProgressBoxTD[ playerid ], p_ProgressStatus[ playerid ], 14.000000 );
    TextDrawShowForPlayer( playerid, p_ProgressBoxTD[ playerid ] );

	CallLocalFunction( "OnPlayerProgressUpdate", "ddd", playerid, progressid, params );

	if ( p_ProgressStatus[ playerid ] >= 388 )
	{
    	StopProgressBar( playerid );
    	CallLocalFunction( "OnPlayerProgressComplete", "ddd", playerid, progressid, params );
    	return 1;
 	}
 	KillTimer( p_ProgressUpdateTimer[ playerid ] ); // Just incase.
	return ( p_ProgressUpdateTimer[ playerid ] = SetTimerEx( "ProgressBar_Update", tickrate, false, "dddd", playerid, progressid, tickrate, params ) );
}

stock ResetVehicleBurglaryData( vehicleid )
{
    if ( GetVehicleModel( vehicleid ) != 498 )
        return 0;

	new szString[ 18 ];
	for( new i; i < MAX_BURGLARY_SLOTS; i++ )
		format( szString, sizeof( szString ), "vburg_%d_%d", vehicleid, i ), DeleteGVar( szString );

    format( szString, sizeof( szString ), "vburg_%d_items", vehicleid );
    DeleteGVar( szString );
	return 1;
}

stock RemovePlayerStolensFromHands( playerid )
{
	DeletePVar( playerid, "stolen_fid" );
	RemovePlayerAttachedObject( playerid, 3 );
	SetPlayerSpecialAction( playerid, 0 );
	return 1;
}

stock getClosestFurniture( playerid, &Float: dis = 99999.99 )
{
	new
		Float: dis2,
		object = INVALID_OBJECT_ID,
		Float: X, Float: Y, Float: Z,
		is_in_apartment = IsPlayerInApartmentArea( playerid, p_ApartmentEditing{ playerid } )
	;
    for( new i = g_preloadedObjectCount; i < Streamer_GetUpperBound( STREAMER_TYPE_OBJECT ); i++ )
	{
		if ( IsValidDynamicObject( i ) )
		{
			if ( is_in_apartment && GetGVarInt( "fur_a", i ) != p_ApartmentEditing{ playerid } ) continue;
			if ( !is_in_apartment && GetGVarInt( "fur_w", i ) != p_InHouse[ playerid ] + MAX_HOUSES ) continue;

			GetDynamicObjectPos( i, X, Y, Z );
	    	dis2 = GetPlayerDistanceFromPoint( playerid, X, Y, Z );
	    	if ( dis2 < dis && dis2 != -1.00 ) {
	    	    dis = dis2;
	    	    object = i;
			}
		}
	}
	return object;
}

stock IsPlayerInWater(playerid) // SuperViper
{
    new animationIndex = GetPlayerAnimationIndex(playerid);
    return (animationIndex >= 1538 && animationIndex <= 1544 && animationIndex != 1542);
}

stock ForceSpectateOnPlayer( playerid, pID )
{
	if ( IsPlayerConnected( p_whomSpectating[ playerid ] ) ) {
    	p_beingSpectated[ p_whomSpectating[ playerid ] ] = false;
    	p_whomSpectating[ playerid ] = INVALID_PLAYER_ID;
	}
    p_whomSpectating[ playerid ] = pID;
    p_beingSpectated[ pID ] = true;
	SendClientMessageFormatted( playerid, -1, ""COL_PINK"[ADMIN]"COL_WHITE" You are now spectating %s(%d).", ReturnPlayerName( pID ), pID );
	SetPlayerVirtualWorld( playerid, GetPlayerVirtualWorld( pID ) );
	SetPlayerInterior( playerid, GetPlayerInterior( pID ) );
	if ( IsPlayerInAnyVehicle( pID ) )
	{
		TogglePlayerSpectating(playerid, 1),
		PlayerSpectateVehicle(playerid, GetPlayerVehicleID( pID ) );
	}
	else
	{
		TogglePlayerSpectating( playerid, 1 ),
		PlayerSpectatePlayer( playerid, pID );
	}
}

stock KickPlayerTimed( playerid )
	return SetTimerEx( "KickPlayer", 500, false, "d", playerid );

function KickPlayer( playerid )
	return SetPVarInt( playerid, "banned_connection", 1 ), Kick( playerid );

stock IsPointInPolygon(Float: point_X, Float: point_Y, { Float, _ }: ...)
{
    #define MAX_POINTS (32)

    new
        args_Total = numargs(),
        polygon_Sides = (args_Total - 2) / 2
    ;
    if ((args_Total - 2) & 0b1 || MAX_POINTS <= polygon_Sides || polygon_Sides < 3)
        return 0;

    new
        Float: polygon_Data[2][MAX_POINTS],
        cross_Total
    ;
    #undef MAX_POINTS

    for(new i = 2, j; i < args_Total; i += 2, ++j)
    {
        polygon_Data[0][j] = Float: getarg(i);
        polygon_Data[1][j] = Float: getarg(i + 1);
    }
    for(new i, j = polygon_Sides - 1; i < polygon_Sides; j = i, ++i)
    {
        if (polygon_Data[1][i] < point_Y && polygon_Data[1][j] >= point_Y || polygon_Data[1][j] < point_Y && polygon_Data[1][i] >= point_Y)
        {
            if (polygon_Data[0][i] + (point_Y - polygon_Data[1][i]) / (polygon_Data[1][j] - polygon_Data[1][i]) * (polygon_Data[0][j] - polygon_Data[0][i]) < point_X)
            {
                cross_Total++;
            }
        }
    }
    return cross_Total & 0b1;
}

stock ShowBuyableVehiclesList( playerid )
{
	static
		szCategory[ 16 * sizeof( g_BVCategories ) ];

	if ( szCategory[ 0 ] == '\0' )
	{
		for( new i; i < sizeof( g_BVCategories ); i++ )
			format( szCategory, sizeof( szCategory ), "%s%s\n", szCategory, g_BVCategories[ i ] );
	}
	return ShowPlayerDialog( playerid, DIALOG_VEHDEALER, DIALOG_STYLE_LIST, "{FFFFFF}Vehicle Dealership", szCategory, "Select", "Cancel" );
}

stock ShowBuyableVehiclesTypeDialog( playerid, type_id )
{
	static
		szBuyableVehicles[ 1400 ];

	erase( szBuyableVehicles );

	for( new i; i < sizeof( g_BuyableVehicleData ); i++ )
	{
		if ( g_BuyableVehicleData[ i ] [ E_TYPE ] == type_id )
			format( szBuyableVehicles, sizeof( szBuyableVehicles ), "%s"COL_GOLD"%s%s%s\t%s\n", szBuyableVehicles, ConvertPrice( g_BuyableVehicleData[ i ] [ E_PRICE ] ), g_BuyableVehicleData[ i ] [ E_VIP ] ? ( "" ) : ( #COL_WHITE ), g_BuyableVehicleData[ i ] [ E_PRICE ] < 100000 ? ( "\t" ) : ( "" ), g_BuyableVehicleData[ i ] [ E_NAME ] );
	}

	ShowPlayerDialog( playerid, DIALOG_VEHDEALER_BUY, DIALOG_STYLE_LIST, "{FFFFFF}Vehicle Dealership", szBuyableVehicles, "Options", "Cancel" );
	SetPVarInt( playerid, "vehicle_preview", type_id );
	return 1;
}

stock CreateMiningRock( ore_type, model, Float: X, Float: Y, Float: Z, Float: rX = 0.0, Float: rY = 0.0, Float: rZ = 0.0 )
{
	new
		ID = Iter_Free(miningrock),
		szOre[ 14 ],
		iOreColour
	;

	if ( ID != ITER_NONE )
	{
		Iter_Add(miningrock, ID);

		g_miningData[ ID ] [ E_OBJECT ] 		= CreateDynamicObject( model, X, Y, Z, rX, rY, rZ );
		g_miningData[ ID ] [ E_MINING ] 		= INVALID_PLAYER_ID;
		g_miningData[ ID ] [ E_ORES ] 			= g_oreQuanities[ ore_type ]; // To replenish
		g_miningData[ ID ] [ E_MAX_ORES ]		= g_oreQuanities[ ore_type ];
		g_miningData[ ID ] [ E_ORE ] 			= ore_type;

		switch( ore_type )
		{
			case ORE_BAUXITE:
			{
				iOreColour = 0xC24000FF;
			 	SetDynamicObjectMaterial( g_miningData[ ID ] [ E_OBJECT ], 0,  2936, "kmb_rckx", "larock256", 0xFFC24000 );
			}
			case ORE_COAL:
			{
				iOreColour = 0x5B5E28FF;
			 	SetDynamicObjectMaterial( g_miningData[ ID ] [ E_OBJECT ], 0, 2936, "kmb_rckx", "larock256", 0xFF5B5E28 );
			}
			case ORE_IRON:
			{
				iOreColour = 0x3D3837FF;
			 	SetDynamicObjectMaterial( g_miningData[ ID ] [ E_OBJECT ], 0, 2936, "kmb_rckx", "larock256", 0xFF3D3837 );
			}
			case ORE_GOLD:
			{
				iOreColour = 0xE6A615FF;
			 	SetDynamicObjectMaterial( g_miningData[ ID ] [ E_OBJECT ], 0, 2936, "kmb_rckx", "larock256", 0xFFE6A615 );
			}
			case ORE_RUBY:
			{
				iOreColour = 0xE0115FFF;
			 	SetDynamicObjectMaterial( g_miningData[ ID ] [ E_OBJECT ], 0, 2936, "kmb_rckx", "larock256", 0xFFE0115F );
			}
			case ORE_EMERALD:
			{
				iOreColour = 0x50C878FF;
			 	SetDynamicObjectMaterial( g_miningData[ ID ] [ E_OBJECT ], 0, 2936, "kmb_rckx", "larock256", 0xFF50C878 );
			}
			case ORE_SAPHHIRE:
			{
				iOreColour = 0x0F52BAFF;
			 	SetDynamicObjectMaterial( g_miningData[ ID ] [ E_OBJECT ], 0, 2936, "kmb_rckx", "larock256", 0xFF0F52BA );
			}
			case ORE_PLATINUM:
			{
				iOreColour = 0xE5E5E5FF;
			 	SetDynamicObjectMaterial( g_miningData[ ID ] [ E_OBJECT ], 0, 2936, "kmb_rckx", "larock256", 0xFFE5E5E5 );
			}
			case ORE_DIAMOND:
			{
				iOreColour = 0x232323FF;
			 	SetDynamicObjectMaterial( g_miningData[ ID ] [ E_OBJECT ], 0, 2936, "kmb_rckx", "larock256", 0xFF232323 );
			}
			case ORE_AMETHYST:
			{
				iOreColour = 0x9966CCFF;
			 	SetDynamicObjectMaterial( g_miningData[ ID ] [ E_OBJECT ], 0, 2936, "kmb_rckx", "larock256", 0xFF9966CC );
			}
		}
		format( szOre, sizeof( szOre ), "%s\n%d/%d", getOreName( ore_type ), g_miningData[ ID ] [ E_ORES ], g_miningData[ ID ] [ E_MAX_ORES ] );
		g_miningData[ ID ] [ E_COLOR ] = iOreColour;
		g_miningData[ ID ] [ E_LABEL ] = CreateDynamic3DTextLabel( szOre, iOreColour, X, Y, Z + 1, 10.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, -1 );
	}
	return ID;
}

stock getOreName( id )
{
	static
		szOre[ 9 ];

	switch( id )
	{
		case ORE_GOLD: szOre = "Gold";
		case ORE_IRON: szOre = "Iron";
		case ORE_COAL: szOre = "Coal";
		case ORE_BAUXITE: szOre = "Bauxite";
		case ORE_AMETHYST: szOre = "Amethyst";
		case ORE_EMERALD: szOre = "Emerald";
		case ORE_SAPHHIRE: szOre = "Saphhire";
		case ORE_PLATINUM: szOre = "Platinum";
		case ORE_DIAMOND: szOre = "Diamond";
		case ORE_RUBY: szOre = "Ruby";
		default: szOre = "n/a";
	}
	return szOre;
}

stock RemoveEquippedOre( playerid )
{
	RemovePlayerAttachedObject( playerid, 4 );
	SetPlayerSpecialAction( playerid, SPECIAL_ACTION_NONE );
	ClearAnimations( playerid );
	DeletePVar( playerid, "carrying_ore" );
	return 1;
}

stock returnCityName( city )
{
	static
		string[ 13 ];

	switch( city )
	{
		case CITY_SF: string = "San Fierro";
		case CITY_LV: string = "Las Venturas";
		case CITY_LS: string = "Los Santos";
		default: string = "Unknown City";
	}
	return string;
}

stock jailMoveGate( playerid, city, bool: close = false, bool: alcatraz = false )
{
	static const
		Float: speed = 2.0;

	if ( !close && IsPlayerAdminJailed( playerid ) )
		return;

	if ( alcatraz )
	{
		if ( close ) MoveDynamicObject( p_AlcatrazObject[ playerid ], -2038.832641, 1843.541992, 24.695789, 		speed );
		else  		MoveDynamicObject( p_AlcatrazObject[ playerid ], -2038.832641, 1843.541992, 24.695789 - 10,	speed );
	 	return;
	}

	switch( city )
	{
		case CITY_LV:
		{
			if ( close )
			{
				MoveDynamicObject( p_JailObjectLV[ playerid ] [ 0 ], 198.94980, 160.26476, 1003.26135, speed );
				MoveDynamicObject( p_JailObjectLV[ playerid ] [ 1 ], 192.95604, 177.08791, 1003.26215, speed );
				MoveDynamicObject( p_JailObjectLV[ playerid ] [ 2 ], 197.19141, 177.08476, 1003.26215, speed );
			}
			else
			{
				MoveDynamicObject( p_JailObjectLV[ playerid ] [ 0 ], 197.18980, 160.26480, 1003.26141, speed );
				MoveDynamicObject( p_JailObjectLV[ playerid ] [ 1 ], 194.69600, 177.08791, 1003.26208, speed );
				MoveDynamicObject( p_JailObjectLV[ playerid ] [ 2 ], 198.95140, 177.08479, 1003.26208, speed );
			}
		}
		case CITY_SF:
		{
			if ( close )
			{
				MoveDynamicObject( p_JailObjectSF[ playerid ] [ 0 ], 214.68274, 112.62182, 999.29553, speed );
				MoveDynamicObject( p_JailObjectSF[ playerid ] [ 1 ], 218.61810, 112.62180, 999.29547, speed );
				MoveDynamicObject( p_JailObjectSF[ playerid ] [ 2 ], 222.62241, 112.62180, 999.29547, speed );
				MoveDynamicObject( p_JailObjectSF[ playerid ] [ 3 ], 226.51570, 112.62180, 999.29547, speed );
			}
			else
			{
				MoveDynamicObject( p_JailObjectSF[ playerid ] [ 0 ], 216.44754, 112.61965, 999.29547, speed );
				MoveDynamicObject( p_JailObjectSF[ playerid ] [ 1 ], 220.40450, 112.62180, 999.29547, speed );
				MoveDynamicObject( p_JailObjectSF[ playerid ] [ 2 ], 224.40781, 112.62180, 999.29547, speed );
				MoveDynamicObject( p_JailObjectSF[ playerid ] [ 3 ], 228.27820, 112.62180, 999.29547, speed );
			}
		}
		case CITY_LS:
		{
			if ( close )
			{
				MoveDynamicObject( p_JailObjectLS[ playerid ] [ 0 ], 266.36481, 85.710700, 1001.27979, speed );
				MoveDynamicObject( p_JailObjectLS[ playerid ] [ 1 ], 266.36481, 81.211600, 1001.27979, speed );
				MoveDynamicObject( p_JailObjectLS[ playerid ] [ 2 ], 266.36481, 76.709470, 1001.27985, speed );
			}
			else
			{
				MoveDynamicObject( p_JailObjectLS[ playerid ] [ 0 ], 266.36481, 87.45710, 1001.27979, speed );
				MoveDynamicObject( p_JailObjectLS[ playerid ] [ 1 ], 266.36481, 82.95660, 1001.27979, speed );
				MoveDynamicObject( p_JailObjectLS[ playerid ] [ 2 ], 266.36481, 78.44830, 1001.27979, speed );
			}
		}
	}
}

stock jailDoors( playerid, remove = false, set_closed = true )
{
	if ( set_closed )
	{
		if ( IsValidDynamicObject( p_JailObjectLV[ playerid ] [ 0 ] ) || IsValidDynamicObject( p_JailObjectSF[ playerid ] [ 0 ] ) || IsValidDynamicObject( p_JailObjectLS[ playerid ] [ 0 ] ) )
		{
			SetDynamicObjectPos( p_JailObjectLV[ playerid ] [ 0 ], 198.94980, 160.26476, 1003.26135 );
			SetDynamicObjectPos( p_JailObjectLV[ playerid ] [ 1 ], 192.95604, 177.08791, 1003.26215 );
			SetDynamicObjectPos( p_JailObjectLV[ playerid ] [ 2 ], 197.19141, 177.08476, 1003.26215 );

			SetDynamicObjectPos( p_JailObjectSF[ playerid ] [ 0 ], 214.68274, 112.62182, 999.29553 );
			SetDynamicObjectPos( p_JailObjectSF[ playerid ] [ 1 ], 218.61810, 112.62180, 999.29547 );
			SetDynamicObjectPos( p_JailObjectSF[ playerid ] [ 2 ], 222.62241, 112.62180, 999.29547 );
			SetDynamicObjectPos( p_JailObjectSF[ playerid ] [ 3 ], 226.51570, 112.62180, 999.29547 );

			SetDynamicObjectPos( p_JailObjectLS[ playerid ] [ 0 ], 266.36481, 85.710700, 1001.27979 );
			SetDynamicObjectPos( p_JailObjectLS[ playerid ] [ 1 ], 266.36481, 81.211600, 1001.27979 );
			SetDynamicObjectPos( p_JailObjectLS[ playerid ] [ 2 ], 266.36481, 76.709470, 1001.27985 );

			SetDynamicObjectPos( p_AlcatrazObject[ playerid ], -2038.832641, 1843.541992, 24.695789 );
			return;
		}
	}

	if ( !remove )
	{
		if ( IsValidDynamicObject( p_JailObjectLV[ playerid ] [ 0 ] ) || IsValidDynamicObject( p_JailObjectSF[ playerid ] [ 0 ] ) || IsValidDynamicObject( p_JailObjectLS[ playerid ] [ 0 ] ) )
		{
			DestroyDynamicObject( p_JailObjectLV[ playerid ] [ 0 ] ), p_JailObjectLV[ playerid ] [ 0 ] = INVALID_OBJECT_ID;
			DestroyDynamicObject( p_JailObjectLV[ playerid ] [ 1 ] ), p_JailObjectLV[ playerid ] [ 1 ] = INVALID_OBJECT_ID;
			DestroyDynamicObject( p_JailObjectLV[ playerid ] [ 2 ] ), p_JailObjectLV[ playerid ] [ 2 ] = INVALID_OBJECT_ID;

			DestroyDynamicObject( p_JailObjectSF[ playerid ] [ 0 ] ), p_JailObjectSF[ playerid ] [ 0 ] = INVALID_OBJECT_ID;
			DestroyDynamicObject( p_JailObjectSF[ playerid ] [ 1 ] ), p_JailObjectSF[ playerid ] [ 1 ] = INVALID_OBJECT_ID;
			DestroyDynamicObject( p_JailObjectSF[ playerid ] [ 2 ] ), p_JailObjectSF[ playerid ] [ 2 ] = INVALID_OBJECT_ID;
			DestroyDynamicObject( p_JailObjectSF[ playerid ] [ 3 ] ), p_JailObjectSF[ playerid ] [ 3 ] = INVALID_OBJECT_ID;

			DestroyDynamicObject( p_JailObjectLS[ playerid ] [ 0 ] ), p_JailObjectLS[ playerid ] [ 0 ] = INVALID_OBJECT_ID;
			DestroyDynamicObject( p_JailObjectLS[ playerid ] [ 1 ] ), p_JailObjectLS[ playerid ] [ 1 ] = INVALID_OBJECT_ID;
			DestroyDynamicObject( p_JailObjectLS[ playerid ] [ 2 ] ), p_JailObjectLS[ playerid ] [ 2 ] = INVALID_OBJECT_ID;

			DestroyDynamicObject( p_AlcatrazObject[ playerid ] ), p_AlcatrazObject[ playerid ] = INVALID_OBJECT_ID;
		}

		p_JailObjectLV[ playerid ] [ 0 ] = CreateDynamicObject( 19303, 198.94980, 160.26476, 1003.26135, 0.00000, 0.00000, 0.00000, -1, -1, playerid );
		p_JailObjectLV[ playerid ] [ 1 ] = CreateDynamicObject( 19302, 192.95604, 177.08791, 1003.26215, 0.00000, 0.00000, 0.00000, -1, -1, playerid );
		p_JailObjectLV[ playerid ] [ 2 ] = CreateDynamicObject( 19302, 197.19141, 177.08476, 1003.26215, 0.00000, 0.00000, 0.00000, -1, -1, playerid );

		p_JailObjectSF[ playerid ] [ 0 ] = CreateDynamicObject( 19302, 214.68274, 112.62182, 999.295530, 0.00000, 0.00000, 0.00000, -1, -1, playerid );
		p_JailObjectSF[ playerid ] [ 1 ] = CreateDynamicObject( 19302, 218.61810, 112.62180, 999.295470, 0.00000, 0.00000, 0.00000, -1, -1, playerid );
		p_JailObjectSF[ playerid ] [ 2 ] = CreateDynamicObject( 19302, 222.62241, 112.62180, 999.295470, 0.00000, 0.00000, 0.00000, -1, -1, playerid );
		p_JailObjectSF[ playerid ] [ 3 ] = CreateDynamicObject( 19302, 226.51570, 112.62180, 999.295470, 0.00000, 0.00000, 0.00000, -1, -1, playerid );

		p_JailObjectLS[ playerid ] [ 0 ] = CreateDynamicObject( 19302, 266.36481, 85.710700, 1001.27979, 0.00000, 0.00000, 90.0000, -1, -1, playerid );
		p_JailObjectLS[ playerid ] [ 1 ] = CreateDynamicObject( 19302, 266.36481, 81.211600, 1001.27979, 0.00000, 0.00000, 90.0000, -1, -1, playerid );
		p_JailObjectLS[ playerid ] [ 2 ] = CreateDynamicObject( 19302, 266.36481, 76.709470, 1001.27985, 0.00000, 0.00000, 90.0000, -1, -1, playerid );

		p_AlcatrazObject[ playerid ] = 	   CreateDynamicObject( 16775, -2038.832, 1843.5419, 24.695789, 0.00000, 0.00000, 0.999999, -1, -1, playerid );
	}
	else
	{
		DestroyDynamicObject( p_JailObjectLV[ playerid ] [ 0 ] ), p_JailObjectLV[ playerid ] [ 0 ] = INVALID_OBJECT_ID;
		DestroyDynamicObject( p_JailObjectLV[ playerid ] [ 1 ] ), p_JailObjectLV[ playerid ] [ 1 ] = INVALID_OBJECT_ID;
		DestroyDynamicObject( p_JailObjectLV[ playerid ] [ 2 ] ), p_JailObjectLV[ playerid ] [ 2 ] = INVALID_OBJECT_ID;

		DestroyDynamicObject( p_JailObjectSF[ playerid ] [ 0 ] ), p_JailObjectSF[ playerid ] [ 0 ] = INVALID_OBJECT_ID;
		DestroyDynamicObject( p_JailObjectSF[ playerid ] [ 1 ] ), p_JailObjectSF[ playerid ] [ 1 ] = INVALID_OBJECT_ID;
		DestroyDynamicObject( p_JailObjectSF[ playerid ] [ 2 ] ), p_JailObjectSF[ playerid ] [ 2 ] = INVALID_OBJECT_ID;
		DestroyDynamicObject( p_JailObjectSF[ playerid ] [ 3 ] ), p_JailObjectSF[ playerid ] [ 3 ] = INVALID_OBJECT_ID;

		DestroyDynamicObject( p_JailObjectLS[ playerid ] [ 0 ] ), p_JailObjectLS[ playerid ] [ 0 ] = INVALID_OBJECT_ID;
		DestroyDynamicObject( p_JailObjectLS[ playerid ] [ 1 ] ), p_JailObjectLS[ playerid ] [ 1 ] = INVALID_OBJECT_ID;
		DestroyDynamicObject( p_JailObjectLS[ playerid ] [ 2 ] ), p_JailObjectLS[ playerid ] [ 2 ] = INVALID_OBJECT_ID;

		DestroyDynamicObject( p_AlcatrazObject[ playerid ] ), p_AlcatrazObject[ playerid ] = INVALID_OBJECT_ID;
	}
}

stock autosaveStart( playerid, bool: force_save = false )
{
	new
		iTime = g_iTime;

    if (  p_PlayerSettings[ playerid ] { SETTING_AUTOSAVE } && force_save == false )
		return;

    if ( GetPVarInt( playerid, "last_transaction" ) > iTime && force_save == false )
    	return;

	SavePlayerData( playerid );
	SetPVarInt( playerid, "last_transaction", iTime + 15 );
	SendClientMessage( playerid, -1, p_PlayerSettings[ playerid ] { SETTING_AUTOSAVE } ? ( ""COL_LRED"[AUTO-SAVE]"COL_WHITE" Your statistics have been saved." ) :  (""COL_LRED"[AUTO-SAVE]"COL_WHITE" Your statistics have been saved, "COL_GREY"you can disable this over /cp"COL_WHITE"." ) );
}

stock getCurrentDate( )
{
	static
		Year, Month, Day,
		szString[ 11 ]
	;

	getdate( Year, Month, Day );
	format( szString, sizeof( szString ), "%02d/%02d/%d", Day, Month, Year );
	return szString;
}

stock getCurrentTime( )
{
	static
		Hour, Minute, Second,
		szString[ 11 ]
	;

	gettime( Hour, Minute, Second );
	format( szString, sizeof( szString ), "%02d:%02d:%02d", Hour, Minute, Second );
	return szString;
}

stock getPlayerBusinessCapacity( playerid )
{
	new
		slots = 2; // Default

	switch( p_VIPLevel[ playerid ] )
	{
		case VIP_DIAMOND: // dia
			slots = 10;

		case VIP_PLATINUM: // plat
			slots = 6;

		case VIP_GOLD: // gold
			slots = 5;

		case VIP_BRONZE: // bronze
			slots = 4;

		case VIP_REGULAR: // regular
			slots = 3;
	}
	return slots;
}

stock getPlayerVehicleCapacity( playerid )
{
	new
		slots = 3; // Default

	switch( p_VIPLevel[ playerid ] )
	{
		case VIP_DIAMOND:
			slots = 20;

		case VIP_PLATINUM:
			slots = 10;

		case VIP_GOLD:
			slots = 8;

		case VIP_BRONZE:
			slots = 6;

		case VIP_REGULAR:
			slots = 5;
	}
	return slots + p_ExtraAssetSlots{ playerid };
}

stock getPlayerHouseCapacity( playerid )
{
	new
		slots = 3;

	switch( p_VIPLevel[ playerid ] )
	{
		case VIP_DIAMOND:
			slots = 20;

		case VIP_PLATINUM:
			slots = 10;

		case VIP_GOLD:
			slots = 8;

		case VIP_BRONZE:
			slots = 6;

		case VIP_REGULAR:
			slots = 5;
	}
	return slots + p_ExtraAssetSlots{ playerid };
}

stock hasTooManyHouses( playerid )
{
	if ( IsPlayerLorenc( playerid ) )
		return false; // No house limit

	new
		totalhouses = getPlayerHouseCapacity( playerid );

	if ( p_OwnedHouses[ playerid ] >= totalhouses )
		return true;

	return false;
}

stock hasTooManyVehicles( playerid )
{
	new
		totalvehicles = getPlayerVehicleCapacity( playerid );

	if ( p_OwnedVehicles[ playerid ] >= totalvehicles )
		return true;

	return false;
}

new
	p_HideHelpDialogTimer[ MAX_PLAYERS ] = { 0xFFFF, ... };

stock ShowPlayerHelpDialog( playerid, timeout, format[ ], va_args<> )
{
    static
		out[ 255 ]
	;

	if ( !IsPlayerConnected( playerid ) )
		return 0;

    va_format( out, sizeof( out ), format, va_start<3> );

    TextDrawSetString( p_HelpBoxTD[ playerid ], out );
    TextDrawShowForPlayer( playerid, p_HelpBoxTD[ playerid ] );

    KillTimer( p_HideHelpDialogTimer[ playerid ] );

   	if ( timeout != 0 )
   		p_HideHelpDialogTimer[ playerid ] = SetTimerEx( "HidePlayerHelpDialog", timeout, false, "d", playerid );

	return 1;
}

function HidePlayerHelpDialog( playerid )
{
	p_HideHelpDialogTimer[ playerid ] = 0xFFFF;
	TextDrawHideForPlayer( playerid, p_HelpBoxTD[ playerid ] );
}

stock fix_NightThermalVisionHack( playerid ) // Created by wups
{
    static
    	weapon;

    weapon = GetPlayerWeapon( playerid );
    if ( weapon == 44 || weapon == 45 )
    {
        static
            HoldingFire[ MAX_PLAYERS ],
            IsHoldingFire[ MAX_PLAYERS char ],
            CanHoldAgain[ MAX_PLAYERS char ],
            keys, lr, tick
      	;

        GetPlayerKeys( playerid, keys, lr, lr);
        tick = GetTickCount( );

        if ( keys & KEY_FIRE )
        {
            if ( !IsHoldingFire{ playerid } && CanHoldAgain{ playerid } )
            {
                IsHoldingFire{ playerid } = 1;
                HoldingFire[ playerid ] = tick;
                CanHoldAgain{ playerid } = 0;
            }
        }
        else if ( !CanHoldAgain{ playerid } ) CanHoldAgain{ playerid } = 1;

        if ( IsHoldingFire{ playerid } )
        {
            if ( tick - 1500 <= HoldingFire[ playerid ] )
            {
                return 0;
            }
            else
            {
                IsHoldingFire{ playerid } = 0;
                return 1;
            }
        }
    }
    return 1;
}

thread OnGatesLoad( )
{
	new
		rows, fields, i = -1, gID,
		Field[ 20 ],
	    loadingTick = GetTickCount( )
	;

	cache_get_data( rows, fields );
	if ( rows )
	{
		while( ++i < rows )
		{
			cache_get_field_content( i, "ID", Field ),			gID = strval( Field );
			cache_get_field_content( i, "PASSWORD", 			g_gateData[ gID ] [ E_PASS ], dbHandle, 8 );
			cache_get_field_content( i, "NAME", 				g_gateData[ gID ] [ E_NAME ], dbHandle, 24 );
			cache_get_field_content( i, "OWNER", Field ),     	g_gateData[ gID ] [ E_OWNER ] = strval( Field );
			cache_get_field_content( i, "MODEL", Field ),     	g_gateData[ gID ] [ E_MODEL ] = strval( Field );
			cache_get_field_content( i, "TIME", Field ),     	g_gateData[ gID ] [ E_TIME ] = strval( Field );
			cache_get_field_content( i, "SPEED", Field ),     	g_gateData[ gID ] [ E_SPEED ] = floatstr( Field );
			cache_get_field_content( i, "RANGE", Field ),     	g_gateData[ gID ] [ E_RANGE ] = floatstr( Field );
			cache_get_field_content( i, "X", Field ),         	g_gateData[ gID ] [ E_X ] = floatstr( Field );
			cache_get_field_content( i, "Y", Field ),         	g_gateData[ gID ] [ E_Y ] = floatstr( Field );
			cache_get_field_content( i, "Z", Field ),         	g_gateData[ gID ] [ E_Z ] = floatstr( Field );
			cache_get_field_content( i, "RX", Field ),         	g_gateData[ gID ] [ E_RX ] = floatstr( Field );
			cache_get_field_content( i, "RY", Field ),         	g_gateData[ gID ] [ E_RY ] = floatstr( Field );
			cache_get_field_content( i, "RZ", Field ),         	g_gateData[ gID ] [ E_RZ ] = floatstr( Field );
			cache_get_field_content( i, "MOVE_X", Field ),     	g_gateData[ gID ] [ E_MOVE_X ] = floatstr( Field );
			cache_get_field_content( i, "MOVE_Y", Field ),   	g_gateData[ gID ] [ E_MOVE_Y ] = floatstr( Field );
			cache_get_field_content( i, "MOVE_Z", Field ),    	g_gateData[ gID ] [ E_MOVE_Z ] = floatstr( Field );
			cache_get_field_content( i, "MOVE_RX", Field ),   	g_gateData[ gID ] [ E_MOVE_RX ] = floatstr( Field );
			cache_get_field_content( i, "MOVE_RY", Field ),    	g_gateData[ gID ] [ E_MOVE_RY ] = floatstr( Field );
			cache_get_field_content( i, "MOVE_RZ", Field ),  	g_gateData[ gID ] [ E_MOVE_RZ ] = floatstr( Field );

			g_gateData[ gID ] [ E_CLOSE_TIMER ] = -1;
			g_gateData[ gID ] [ E_OBJECT ] = CreateDynamicObject( g_gateData[ gID ] [ E_MODEL ], g_gateData[ gID ] [ E_X ], g_gateData[ gID ] [ E_Y ], g_gateData[ gID ] [ E_Z ], g_gateData[ gID ] [ E_RX ], g_gateData[ gID ] [ E_RY ], g_gateData[ gID ] [ E_RZ ] );

	    	Iter_Add(gates, gID);
		}
	}
	printf( "[GATES]: %d gates have been loaded. (Tick: %dms)", i, GetTickCount( ) - loadingTick );
	return 1;
}

stock CreateGate( playerid, password[ 8 ], model, Float: speed, Float: range, Float: x, Float: y, Float: z, Float: rx, Float: ry, Float: rz )
{
	new gID = Iter_Free(gates);

	if ( gID != ITER_NONE )
	{
		erase( g_gateData[ gID ] [ E_NAME ] );

		format( g_gateData[ gID ] [ E_PASS ], 8, "%s", password );
		format( g_gateData[ gID ] [ E_NAME ], 24, "Gate" );
		g_gateData[ gID ] [ E_OWNER ] = p_AccountID[ playerid ];
		g_gateData[ gID ] [ E_MODEL ] = model;
		g_gateData[ gID ] [ E_SPEED ] = speed;
		g_gateData[ gID ] [ E_TIME ] = 2000;
		g_gateData[ gID ] [ E_CLOSE_TIMER ] = -1;
		g_gateData[ gID ] [ E_RANGE ] = range;
		g_gateData[ gID ] [ E_X ] = x;
		g_gateData[ gID ] [ E_Y ] = y;
		g_gateData[ gID ] [ E_Z ] = z;
		g_gateData[ gID ] [ E_RX ] = rx;
		g_gateData[ gID ] [ E_RY ] = ry;
		g_gateData[ gID ] [ E_RZ ] = rz;
		g_gateData[ gID ] [ E_MOVE_X ] = x;
		g_gateData[ gID ] [ E_MOVE_Y ] = y;
		g_gateData[ gID ] [ E_MOVE_Z ] = z;
		g_gateData[ gID ] [ E_MOVE_RX ] = rx;
		g_gateData[ gID ] [ E_MOVE_RY ] = ry;
		g_gateData[ gID ] [ E_MOVE_RZ ] = rz;

		format( szBigString, sizeof( szBigString ), "INSERT INTO `GATES` VALUES(%d,%d,'%s','Gate',%d,2000,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f)", gID, playerid, mysql_escape( password ), model, speed, range, x, y, z, rx, ry, rz, x, y, z, rx, ry, rz );
		mysql_single_query( szBigString );

		g_gateData[ gID ] [ E_OBJECT ] = CreateDynamicObject( g_gateData[ gID ] [ E_MODEL ], g_gateData[ gID ] [ E_X ], g_gateData[ gID ] [ E_Y ], g_gateData[ gID ] [ E_Z ], g_gateData[ gID ] [ E_RX ], g_gateData[ gID ] [ E_RY ], g_gateData[ gID ] [ E_RZ ] );
		Iter_Add(gates, gID);
	}
	return gID;
}

stock getClosestGate( playerid, &Float: dis = 99999.99 )
{
	new
		Float: dis2,
		object = INVALID_OBJECT_ID
	;
	foreach(new i : gates)
	{
    	dis2 = GetPlayerDistanceFromPoint( playerid, g_gateData[ i ] [ E_X ], g_gateData[ i ] [ E_Y ], g_gateData[ i ] [ E_Z ] );
    	if ( dis2 < dis && dis2 != -1.00 ) {
    	    dis = dis2;
    	    object = i;
		}
	}
	return object;
}

stock UpdateGateData( gID )
{
	if ( Iter_Contains( gates, gID ) )
	{
		format( szLargeString, sizeof( szLargeString ),
			"UPDATE `GATES` SET `OWNER`=%d,`NAME`='%s',`PASSWORD`='%s',`MODEL`=%d,`TIME`=%d,`SPEED`=%f,`RANGE`=%f,`X`=%f,`Y`=%f,`Z`=%f,`RX`=%f,`RY`=%f,`RZ`=%f,`MOVE_X`=%f,`MOVE_Y`=%f,`MOVE_Z`=%f,`MOVE_RX`=%f,`MOVE_RY`=%f,`MOVE_RZ`=%f WHERE `ID`=%d",
			g_gateData[ gID ] [ E_OWNER ], mysql_escape( g_gateData[ gID ] [ E_NAME ] ), mysql_escape( g_gateData[ gID ] [ E_PASS ] ), g_gateData[ gID ] [ E_MODEL ], g_gateData[ gID ] [ E_TIME ], g_gateData[ gID ] [ E_SPEED ], g_gateData[ gID ] [ E_RANGE ],
			g_gateData[ gID ] [ E_X ], g_gateData[ gID ] [ E_Y ], g_gateData[ gID ] [ E_Z ], g_gateData[ gID ] [ E_RX ], g_gateData[ gID ] [ E_RY ], g_gateData[ gID ] [ E_RZ ],
			g_gateData[ gID ] [ E_MOVE_X ], g_gateData[ gID ] [ E_MOVE_Y ], g_gateData[ gID ] [ E_MOVE_Z ], g_gateData[ gID ] [ E_MOVE_RX ], g_gateData[ gID ] [ E_MOVE_RY ], g_gateData[ gID ] [ E_MOVE_RZ ], gID );

		mysql_single_query( szLargeString );

		DestroyDynamicObject( g_gateData[ gID ] [ E_OBJECT ] );
		g_gateData[ gID ] [ E_OBJECT ] = CreateDynamicObject( g_gateData[ gID ] [ E_MODEL ], g_gateData[ gID ] [ E_X ], g_gateData[ gID ] [ E_Y ], g_gateData[ gID ] [ E_Z ], g_gateData[ gID ] [ E_RX ], g_gateData[ gID ] [ E_RY ], g_gateData[ gID ] [ E_RZ ] );
	}
}

function StartGateClose( gID ) {
	g_gateData[ gID ] [ E_CLOSE_TIMER ] = -1;
	return MoveDynamicObject( g_gateData[ gID ] [ E_OBJECT ], g_gateData[ gID ] [ E_X ], g_gateData[ gID ] [ E_Y ], g_gateData[ gID ] [ E_Z ], g_gateData[ gID ] [ E_SPEED ], g_gateData[ gID ] [ E_RX ], g_gateData[ gID ] [ E_RY ], g_gateData[ gID ] [ E_RZ ] ), 1;
}

stock CreatePaintballLobby( pid, playerid, const szLobbyName[ 16 ], iPlayerCap, iArena, Float: fHealth = 100.0, Float: fArmour = 100.0 )
{
	if ( !Iter_Contains(paintball, pid) )
	{
		format( g_paintballData[ pid ] [ E_NAME ], 16, "%s", szLobbyName );
		g_paintballData[ pid ] [ E_PASSWORD ] [ 0 ] = '\0';
		g_paintballData[ pid ] [ E_PASSWORDED ]		= false;
		g_paintballData[ pid ] [ E_HOST ] 			= playerid;
		g_paintballData[ pid ] [ E_PLAYERS ] 		= 0;
		g_paintballData[ pid ] [ E_LIMIT ] 			= iPlayerCap;
		g_paintballData[ pid ] [ E_WEAPONS ] [ 0 ] 	= 0;
		g_paintballData[ pid ] [ E_WEAPONS ] [ 1 ] 	= 0;
		g_paintballData[ pid ] [ E_WEAPONS ] [ 2 ] 	= 0;
		g_paintballData[ pid ] [ E_ARMOUR ] 		= fHealth;
		g_paintballData[ pid ] [ E_HEALTH ] 		= fArmour;
		g_paintballData[ pid ] [ E_ARENA ] 			= iArena;
		g_paintballData[ pid ] [ E_ACTIVE ] 		= false;
		g_paintballData[ pid ] [ E_REFILLER ] 		= false;
		g_paintballData[ pid ] [ E_CD_TIMER ] 		= 0xFFFF;
		Iter_Add(paintball, pid);
		return true;
	}
	return false;
}

stock DestroyPaintballArena( p )
{
	if ( !Iter_Contains(paintball, p) )
		return false;

	Iter_Remove(paintball, p);
	g_paintballData[ p ] [ E_HOST ] = INVALID_PLAYER_ID;
	g_paintballData[ p ] [ E_PLAYERS ] = 0;
	g_paintballData[ p ] [ E_ACTIVE ] = false;
	g_paintballData[ p ] [ E_CD_TIMER ] = 0xFFFF;
	return true;
}

stock listPaintBallLobbies( playerid )
{
	if ( p_WantedLevel[ playerid ] ) return SendError( playerid, "You mustn't be wanted to join a paintball arena." );
	if ( p_Class[ playerid ] != CLASS_CIVILIAN ) return SendError( playerid, "You must be a civilian to join a paintball arena." );

	new
		szLobbies[ 64 * MAX_PAINTBALL_ARENAS + 64 ];

	for( new p = 0; p < MAX_PAINTBALL_ARENAS; p++ )
	{
		if ( !g_paintballData[ p ] [ E_ACTIVE ] && !Iter_Contains(paintball, p) ) {
			format( szLobbies, sizeof( szLobbies ), "%s{334D5C}Vacant Paintball Slot ($5,000)\n", szLobbies );
		}
		else if ( Iter_Contains(paintball, p) ) {
			format( szLobbies, sizeof( szLobbies ), "%s%s%s[%02d/%02d] %s hosted by %s\n",
				szLobbies, g_paintballData[ p ] [ E_PASSWORDED ] ? ( "{DF4949}" ) : ( "{53B240}" ), g_paintballData[ p ] [ E_ACTIVE ] ? ( "" ) : ( "{EFC94C}" ), g_paintballData[ p ] [ E_PLAYERS ], g_paintballData[ p ] [ E_LIMIT ], g_paintballData[ p ] [ E_NAME ], ReturnPlayerName( g_paintballData[ p ] [ E_HOST ] )
			);
		}
	}
    return ShowPlayerDialog( playerid, DIALOG_PAINTBALL, DIALOG_STYLE_LIST, "{FFFFFF}Paintball - Selection", szLobbies, "Select", "Cancel" );
}

stock showPaintBallLobbyData( playerid, id, second_button[ ] = "Join Game" )
{
	format( szLargeString, sizeof( szLargeString ), "Lobby Name\t\t"COL_GREY"%s"COL_WHITE"\nLobby Password\t%s"COL_WHITE"\nPlayer Capacity\t\t"COL_GREY"%d"COL_WHITE"\nHealth\t\t\t"COL_GREY"%0.2f%%"COL_WHITE"\nArmour\t\t\t"COL_GREY"%0.2f%%"COL_WHITE"\nRefill Health/Armour\t%s"COL_WHITE"\nArena\t\t\t"COL_GREY"%s"COL_WHITE"\nPrimary Weapon\t"COL_GREY"%s"COL_WHITE"\nSecondary Weapon\t"COL_GREY"%s"COL_WHITE"\nTertiary Weapon\t"COL_GREY"%s",
		g_paintballData[ id ] [ E_NAME ], g_paintballData[ id ] [ E_PASSWORDED ] == true ? ( ""COL_GREEN"ENABLED" ) : ( ""COL_RED"DISABLED" ), g_paintballData[ id ] [ E_LIMIT ], g_paintballData[ id ] [ E_HEALTH ], g_paintballData[ id ] [ E_ARMOUR ], g_paintballData[ id ] [ E_REFILLER ] == true ? ( ""COL_GREEN"ENABLED" ) : ( ""COL_RED"DISABLED" ), g_paintballArenaData[ g_paintballData[ id ] [ E_ARENA ] ] [ E_NAME ],
		ReturnWeaponName( g_paintballData[ id ] [ E_WEAPONS ] [ 0 ] ), ReturnWeaponName( g_paintballData[ id ] [ E_WEAPONS ] [ 1 ] ), ReturnWeaponName( g_paintballData[ id ] [ E_WEAPONS ] [ 2 ] )
	);
	ShowPlayerDialog( playerid, DIALOG_PAINTBALL_EDIT, DIALOG_STYLE_LIST, "{FFFFFF}Paintball - Lobby Settings", szLargeString, "Change", second_button );
}

stock ShowPlayerPaintballArenas( playerid )
{
	static
		szArenas[ 16 * sizeof( g_paintballArenaData ) ];

	if ( szArenas[ 0 ] == '\0' )
	{
		for( new i; i < sizeof( g_paintballArenaData ); i++ )
		{
			strcat( szArenas, g_paintballArenaData[ i ] [ E_NAME ] );
			strcat( szArenas, "\n" );
		}
	}

	ShowPlayerDialog( playerid, DIALOG_PAINTBALL_ARENAS, DIALOG_STYLE_LIST, "{FFFFFF}Paintball - Edit", szArenas, "Select", "Back" );
}

stock JoinPlayerPaintball( playerid, p )
{
	if ( !IsPlayerConnected( playerid ) )
		return -1;

	if ( !Iter_Contains( paintball, p ) )
		return -1;

	if ( g_paintballData[ p ] [ E_PLAYERS ] >= g_paintballData[ p ] [ E_LIMIT ] )
		return SendError( playerid, "This lobby is currently full, you're unable to join it." );

	p_PaintBallArena	{ playerid } = p;
	p_inPaintBall		{ playerid } = true;
	g_paintballData 	[ p ] [ E_PLAYERS ] ++;

	SpawnToPaintball( playerid, p );
	SendClientMessageFormatted( playerid, -1, ""COL_GREY"[PAINTBALL]"COL_WHITE" You've joined the paintball area: "COL_GREY"%s"COL_WHITE".", g_paintballData[ p ] [ E_NAME ] );
	return 1;
}

stock SpawnToPaintball( playerid, p )
{
	if ( !IsPlayerConnected( playerid ) )
		return;

	if ( !Iter_Contains( paintball, p ) )
		return;

	new
		iArena = g_paintballData[ p ] [ E_ARENA ];

    ResetPlayerWeapons( playerid );

    GivePlayerWeapon( playerid, g_paintballData[ p ] [ E_WEAPONS ] [ 0 ], 16000 );
    GivePlayerWeapon( playerid, g_paintballData[ p ] [ E_WEAPONS ] [ 1 ], 16000 );
    GivePlayerWeapon( playerid, g_paintballData[ p ] [ E_WEAPONS ] [ 2 ], 16000 );

    SetPlayerHealth( playerid, g_paintballData[ p ] [ E_HEALTH ] );
	SetPlayerArmour( playerid, g_paintballData[ p ] [ E_ARMOUR ] );

 	SetPlayerPos( playerid, g_paintballArenaData[ iArena ] [ E_X ], g_paintballArenaData[ iArena ] [ E_Y ], g_paintballArenaData[ iArena ] [ E_Z ] );
	SetPlayerInterior( playerid, g_paintballArenaData[ iArena ] [ E_INTERIOR ] );
    SetPlayerVirtualWorld( playerid, p + 10000 );
}

stock LeavePlayerPaintball( playerid )
{
	if ( !IsPlayerConnected( playerid ) )
		return;

	new
		p = -1;

	if ( !hasPaintBallArena( playerid, p ) )
		p = p_PaintBallArena{ playerid }; // Backup

	if ( IsPlayerInPaintBall( playerid ) )
	{
		p_inPaintBall		{ playerid } = false;
		p_LeftPaintball		{ playerid } = true;
		g_paintballData 	[ p ] [ E_PLAYERS ] --;
	}

	if ( !Iter_Contains( paintball, p ) )
		return;

	if ( g_paintballData[ p ] [ E_HOST ] == playerid )
	{
		new
			oldHost = g_paintballData[ p ] [ E_HOST ];

		foreach(new i : Player)
		{
			if ( IsPlayerInPaintBall( i ) && p_PaintBallArena{ i } == p && playerid != i )
			{
				g_paintballData[ p ] [ E_HOST ] = i;
				SendClientMessageFormatted( i, -1, ""COL_GREY"[PAINTBALL]"COL_WHITE" %s(%d) is now the leader of the lobby.", ReturnPlayerName( i ), i );
				break;
			}
		}

		if ( oldHost == g_paintballData[ p ] [ E_HOST ] )
		{
			SendClientMessage( playerid, -1, ""COL_GREY"[PAINTBALL]"COL_WHITE" There is no one playing in your lobby therefore the game has been destroyed." );
			DestroyPaintballArena( p );
		}
	}
}

stock respawnAllInPaintballLobby( lobby )
{
	foreach(new i : Player)
	{
		if ( IsPlayerInPaintBall( i ) && p_PaintBallArena{ i } == lobby && GetPlayerState( i ) != PLAYER_STATE_WASTED && IsPlayerSpawned( i ) )
			SpawnPlayer( i ), SendServerMessage( i, "As the lobby host changed some settings, you've been spawned." );
	}
}

stock hasPaintBallArena( playerid, &arena = -1 )
{
	foreach(new i : paintball) {
		if ( g_paintballData[ i ] [ E_HOST ] == playerid ) {
			arena = i;
			return true;
		}
	}
	return false;
}

stock hasBadDrivebyWeapon( playerid )
{
	for( new i; i < sizeof g_BannedDrivebyWeapons; i++ )
		if ( g_BannedDrivebyWeapons[ i ] == GetPlayerWeapon( playerid ) )
			return true;

	return false;
}

thread OnLoadServerVariables( )
{
	new
		rows, fields, i = -1,
		Field[ 30 ],
		szName[ 64 ],
		iValue,
		Float: fValue,
		iType
	;

	cache_get_data( rows, fields );
	if ( rows )
	{
		while( ++i < rows )
		{
			cache_get_field_content( i, "NAME", szName );
			cache_get_field_content( i, "STRING_VAL", szBigString );
			cache_get_field_content( i, "INT_VAL", Field ),		iValue = strval( Field );
			cache_get_field_content( i, "FLOAT_VAL", Field ),	fValue = floatstr( Field );
			cache_get_field_content( i, "TYPE", Field ),		iType = strval( Field );

			switch( iType )
			{
				case GLOBAL_VARTYPE_INT: SetGVarInt( szName, iValue );
				case GLOBAL_VARTYPE_STRING: SetGVarString( szName, szBigString );
				case GLOBAL_VARTYPE_FLOAT: SetGVarFloat( szName, fValue );
			}
		}
	}
	printf( "[SERVER] %d server variables have been loaded.", rows );
	return 1;
}

stock UpdateServerVariable( szName[ 64 ], intVal, Float: floatVal, stringVal[ 128 ], type )
{
	static
		szString[ 256 ];

	switch( type )
	{
		case GLOBAL_VARTYPE_INT:	format( szString, 128, "UPDATE `SERVER` SET `INT_VAL`=%d WHERE `NAME`='%s'", intVal, mysql_escape( szName ) ),							SetGVarInt( szName, intVal );
		case GLOBAL_VARTYPE_STRING:	format( szString, 256, "UPDATE `SERVER` SET `STRING_VAL`='%s' WHERE `NAME`='%s'", mysql_escape( stringVal ), mysql_escape( szName ) ), 	SetGVarString( szName, stringVal );
		case GLOBAL_VARTYPE_FLOAT:	format( szString, 128, "UPDATE `SERVER` SET `FLOAT_VAL`=%f WHERE `NAME`='%s'", floatVal, mysql_escape( szName ) ),						SetGVarFloat( szName, floatVal );
		default: return;
	}

	mysql_single_query( szString );
}

stock AddServerVariable( szName[ 64 ], szValue[ 128 ], type )
{
	switch( type )
	{
		case GLOBAL_VARTYPE_INT:	format( szLargeString, 164, "INSERT IGNORE INTO `SERVER`(`NAME`,`INT_VAL`,`TYPE`) VALUES ('%s',%d,%d)", mysql_escape( szName ), strval( szValue ), type );
		case GLOBAL_VARTYPE_STRING:	format( szLargeString, 296, "INSERT IGNORE INTO `SERVER`(`NAME`,`STRING_VAL`,`TYPE`) VALUES ('%s','%s',%d)", mysql_escape( szName ), mysql_escape( szValue ), type );
		case GLOBAL_VARTYPE_FLOAT:	format( szLargeString, 164, "INSERT IGNORE INTO `SERVER`(`NAME`,`FLOAT_VAL`,`TYPE`) VALUES ('%s',%f,%d)", mysql_escape( szName ), floatstr( szValue ), type );
		default: return;
	}

	mysql_single_query( szLargeString );
}

stock SetPlayerVipLevel( pID, level, bool: gifted = false )
{
	if ( !IsPlayerConnected( pID ) )
		return;

	switch( level )
	{
	    case VIP_REGULAR: GivePlayerXP( pID, 2000 ), 	GivePlayerCash( pID, 500000 );
	    case VIP_BRONZE:
	    {
			if ( !gifted ) {
	    		SendClientMessageToAdmins( -1, ""COL_PINK"[DONOR NEEDS HELP]"COL_GREY" %s(%d) needs a VIP house & Land Vehicle. (/viewnotes)", ReturnPlayerName( pID ), pID );
	    		AddPlayerNote( pID, -1, ""COL_GOLD"V.I.P House (Bronze)" #COL_WHITE );
	    		AddPlayerNote( pID, -1, ""COL_GOLD"V.I.P Land Vehicle (Bronze)" #COL_WHITE );
	    	}
	    	GivePlayerXP( pID, 5000 ), 	GivePlayerCash( pID, 2500000 );
	    }
	    case VIP_GOLD:
	    {
			if ( !gifted ) {
				SendClientMessageToAdmins( -1, ""COL_PINK"[DONOR NEEDS HELP]"COL_GREY" %s(%d) needs a VIP house and vehicle. (/viewnotes)", ReturnPlayerName( pID ), pID );
	    		AddPlayerNote( pID, -1, ""COL_GOLD"V.I.P House (Gold)" #COL_WHITE );
	    		AddPlayerNote( pID, -1, ""COL_GOLD"V.I.P Vehicle" #COL_WHITE );
	    	}
	      	SetPlayerArmour( pID, 100.0 ), GivePlayerXP( pID, 10000 ), GivePlayerCash( pID, 5000000 );
	    }
	    case VIP_PLATINUM:
	    {
			if ( !gifted ) {
				SendClientMessageToAdmins( -1, ""COL_PINK"[DONOR NEEDS HELP]"COL_GREY" %s(%d) needs a VIP house, garage and vehicle. (/viewnotes)", ReturnPlayerName( pID ), pID );
	    		AddPlayerNote( pID, -1, ""COL_GOLD"V.I.P House (Platinum)" #COL_WHITE );
	    		AddPlayerNote( pID, -1, ""COL_GOLD"V.I.P Vehicle" #COL_WHITE );
	    		AddPlayerNote( pID, -1, ""COL_GOLD"V.I.P Garage" #COL_WHITE );
	    	}
	    	SetPlayerArmour( pID, 100.0 ), GivePlayerXP( pID, 25000 ), GivePlayerCash( pID, 12500000 );
	    }
	    case VIP_DIAMOND:
	    {
			if ( !gifted ) {
				SendClientMessageToAdmins( -1, ""COL_PINK"[DONOR NEEDS HELP]"COL_GREY" %s(%d) needs a VIP house, garage, gate and vehicle. (/viewnotes)", ReturnPlayerName( pID ), pID );
	    		AddPlayerNote( pID, -1, ""COL_GOLD"V.I.P House (Diamond)" #COL_WHITE );
	    		AddPlayerNote( pID, -1, ""COL_GOLD"V.I.P Vehicle" #COL_WHITE );
	    		AddPlayerNote( pID, -1, ""COL_GOLD"V.I.P Garage" #COL_WHITE );
	    		AddPlayerNote( pID, -1, ""COL_GOLD"V.I.P Gate" #COL_WHITE );
	    	}
	    	SetPlayerArmour( pID, 100.0 ), GivePlayerXP( pID, 50000 ), GivePlayerCash( pID, 25000000 );
	    }
	    default: printf("VIP NOT FOUND %d LEVEL SPECIFIED", level);
	}

	if ( p_VIPLevel[ pID ] < level ) p_VIPLevel[ pID ] = level;
	if ( level > 0 ) {
	    if ( p_VIPExpiretime[ pID ] > g_iTime ) p_VIPExpiretime[ pID ] += 2595600;
	    else p_VIPExpiretime[ pID ] += ( g_iTime + 2595600 );
	}
	else { p_VIPExpiretime[ pID ] = 0; }
}

stock CensoreString( query[ ], characters = 5 )
{
	static
		szString[ 256 ];

	format( szString, 256, query );
	strdel( szString, 0, characters );

	for( new i = 0; i < characters; i++ )
		strins( szString, "*", 0 );

	return szString;
}

function handlePlayerRobbery( playerid, newkeys, oldkeys )
{
	if ( IsPlayerConnected( playerid ) )
 	{
		new
			Float: X, Float: Y, Float: Z,
		    Float: distance = 99999.99,
			robberyid = getClosestRobberySafe( playerid, distance ),
		 	Float: sZ
		;

		if ( g_Debugging )
		{
			printf("[DEBUG] [ROBBERY] [%d] handlePlayerRobbery( %d, %d, %d ) { open : %d, robbed : %d, c4: %d, drill : %d, dplacer : %d, deffect : %d, replenish : %d, raw ts : %d, current ts : %d, name : %s, velocity : %f, state : %d }",
					robberyid, playerid, newkeys, oldkeys,
					g_robberyData[ robberyid ] [ E_OPEN ], g_robberyData[ robberyid ] [ E_ROBBED ], g_robberyData[ robberyid ] [ E_C4 ],
					g_robberyData[ robberyid ] [ E_DRILL ], g_robberyData[ robberyid ] [ E_DRILL_PLACER ], g_robberyData[ robberyid ] [ E_DRILL_EFFECT ], g_robberyData[ robberyid ] [ E_ROB_TIME ] - g_iTime,
					g_robberyData[ robberyid ] [ E_ROB_TIME ], g_iTime, g_robberyData[ robberyid ] [ E_NAME ], g_robberyData[ robberyid ] [ E_VELOCITY ], g_robberyData[ robberyid ] [ E_STATE ] );
		}

		if ( robberyid != INVALID_OBJECT_ID && distance < 1.5 )
		{
			if ( !g_robberyData[ robberyid ] [ E_STATE ] && !g_robberyData[ robberyid ] [ E_VELOCITY ] && !g_robberyData[ robberyid ] [ E_ROBBED ] && !IsValidDynamicObject( g_robberyData[ robberyid ] [ E_SAFE_MONEY ] ) )
			{
				if ( IsPlayerCuffed( playerid ) || IsPlayerTazed( playerid ) || IsPlayerTied( playerid ) ) return SendError( playerid, "You cannot pick the safe at the moment." );

				if ( p_drillStrength[ playerid ] )
				{
					new
						success = AttachToRobberySafe( robberyid, playerid, ROBBERY_TYPE_DRILL );

					if ( success == 1 ) {
						SendServerMessage( playerid, "You have attached your thermal drill on this "COL_ORANGE"safe"COL_WHITE"." ), p_UsingRobberySafe[ playerid ] = robberyid;
					}
				}
				else
				{
		       	 	if ( g_robberyData[ robberyid ] [ E_STATE ] ) return SendError( playerid, "This safe must be in an idle state to pick it." );
		       	 	//else if ( p_UsingRobberySafe[ playerid ] != -1 ) return SendError( playerid, "You're currently working on another safe." );
		       	 	else if ( g_robberyData[ robberyid ] [ E_OPEN ] ) return 1; //SendError( playerid, "This safe is open." );
		       	 	else if ( p_InAnimation{ playerid } ) return 1; //SendError( playerid, "You mustn't be using an animation." );
		       	 	else if ( g_robberyData[ robberyid ] [ E_ROBTIMER ] != 0xFFFF ) return SendError( playerid, "This safe is currently busy." );
		       	 	else if ( p_Class[ playerid ] == CLASS_POLICE ) return SendError( playerid, "You cannot pick this safe as a law enforcement officer." );
		       	 	else if ( g_robberyData[ robberyid ] [ E_DRILL_PLACER ] != INVALID_PLAYER_ID || IsValidDynamicObject( g_robberyData[ robberyid ] [ E_DRILL ] ) ) return SendError( playerid, "The safe is currently occupied by a drill." );
		       	 	else
		       	 	{
		       	 		TriggerRobberyForClerks( playerid, robberyid );

						p_UsingRobberySafe[ playerid ] = robberyid;
		       	 		GetDynamicObjectPos( g_robberyData[ robberyid ] [ E_SAFE ], X, Y, Z );
						SetPlayerFacePoint( playerid, X, Y );
			        	GetXYInFrontOfSafe( robberyid, X, Y, sZ );
						GetPlayerPos( playerid, Z, Z, Z );
			        	SetPlayerPos( playerid, X, Y, Z );

			        	if ( sZ > Z )
							ApplyAnimation( playerid, "PED", "bomber", 5.0, 1, 1, 1, 1, 0 );
						else
							ApplyAnimation( playerid, "BOMBER", "BOM_Plant", 5.0, 1, 1, 1, 1, 0 );

						SetPlayerArmedWeapon( playerid, 0 );
						RemovePlayerAttachedObject( playerid, 0 );
			        	SetPlayerAttachedObject( playerid, 0, 18634, 6, 0.073999, 0.036999, 0.095999, 88.400009, 0.000000, 0.000000, 1.000000, 1.000000, 1.000000 );

						SendClientMessage( playerid, -1, ""COL_GOLD"[ROBBERY]"COL_WHITE" You are now picking a safe, please wait until you've finished. Press C or type /stoprob to cancel the operation." );
						g_robberyData[ robberyid ] [ E_STATE ] = STATE_PICKED;

						//SendClientMessageFormatted( playerid, COLOR_RED, "beginning - robbery %d", robberyid );
						ShowProgressBar( playerid, "Picking Safe", PROGRESS_SAFEPICK, 1800, COLOR_RED, robberyid );
					}
				}
			}
			if ( IsValidDynamicObject( g_robberyData[ robberyid ] [ E_SAFE_MONEY ] ) )
			{
		    	if ( g_robberyData[ robberyid ] [ E_STATE ] ) return SendError( playerid, "This safe must be in an idle state to rob it." );
		       	else if ( p_Class[ playerid ] == CLASS_POLICE ) return SendError( playerid, "You cannot rob this safe as a law enforcement officer." );
		        else
		        {
					p_UsingRobberySafe[ playerid ] = robberyid;
		   	 		GetDynamicObjectPos( g_robberyData[ robberyid ] [ E_SAFE ], X, Y, Z );
					SetPlayerFacePoint( playerid, X, Y );
		        	GetXYInFrontOfSafe( robberyid, X, Y, sZ );
					GetPlayerPos( playerid, Z, Z, Z );
		        	SetPlayerPos( playerid, X, Y, Z );

		        	if ( sZ > Z )
						ApplyAnimation( playerid, "CARRY", "liftup105", 4.0, 1, 0, 0, 1, 0 );
					else
						ApplyAnimation( playerid, "ROB_BANK", "CAT_Safe_Rob", 4.0, 1, 0, 0, 1, 0 );

		        	g_robberyData[ robberyid ] [ E_STATE ] = STATE_ROBBED;

					ShowProgressBar( playerid, "Robbing Safe", PROGRESS_ROBBING, 250, COLOR_YELLOW, robberyid );
		        }
			}
		}
 	}
	return 1;
}

stock GetShopItemVariable( playerid, id )
{
	switch( id )
	{
		case 0:  return p_CausticSoda		{ playerid };
		case 1:  return p_MuriaticAcid		{ playerid };
		case 2:  return p_HydrogenChloride	{ playerid };
		case 3:  return p_AidsVaccine		{ playerid };
		case 4:  return p_SecureWallet		{ playerid };
		case 5:  return p_Scissors 			[ playerid ];
		case 6:  return p_BobbyPins 		[ playerid ];
		case 7:  return p_MoneyBag 			{ playerid };
		case 8:  return p_Ropes 			[ playerid ];
		case 9:  return p_AntiEMP 			[ playerid ];
		case 10: return p_drillStrength		[ playerid ];
		case 11: return p_MetalMelter		[ playerid ];
	}
	return 0;
}

stock SetShopItemVariable( playerid, id, value )
{
	switch( id )
	{
		case 0:  return p_CausticSoda		{ playerid } = value;
		case 1:  return p_MuriaticAcid		{ playerid } = value;
		case 2:  return p_HydrogenChloride	{ playerid } = value;
		case 3:  return p_AidsVaccine 		{ playerid } = !!value;
		case 4:  return p_SecureWallet 		{ playerid } = !!value;
		case 5:  return p_Scissors			[ playerid ] = value;
		case 6:  return p_BobbyPins			[ playerid ] = value;
		case 7:  return p_MoneyBag			{ playerid } = !!value;
		case 8:  return p_Ropes 			[ playerid ] = value;
		case 9:  return p_AntiEMP 			[ playerid ] = value;
		case 10: return p_drillStrength		[ playerid ] = value;
		case 11: return p_MetalMelter 		[ playerid ] = value;
	}
	return 0;
}

stock ShowPlayerShopMenu( playerid )
{
	static szString[ 800 ];

	if ( szString[ 0 ] == '\0' )
	{
		strcat( szString, ""COL_GREY"\t\tThe grey coloured options are non-savable.\n" );
		for( new i; i < sizeof( g_shopItemData ); i++ )
	 		format( szString, sizeof( szString ), "%s"COL_GOLD"%s%s\t\t%s "COL_ORANGE"(%s)\n", szString, ConvertPrice( g_shopItemData[ i ] [ E_PRICE ] ), g_shopItemData[ i ] [ E_SAVABLE ] ? ( COL_WHITE ) : ( COL_GREY ), g_shopItemData[ i ] [ E_NAME ], g_shopItemData[ i ] [ E_USAGE ] );
	}
	return ShowPlayerDialog( playerid, DIALOG_SHOP_MENU, DIALOG_STYLE_LIST, "{FFFFFF}Shop Items", szString, "Select", "Cancel" );
}

#if ENABLED_EASTER_EGG == true
	stock DestroyEasterEgg( id )
	{
		if ( !( 0 <= id < MAX_EGGS ) )
			return 0;

		Iter_Remove(eastereggs, id);
	    DestroyDynamicPickup( g_EasterEggs[ id ] [ E_PICK_UP ] );
	    DestroyDynamic3DTextLabel( g_EasterEggs[ id ] [ E_LABEL ] );
		return 1;
	}

	stock CreateEasterEgg( Float: X, Float: Y, Float: Z )
	{
		new
		    ID = Iter_Free(eastereggs);

		if ( ID != ITER_NONE ) {
			Iter_Add(eastereggs, ID);
		    g_EasterEggs[ ID ] [ E_X ] = X;
		    g_EasterEggs[ ID ] [ E_Y ] = Y;
		    g_EasterEggs[ ID ] [ E_Z ] = Z;
		    g_EasterEggs[ ID ] [ E_PICK_UP ] = CreateDynamicPickup( EASTEREGG_MODEL, 1, X, Y, Z );
		    g_EasterEggs[ ID ] [ E_LABEL ] = CreateDynamic3DTextLabel( EASTEREGG_LABEL, COLOR_GOLD, X, Y, Z, 10.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 1, 0 );
		}
		return ID;
	}
#endif

stock IsPlayerSecurityDriver( playerid ) {
	#if ENABLED_SECURE_TRUCK == true
		new
			npc_id = IsPlayerNPC( playerid );

		if ( strmatch( ReturnPlayerName( playerid ), SECURE_TRUCK_DRIVER_NAME ) && !npc_id ) {
			return 0;
		}

		return ( npc_id && playerid == g_secureTruckDriver );
	#else
		#pragma unused playerid
		return 0;
	#endif
}

stock IsVehicleSecurityVehicle( vehicleid )
{
	#if ENABLED_SECURE_TRUCK == true
		return vehicleid == g_secureTruckVehicle;
	#else
		#pragma unused vehicleid
		return 0;
	#endif
}

#if ENABLED_SECURE_TRUCK == true
	stock restartSecurityGuardProcess( bool: inform_npc = true ) {
		g_secureTruckData[ E_LOOT ] 		= 0;
		g_secureTruckData[ E_ROBBED ] 		= false;
		g_secureTruckData[ E_BEING_ROBBED ] = false;
		g_secureTruckData[ E_OPEN ] 		= false;

		DestroyDynamicMapIcon( g_secureTruckData[ E_MAP_ICON ] );
		g_secureTruckData[ E_MAP_ICON ]  	= 0xFFFF;

		for( new i = 0; i < sizeof( g_secureTruckOffsets ); i++ ) {
			g_secureTruckOffsets[ i ] [ E_LEFT ] 	= false;
			g_secureTruckOffsets[ i ] [ E_ENABLED ] = true;
			g_secureTruckOffsets[ i ] [ E_HP ] 		= 100.0;
			UpdateDynamic3DTextLabelText( g_secureTruckVehicleLabel[ i ], setAlpha( COLOR_GREY, 0x90 ), "100%" );
		}

		if ( inform_npc ) SendClientMessage( g_secureTruckDriver, 0x112233FF, "[0x03] 300 SECOND START." );
	}

	stock allSecurityOffsetsShot( ) {
		for( new i = 0; i < sizeof( g_secureTruckOffsets ); i++ )
			if ( g_secureTruckOffsets[ i ] [ E_ENABLED ] )
				return 0;
		return 1;
	}
#endif

stock KillEveryoneInShamal( vehicleid )
{
	static
		Float: X, Float: Y, Float: Z;

	foreach(new i : Player) {
		if ( IsPlayerInShamal( i ) && ( GetPlayerVirtualWorld( i ) - VW_SHAMAL ) == vehicleid ) {
			if ( IsValidVehicle( vehicleid ) ) {
				GetPlayerPos( i, X, Y, Z );
				CreateExplosionForPlayer( i, X, Y, Z - 0.75, 0, 10.0 );
				SetPlayerHealth( i, -1 );
			}
		}
	}
}

stock adhereBanCodes( string[ ], maxlength = sizeof( string ) ) {
    for( new i; i < sizeof( g_banCodes ); i++ ) {
    	if ( strfind( string, g_banCodes[ i ] [ E_CODE ], false ) != -1 ) {
			strreplace( string, g_banCodes[ i ] [ E_CODE ], g_banCodes[ i ] [ E_DATA ], false, 0, -1, maxlength );
		}
	}
	return 1;
}

stock CreateExplosionEx( Float: X, Float: Y, Float: Z, type, Float: radius, world, interior, issuerid = INVALID_PLAYER_ID )
{
	foreach(new i : Player) {
		if ( IsPlayerLoadingObjects( i ) ) continue;
		if ( p_BulletInvulnerbility[ i ] > g_iTime ) continue;
		if ( interior != -1 && GetPlayerInterior( i ) != interior ) continue;
		if ( world != -1 && GetPlayerVirtualWorld( i ) != world ) continue;
		//if ( IsDeathmatchProtectedZone( i ) && !p_WantedLevel[ i ] ) continue;
		if ( IsRandomDeathmatch( issuerid, i ) && issuerid != i ) continue;
		CreateExplosionForPlayer( i, X, Y, Z, type, radius );
	}
}

stock CreateCarjackerContainer( Float: X, Float: Y, Float: Z, Float: Angle, {Float,_}: fDoor1Cords[ 3 ], {Float,_}: fDoor2Cords[ 3 ], {Float,_}: fDoorOpenAngle[ 2 ], {Float,_}: fDoorCloseAngle[ 2 ] )
{
	new
		id = Iter_Free(containers);

	if ( id != ITER_NONE ) {
		g_containerData[ id ] [ E_OBJECT ] 		= CreateDynamicObject( 19321, X, Y, Z, 0.000000, 0.000000, Angle );
		g_containerData[ id ] [ E_DOOR ] [ 0 ] 	= CreateDynamicObject( 3062, fDoor1Cords[ 0 ], fDoor1Cords[ 1 ], fDoor1Cords[ 2 ], 0.000000, 0.000000, fDoorOpenAngle[ 0 ] );
		g_containerData[ id ] [ E_DOOR ] [ 1 ] 	= CreateDynamicObject( 3062, fDoor2Cords[ 0 ], fDoor2Cords[ 1 ], fDoor2Cords[ 2 ], 0.000000, 0.000000, fDoorOpenAngle[ 1 ] );

		g_containerData[ id ] [ E_OPEN_ANGLE ] [ 0 ] 	= fDoorOpenAngle[ 0 ];
		g_containerData[ id ] [ E_OPEN_ANGLE ] [ 1 ] 	= fDoorOpenAngle[ 1 ];
		g_containerData[ id ] [ E_CLOSE_ANGLE ] [ 0 ] 	= fDoorCloseAngle[ 0 ];
		g_containerData[ id ] [ E_CLOSE_ANGLE ] [ 1 ] 	= fDoorCloseAngle[ 1 ];

		g_containerData[ id ] [ E_DOOR1_CORDS ]	= fDoor1Cords;
		g_containerData[ id ] [ E_DOOR2_CORDS ]	= fDoor2Cords;

		g_containerData[ id ] [ E_CLOSED ] 		= false;
	    g_containerData[ id ] [ E_CHECKPOINT ] 	= CreateDynamicCP( X, Y, Z, 2.0, -1, -1 );
	    g_containerData[ id ] [ E_LABEL ] 		= CreateDynamic3DTextLabel( "[VEHICLE EXPORT]", COLOR_GOLD, X, Y, Z, 15.0 );

	    Iter_Add(containers, id);
	}
}

stock IsCarjackableVehicleModel(value)
{
	/*
		Bikes: 462, 581,522,561,521,463,586,468,471
		Convertibles: 480,533,439,555
		Industrial: 422, 482, 582, 600, 413, 440, 543, 605, 459,531,552,478,554
		Lowriders: 536,575,534,567,535,566,576,412
		Offroad: 568,424,579,400,500,489,505,495
		Saloons: 445, 504, 401, 518, 527, 542, 507, 562, 585, 419, 526, 604, 466, 492, 474, 546, 517, 410, 551, 516, 467, 426, 436, 547, 405, 580, 560, 550, 549, 540, 491, 529, 421
		Sport Vehicles: 602, 429, 496, 402, 541, 415, 589, 587, 565, 494, 502, 503, 411, 559, 603, 475, 506, 451, 558, 477
		Station Wagons: 418, 404, 479, 458, 561

		Generate: http://spelsajten.net/bitarray/
	*/
	static const valid_values[7] = {
		627883063, -871882352, -637145956, -965734447, -840109590, 779715047, 15616
	};

	if (400 <= value <= 605) {
		value -= 400;
		return (valid_values[value >>> 5] & (1 << (value & 31))) || false;
	}
	return false;
}

stock calculateVehicleSellPrice( vehicleid )
{
	static const
		g_aVehicleSellingPrice[ 212 ] =
		{
			3500, 3000, 7000, 4500, 2700, 3200, 7500, 6000, 3500, 5000, 2500, 12500, 4500, 2300, 2700, 6500, 5500, 10000, 3000, 4700, 3500, 4700, 2900, 3300, 5000, 17000, 3500, 4200, 6000, 6500, 9000, 4900, 8000, 5500, 5400, 3000,
			3200, 5000, 3300, 6500, 3900, 3000, 2900, 4650, 8500, 2600, 9800, 14000, 2300, 4000, 3500, 11000, 5600, 2900, 4400, 3300, 3400, 1500, 4700, 3900, 7500, 5100, 2700, 5500, 5000, 5000, 4000, 4500, 5700, 7600, 4500, 4600,
			3200, 2900, 4200, 4300, 13500, 5500, 1500, 2400, 6800, 3200, 3600, 3800, 5700, 2000, 4200, 14000, 12500, 3400, 3900, 3500, 3900, 7600, 7400, 8200, 4600, 13500, 2300, 2000, 3900, 5000, 7800, 7600, 5600, 2700, 6000, 3200,
			3700, 2300, 4200, 7800, 6900, 9000, 4000, 5700, 4300, 2700, 3000, 14000, 14500, 6500, 8000, 7500, 4200, 4000, 5400, 4700, 6000, 5000, 2200, 1900, 4900, 6400, 3900, 4800, 6900, 7500, 6400, 6500, 5200, 9000, 2000, 1200,
			4300, 3200, 4900, 4200, 9000, 2700, 5600, 4200, 2700, 7500, 5500, 5200, 8000, 7000, 6500, 6300, 7500, 3400, 7900, 8000, 5000, 3800, 3000, 5800, 5700, 3200, 3200, 2500, 2500, 4800, 1200, 4800, 2000, 20000, 3200, 6800,
			4000, 6100, 3800, 2300, 3000, 3900, 4500, 5100, 3500, 3900, 3000, 3200, 9000, 6000, 5000, 4500, 4700, 4700, 4700, 5000, 2300, 5300, 6400, 4200, 800, 700, 1000, 1200, 600, 2300, 1000, 2300
		}
	;

	if ( !IsValidVehicle( vehicleid ) )
		return 0;

	new
		Float: fHealth,
		iModel = GetVehicleModel( vehicleid )
	;

	if ( !GetVehicleHealth( vehicleid, fHealth ) || !IsCarjackableVehicleModel( iModel ) || g_adminSpawnedCar{ vehicleid } || g_buyableVehicle{ vehicleid } || Iter_Contains( business, g_isBusinessVehicle[ vehicleid ] ) )
		return 0;

	if ( fHealth > 1000.0 )
		fHealth = 1000.0;

	if ( fHealth < 0.0 )
		fHealth = 0.0;

	return floatround( float( g_aVehicleSellingPrice[ iModel - 400 ] ) * ( fHealth / 1000.0 ) * 0.75 );
}

stock ArePlayersInHouse( houseid, owner )
{
	foreach(new i : Player) if ( i != owner )
	{
		if ( p_InHouse[ i ] == houseid )
		{
			if ( GetPlayerVirtualWorld( i ) == g_houseData[ houseid ] [ E_WORLD ] )
				return true;

			p_InHouse[ i ] = -1; // They're bugged probably
		}
	}
	return false;
}

stock massUnjailPlayers( city, bool: alcatraz = false )
{
	foreach(new p : Player)
    {
		if ( IsPlayerAdminJailed( p ) )
			continue;

		if ( !IsPlayerInJails( p, city ) && !alcatraz )
			continue;

		//if ( IsPlayerAFK( p ) )
		//	continue;

		jailMoveGate( p, city, false, alcatraz ); // Show everyone
		if ( p_Jailed{ p } == true )
		{
			CallLocalFunction( "OnPlayerUnjailed", "dd", p, alcatraz ? 5 : 4 );
			SetPlayerHealth( p, INVALID_PLAYER_ID ); // Just ensuring.
	        SetTimerEx( "RestoreHealthAfterBrokenOut", 5000, false, "d", p );
		}
	}
}

stock IsPlayerInJails( playerid, city )
{
	static const
		g_jailIntData[ MAX_CITIES ] = { 10, 3, 6 } // Ordered SF, LV, LS
	;

	return ( GetPlayerInterior( playerid ) == g_jailIntData[ city ] );
}

stock GetPlayerBankCity( playerid )
{
	static const
		g_bankIntData[ MAX_CITIES ] [ 2 ] = { 23, 52, 56 }
	;

	for( new i = 0; i < sizeof( g_bankIntData ); i++ )
	{
		if ( GetPlayerVirtualWorld( playerid ) == g_bankIntData[ i ] && GetPlayerInterior( playerid ) == i )
			return i;
	}
	return -1;
}
stock getClosestPoliceStation( playerid )
{
	static const
		Float: g_policeStationCoords[ ] [ 3 ] =
		{
		 	{ -1605.330, 711.6586, 13.8672 }, // SF
			{ 2337.0854, 2459.313, 14.9742 }, // LV
			{ 1555.5012, -1675.63, 16.1953 }  // LS
		}
	;

    static
    	Float: X, Float: Y, Float: Z,
    	iCity, iEntrance
    ;

    if ( !GetPlayerInterior( playerid ) ) GetPlayerPos( playerid, X, Y, Z );
	else
   	{
		if ( ( iEntrance = p_LastEnteredEntrance[ playerid ] ) == -1 ) GetPlayerPos( playerid, X, Y, Z );
		else
		{
			X = g_entranceData[ iEntrance ] [ E_EX ];
			Y = g_entranceData[ iEntrance ] [ E_EY ];
			Z = g_entranceData[ iEntrance ] [ E_EZ ];
		}
   	}

    for( new i = 0, Float: fLast = -1.0, Float: fDistance = 99999.0; i < sizeof( g_policeStationCoords ); i++ )
	{
	    fLast = GetDistanceBetweenPoints( X, Y, Z, g_policeStationCoords[ i ] [ 0 ], g_policeStationCoords[ i ] [ 1 ], g_policeStationCoords[ i ] [ 2 ] );
	    if ( fLast < fDistance && fLast ) {
	        fDistance = fLast;
	        iCity = i;
	    }
	}
    return iCity;
}

stock Achievement::HandleBankBlown( playerid )
{
	switch( ++p_BankBlown[ playerid ] )
	{
	    case 5:     ShowAchievement( playerid, "Blown Bank Vault ~r~5~w~~h~~h~ Times!", 3 );
	    case 20:  	ShowAchievement( playerid, "Blown Bank Vault ~r~20~w~~h~~h~ Times!", 6 );
	    case 50:   	ShowAchievement( playerid, "Blown Bank Vault ~r~50~w~~h~~h~ Times!", 9 );
	    case 100:  	ShowAchievement( playerid, "Blown Bank Vault ~r~100~w~~h~~h~ Times!", 12 );
	    case 200:  	ShowAchievement( playerid, "Blown Bank Vault ~r~200~w~~h~~h~ Times!", 15 );
	    case 500:  	ShowAchievement( playerid, "Blown Bank Vault ~r~500~w~~h~~h~ Times!", 18 );
	    case 1000: 	ShowAchievement( playerid, "Blown Bank Vault ~r~1000~w~~h~~h~ Times!", 25 );
	}
}

stock Achievement::HandleCarJacked( playerid )
{
	switch( ++p_CarsJacked[ playerid ] )
	{
	    case 5:     ShowAchievement( playerid, "Jacked ~r~5~w~~h~~h~ Cars!" , 3 );
	    case 20:  	ShowAchievement( playerid, "Jacked ~r~20~w~~h~~h~ Cars!", 6 );
	    case 50:   	ShowAchievement( playerid, "Jacked ~r~50~w~~h~~h~ Cars!", 9 );
	    case 100:  	ShowAchievement( playerid, "Jacked ~r~100~w~~h~~h~ Cars!", 12 );
	    case 200:  	ShowAchievement( playerid, "Jacked ~r~200~w~~h~~h~ Cars!", 15 );
	    case 500:  	ShowAchievement( playerid, "Jacked ~r~500~w~~h~~h~ Cars!", 18 );
	    case 1000: 	ShowAchievement( playerid, "Jacked ~r~1000~w~~h~~h~ Cars!", 25 );
	}
}

stock Achievement::HandleJailBlown( playerid )
{
	switch( ++p_JailsBlown[ playerid ] )
	{
	    case 5:     ShowAchievement( playerid, "Blown Jail ~r~5~w~~h~~h~ Times!", 3 );
	    case 20:  	ShowAchievement( playerid, "Blown Jail ~r~20~w~~h~~h~ Times!", 6 );
	    case 50:   	ShowAchievement( playerid, "Blown Jail ~r~50~w~~h~~h~ Times!", 9 );
	    case 100:  	ShowAchievement( playerid, "Blown Jail ~r~100~w~~h~~h~ Times!", 12 );
	    case 200:  	ShowAchievement( playerid, "Blown Jail ~r~200~w~~h~~h~ Times!", 15 );
	    case 500:  	ShowAchievement( playerid, "Blown Jail ~r~500~w~~h~~h~ Times!", 18 );
	    case 1000: 	ShowAchievement( playerid, "Blown Jail ~r~1000~w~~h~~h~ Times!", 25 );
	}
}

stock Achievement::HandleExtinguishedFires( playerid )
{
    switch( ++p_Fires[ playerid ] )
   	{
   	    case 5:     ShowAchievement( playerid, "Extinguished ~r~5~w~~h~~h~ fires!", 3 );
   	    case 20:    ShowAchievement( playerid, "Extinguished ~r~20~w~~h~~h~ fires!", 6 );
   	    case 50:    ShowAchievement( playerid, "Extinguished ~r~50~w~~h~~h~ fires!", 9 );
   	    case 100:   ShowAchievement( playerid, "Extinguished ~r~100~w~~h~~h~ fires!", 12 );
   	    case 200:   ShowAchievement( playerid, "Extinguished ~r~200~w~~h~~h~ fires!", 15 );
   	    case 500:   ShowAchievement( playerid, "Extinguished ~r~500~w~~h~~h~ fires!", 18 );
   	    case 1000:  ShowAchievement( playerid, "Extinguished ~r~1000~w~~h~~h~ fires!", 25 );
	}
}

stock Achievement::HandleMethYielded( playerid )
{
	switch( ++p_MethYielded[ playerid ] )
	{
	    case 5:     ShowAchievement( playerid, "Yielded ~r~5~w~~h~~h~ Meth Bags!", 3 );
	    case 20:  	ShowAchievement( playerid, "Yielded ~r~20~w~~h~~h~ Meth Bags!", 6 );
	    case 50:   	ShowAchievement( playerid, "Yielded ~r~50~w~~h~~h~ Meth Bags!", 9 );
	    case 100:  	ShowAchievement( playerid, "Yielded ~r~100~w~~h~~h~ Meth Bags!", 12 );
	    case 200:  	ShowAchievement( playerid, "Yielded ~r~200~w~~h~~h~ Meth Bags!", 15 );
	    case 500:  	ShowAchievement( playerid, "Yielded ~r~500~w~~h~~h~ Meth Bags!", 18 );
	    case 1000: 	ShowAchievement( playerid, "Yielded ~r~1000~w~~h~~h~ Meth Bags!", 25 );
	}
}

stock Achievement::HandlePlayerRobbery( playerid )
{
	incrementPlayerStreak( playerid, STREAK_ROBBERY );

	switch( ++p_Robberies[ playerid ] )
	{
	    case 5:     ShowAchievement( playerid, "Robbed ~r~5~w~~h~~h~ stores!", 3 );
	    case 20:    ShowAchievement( playerid, "Robbed ~r~20~w~~h~~h~ stores!", 6 );
	    case 50:    ShowAchievement( playerid, "Robbed ~r~50~w~~h~~h~ stores!", 9 );
	    case 100:   ShowAchievement( playerid, "Robbed ~r~100~w~~h~~h~ stores!", 12 );
	    case 200:   ShowAchievement( playerid, "Robbed ~r~200~w~~h~~h~ stores!", 15 );
	    case 500:   ShowAchievement( playerid, "Robbed ~r~500~w~~h~~h~ stores!", 18 );
	    case 1000:  ShowAchievement( playerid, "Robbed ~r~1000~w~~h~~h~ stores!", 25 );
	}
}

stock Achievement::HandleTruckingCouriers( playerid )
{
	switch( ++p_TruckedCargo[ playerid ] )
	{
	    case 5:     ShowAchievement( playerid, "Trucked ~r~5~w~~h~~h~ cargo!", 3 );
	    case 20:    ShowAchievement( playerid, "Trucked ~r~20~w~~h~~h~ cargo!", 6 );
	    case 50:    ShowAchievement( playerid, "Trucked ~r~50~w~~h~~h~ cargo!", 9 );
	    case 100:   ShowAchievement( playerid, "Trucked ~r~100~w~~h~~h~ cargo!", 12 );
	    case 200:   ShowAchievement( playerid, "Trucked ~r~200~w~~h~~h~ cargo!", 15 );
	    case 500:   ShowAchievement( playerid, "Trucked ~r~500~w~~h~~h~ cargo!", 18 );
	    case 1000:  ShowAchievement( playerid, "Trucked ~r~1000~w~~h~~h~ cargo!", 25 );
	}
}

thread readplayernotes( playerid )
{
	new
	    rows, fields
	;
    cache_get_data( rows, fields );

    if ( rows )
    {
    	new
    		ID,
    		i = 0,
    		Field[ 30 ],
    		szNote[ 72 ]
    	;

    	szHugeString = ""COL_GREY"ID\tTime\t\t\tNote\n" #COL_WHITE;

		while( i < rows )
		{
			cache_get_field_content( i, "ID", Field ), 		 ID = strval( Field );
			cache_get_field_content( i, "NOTE", szNote );
			cache_get_field_content( i, "TIME", Field );

			format( szHugeString, sizeof( szHugeString ), "%s%05d\t%s\t%s\n", szHugeString, ID, Field, szNote );
			i++;
		}

		ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_MSGBOX, "{FFFFFF}Player Notes", szHugeString, "Okay", "" );
		return 1;
	}
	SendError( playerid, "This user does not have any notes." );
	return 1;
}

thread readnamechanges( playerid, searchid )
{
	new
	    rows, fields
	;
    cache_get_data( rows, fields );

    if ( rows )
    {
    	new
    		szTime[ 20 ],
    		szName[ MAX_PLAYER_NAME ]
    	;

    	szLargeString = ""COL_GREY"Time\t\t\tName\n" #COL_WHITE;

    	for( new i = 0; i < rows; i++ )
		{
			cache_get_field_content( i, "NAME", szName );
			cache_get_field_content( i, "TIME", szTime );

			format( szLargeString, sizeof( szLargeString ), "%s%s\t%s\n", szLargeString, szTime, szName );
		}

		ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_MSGBOX, sprintf( "{FFFFFF}Name changes of %s(%d)", ReturnPlayerName( searchid ), searchid ), szLargeString, "Okay", "" );
		return 1;
	}
	SendError( playerid, "This user has not recently changed their name." );
	return 1;
}

thread readmoneylog( playerid, searchid )
{
	new
	    rows, fields
	;
    cache_get_data( rows, fields );

    if ( rows )
    {
    	new
    		szTime[ 20 ],
    		szName[ MAX_PLAYER_NAME ],
    		iCashMoney
    	;

    	szLargeString = COL_WHITE # "Sent to\t" #COL_WHITE "Amount\t" #COL_WHITE "Time\n";

    	for( new i = 0; i < rows; i++ )
		{
			cache_get_field_content( i, "NAME", szName );
			cache_get_field_content( i, "DATE", szTime );
			iCashMoney = cache_get_field_content_int( i, "CASH", dbHandle );

			format( szLargeString, sizeof( szLargeString ), "%s%s\t%s\t%s\n", szLargeString, szName, ConvertPrice( iCashMoney ), szTime );
		}

		ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_TABLIST_HEADERS, sprintf( "{FFFFFF}Transactions sent by %s(%d)", ReturnPlayerName( searchid ), searchid ), szLargeString, "Okay", "" );
		return 1;
	}
	SendError( playerid, "This user has not recently made any transactions." );
	return 1;
}

thread readiclog( playerid, searchid )
{
	new
	    rows, fields
	;
    cache_get_data( rows, fields );

    if ( rows )
    {
    	new
    		szTime[ 20 ],
    		szName[ MAX_PLAYER_NAME ],
    		Float: fCoins
    	;

    	szLargeString = COL_WHITE # "Time\t" #COL_WHITE "Sent to\t" #COL_WHITE "Amount\n";

    	for( new i = 0; i < rows; i++ )
		{
			cache_get_field_content( i, "NAME", szName );
			cache_get_field_content( i, "DATE", szTime );
			fCoins = cache_get_field_content_float( i, "IC", dbHandle );

			format( szLargeString, sizeof( szLargeString ), "%s%s\t%s\t%f\n", szLargeString, szTime, szName, fCoins );
		}

		ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_TABLIST_HEADERS, sprintf( "{FFFFFF}IC Transactions sent by %s(%d)", ReturnPlayerName( searchid ), searchid ), szLargeString, "Okay", "" );
		return 1;
	}
	SendError( playerid, "This user has not recently made any IC transactions." );
	return 1;
}

thread deleteplayernote( playerid, noteid )
{
	new
	    rows, fields
	;
    cache_get_data( rows, fields );

	if ( rows ) {
		SaveToAdminLog( playerid, noteid, "removed note" );
 		format( szNormalString, 64, "UPDATE `NOTES` SET `DELETED`=%d WHERE `ID`=%d", p_AccountID[ playerid ], noteid ), mysql_single_query( szNormalString );
 		SendServerMessage( playerid, "You have removed note id %d. If there are any problems, contact Lorenc/Council.", noteid );
		AddAdminLogLineFormatted( "%s(%d) has deleted note id %d", ReturnPlayerName( playerid ), playerid, noteid );
 		return 1;
	}

 	SendError( playerid, "Couldn't remove note id %d due to it being already deleted or invalid permissions.", noteid );
	return 1;
}

stock AddPlayerNote( playerid, authorid, note[ ] ) {
	format( szBigString, sizeof( szBigString ), "INSERT INTO `NOTES`(`USER_ID`, `ADDED_BY`, `NOTE`) VALUES (%d,%d,'%s')", p_AccountID[ playerid ], IsPlayerConnected( authorid ) ? p_AccountID[ authorid ] : 1, mysql_escape( note ) );
	mysql_single_query( szBigString );
}

stock IsPlayerInBank( playerid )
{
	static const
		valid_values[ 2 ] = { 536870913, 2 }
	;

	if ( GetPlayerInterior( playerid ) > 3 )
		return false;

	new
		value = GetPlayerVirtualWorld( playerid );

	if ( 23 <= value <= 56 ) {
		value -= 23;
		return ( valid_values[ value >>> 5 ] & ( 1 << ( value & 31 ) ) ) || false;
	}
	return false;
}

stock displayStreaks( playerid, dialogid = DIALOG_NULL, szSecondButton[ ] = "", forid = INVALID_PLAYER_ID ) {

	szLargeString = ""COL_WHITE"Streak\t"COL_WHITE"Best Streak\t"COL_WHITE"Current Streak\n";

	for( new streakid = 0, szStreak[ 8 ]; streakid < MAX_STREAKS; streakid++ ) {
		szStreak = g_streaksTypes[ streakid ];
		szStreak[ 0 ] = toupper( szStreak[ 0 ] );

		format( szLargeString, 512, "%s%s\t%d\t%d\n", szLargeString, szStreak, p_streakData[ playerid ] [ streakid ] [ E_BEST_STREAK ], p_streakData[ playerid ] [ streakid ] [ E_STREAK ] );
	}

	if ( !IsPlayerConnected( forid ) )
		forid = playerid;

	return ShowPlayerDialog( forid, dialogid, DIALOG_STYLE_TABLIST_HEADERS, "{FFFFFF}Best Streaks", szLargeString, "Okay", szSecondButton );
}

stock displayAchievements( playerid, dialogid = DIALOG_NULL, szSecondButton[ ] = "", forid = INVALID_PLAYER_ID )
{
	static
		szAchievements[ 1300 ];

	format( szAchievements, sizeof( szAchievements ),
		""COL_GREY"Played For\t\t\t%s10m\t%s1h\t%s5h\t%s10h\t%s15h\t%s20h\t%s1d\n",
		Ach_Unlock( p_Uptime[ playerid ], 1200 ), 		Ach_Unlock( p_Uptime[ playerid ], 3600 ), 		Ach_Unlock( p_Uptime[ playerid ], 18000 ),
		Ach_Unlock( p_Uptime[ playerid ], 36000 ), 		Ach_Unlock( p_Uptime[ playerid ], 54000 ), 		Ach_Unlock( p_Uptime[ playerid ], 72000 ),
		Ach_Unlock( p_Uptime[ playerid ], 86400 )
	);
	format( szAchievements, sizeof( szAchievements ),
		"%s"COL_GREY"Kills Achieved\t\t\t%s5\t%s20\t%s50\t%s100\t%s200\t%s500\t%s1000\n", szAchievements,
		Ach_Unlock( p_Kills[ playerid ], 5 ), 			Ach_Unlock( p_Kills[ playerid ], 20 ),     		Ach_Unlock( p_Kills[ playerid ], 50 ),
		Ach_Unlock( p_Kills[ playerid ], 100 ), 		Ach_Unlock( p_Kills[ playerid ], 200 ),    		Ach_Unlock( p_Kills[ playerid ], 500 ),
		Ach_Unlock( p_Kills[ playerid ], 1000 )
	);
	format( szAchievements, sizeof( szAchievements ),
		"%s"COL_GREY"Arrested Criminals\t\t%s5\t%s20\t50\t%s100\t%s200\t%s500\t%s1000\n", szAchievements,
		Ach_Unlock( p_Arrests[ playerid ], 5 ),     	Ach_Unlock( p_Arrests[ playerid ], 20 ),    	Ach_Unlock( p_Arrests[ playerid ], 50 ),
		Ach_Unlock( p_Arrests[ playerid ], 100 ),   	Ach_Unlock( p_Arrests[ playerid ], 200 ),   	Ach_Unlock( p_Arrests[ playerid ], 500 ),
		Ach_Unlock( p_Arrests[ playerid ], 1000 )
	);

	format( szAchievements, sizeof( szAchievements ),
		"%s"COL_GREY"Total Robberies\t\t%s5\t%s20\t%s50\t%s100\t%s200\t%s500\t%s1000\n", szAchievements,
		Ach_Unlock( p_Robberies[ playerid ], 5 ),		Ach_Unlock( p_Robberies[ playerid ], 20 ),		Ach_Unlock( p_Robberies[ playerid ], 50 ),
		Ach_Unlock( p_Robberies[ playerid ], 100 ),		Ach_Unlock( p_Robberies[ playerid ], 200 ),		Ach_Unlock( p_Robberies[ playerid ], 500 ),
		Ach_Unlock( p_Robberies[ playerid ], 1000 )
	);

	format( szAchievements, sizeof( szAchievements ),
		"%s"COL_GREY"Extinguished Fires\t\t%s5\t%s20\t%s50\t%s100\t%s200\t%s500\t%s1000\n", szAchievements,
		Ach_Unlock( p_Fires[ playerid ], 5 ),     		Ach_Unlock( p_Fires[ playerid ], 20 ),    		Ach_Unlock( p_Fires[ playerid ], 50 ),
		Ach_Unlock( p_Fires[ playerid ], 100 ),   		Ach_Unlock( p_Fires[ playerid ], 200 ),   		Ach_Unlock( p_Fires[ playerid ], 500 ),
		Ach_Unlock( p_Fires[ playerid ], 1000 )
	);
	format( szAchievements, sizeof( szAchievements ),
		"%s"COL_GREY"Completed Contracts\t\t%s5\t%s20\t%s50\t%s100\t%s200\t%s500\t%s1000\n", szAchievements,
		Ach_Unlock( p_HitsComplete[ playerid ], 5 ),     Ach_Unlock( p_HitsComplete[ playerid ], 20 ), 	Ach_Unlock( p_HitsComplete[ playerid ], 50 ),
		Ach_Unlock( p_HitsComplete[ playerid ], 100 ),   Ach_Unlock( p_HitsComplete[ playerid ], 200 ), Ach_Unlock( p_HitsComplete[ playerid ], 500 ),
		Ach_Unlock( p_HitsComplete[ playerid ], 1000 )
	);
	format( szAchievements, sizeof( szAchievements ),
		"%s"COL_GREY"Commited Burglaries\t\t%s5\t%s20\t%s50\t%s100\t%s200\t%s500\t%s1000\n", szAchievements,
		Ach_Unlock( p_Burglaries[ playerid ], 5 ),     	Ach_Unlock( p_Burglaries[ playerid ], 20 ),    	Ach_Unlock( p_Burglaries[ playerid ], 50 ),
		Ach_Unlock( p_Burglaries[ playerid ], 100 ),   	Ach_Unlock( p_Burglaries[ playerid ], 200 ),   	Ach_Unlock( p_Burglaries[ playerid ], 500 ),
		Ach_Unlock( p_Burglaries[ playerid ], 1000 )
	);
	format( szAchievements, sizeof( szAchievements ),
		"%s"COL_GREY"Yielded Meth Bags\t\t%s5\t%s20\t%s50\t%s100\t%s200\t%s500\t%s1000\n", szAchievements,
		Ach_Unlock( p_MethYielded[ playerid ], 5 ),     Ach_Unlock( p_MethYielded[ playerid ], 20 ),    Ach_Unlock( p_MethYielded[ playerid ], 50 ),
		Ach_Unlock( p_MethYielded[ playerid ], 100 ),   Ach_Unlock( p_MethYielded[ playerid ], 200 ),   Ach_Unlock( p_MethYielded[ playerid ], 500 ),
		Ach_Unlock( p_MethYielded[ playerid ], 1000 )
	);
	format( szAchievements, sizeof( szAchievements ),
		"%s"COL_GREY"Cars Jacked\t\t\t%s5\t%s20\t%s50\t%s100\t%s200\t%s500\t%s1000\n", szAchievements,
		Ach_Unlock( p_CarsJacked[ playerid ], 5 ),     	Ach_Unlock( p_CarsJacked[ playerid ], 20 ),    	Ach_Unlock( p_CarsJacked[ playerid ], 50 ),
		Ach_Unlock( p_CarsJacked[ playerid ], 100 ),   	Ach_Unlock( p_CarsJacked[ playerid ], 200 ),   	Ach_Unlock( p_CarsJacked[ playerid ], 500 ),
		Ach_Unlock( p_CarsJacked[ playerid ], 1000 )
	);
	format( szAchievements, sizeof( szAchievements ),
		"%s"COL_GREY"Blew Bank Vault\t\t%s5\t%s20\t%s50\t%s100\t%s200\t%s500\t%s1000\n", szAchievements,
		Ach_Unlock( p_BankBlown[ playerid ], 5 ),     	Ach_Unlock( p_BankBlown[ playerid ], 20 ),    	Ach_Unlock( p_BankBlown[ playerid ], 50 ),
		Ach_Unlock( p_BankBlown[ playerid ], 100 ),   	Ach_Unlock( p_BankBlown[ playerid ], 200 ),   	Ach_Unlock( p_BankBlown[ playerid ], 500 ),
		Ach_Unlock( p_BankBlown[ playerid ], 1000 )
	);
	format( szAchievements, sizeof( szAchievements ),
		"%s"COL_GREY"Blew Jail Cells\t\t\t%s5\t%s20\t%s50\t%s100\t%s200\t%s500\t%s1000\n", szAchievements,
		Ach_Unlock( p_JailsBlown[ playerid ], 5 ),     	Ach_Unlock( p_JailsBlown[ playerid ], 20 ),    	Ach_Unlock( p_JailsBlown[ playerid ], 50 ),
		Ach_Unlock( p_JailsBlown[ playerid ], 100 ),   	Ach_Unlock( p_JailsBlown[ playerid ], 200 ),   	Ach_Unlock( p_JailsBlown[ playerid ], 500 ),
		Ach_Unlock( p_JailsBlown[ playerid ], 1000 )
	);
	format( szAchievements, sizeof( szAchievements ),
		"%s"COL_GREY"Total Trucked Cargo\t\t%s5\t%s20\t%s50\t%s100\t%s200\t%s500\t%s1000\n", szAchievements,
		Ach_Unlock( p_TruckedCargo[ playerid ], 5 ),     Ach_Unlock( p_TruckedCargo[ playerid ], 20 ),    	Ach_Unlock( p_TruckedCargo[ playerid ], 50 ),
		Ach_Unlock( p_TruckedCargo[ playerid ], 100 ),   Ach_Unlock( p_TruckedCargo[ playerid ], 200 ),   	Ach_Unlock( p_TruckedCargo[ playerid ], 500 ),
		Ach_Unlock( p_TruckedCargo[ playerid ], 1000 )
	);

	if ( !IsPlayerConnected( forid ) ) forid = playerid;
	ShowPlayerDialog( forid, dialogid, DIALOG_STYLE_MSGBOX, "{FFFFFF}Achievements", szAchievements, "Okay", szSecondButton );
}

stock PlainUnjailPlayer( playerid )
{
	p_inAlcatraz{ playerid } = false;
    p_Jailed 	{ playerid } = false;
    p_JailTime 	[ playerid ] = 0;

	format( szNormalString, sizeof( szNormalString ), "UPDATE USERS SET JAIL_TIME=0,JAIL_ADMIN=0 WHERE ID=%d", p_AccountID[ playerid ] );
	mysql_single_query( szNormalString );

    KillTimer				( p_JailTimer[ playerid ] );
	TextDrawHideForPlayer	( playerid, p_JailTimeTD[ playerid ] );
}

stock JobEquals( playerid, jobid )
	return ( p_Job{ playerid } == jobid ) || ( p_VIPLevel[ playerid ] >= VIP_PLATINUM && p_VIPJob{ playerid } == jobid );

stock isNotNearPlayer( playerid, nearid, Float: distance = 200.0 )
{
	if ( ! IsPlayerNPC( playerid ) && ( GetTickCount( ) - p_AFKTime[ playerid ] ) >= 500 )
		return 0;

	if ( !IsPlayerConnected( nearid ) )
		return 1;

	if ( IsPlayerAFK( nearid ) )
		return 1;

	new
		Float: fDistance 	= 9999.9,
		Float: X, Float: Y, Float: Z,

		// Get kidnapper data
		iEntrance 			= p_LastEnteredEntrance[ nearid ],
		iHouse 				= p_InHouse[ nearid ],
		iGarage 			= p_InGarage[ nearid ]
	;

	GetPlayerPos( nearid, X, Y, Z );

	if ( GetPlayerInterior( playerid ) != GetPlayerInterior( nearid ) && GetPlayerVirtualWorld( playerid ) != GetPlayerVirtualWorld( nearid ) )
	{
	    if ( iEntrance != -1 )
	  		fDistance = GetPlayerDistanceFromPoint( playerid, g_entranceData[ iEntrance ] [ E_EX ], g_entranceData[ iEntrance ] [ E_EY ], g_entranceData[ iEntrance ] [ E_EZ ] );

	  	else if ( iGarage != -1 )
	  		fDistance = GetPlayerDistanceFromPoint( playerid, g_garageData[ iGarage ] [ E_X ], g_garageData[ iGarage ] [ E_Y ], g_garageData[ iGarage ] [ E_Z ] );

	  	else if ( iHouse != -1 )
	  		fDistance = GetPlayerDistanceFromPoint( playerid, g_houseData[ iHouse ] [ E_EX ], g_houseData[ iHouse ] [ E_EY ], g_houseData[ iHouse ] [ E_EZ ] );

  		else fDistance = GetPlayerDistanceFromPoint( playerid, X, Y, Z );
	}
  	else fDistance = GetPlayerDistanceFromPoint( playerid, X, Y, Z );

	return fDistance > distance ? 1 : 0;
}

stock getToyCategories( bool: pawnshop = false )
{
	static
		szToyCategory[ 150 ],
		szPawnCategory[ 150 ];

	if ( szToyCategory[ 0 ] == '\0' ) {
		for( new i = 0; i < sizeof( g_ToyCategory ); i++ )
			format( szToyCategory, sizeof( szToyCategory ), "%s%s\n", szToyCategory, g_ToyCategory[ i ] );
	}

	if ( szPawnCategory[ 0 ] == '\0' ) {
		for( new i = 0; i < sizeof( g_ToyCategory ); i++ ) if ( i != CATEGORY_VIP )
			format( szPawnCategory, sizeof( szPawnCategory ), "%s%s\n", szPawnCategory, g_ToyCategory[ i ] );
	}

	return pawnshop ? szPawnCategory : szToyCategory;
}

stock showToyCategoryItems( playerid, category, bool: pawnshop = false )
{
	erase( szLargeString );

	for( new i = 0; i < sizeof( g_ToyData ); i++ )
	{
		if ( g_ToyData[ i ] [ E_CATEGORY ] == category )
		{
			if ( pawnshop ) {
				format( szLargeString, sizeof( szLargeString ), "%s%s%s\t"COL_GOLD"%s\n", szLargeString, p_ToyUnlocked[ playerid ] { g_ToyData[ i ] [ E_ID ] } ? ( #COL_LGREEN ) : ( #COL_WHITE ), g_ToyData[ i ] [ E_NAME ], ConvertPrice( g_ToyData[ i ] [ E_PRICE ] ) );
			} else {
				format( szLargeString, sizeof( szLargeString ), "%s%s%s\n", szLargeString, g_ToyData[ i ] [ E_ID ] != -1 ? ( !p_ToyUnlocked[ playerid ] { g_ToyData[ i ] [ E_ID ] } ? ( "{3D3D3D}" ) : ( "{FFFFFF}" ) ) : ( COL_GOLD ), g_ToyData[ i ] [ E_NAME ] );
			}
		}
	}

	if ( pawnshop ) {
		return ShowPlayerDialog( playerid, DIALOG_TOYS_ITEMS_BUY, DIALOG_STYLE_TABLIST, pawnshop ? ( "{FFFFFF}Purchase Toys" ) : ( "{FFFFFF}Toys" ), szLargeString, "Select", "Back" );
	} else {
		return ShowPlayerDialog( playerid, DIALOG_TOYS_ITEMS, DIALOG_STYLE_LIST, pawnshop ? ( "{FFFFFF}Purchase Toys" ) : ( "{FFFFFF}Toys" ), szLargeString, "Select", "Back" );
	}
}

stock unlockPlayerToy( playerid, toy_id )
{
	if ( toy_id > MAX_TOYS )
		return;

	p_ToyUnlocked[ playerid ] { toy_id } = true;
	format( szNormalString, 72, "INSERT INTO `TOY_UNLOCKS`(`USER_ID`, `TOY_ID`) VALUES (%d, %d)", p_AccountID[ playerid ], toy_id);
	mysql_single_query( szNormalString );
}

stock resetPlayerToys( playerid, slot ) {
   	p_AttachedObjectsData[ playerid ] [ slot ] [ E_ENABLED ] = 0;
	p_AttachedObjectsData[ playerid ] [ slot ] [ E_MODELID ] = 0;
   	p_AttachedObjectsData[ playerid ] [ slot ] [ E_BONE ] = 0;
	p_AttachedObjectsData[ playerid ] [ slot ] [ E_OX ] = 0.0;
	p_AttachedObjectsData[ playerid ] [ slot ] [ E_OY ] = 0.0;
	p_AttachedObjectsData[ playerid ] [ slot ] [ E_OZ ] = 0.0;
	p_AttachedObjectsData[ playerid ] [ slot ] [ E_RX ] = 0.0;
	p_AttachedObjectsData[ playerid ] [ slot ] [ E_RY ] = 0.0;
	p_AttachedObjectsData[ playerid ] [ slot ] [ E_RZ ] = 0.0;
	p_AttachedObjectsData[ playerid ] [ slot ] [ E_SX ] = 0.0;
	p_AttachedObjectsData[ playerid ] [ slot ] [ E_SY ] = 0.0;
	p_AttachedObjectsData[ playerid ] [ slot ] [ E_SZ ] = 0.0;
}

thread OnToyLoad( playerid )
{
	if ( !IsPlayerConnected( playerid ) )
		return 0;

	new
		rows, fields, i = -1
	;

	cache_get_data( rows, fields );
	if ( rows ) {
		while( ++i < rows ) {
			new iToy = cache_get_field_content_int( i, "TOY_ID", dbHandle );

			if ( iToy < MAX_TOYS ) // Must be something wrong otherwise...
				p_ToyUnlocked[ playerid ] { iToy } = true;
		}
	}
	return 1;
}

thread OnToyOffsetLoad( playerid )
{
	if ( !IsPlayerConnected( playerid ) )
		return 0;

	new
		rows, fields, i = -1
	;

	cache_get_data( rows, fields );
	if ( rows ) {
		while( ++i < rows ) {
			new
				iSlot = cache_get_field_content_int( i, "SLOT_ID", dbHandle );

			if ( iSlot < sizeof( p_AttachedObjectsData[ ] ) ) {
				p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_SQL_ID ] = cache_get_field_content_int( i, "ID", dbHandle );
				p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_ENABLED ] = cache_get_field_content_int( i, "ENABLED", dbHandle );
				p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_MODELID ] = cache_get_field_content_int( i, "MODEL_ID", dbHandle );
				p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_BONE ] = cache_get_field_content_int( i, "BONE", dbHandle );
				p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_OX ] = cache_get_field_content_float( i, "OX", dbHandle );
				p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_OY ] = cache_get_field_content_float( i, "OY", dbHandle );
				p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_OZ ] = cache_get_field_content_float( i, "OZ", dbHandle );
				p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_RX ] = cache_get_field_content_float( i, "RX", dbHandle );
				p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_RY ] = cache_get_field_content_float( i, "RY", dbHandle );
				p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_RZ ] = cache_get_field_content_float( i, "RZ", dbHandle );
				p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_SX ] = cache_get_field_content_float( i, "SX", dbHandle );
				p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_SY ] = cache_get_field_content_float( i, "SY", dbHandle );
				p_AttachedObjectsData[ playerid ] [ iSlot ] [ E_SZ ] = cache_get_field_content_float( i, "SZ", dbHandle );
			}
		}
	}
	return 1;
}

thread OnPlayerAddToy( playerid, slotid ) {
	p_AttachedObjectsData[ playerid ] [ slotid ] [ E_SQL_ID ] = cache_insert_id( );
	return 1;
}

stock showToyEditMenu( playerid, slot )
{
	format( szNormalString, 86, "%sEdit Toy Position\n%sEdit Toy Bone\n%s Toy\n"COL_LRED"Remove Toy", p_AttachedObjectsData[ playerid ] [ slot ] [ E_ENABLED ] ? ( #COL_WHITE ) : ( COL_BLACK ), p_AttachedObjectsData[ playerid ] [ slot ] [ E_ENABLED ] ? ( #COL_WHITE ) : ( #COL_BLACK ), p_AttachedObjectsData[ playerid ] [ slot ] [ E_ENABLED ] ? ( "Disable" ) : ( "Enable" ) );
	return ShowPlayerDialog( playerid, DIALOG_TOYS_EDIT, DIALOG_STYLE_LIST, "{FFFFFF}Toys", szNormalString, "Select", "Back" );
}

stock loadPlayerToys( playerid )
{
	// Loop is more slower than this!
	if ( p_AttachedObjectsData[ playerid ] [ 0 ] [ E_ENABLED ] ) {
		RemovePlayerAttachedObject( playerid, 7 );
		SetPlayerAttachedObject( playerid, 7, p_AttachedObjectsData[ playerid ] [ 0 ] [ E_MODELID ], p_AttachedObjectsData[ playerid ] [ 0 ] [ E_BONE ],
			p_AttachedObjectsData[ playerid ] [ 0 ] [ E_OX ], p_AttachedObjectsData[ playerid ] [ 0 ] [ E_OY ], p_AttachedObjectsData[ playerid ] [ 0 ] [ E_OZ ],
			p_AttachedObjectsData[ playerid ] [ 0 ] [ E_RX ], p_AttachedObjectsData[ playerid ] [ 0 ] [ E_RY ], p_AttachedObjectsData[ playerid ] [ 0 ] [ E_RZ ],
			p_AttachedObjectsData[ playerid ] [ 0 ] [ E_SX ], p_AttachedObjectsData[ playerid ] [ 0 ] [ E_SY ], p_AttachedObjectsData[ playerid ] [ 0 ] [ E_SZ ]
		);
	}
	if ( p_AttachedObjectsData[ playerid ] [ 1 ] [ E_ENABLED ] ) {
		RemovePlayerAttachedObject( playerid, 8 );
		SetPlayerAttachedObject( playerid, 8, p_AttachedObjectsData[ playerid ] [ 1 ] [ E_MODELID ], p_AttachedObjectsData[ playerid ] [ 1 ] [ E_BONE ],
			p_AttachedObjectsData[ playerid ] [ 1 ] [ E_OX ], p_AttachedObjectsData[ playerid ] [ 1 ] [ E_OY ], p_AttachedObjectsData[ playerid ] [ 1 ] [ E_OZ ],
			p_AttachedObjectsData[ playerid ] [ 1 ] [ E_RX ], p_AttachedObjectsData[ playerid ] [ 1 ] [ E_RY ], p_AttachedObjectsData[ playerid ] [ 1 ] [ E_RZ ],
			p_AttachedObjectsData[ playerid ] [ 1 ] [ E_SX ], p_AttachedObjectsData[ playerid ] [ 1 ] [ E_SY ], p_AttachedObjectsData[ playerid ] [ 1 ] [ E_SZ ]
		);
	}
	if ( p_AttachedObjectsData[ playerid ] [ 2 ] [ E_ENABLED ] ) {
		RemovePlayerAttachedObject( playerid, 9 );
		SetPlayerAttachedObject( playerid, 9, p_AttachedObjectsData[ playerid ] [ 2 ] [ E_MODELID ], p_AttachedObjectsData[ playerid ] [ 2 ] [ E_BONE ],
			p_AttachedObjectsData[ playerid ] [ 2 ] [ E_OX ], p_AttachedObjectsData[ playerid ] [ 2 ] [ E_OY ], p_AttachedObjectsData[ playerid ] [ 2 ] [ E_OZ ],
			p_AttachedObjectsData[ playerid ] [ 2 ] [ E_RX ], p_AttachedObjectsData[ playerid ] [ 2 ] [ E_RY ], p_AttachedObjectsData[ playerid ] [ 2 ] [ E_RZ ],
			p_AttachedObjectsData[ playerid ] [ 2 ] [ E_SX ], p_AttachedObjectsData[ playerid ] [ 2 ] [ E_SY ], p_AttachedObjectsData[ playerid ] [ 2 ] [ E_SZ ]
		);
	}
}

thread OnSettingsLoad( playerid )
{
	if ( !IsPlayerConnected( playerid ) )
		return 0;

	new
		rows, fields, i = -1
	;

	cache_get_data( rows, fields );
	if ( rows ) {
		while( ++i < rows ) {
			new iSetting = cache_get_field_content_int( i, "SETTING_ID", dbHandle );

			if ( iSetting < MAX_SETTINGS ) // Must be something wrong otherwise...
				p_PlayerSettings[ playerid ] { iSetting } = true;
		}
	}
	return 1;
}

stock GetVehicleDriver( vehicleid )
{
	foreach(new i : Player)
		if ( IsPlayerInVehicle( i, vehicleid ) && GetPlayerState( i ) == PLAYER_STATE_DRIVER )
			return i;

	return INVALID_PLAYER_ID;
}

stock IsSecurityDriverAFK( ) { // Damn thing bugged with range of point
	new
		Float: Z;

#if ENABLED_SECURE_TRUCK == true
	return ( GetPlayerPos( g_secureTruckDriver, Z, Z, Z ) && Z > 1000.0 );
#else
	return 1;
#endif
}

/*stock CreateNoDeathmatchZone( const Float: fRadius, const Float: fX, const Float: fY, const fSize = 15 ) // Warning: do not change size!
{
	new
		iZone = Iter_Free(rdmzone);

	if ( iZone != ITER_NONE )
	{
	    new
	        Float: fIncrement = 90.0 / fSize,
	        Float: fDegrees = fIncrement,
	        Float: fCos,
	        Float: fSin,
	        iGangZone = -1
	    ;

	    while( fDegrees < 90.0 )
	    {
	        fCos = floatcos( fDegrees, degrees ) * fRadius;
	        fSin = floatsin( fDegrees, degrees ) * fRadius;

	        g_antiDeathmatchZoneData[ iZone ] [ E_GANGZONES ] [ ++iGangZone ] = GangZoneCreate( fX - fCos, fY - fSin, fX + fCos, fY + fSin );
	        g_antiDeathmatchZoneData[ iZone ] [ E_CIRCLE ] = CreateDynamicCircle( fX, fY, fRadius );

	        fDegrees += fIncrement;
	    }

	    Iter_Add(rdmzone, iZone);
	}
}

stock IsDeathmatchProtectedZone( playerid ) {

	if ( IsPlayerInPaintBall( playerid ) )
		return false;

	if ( IsPlayerInEntrance( playerid, g_Ammunation ) || IsPlayerInEntrance( playerid, g_PoliceDepartment ) || IsPlayerInEntrance( playerid, g_Hospital ) )
		return true;

	if ( IsPlayerInBank( playerid ) )
		return true;

	foreach(new r : rdmzone)
		if ( IsPlayerInDynamicArea( playerid, g_antiDeathmatchZoneData[ r ] [ E_CIRCLE ] ) )
			return true;

	return false;
}*/

stock CreateGarage( iAccountID, iPrice, iInterior, Float: fX, Float: fY, Float: fZ, Float: fAngle, iExistingID = -1 )
{
	new
		iGarage = iExistingID != ITER_NONE ? iExistingID : Iter_Free(garages);

	if ( Iter_Contains( garages, iExistingID ) )
		iGarage = ITER_NONE; // In the unlikelihood...

	if ( iGarage != ITER_NONE )
	{
		g_garageData[ iGarage ] [ E_OWNER_ID ] 		= iAccountID;
		g_garageData[ iGarage ] [ E_PRICE ] 		= iPrice;
		g_garageData[ iGarage ] [ E_INTERIOR_ID ] 	= iInterior;
		g_garageData[ iGarage ] [ E_WORLD ] 		= iGarage + ( MAX_GARAGES * 32 ); // Random

		g_garageData[ iGarage ] [ E_X ] 	= fX;
		g_garageData[ iGarage ] [ E_Y ] 	= fY;
		g_garageData[ iGarage ] [ E_Z ] 	= fZ;
		g_garageData[ iGarage ] [ E_ANGLE ] = fAngle;

		g_garageData[ iGarage ] [ E_CHECKPOINT ] = CreateDynamicCP( fX, fY, fZ, 3.0, -1, 0, -1, 100.0 );
	    g_garageData[ iGarage ] [ E_LABEL ] 	 = CreateDynamic3DTextLabel( sprintf( "Garage(%d)\nOwner:"COL_WHITE" No-one\n"COL_GOLD"Price:"COL_WHITE" %s", iGarage, ConvertPrice( g_garageData[ iGarage ] [ E_PRICE ] ) ), COLOR_GOLD, fX, fY, fZ, 20.0 );

		if ( iExistingID != -1 && iAccountID ) UpdateGarageTitle( iGarage );
		else if ( iExistingID == -1 )
		{
			format( szBigString, 162, "INSERT INTO `GARAGES`(`ID`,`OWNER`,`PRICE`,`INTERIOR`,`X`,`Y`,`Z`,`ANGLE`) VALUES (%d,%d,%d,%d,%f,%f,%f,%f)", iGarage, iAccountID, iPrice, iInterior, fX, fY, fZ, fAngle );
			mysql_single_query( szBigString );
		}

		Iter_Add(garages, iGarage);
	}
	return iGarage;
}

stock DestroyGarage( iGarage )
{
	if ( iGarage < 0 || iGarage >= MAX_GARAGES )
		return 0;

	if ( !Iter_Contains( garages, iGarage ) )
	    return 0;

	new
		playerid = GetPlayerIDFromAccountID( g_garageData[ iGarage ] [ E_OWNER_ID ] );

	if ( IsPlayerConnected( playerid ) )
	{
		for( new i = 0; i < MAX_BUYABLE_VEHICLES; i++ )
			if ( g_vehicleData[ playerid ] [ i ] [ E_CREATED ] && g_vehicleData[ playerid ] [ i ] [ E_GARAGE ] == iGarage )
				SetVehiclePos( g_vehicleData[ playerid ] [ i ] [ E_VEHICLE_ID ], g_garageData[ iGarage ] [ E_X ], g_garageData[ iGarage ] [ E_Y ], g_garageData[ iGarage ] [ E_Z ] ), LinkVehicleToInterior( g_vehicleData[ playerid ] [ i ] [ E_VEHICLE_ID ], 0 ), SetVehicleVirtualWorld( g_vehicleData[ playerid ] [ i ] [ E_VEHICLE_ID ], 0 );

	    SendClientMessage( playerid, -1, ""COL_PINK"[GARAGE]"COL_WHITE" One of your garages has been destroyed.");
	}

	mysql_single_query( sprintf( "UPDATE `VEHICLES` SET `X`=%f,`Y`=%f,`Z`=%f,`GARAGE`=-1 WHERE `GARAGE`=%d", g_garageData[ iGarage ] [ E_X ], g_garageData[ iGarage ] [ E_Y ], g_garageData[ iGarage ] [ E_Z ], iGarage ) );
	mysql_single_query( sprintf( "DELETE FROM `GARAGES` WHERE `ID`=%d", iGarage ) );

	Iter_Remove(garages, iGarage);
	g_garageData[ iGarage ] [ E_OWNER_ID ] = 0;
	DestroyDynamicCP( g_garageData[ iGarage ] [ E_CHECKPOINT ] );
	DestroyDynamic3DTextLabel( g_garageData[ iGarage ] [ E_LABEL ] );
	return 1;
}


thread OnUpdateGarageTitle( slot )
{
	new
		rows, szOwner[ MAX_PLAYER_NAME ] = "No-one";

	cache_get_data( rows, tmpVariable );

	if ( rows )
		cache_get_field_content( 0, "NAME", szOwner );

	UpdateDynamic3DTextLabelText( g_garageData[ slot ] [ E_LABEL ], COLOR_GOLD, sprintf( "Garage(%d)\nOwner:"COL_WHITE" %s\n"COL_GOLD"Price:"COL_WHITE" %s", slot, szOwner, ConvertPrice( g_garageData[ slot ] [ E_PRICE ] ) ) );
	return 1;
}

thread OnGaragesLoad( )
{
	new
		rows, fields, i = -1,
	    loadingTick = GetTickCount( )
	;

	cache_get_data( rows, fields );
	if ( rows )
	{
		while( ++i < rows )
		{
			CreateGarage(
				cache_get_field_content_int( i, "OWNER", dbHandle ),
				cache_get_field_content_int( i, "PRICE", dbHandle ),
				cache_get_field_content_int( i, "INTERIOR", dbHandle ),
				cache_get_field_content_float( i, "X", dbHandle ),
				cache_get_field_content_float( i, "Y", dbHandle ),
				cache_get_field_content_float( i, "Z", dbHandle ),
				cache_get_field_content_float( i, "ANGLE", dbHandle ),
				cache_get_field_content_int( i, "ID", dbHandle )
			);
		}
	}
	printf( "[GARAGES]: %d garages have been loaded. (Tick: %dms)", i, GetTickCount( ) - loadingTick );
	return 1;
}

stock SetPlayerVehicleInteriorData( iOwner, iSlot, iInterior, iWorld, Float: fX, Float: fY, Float: fZ, Float: fAngle, iGarage = -1 )
{
	new
		iVehicle = g_vehicleData[ iOwner ] [ iSlot ] [ E_VEHICLE_ID ];

	SetVehiclePos( iVehicle, fX, fY, fZ );
	SetVehicleZAngle( iVehicle, fAngle );

	LinkVehicleToInterior( iVehicle, iInterior );
	SetVehicleVirtualWorld( iVehicle, iWorld );

	ReplaceVehicleCustomComponents( iOwner, iSlot ); // Change virtual worlds

	// Update for passengers etc
	foreach(new i : Player)
	{
		if ( GetPlayerVehicleID( i ) == iVehicle || GetPlayerSurfingVehicleID( i ) == iVehicle )
		{
			p_InGarage[ i ] = iGarage;
			SetPlayerInterior( i, iInterior );
			SetPlayerVirtualWorld( i, iWorld );
		}
	}
}

stock PlayerBreachedGarageLimit( playerid, vID, bool: admin_place = false )
{
	new
		iOwner = playerid;

	if ( admin_place ) /// Admin Mode
 		getVehicleSlotFromID( GetPlayerVehicleID( playerid ), iOwner );

	// Garage System
	if ( ( g_vehicleData[ iOwner ] [ vID ] [ E_GARAGE ] = p_InGarage[ playerid ] ) != -1 )
	{
		new
			iGarage = g_vehicleData[ iOwner ] [ vID ] [ E_GARAGE ],
			iVehiclesOccupying = GetPlayerVehiclesInGarage( iOwner, iGarage )
		;

		if ( g_vehicleData[ iOwner ] [ vID ] [ E_OWNER_ID ] != g_garageData[ iGarage ] [ E_OWNER_ID ] )
			return g_vehicleData[ iOwner ] [ vID ] [ E_GARAGE ] = -1, -1;

		if ( iVehiclesOccupying > g_garageInteriorData[ g_garageData[ iGarage ] [ E_INTERIOR_ID ] ] [ E_VEHICLE_CAPACITY ] )
			return g_vehicleData[ iOwner ] [ vID ] [ E_GARAGE ] = -1, -2;
	}
	return 1;
}

stock GetPlayerVehiclesInGarage( playerid, slot, strict_mode=0 )
{
	new
		count = 0;

	if ( Iter_Contains( garages, slot ) )
	{
		for( new i = 0; i < MAX_BUYABLE_VEHICLES; i++ ) if ( g_vehicleData[ playerid ] [ i ] [ E_CREATED ] ) {
			if ( g_vehicleData[ playerid ] [ i ] [ E_GARAGE ] == slot || ( strict_mode && GetVehicleVirtualWorld( g_vehicleData[ playerid ] [ i ] [ E_VEHICLE_ID ] ) == g_garageData[ slot ] [ E_WORLD ] ) )
				count++;
		}
	}
	return count;
}

stock ArePlayersInGarage( playerid, slot )
{
	foreach(new i : Player)
		if ( p_InGarage[ i ] == slot && i != playerid )
			return true;

	return false;
}

stock GetJobIDFromName( szJob[ ] )
{
	static const
		g_jobsData[ ] [ MAX_JOB_NAME char ] =
		{
			{ !"Rapist" }, { !"Kidnapper" }, { !"Terrorist" }, { !"Hitman" }, { !"Prostitute" },
			{ !"Weapon Dealer" }, { !"Drug Dealer" }, { !"Dirty Mechanic" }, { !"Burglar" }
		}
	;

	for( new iJob = 0; iJob < sizeof( g_jobsData ); iJob++ )
		if ( strunpack( szNormalString, g_jobsData[ iJob ], MAX_JOB_NAME ) )
			if ( strfind( szNormalString, szJob, true ) != -1 )
				return iJob;

	return 0xFE;
}

stock GetJobName( iJob )
{
	new
		szJob[ MAX_JOB_NAME ] = "unknown";

	switch( iJob )
	{
		case JOB_RAPIST: 			szJob = "Rapist";
		case JOB_KIDNAPPER:			szJob = "Kidnapper";
		case JOB_TERRORIST: 		szJob = "Terrorist";
		case JOB_HITMAN: 			szJob = "Hitman";
		case JOB_PROSTITUTE: 		szJob = "Prostitute";
		case JOB_WEAPON_DEALER: 	szJob = "Weapon Dealer";
		case JOB_DRUG_DEALER: 		szJob = "Drug Dealer";
		case JOB_DIRTY_MECHANIC: 	szJob = "Dirty Mechanic";
		case JOB_BURGLAR: 			szJob = "Burglar";
	}
	return szJob;
}

stock GetPlayerLocation( iPlayer, szCity[ ], szLocation[ ] ) {
	static
		Float: X, Float: Y, Float: Z;

	if ( GetPlayerInterior( iPlayer ) != 0 || IsPlayerInBank( iPlayer ) ) {
		new
			iEntrance = p_LastEnteredEntrance[ iPlayer ],
			iHouse = p_InHouse[ iPlayer ],
			iGarage = p_InGarage[ iPlayer ]
		;

	    if ( iEntrance != -1 ) X = g_entranceData[ iEntrance ] [ E_EX ], Y = g_entranceData[ iEntrance ] [ E_EY ], Z = g_entranceData[ iEntrance ] [ E_EZ ];
	    else if ( iGarage != -1 ) X = g_garageData[ iGarage ] [ E_X ], Y = g_garageData[ iGarage ] [ E_Y ], Z = g_garageData[ iGarage ] [ E_Z ];
	    else if ( iHouse != -1 ) X = g_houseData[ iHouse ] [ E_EX ], Y = g_houseData[ iHouse ] [ E_EY ], Z = g_houseData[ iHouse ] [ E_EZ ];
		else return false;
	}
	else GetPlayerPos( iPlayer, X, Y, Z );

	Get2DCity( szCity, X, Y, Z );
	GetZoneFromCoordinates( szLocation, X, Y, Z );
	return true;
}

stock getRandomTrailerLoad( iModel, iRisk ) {

	new
		aRandom[ sizeof( g_aTrailerData[ ] ) ],
		iRandomIndex = -1
	;

	for( new i = 0; i < sizeof( g_aTrailerData[ ] ); i++ ) {
		if ( g_aTrailerData[ iModel ] [ i ] [ E_RISK ] == iRisk ) {
			aRandom[ ++iRandomIndex ] = i;
		}
	}

	return aRandom[ random( iRandomIndex + 1 ) ];
}

//stock randarg( ... )
//	return getarg( random( numargs( ) ) );

stock getClosestTruckingRoute( playerid, &Float: distance = FLOAT_INFINITY ) {
    new
    	iCurrent = INVALID_PLAYER_ID, Float: fTmp;

    for( new i = 0; i < sizeof( g_aTruckingLocations ); i++ )
    	if ( 0.0 < ( fTmp = GetDistanceFromPlayerSquared( playerid, g_aTruckingLocations[ i ] [ E_X ], g_aTruckingLocations[ i ] [ E_Y ], g_aTruckingLocations[ i ] [ E_Z ] ) ) < distance )
    		distance = fTmp, iCurrent = i;

    return iCurrent;
}

function OnTruckPositionUpdate( playerid, routeid )
{
	if ( !IsPlayerInAnyVehicle( playerid ) && !p_hasTruckingJob{ playerid } && ( p_TruckingRoute[ playerid ] { 0 } == 0 && p_TruckingRoute[ playerid ] { 1 } == 0 ) ) {
	  	TextDrawHideForPlayer( playerid, p_TruckingTD[ playerid ] );
		return ( p_TruckingPositionTimer[ playerid ] = 0xFFFF );
	}

	new
		Float: fDistance = GetPlayerDistanceFromPoint( playerid, g_aTruckingLocations[ routeid ] [ E_X ], g_aTruckingLocations[ routeid ] [ E_Y ], g_aTruckingLocations[ routeid ] [ E_Z ] );

	TextDrawSetString( p_TruckingTD[ playerid ], sprintf( "~b~Location:~w~ %s~n~~b~Distance:~w~ %0.2fm", g_aTruckingLocations[ routeid ] [ E_NAME ], fDistance ) );
	return ( p_TruckingPositionTimer[ playerid ] = SetTimerEx( "OnTruckPositionUpdate", 750, false, "dd", playerid, routeid ) );
}


stock getTrailerType( model )
{
	switch( model ) {
		case 584:
			return 0;
		case 450:
			return 1;
		case 435, 591:
			return 2;
	}
	return 0xF;
}

function cancelPlayerTruckingCourier( playerid, vehicleid, ticks )
{
	if ( IsTrailerAttachedToVehicle( vehicleid ) && ticks )
		return KillTimer( p_TruckingCancelTimer[ playerid ] ), p_TruckingCancelTimer[ playerid ] = 0xFFFF;

	if ( ticks < 1 || !IsPlayerConnected( playerid ) || !IsPlayerSpawned( playerid ) )
	{
		StopPlayerTruckingCourier( playerid );
		SendServerMessage( playerid, "Your trucking mission has been stopped." );
	}
	else
	{
		ShowPlayerHelpDialog( playerid, 1000, "You have %d seconds to attach back the trailer you were using.", ticks - 1 );
		p_TruckingCancelTimer[ playerid ] = SetTimerEx( "cancelPlayerTruckingCourier", 980, false, "ddd", playerid, vehicleid, ticks - 1 );
	}
	return 1;
}

stock StopPlayerTruckingCourier( playerid )
{
	DestroyDynamicRaceCP	( p_TruckingCheckPoint[ playerid ] );
	DestroyDynamicMapIcon 	( p_TruckingMapIcon[ playerid ] );

	KillTimer 				( p_TruckingPositionTimer[ playerid ] );
	KillTimer 				( p_TruckingCancelTimer[ playerid ] );

	p_TruckingDistance		[ playerid ] = 0.0;
	p_hasTruckingJob		{ playerid } = false;
	p_TruckingCheckPoint	[ playerid ] = 0xFFFF;
	p_TruckingMapIcon 		[ playerid ] = 0xFFFF;
	p_TruckingCancelTimer	[ playerid ] = 0xFFFF;
	p_TruckingPositionTimer [ playerid ] = 0xFFFF;
	p_TruckingRoute 		[ playerid ] { 0 } = INVALID_TRUCKING_ROUTE;
	p_TruckingRoute 		[ playerid ] { 1 } = INVALID_TRUCKING_ROUTE;

	TextDrawHideForPlayer( playerid, p_TruckingTD[ playerid ] );
}

stock WarnPlayerClass( playerid, bool: bArmy = false, iPoints = 1 )
{
	new
		iWarns = bArmy ? ( p_ArmyBanned{ playerid } += iPoints ) : ( p_CopBanned{ playerid } += iPoints );

	if ( iWarns > MAX_CLASS_BAN_WARNS )
		iWarns = bArmy ? ( p_ArmyBanned{ playerid } = MAX_CLASS_BAN_WARNS ) : ( p_CopBanned{ playerid } = MAX_CLASS_BAN_WARNS );

	if ( p_Class[ playerid ] != CLASS_CIVILIAN && iWarns >= MAX_CLASS_BAN_WARNS )
		SetPlayerHealth( playerid, -1 ), ForceClassSelection( playerid );

	if ( iWarns >= MAX_CLASS_BAN_WARNS )
		SendServerMessage( playerid, "You have been %s-banned due to many offenses, use "COL_GREY"/unbanme"COL_WHITE" to unban yourself.", bArmy ? ( "army" ) : ( "cop" ) );

	mysql_single_query( sprintf( "UPDATE `USERS` SET `%s`=%d WHERE ID=%d", bArmy ? ( "ARMY_BAN" ) : ( "COP_BAN" ), iWarns, p_AccountID[ playerid ] ) );

	return iWarns;
}

stock IsRandomDeathmatch( issuerid, damagedid )
{
	if ( issuerid != INVALID_PLAYER_ID && damagedid != INVALID_PLAYER_ID )
	{
		new
			iW = p_WantedLevel[ issuerid ], 	iC = p_Class[ issuerid ],
			dW = p_WantedLevel[ damagedid ], 	dC = p_Class[ damagedid ]
		;

		if ( !IsPlayerInCasino( issuerid ) || !IsPlayerInCasino( damagedid ) )
			return false; // applies only to casinos

		return ( !iW && iC != CLASS_POLICE && !dW && dC != CLASS_POLICE ) || ( iW && iC != CLASS_POLICE && !dW && dC != CLASS_POLICE ) || ( !iW && iC != CLASS_POLICE && dW && dC != CLASS_POLICE ) || ( !iW && iC != CLASS_POLICE && dC == CLASS_POLICE );
	}
	return false;
}

stock IsPlayerInCasino( playerid )
	return ( GetPlayerInterior( playerid ) == 10 && GetPlayerVirtualWorld( playerid ) == 23 ) || ( GetPlayerInterior( playerid ) == 1 && GetPlayerVirtualWorld( playerid ) == 82 );

//function RespawnVehicle( vehicleid )
//	return SetVehicleToRespawn( vehicleid );

stock ShowPlayerCoinMarketDialog( playerid, bool: second_page = false )
{
	if ( p_accountSecurityData[ playerid ] [ E_ID ] && ! p_accountSecurityData[ playerid ] [ E_VERIFIED ] && p_accountSecurityData[ playerid ] [ E_MODE ] != SECURITY_MODE_DISABLED )
		return SendError( playerid, "You must be verified in order to use this feature. "COL_YELLOW"(use /verify)" );

	new
		Float: discount = GetGVarFloat( "vip_discount" ),
		szMarket[ 512 ] = ""COL_GREY"Item Name\t"COL_GREY"Coins Needed\n";

	if ( ! second_page )
	{
		for( new i = 5; i != 0; i-- )
		{
			new
				iCoinRequirement = floatround( a_vipCoinRequirements[ i ] * ( i == VIP_DIAMOND ? 1.0 : discount ) );

			format( szMarket, sizeof( szMarket ), "%s%s V.I.P\t"COL_GOLD"%d\n", szMarket, VIPToString( i ), iCoinRequirement );
		}

		strcat( szMarket, ""COL_GREY"See other items...\t"COL_GREY">>>" );
		return ShowPlayerDialog( playerid, DIALOG_IC_MARKET, DIALOG_STYLE_TABLIST_HEADERS, ""COL_GOLD"Irresistible Coin -{FFFFFF} Market", szMarket, "Select", "" );
	}
	else
	{
		format( szMarket, sizeof( szMarket ), "%sCoke Business\t"COL_GOLD"%0.0f\n", szMarket, 1500.0 * discount );
		format( szMarket, sizeof( szMarket ), "%sMeth Business\t"COL_GOLD"%0.0f\n", szMarket, 800.0 * discount );
		format( szMarket, sizeof( szMarket ), "%sExtra Vehicle And House Slot\t"COL_GOLD"%0.0f\n", szMarket, 750.0 * discount );
		format( szMarket, sizeof( szMarket ), "%sV.I.P Vehicle\t"COL_GOLD"%0.0f\n", szMarket, 600.0 * discount );
		format( szMarket, sizeof( szMarket ), "%sV.I.P House\t"COL_GOLD"%0.0f\n", szMarket, 600.0 * discount );
		format( szMarket, sizeof( szMarket ), "%sWeed Business\t"COL_GOLD"%0.0f\n", szMarket, 500.0 * discount );
		format( szMarket, sizeof( szMarket ), "%sCustom Gate\t"COL_GOLD"%0.0f\n", szMarket, 350.0 * discount );
		format( szMarket, sizeof( szMarket ), "%sV.I.P Garage\t"COL_GOLD"%0.0f\n", szMarket, 250.0 * discount );
		format( szMarket, sizeof( szMarket ), "%sGold Rims\t"COL_GOLD"%0.0f\n", szMarket, 100.0 * discount );
		format( szMarket, sizeof( szMarket ), "%sChange your name\t"COL_GOLD"%0.0f", szMarket, 50.0 * discount );
	}
	return ShowPlayerDialog( playerid, DIALOG_IC_MARKET_2, DIALOG_STYLE_TABLIST_HEADERS, ""COL_GOLD"Irresistible Coin -{FFFFFF} Market", szMarket, "Select", "Back" );
}

stock ShowPlayerBankMenuDialog( playerid )
{
	new
		gangid = p_GangID[ playerid ];

	if ( gangid != -1 && Iter_Contains( gangs, gangid ) )
		return ShowPlayerDialog( playerid, DIALOG_BANK_MENU, DIALOG_STYLE_LIST, "{FFFFFF}Account", "Withdraw\nDeposit\nAccount Information\n"COL_GREEN"Gang Bank Withdraw\n"COL_GREEN"Gang Bank Deposit\n"COL_GREEN"Gang Bank Balance", "Select", "Cancel" );

	return ShowPlayerDialog( playerid, DIALOG_BANK_MENU, DIALOG_STYLE_LIST, "{FFFFFF}Account", "Withdraw\nDeposit\nAccount Information", "Select", "Cancel" );
}

stock SetPlayerPosition( playerid, Float: x, Float: y, Float: z, interiorid = 0, worldid = 0, in_vehicle = 1 )
{
	new
		vehicleid = ( in_vehicle ? GetPlayerVehicleID( playerid ) : INVALID_VEHICLE_ID );

    SetPlayerInterior( playerid, interiorid );
    SetPlayerVirtualWorld( playerid, worldid );

	if ( 0 < vehicleid < MAX_VEHICLES )
	{
		SetVehicleVirtualWorld( vehicleid, worldid );
		LinkVehicleToInterior( vehicleid, interiorid );
		return SetVehiclePos( vehicleid, x, y, z );
	}

	return SetPlayerPos( playerid, x, y, z );
}

stock GetOnlineGangMembers( gangid, exceptid = INVALID_PLAYER_ID )
{
	new
		iPlayers = 0;

	foreach (new playerid : Player)
		if ( playerid != exceptid && p_GangID[ playerid ] != INVALID_GANG_ID && p_GangID[ playerid ] == gangid )
			iPlayers ++;

	return iPlayers;
}

stock initializeVendingMachines( )
{
	for( new i = 0; i < sizeof( g_VendingMachineObject ); i++ )
	{
		g_VendingMachineObject[ i ] = CreateDynamicObject(
			g_VendingMachines[ i ] [ E_MODEL ],
			g_VendingMachines[ i ] [ E_X ],
			g_VendingMachines[ i ] [ E_Y ],
			g_VendingMachines[ i ] [ E_Z ],
			g_VendingMachines[ i ] [ E_RX ],
			g_VendingMachines[ i ] [ E_RY ],
			g_VendingMachines[ i ] [ E_RZ ],
			-1, -1
			//-1, g_VendingMachines[ i ] [ E_INTERIOR ]
		);
	}
}

stock SplitPlayerCashForGang( playerid, Float: cashRobbed )
{
	new
		bGangProfitSplit = ( p_GangID[ playerid ] != INVALID_GANG_ID && p_GangSplitProfits[ playerid ] ), Float: cashBanked = 0;

	if ( bGangProfitSplit )
	{
		new
			Float: keepOnHand = cashRobbed;

		cashRobbed = ( keepOnHand * float( 100 - p_GangSplitProfits[ playerid ] ) ) / 100.0;
		cashBanked = ( keepOnHand * float( p_GangSplitProfits[ playerid ] ) ) / 100.0;

		new
			iRoundedBanked = floatround( cashBanked, floatround_floor );

		SendServerMessage( playerid, "You've split %s (%d%s) towards your gang's bank balance.", ConvertPrice( iRoundedBanked ), p_GangSplitProfits[ playerid ], "%%" );

		if ( -1 < iRoundedBanked > 50000 )
		{
			printf( "[EXPLOIT] [0xC1] %s has tried to store %s to gang %d", ReturnPlayerName( playerid ), ConvertPrice( iRoundedBanked ), p_GangID[ playerid ] );
			return SendError( playerid, "An exploit (0xC2) had occured, therefore this robbery was denied. Please report this to Lorenc!" );
		}

		g_gangData[ p_GangID[ playerid ] ] [ E_BANK ] += iRoundedBanked;
	}

	new
		iRoundedRobbed = floatround( cashRobbed, floatround_floor );

	if ( iRoundedRobbed != 0 )
	{
		if ( -1 < iRoundedRobbed > 50000 )
		{
			printf( "[EXPLOIT] [0xC1] %s has robbed %s", ReturnPlayerName( playerid ), ConvertPrice( iRoundedRobbed ) );
			return SendError( playerid, "An exploit (0xC1) had occured, therefore this robbery was denied. Please report this to Lorenc!" );
		}

		GivePlayerCash( playerid, iRoundedRobbed );
	}
	return 1;
}

stock ResetPlayerVendingMachineData( playerid )
{
	if ( p_VendingUseTimer[ playerid ] != -1 )
	{
		KillTimer( p_VendingUseTimer[ playerid ] );
		p_VendingUseTimer[ playerid ] = -1;
	}
}

stock GetPlayerRank( playerid )
{
	new
		iRank;

	for( iRank = 0; iRank < sizeof( g_aPlayerRanks ); iRank++ )
		if ( p_IrresistiblePoints[ playerid ] >= g_aPlayerRanks[ iRank ] [ E_POINTS ] )
			break;

	return iRank;
}

stock ShowPlayerIrresistibleRank( playerid )
{
	new
		iRank = GetPlayerRank( playerid );

	PlayerTextDrawColor( playerid, p_PlayerRankTextTD[ playerid ], g_aPlayerRanks[ iRank ] [ E_COLOR ] );
	PlayerTextDrawSetString( playerid, p_PlayerRankTextTD[ playerid ], g_aPlayerRanks[ iRank ] [ E_NAME ] );

	PlayerTextDrawColor( playerid, p_PlayerRankTD[ playerid ], g_aPlayerRanks[ iRank ] [ E_COLOR ] );
	PlayerTextDrawSetPreviewModel( playerid, p_PlayerRankTD[ playerid ], g_aPlayerRanks[ iRank ] [ E_MODEL ] );

	PlayerTextDrawShow( playerid, p_PlayerRankTD[ playerid ] );
	PlayerTextDrawShow( playerid, p_PlayerRankTextTD[ playerid ] );
}

stock GivePlayerIrresistiblePoints( playerid, Float: points )
{
	new
		Float: fPreviousPoints 	= p_IrresistiblePoints[ playerid ],
		Float: fCurrentPoints 	= fPreviousPoints + points
	;

	if ( fCurrentPoints < 0.0 )
		fCurrentPoints = 0.0;

	if ( fCurrentPoints > 10000.0 )
		fCurrentPoints = 10000.0;

	// gained
	for( new iRank = 0; iRank < sizeof( g_aPlayerRanks ); iRank++ )
	{
		new
			bGained = ( fPreviousPoints < g_aPlayerRanks[ iRank ] [ E_POINTS ] <= fCurrentPoints ),
			bLost = ( fCurrentPoints < g_aPlayerRanks[ iRank ] [ E_POINTS ] <= fPreviousPoints )
		;

		if ( bGained || bLost )
		{
			if ( bGained )
			{
				SendServerMessage( playerid, "Congratulations, your grouped ranking has been increased to {%06x}%s"COL_WHITE"!", g_aPlayerRanks[ iRank ] [ E_COLOR ] >>> 8, g_aPlayerRanks[ iRank ] [ E_NAME ] );

				PlayerTextDrawColor( playerid, p_PlayerRankTextTD[ playerid ], g_aPlayerRanks[ iRank ] [ E_COLOR ] );
				PlayerTextDrawSetString( playerid, p_PlayerRankTextTD[ playerid ], g_aPlayerRanks[ iRank ] [ E_NAME ] );

				PlayerTextDrawColor( playerid, p_PlayerRankTD[ playerid ], g_aPlayerRanks[ iRank ] [ E_COLOR ] );
				PlayerTextDrawSetPreviewModel( playerid, p_PlayerRankTD[ playerid ], g_aPlayerRanks[ iRank ] [ E_MODEL ] );
			}

			if ( bLost )
			{
				SendServerMessage( playerid, "Sorry, your grouped ranking has decreased to {%06x}%s"COL_WHITE"!", g_aPlayerRanks[ iRank + 1 ] [ E_COLOR ] >>> 8, g_aPlayerRanks[ iRank + 1 ] [ E_NAME ] );

				PlayerTextDrawColor( playerid, p_PlayerRankTextTD[ playerid ], g_aPlayerRanks[ iRank + 1 ] [ E_COLOR ] );
				PlayerTextDrawSetString( playerid, p_PlayerRankTextTD[ playerid ], g_aPlayerRanks[ iRank + 1 ] [ E_NAME ] );

				PlayerTextDrawColor( playerid, p_PlayerRankTD[ playerid ], g_aPlayerRanks[ iRank + 1 ] [ E_COLOR ] );
				PlayerTextDrawSetPreviewModel( playerid, p_PlayerRankTD[ playerid ], g_aPlayerRanks[ iRank + 1 ] [ E_MODEL ] );
			}

			PlayerTextDrawShow( playerid, p_PlayerRankTD[ playerid ] );
			PlayerTextDrawShow( playerid, p_PlayerRankTextTD[ playerid ] );
			break;
		}
	}
	//printf( "%s: %f points", ReturnPlayerName( playerid ), fCurrentPoints );
	p_IrresistiblePoints[ playerid ] = fCurrentPoints;
}

stock CreateBusinessActors( businessid )
{
	static const
		g_businessActorData[ 4 ] [ MAX_BIZ_ACTORS ] [ E_ACTOR_DATA ] =
		{
			// Weed lab
			{
				{ 21, -1747.3533, -1372.9813, 5874.1333, 2.07910, "INT_SHOP", "shop_loop", 0 },
				{ 22, -1749.7698, -1377.1772, 5874.1333, 87.3066, "INT_SHOP", "shop_loop", 0 },
				{ 41, -1749.7698, -1378.2697, 5874.1333, 87.9333, "INT_SHOP", "shop_loop", 0 },
				{ 143, -1746.3678, -1377.1827, 5874.1333, 89.5236, "INT_SHOP", "shop_loop", 0 },
				{ 183, -1734.0258, -1359.8907, 5874.1372, 49.1026, "COP_AMBIENT", "Coplook_think", 0 },
				{ 184, -1730.9587, -1370.6337, 5874.1455, 320.139, "INT_SHOP", "shop_pay", 0 },
				{ 220, -1734.9357, -1379.7953, 5874.1475, 242.118, "INT_SHOP", "shop_loop", 0 },
				{ 222, -1727.6835, -1367.3120, 5874.1436, 86.0996, "INT_SHOP", "shop_loop", 0 },
				{ 168, -1743.6840, -1368.3126, 5874.1333, 339.252, "INT_SHOP", "shop_shelf", 0 }
			},

			// Meth Lab
			{
	 			{ 70,2023.7355, 1001.6071, 1510.2416, 182.2146, "INT_SHOP", "shop_loop", 0 },
	 			{ 70,2019.7291, 1001.6071, 1510.2416, 179.7077, "INT_SHOP", "shop_loop", 0 },
	 			{ 153,2026.5404, 1008.3461, 1510.2416, 178.4305, "COP_AMBIENT", "Coplook_think", 0 },
	 			{ 259,2026.3182, 1005.4316, 1510.2416, 359.1620, "COP_AMBIENT", "Copbrowse_loop", 0 },
	 			{ 290,2026.3282, 1000.9877, 1510.2416, 177.4259, "INT_SHOP", "shop_pay", 0 },
	 			{ 71,2034.8290, 1006.0858, 1510.2416, 88.77530, "COP_AMBIENT", "Coplook_loop", 0 },
	 			{ -1, 0.0, 0.0, 0.0, 0.0, "", "", 0 },
	 			{ -1, 0.0, 0.0, 0.0, 0.0, "", "", 0 },
	 			{ -1, 0.0, 0.0, 0.0, 0.0, "", "", 0 }
	 		},

			// Cocaine Lab
			{
				{ 146, 2554.8198, -1287.2550, 1143.7559, 358.8902, "INT_SHOP", "shop_loop", 0 },
				{ 146, 2553.5564, -1293.3484, 1143.7539, 180.9151, "INT_SHOP", "shop_loop", 0 },
				{ 145, 2555.1589, -1295.2550, 1143.7559, 0.433400, "INT_SHOP", "shop_loop", 0 },
				{ 146, 2560.0005, -1294.4984, 1143.7559, 269.8790, "INT_SHOP", "shop_loop", 0 },
				{ 146, 2562.7671, -1293.3485, 1143.7539, 177.1313, "INT_SHOP", "shop_loop", 0 },
				{ 145, 2564.3228, -1293.3485, 1143.7539, 181.2047, "INT_SHOP", "shop_loop", 0 },
				{ 146, 2560.0005, -1286.4615, 1143.7559, 267.9984, "INT_SHOP", "shop_loop", 0 },
				{ 146, 2564.1406, -1285.3485, 1143.7539, 180.8909, "INT_SHOP", "shop_loop", 0 },
				{ 145, 2548.4253, -1297.8320, 1143.7242, 89.43240, "INT_SHOP", "shop_loop", 0 }
			},

			// Bunker
			{
				{  73, -4208.1074, 225.9245, 1303.4427, 269.9649, "ped", "arrestgun", 0 },
	 			{  72, -4243.9443, 206.0920, 1304.2760, 195.7034, "COP_AMBIENT", "Coplook_think", 0 },
	 			{  70, -4243.0029, 217.9445, 1302.7787, 267.1439, "COP_AMBIENT", "Coplook_think", 0 },
	 			{ 179, -4249.9536, 212.4322, 1302.7787, 175.6503, "INT_SHOP", "shop_loop", 0 },
	 			{ 191, -4247.6919, 230.0827, 1302.7787, 14.61830, "INT_SHOP", "shop_loop", 0 },
	 			{ 206, -4252.3667, 226.2863, 1302.7787, 104.8591, "INT_SHOP", "shop_loop", 0 },
	 			{ 260, -4318.6001, 225.3439, 1303.4427, 88.90350, "BD_FIRE", "BD_Panic_Loop", 0 },
	 			{  95, -4307.3999, 254.0258, 1303.4427, 104.5234, "SPRAYCAN", "spraycan_fire", 0 },
	 			{ 144, -4256.8809, 208.2703, 1302.7716, 322.2679, "INT_SHOP", "shop_loop", 0 }
			}
		}
	;

	new
		biz_type = g_businessData[ businessid ] [ E_INTERIOR_TYPE ];

	for ( new i = 0; i < MAX_BIZ_ACTORS; i ++ ) if ( g_businessActorData[ biz_type ] [ i ] [ E_SKIN ] != -1 )
	{
		g_businessActors[ businessid ] [ i ] = CreateActor( g_businessActorData[ biz_type ] [ i ] [ E_SKIN ], g_businessActorData[ biz_type ] [ i ] [ E_X ], g_businessActorData[ biz_type ] [ i ] [ E_Y ], g_businessActorData[ biz_type ] [ i ] [ E_Z ], g_businessActorData[ biz_type ] [ i ] [ E_RZ ] );
		SetActorInvulnerable( g_businessActors[ businessid ] [ i ], true );
		SetActorVirtualWorld( g_businessActors[ businessid ] [ i ], g_businessData[ businessid ] [ E_WORLD ] );
    	ApplyActorAnimation( g_businessActors[ businessid ] [ i ], g_businessActorData[ biz_type ] [ i ] [ E_ANIM_LIB ], g_businessActorData[ biz_type ] [ i ] [ E_ANIM_NAME ], 4.1, 1, 1, 1, 1, 0 );
    	ApplyActorAnimation( g_businessActors[ businessid ] [ i ], g_businessActorData[ biz_type ] [ i ] [ E_ANIM_LIB ], g_businessActorData[ biz_type ] [ i ] [ E_ANIM_NAME ], 4.1, 1, 1, 1, 1, 0 );
	}
	return 1;
}

stock initializeActors( )
{
	for( new i = 0; i < sizeof( g_actorData ); i++ )
	{
		new
			actorid = CreateActor( g_actorData[ i ] [ E_SKIN ], g_actorData[ i ] [ E_X ], g_actorData[ i ] [ E_Y ], g_actorData[ i ] [ E_Z ], g_actorData[ i ] [ E_RZ ] );

		SetActorInvulnerable( actorid, true );
		SetActorVirtualWorld( actorid, g_actorData[ i ] [ E_WORLD ] );
    	ApplyActorAnimation( actorid, g_actorData[ i ] [ E_ANIM_LIB ], g_actorData[ i ] [ E_ANIM_NAME ], 4.1, 1, 1, 1, 1, 0 );
    	ApplyActorAnimation( actorid, g_actorData[ i ] [ E_ANIM_LIB ], g_actorData[ i ] [ E_ANIM_NAME ], 4.1, 1, 1, 1, 1, 0 );
	}
}

stock ShowPlayerTogglableTextdraws( playerid, bool: force = false )
{
	// Current Coins
	if ( p_PlayerSettings[ playerid ] { SETTING_COINS_BAR } == false || force ) {
		TextDrawShowForPlayer( playerid, g_CurrentCoinsTD );
		PlayerTextDrawShow( playerid, p_CoinsTD[ playerid ] );
	}

	// Top donor
	if ( p_PlayerSettings[ playerid ] { SETTING_TOP_DONOR } == false || force ) {
		TextDrawShowForPlayer( playerid, g_TopDonorTD );
	}
}

stock HidePlayerTogglableTextdraws( playerid, bool: force = true )
{
	// Current Coins
	if ( p_PlayerSettings[ playerid ] { SETTING_COINS_BAR } == true || force ) {
		TextDrawHideForPlayer( playerid, g_CurrentCoinsTD );
		PlayerTextDrawHide( playerid, p_CoinsTD[ playerid ] );
	}

	// Top donor
	if ( p_PlayerSettings[ playerid ] { SETTING_TOP_DONOR } == true || force ) {
		TextDrawHideForPlayer( playerid, g_TopDonorTD );
	}
}

stock CheckPlayerVipExpiry( playerid )
{
    if ( p_VIPLevel[ playerid ] > 0 && g_iTime > p_VIPExpiretime[ playerid ] )
    {
		SetPlayerArmour( playerid, 0.0 );
        p_VIPExpiretime[ playerid ] = 0;
        SendClientMessage( playerid, -1, ""COL_GREY"[NOTIFICATION]"COL_WHITE" Your V.I.P has expired, consider another donation to have your V.I.P restored again for another period." );
        p_VIPLevel[ playerid ] = 0;
        p_VIPWep1{ playerid } = 0;
        p_VIPWep2{ playerid } = 0;
        p_VIPWep3{ playerid } = 0;
	}
}

thread OnCasinoPoolsLoad( )
{
	new
	    rows, fields;

    cache_get_data( rows, fields );

    if ( rows )
    {
    	for( new i = 0; i < rows; i++ )
    	{
	    	new
	    		poolid = cache_get_field_content_int( i, "ID", dbHandle );

	    	if ( 0 <= poolid < MAX_SLOT_POOLS )
	    	{
	    		if ( Iter_Contains( CasinoPool, poolid ) )
	    			break;

	    		// insert data
	    		g_casinoPoolData[ poolid ] [ E_POOL ] 			= cache_get_field_content_int( i, "POOL", dbHandle );
	    		g_casinoPoolData[ poolid ] [ E_TOTAL_WINNINGS ] = cache_get_field_content_int( i, "TOTAL_WINNINGS", dbHandle );
	    		g_casinoPoolData[ poolid ] [ E_TOTAL_GAMBLED ] 	= cache_get_field_content_int( i, "TOTAL_GAMBLED", dbHandle );

	    		// create specific 3d texts and objects
	    		switch ( poolid )
	    		{
	    			// caligs low
	    			case 0:
	    			{
						g_casinoPoolData[ poolid ] [ E_OBJECT ] [ 0 ] = CreateDynamicObject( 3074, 2216.5166, 1585.5836, 1006.3437, 0.0000, 10.6999, 91.7292 );
						g_casinoPoolData[ poolid ] [ E_OBJECT ] [ 1 ] = CreateDynamicObject( 3074, 2216.7634, 1620.6029, 1006.5472, 0.0000, 2.5, -90.0 );
						g_casinoPoolData[ poolid ] [ E_OBJECT ] [ 2 ] = CreateDynamicObject( 3074, 2277.2065, 1606.6026, 1006.1736, 0.0000, -2.3000, 177.1292 );
						g_casinoPoolData[ poolid ] [ E_OBJECT ] [ 3 ] = CreateDynamicObject( 3074, 2190.8913, 1677.1768, 11.5257, 0.0000, 20.3999, 179.7994 );
						g_casinoPoolData[ poolid ] [ E_OBJECT ] [ 4 ] = CreateDynamicObject( 3074, 2255.6259, 1620.6029, 1006.5472, 0.0000, 2.5, -90.0 );

						g_casinoPoolData[ poolid ] [ E_LABEL ] [ 0 ] = CreateDynamic3DTextLabel( "LOADING", COLOR_GREEN, 2218.8115, 1616.7198, 1008.1833, 15.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, .testlos = 0 );
						g_casinoPoolData[ poolid ] [ E_LABEL ] [ 1 ] = CreateDynamic3DTextLabel( "LOADING", COLOR_GREEN, 2218.5430, 1590.5162, 1008.1849, 15.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, .testlos = 0 );
						g_casinoPoolData[ poolid ] [ E_LABEL ] [ 2 ] = CreateDynamic3DTextLabel( "LOADING", COLOR_GREEN, 2271.5161, 1606.4812, 1008.1797, 15.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, .testlos = 0 );
						g_casinoPoolData[ poolid ] [ E_LABEL ] [ 3 ] = CreateDynamic3DTextLabel( "LOADING", COLOR_GREEN, 2219.1663, 1603.9136, 1008.1797, 15.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, .testlos = 0 );
	    				g_casinoPoolData[ poolid ] [ E_LABEL ] [ 4 ] = CreateDynamic3DTextLabel( "LOADING", COLOR_GREEN, 2255.1665, 1613.9871, 1008.1797, 15.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, .testlos = 0 );
					}

	    			// dragons low
	    			case 1:
	    			{
						g_casinoPoolData[ poolid ] [ E_OBJECT ] [ 0 ] = CreateDynamicObject( 3074, 1956.5617, 995.9906, 991.5460, 0.0000, -90.1000, 144.6679 );
						g_casinoPoolData[ poolid ] [ E_OBJECT ] [ 1 ] = CreateDynamicObject( 3074, 1968.7164, 990.2147, 991.5709, 0.0000, -90.1000, -26.6321 );
	    				g_casinoPoolData[ poolid ] [ E_OBJECT ] [ 2 ] = CreateDynamicObject( 3074, 1956.8721, 1039.3811, 991.4691, 0.0999, -89.899, -147.020 );
	    				g_casinoPoolData[ poolid ] [ E_OBJECT ] [ 3 ] = CreateDynamicObject( 3074, 1968.7106, 1044.6326, 991.4962, 0.0000, -90.1000, 30.9680 );
	    				g_casinoPoolData[ poolid ] [ E_OBJECT ] [ 4 ] = CreateDynamicObject( 3074, 2026.9927, 1008.0256, 9.630300, 0.0000, 0.000000, 1.70270 );

						g_casinoPoolData[ poolid ] [ E_LABEL ] [ 0 ] = CreateDynamic3DTextLabel( "LOADING", COLOR_GREEN, 1962.2894, 992.08720, 994.5215, 15.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, .testlos = 0 );
						g_casinoPoolData[ poolid ] [ E_LABEL ] [ 1 ] = CreateDynamic3DTextLabel( "LOADING", COLOR_GREEN, 1962.1710, 1043.5509, 994.5215, 15.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, .testlos = 0 );
	    				g_casinoPoolData[ poolid ] [ E_LABEL ] [ 2 ] = Text3D: INVALID_3DTEXT_ID;
	    				g_casinoPoolData[ poolid ] [ E_LABEL ] [ 3 ] = Text3D: INVALID_3DTEXT_ID;
	    				g_casinoPoolData[ poolid ] [ E_LABEL ] [ 4 ] = Text3D: INVALID_3DTEXT_ID;
	    			}
	    		}

	    		// Update pool labels etc
	    		UpdateCasinoPoolLabels( poolid );

	    		// shove the id into the system
	    		Iter_Add(CasinoPool, poolid);
	    	}
	    	else printf( "[ERROR]: A slot pool id exceeds %d\n", MAX_SLOT_POOLS );
	    }

	    // create slot machines
		mysql_function_query( dbHandle, "SELECT * FROM `SLOT_MACHINES`", true, "OnSlotMachinesLoad", "" );
    }
    return 1;
}

stock UpdateCasinoPoolLabels( poolid )
{
	for( new i = 0; i < POOL_ENTITIES; i ++ )
	{
		if ( IsValidDynamicObject( g_casinoPoolData[ poolid ] [ E_OBJECT ] [ i ] ) )
			SetDynamicObjectMaterialText( g_casinoPoolData[ poolid ] [ E_OBJECT ] [ i ], 0, sprintf( "%s PRIZE", ConvertPrice( g_casinoPoolData[ poolid ] [ E_POOL ] ) ), 130, "Arial", 20, 1, 0xFF00FF00, 0, 1);

		if ( IsValidDynamic3DTextLabel( g_casinoPoolData[ poolid ] [ E_LABEL ] [ i ] ) )
			UpdateDynamic3DTextLabelText( g_casinoPoolData[ poolid ] [ E_LABEL ] [ i ], 0x00FF00FF, sprintf( "%s Prize Pool", ConvertPrice( g_casinoPoolData[ poolid ] [ E_POOL ] ) ) );
	}
	return 1;
}

stock UpdateCasinoPoolData( poolid, pool_increment = 0, total_win = 0, total_gambled = 0 )
{
	if ( ! Iter_Contains( CasinoPool, poolid ) )
		return;

	static
		iUpdateCooldown;

	// update vars
	g_casinoPoolData[ poolid ] [ E_POOL ] += pool_increment;
	g_casinoPoolData[ poolid ] [ E_TOTAL_WINNINGS ] += total_win;
	g_casinoPoolData[ poolid ] [ E_TOTAL_GAMBLED ] 	+= total_gambled;

	// update labels
	UpdateCasinoPoolLabels( poolid );

	// update the database
	if ( g_iTime > iUpdateCooldown )
	{
		// update the database
		format( szNormalString, sizeof( szNormalString ), "UPDATE `CASINO_POOLS` SET `POOL`=%d,`TOTAL_WINNINGS`=%d,`TOTAL_GAMBLED`=%d WHERE `ID`=%d", g_casinoPoolData[ poolid ] [ E_POOL ], g_casinoPoolData[ poolid ] [ E_TOTAL_WINNINGS ], g_casinoPoolData[ poolid ] [ E_TOTAL_GAMBLED ], poolid );
		mysql_single_query( szNormalString );

		// cooldown
		iUpdateCooldown = g_iTime + 20;
	}
}

thread OnSlotMachinesLoad( )
{
	new
	    rows, fields, loadingTick = GetTickCount( );

    cache_get_data( rows, fields );

    if ( rows )
    {
    	for( new i = 0; i < rows; i++ )
    	{
			new
				id = Iter_Free(SlotMachines);

			if ( id != ITER_NONE )
			{
				new
					Float: X = cache_get_field_content_float( i, "X", dbHandle ),
					Float: Y = cache_get_field_content_float( i, "Y", dbHandle ),
					Float: Z = cache_get_field_content_float( i, "Z", dbHandle ),
					Float: rZ = cache_get_field_content_float( i, "ROTATION", dbHandle ),
					Float: fOffsetX,
					Float: fOffsetY
				;

				// Update positions
				g_slotmachineData[ id ] [ E_X ] = X;
				g_slotmachineData[ id ] [ E_Y ] = Y;
				g_slotmachineData[ id ] [ E_Z ] = Z;
				g_slotmachineData[ id ] [ E_A ] = rZ;

				// Load variables
				g_slotmachineData[ id ] [ E_ENTRY_FEE ] = cache_get_field_content_int( i, "ENTRY_FEE", dbHandle );
				g_slotmachineData[ id ] [ E_POOL_ID ] = cache_get_field_content_int( i, "POOL_ID", dbHandle );

				// 3d Text
				fOffsetX = 1.0 * floatsin( -rZ, degrees );
				fOffsetY = 1.0 * floatcos( -rZ, degrees );
				CreateDynamic3DTextLabel( sprintf( "Press ENTER to use\n"COL_WHITE"%s Minimum", ConvertPrice( g_slotmachineData[ id ] [ E_ENTRY_FEE ] ) ), COLOR_GREY, X + fOffsetX, Y + fOffsetY, Z - 0.1, 5.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, .testlos = 1 );

				// Misc variables
				g_slotmachineData[ id ] [ E_TIMER ] = -1;

				// Create machines
				CreateDynamicObject( 2325, X, Y, Z, 0.00000, 0.00000, rZ );

				// Third slot
				fOffsetX = 0.096 * floatsin( rZ + 96.0, degrees );
				fOffsetY = 0.096 * floatcos( rZ + 96.0, degrees );

				g_slotmachineData[ id ] [ E_SPIN_ROTATE ] [ 0 ] = 20.0 * random( 18 );
				g_slotmachineData[ id ] [ E_SPIN ] [ 0 ] = CreateDynamicObject( 2347, X - fOffsetX, Y + fOffsetY, Z + 0.0024, g_slotmachineData[ id ] [ E_SPIN_ROTATE ] [ 0 ], 0.00000, rZ );

				// Second slot
				fOffsetX = 0.025 * floatsin( rZ + 66.4, degrees );
				fOffsetY = 0.025 * floatcos( rZ + 66.4, degrees );

				g_slotmachineData[ id ] [ E_SPIN_ROTATE ] [ 1 ] = 20.0 * random( 18 );
				g_slotmachineData[ id ] [ E_SPIN ] [ 1 ] = CreateDynamicObject( 2347, X + fOffsetX, Y - fOffsetY, Z + 0.0024, g_slotmachineData[ id ] [ E_SPIN_ROTATE ] [ 1 ], 0.00000, rZ );

				// First slot
				fOffsetX = 0.140 * floatsin( rZ + 85.9, degrees );
				fOffsetY = 0.140 * floatcos( rZ + 85.9, degrees );

				g_slotmachineData[ id ] [ E_SPIN_ROTATE ] [ 2 ] = 20.0 * random( 18 );
				g_slotmachineData[ id ] [ E_SPIN ] [ 2 ] = CreateDynamicObject( 2347, X + fOffsetX, Y - fOffsetY, Z + 0.0024, g_slotmachineData[ id ] [ E_SPIN_ROTATE ] [ 2 ], 0.00000, rZ );

				// Add to iteration
				Iter_Add(SlotMachines, id);
			}
    	}
    }
	printf( "[SLOT MACHINES]: %d slot machines have been loaded. (Tick: %dms)", rows, GetTickCount( ) - loadingTick );
    return 1;
}


stock RollSlotMachine( playerid, id )
{
	new
		randomChance, bool: loss = false, Float: rotation;

	if ( g_slotmachineData[ id ] [ E_ENTRY_FEE ] == 10000 )
	{
		// 1 in 200k odds
		randomChance = random( 200001 );
		printf("random chance %d", randomChance );

		// double brick
		if ( randomChance == 131730 ) // rigged
			rotation = 0.0;

		// single brick
		else if ( 1 <= randomChance <= 3560 )
			rotation = 40.0;

		// gold bells
		else if ( 3561 <= randomChance <= 10680 )
			rotation = 60.0;

		// cherry
		else if ( 10681 <= randomChance <= 24920 )
			rotation = 80.0;

		// grapes
		else if ( 24921 <= randomChance <= 69520 )
			rotation = 100.0;

		// 69s
		else if ( 60521 <= randomChance <= 131720 )
			rotation = 20.0;

		// loss otherwise
		else
			loss = true;
	}
	else
	{
		// 1 in 400k odds
		randomChance = random( 50001 );

		// double brick
		if ( randomChance == 27390 )
			rotation = 0.0;

		// single brick
		else if ( 1 <= randomChance <= 740 )
			rotation = 40.0;

		// gold bells
		else if ( 741 <= randomChance <= 2220 )
			rotation = 60.0;

		// cherry
		else if ( 2221 <= randomChance <= 5180 )
			rotation = 80.0;

		// grapes
		else if ( 5181 <= randomChance <= 12580 )
			rotation = 100.0;

		// 69s
		else if ( 12581 <= randomChance <= 27380 )
			rotation = 20.0;

		// loss otherwise
		else
			loss = true;
	}
	if ( loss )
	{
		if ( random( 2 ) == 0 )
		{
			// assign random rotation (must be <= 16)
			rotation = float( random( 16 ) ) * 20.0;

			// just add 20.0 to each random rotation
			g_slotmachineData[ id ] [ E_RANDOM_ROTATE ] [ 0 ] = rotation;
			g_slotmachineData[ id ] [ E_RANDOM_ROTATE ] [ 1 ] = rotation + 20.0;
			g_slotmachineData[ id ] [ E_RANDOM_ROTATE ] [ 2 ] = rotation + 40.0;
		}
		else
		{
			// assign random rotation (must be <= 16)
			rotation = float( RandomEx( 2, 18 ) ) * 20.0;

			// just add 20.0 to each random rotation
			g_slotmachineData[ id ] [ E_RANDOM_ROTATE ] [ 0 ] = rotation;
			g_slotmachineData[ id ] [ E_RANDOM_ROTATE ] [ 1 ] = rotation - 20.0;
			g_slotmachineData[ id ] [ E_RANDOM_ROTATE ] [ 2 ] = rotation - 40.0;
		}
	}
	else
	{
		g_slotmachineData[ id ] [ E_RANDOM_ROTATE ] [ 0 ] = rotation;
		g_slotmachineData[ id ] [ E_RANDOM_ROTATE ] [ 1 ] = rotation;
		g_slotmachineData[ id ] [ E_RANDOM_ROTATE ] [ 2 ] = rotation;
	}

	// Roll it!
	KillTimer( g_slotmachineData[ id ] [ E_TIMER ] );
	g_slotmachineData[ id ] [ E_ROLLING ] = true;
	g_slotmachineData[ id ] [ E_TIMER ] = SetTimerEx( "rollMachine", 50, false, "ddfd", playerid, id, 0.1, 0 );
	return 1;
}

function rollMachine( playerid, id, Float: velocity, spins )
{
	new
		// Is the player even on...
		bIsConnected = IsPlayerConnected( playerid ),

		// Calculate slot rotations
		Float: fSlotUno = g_slotmachineData[ id ] [ E_SPIN_ROTATE ] [ 0 ] + velocity,
		Float: fSlotDuo = g_slotmachineData[ id ] [ E_SPIN_ROTATE ] [ 1 ] + velocity,
		Float: fSlotTre = g_slotmachineData[ id ] [ E_SPIN_ROTATE ] [ 2 ] + velocity
	;

	if ( velocity >= 360.0 )
	{
		static
			iWinningIndex[ 3 ], bool: beep[ 2 char ];

		velocity = ++spins * 20.0;

		if ( velocity >= ( 360.0 + g_slotmachineData[ id ] [ E_RANDOM_ROTATE ] [ 0 ] ) )
		{
			fSlotUno = 360.0 + g_slotmachineData[ id ] [ E_RANDOM_ROTATE ] [ 0 ];

			if ( ! beep{ 0 } )
				PlayerPlaySound( playerid, 4203, 0.0, 0.0, 0.0 ), beep{ 0 } = true;

			g_slotmachineData[ id ] [ E_SPIN_ROTATE ] [ 0 ] = fSlotUno;
		}

		if ( velocity >= ( 720.0 + g_slotmachineData[ id ] [ E_RANDOM_ROTATE ] [ 1 ] ) )
		{
			fSlotDuo = 720.0 + g_slotmachineData[ id ] [ E_RANDOM_ROTATE ] [ 1 ];

			if ( ! beep{ 1 } )
				PlayerPlaySound( playerid, 4203, 0.0, 0.0, 0.0 ), beep{ 1 } = true;

			g_slotmachineData[ id ] [ E_SPIN_ROTATE ] [ 1 ] = fSlotDuo;
		}

		if ( velocity >= ( 1080.0 + g_slotmachineData[ id ] [ E_RANDOM_ROTATE ] [ 2 ] ) ) // 1080 is an offset
		{
			// Reset the beeps
			beep{ 0 } = false, beep{ 1 } = false;

			// Equal interval rotating
			fSlotTre = 1080.0 + g_slotmachineData[ id ] [ E_RANDOM_ROTATE ] [ 2 ];

			PlayerPlaySound( playerid, 4203, 0.0, 0.0, 0.0 );

			// Calculate index of winning shit
			g_slotmachineData[ id ] [ E_SPIN_ROTATE ] [ 2 ] = fSlotTre;

			// Update the position
			SetDynamicObjectRot( g_slotmachineData[ id ] [ E_SPIN ] [ 2 ], fSlotTre, 0.0, g_slotmachineData[ id ] [ E_A ] );

			// Kill a few things
			g_slotmachineData[ id ] [ E_TIMER ] = -1;
			g_slotmachineData[ id ] [ E_ROLLING ] = false;

			// Check if connected
			if ( bIsConnected )
			{
				// Update final
				iWinningIndex[ 0 ] = floatround( g_slotmachineData[ id ] [ E_RANDOM_ROTATE ] [ 0 ] / 20.0 );
				iWinningIndex[ 1 ] = floatround( g_slotmachineData[ id ] [ E_RANDOM_ROTATE ] [ 1 ] / 20.0 );
				iWinningIndex[ 2 ] = floatround( g_slotmachineData[ id ] [ E_RANDOM_ROTATE ] [ 2 ] / 20.0 );
				TextDrawSetString( g_SlotMachineThreeTD[ id ], g_slotmachineColors[ iWinningIndex[ 2 ] ] );
				TextDrawShowForPlayer( playerid, g_SlotMachineThreeTD[ id ] );

				// Call a winner!
				return CallLocalFunction( "OnPlayerUseSlotMachine", "ddddd", playerid, id, g_slotmachineTypes[ iWinningIndex[ 0 ] ], g_slotmachineTypes[ iWinningIndex[ 1 ] ], g_slotmachineTypes[ iWinningIndex[ 2 ] ] );
			}
			return 1;
		}

		iWinningIndex[ 0 ] = floatround( floatfract( fSlotUno / 360 ) * 18 );
		TextDrawSetString( g_SlotMachineOneTD[ id ], g_slotmachineColors[ iWinningIndex[ 0 ] ] );
		TextDrawShowForPlayer( playerid, g_SlotMachineOneTD[ id ] );

		iWinningIndex[ 1 ] = floatround( floatfract( fSlotDuo / 360 ) * 18 );
		TextDrawSetString( g_SlotMachineTwoTD[ id ], g_slotmachineColors[ iWinningIndex[ 1 ] ] );
		TextDrawShowForPlayer( playerid, g_SlotMachineTwoTD[ id ] );

		iWinningIndex[ 2 ] = floatround( floatfract( fSlotTre / 360 ) * 18 );
		TextDrawSetString( g_SlotMachineThreeTD[ id ], g_slotmachineColors[ iWinningIndex[ 2 ] ] );
		TextDrawShowForPlayer( playerid, g_SlotMachineThreeTD[ id ] );
	}
	else velocity *= 1.45;

	SetDynamicObjectRot( g_slotmachineData[ id ] [ E_SPIN ] [ 0 ], fSlotUno, 0.0, g_slotmachineData[ id ] [ E_A ] );
	SetDynamicObjectRot( g_slotmachineData[ id ] [ E_SPIN ] [ 1 ], fSlotDuo, 0.0, g_slotmachineData[ id ] [ E_A ] );
	SetDynamicObjectRot( g_slotmachineData[ id ] [ E_SPIN ] [ 2 ], fSlotTre, 0.0, g_slotmachineData[ id ] [ E_A ] );

	return ( g_slotmachineData[ id ] [ E_TIMER ] = SetTimerEx( "rollMachine", 50, false, "ddfd", playerid, id, velocity, spins ) );
}

stock GetClosestSlotMachine( playerid, &Float: distance = FLOAT_INFINITY ) {
    new
    	iCurrent = -1, Float: fTmp
    ;

	foreach(new id : SlotMachines)
	{
        if ( 0.0 < ( fTmp = GetDistanceFromPlayerSquared( playerid, g_slotmachineData[ id ] [ E_X ], g_slotmachineData[ id ] [ E_Y ], g_slotmachineData[ id ] [ E_Z ] ) ) < distance ) // Y_Less mentioned there's no need to sqroot
        {
            distance = fTmp;
            iCurrent = id;
        }
    }
    return iCurrent;
}

stock StopPlayerUsingSlotMachine( playerid )
{
	if ( p_usingSlotMachine[ playerid ] == -1 )
		return 1;

	new
		id = p_usingSlotMachine[ playerid ];

	TextDrawHideForPlayer( playerid, g_SlotMachineOneTD[ id ] );
	TextDrawHideForPlayer( playerid, g_SlotMachineTwoTD[ id ] );
	TextDrawHideForPlayer( playerid, g_SlotMachineThreeTD[ id ] );
	TextDrawHideForPlayer( playerid, p_SlotMachineFigureTD[ id ] );
	TextDrawHideForPlayer( playerid, g_SlotMachineBoxTD[ 0 ] );
	TextDrawHideForPlayer( playerid, g_SlotMachineBoxTD[ 1 ] );

	p_AutoSpin{ playerid } = false;
	p_usingSlotMachine[ playerid ] = -1;

	HidePlayerHelpDialog( playerid );
	TogglePlayerControllable( playerid, 1 );
	return 1;
}

thread OnNewNameCheckBanned( playerid, Float: iCoinRequirement, newName[ ] )
{
	new
	    rows;

	cache_get_data( rows, tmpVariable );

	if ( !rows )
	{
	  	return mysql_function_query( dbHandle, sprintf( "SELECT `NAME` FROM `USERS` WHERE `NAME` = '%s'", mysql_escape( newName ) ), true, "OnPlayerChangeName", "dfs", playerid, iCoinRequirement, newName ), 1;
	}
	else
	{
		SendError( playerid, "This name is currently banned. Please choose another name." );
		return ShowPlayerDialog( playerid, DIALOG_CHANGENAME, DIALOG_STYLE_INPUT, "Change your name", ""COL_WHITE"What would you like your new name to be? And also, double check!", "Change", "Back" ), 1;
	}
}

thread OnPlayerChangeName( playerid, Float: iCoinRequirement, newName[ ] )
{
	new
	    rows, fields
	;
	cache_get_data( rows, fields );

	if ( !rows )
	{
	 	mysql_single_query( sprintf( "UPDATE `USERS` SET `NAME` = '%s' WHERE `NAME` = '%s'", mysql_escape( newName ), mysql_escape( ReturnPlayerName( playerid ) ) ) );
	 	mysql_single_query( sprintf( "INSERT INTO `NAME_CHANGES`(`USER_ID`,`ADMIN_ID`,`NAME`) VALUES (%d,0,'%s')", p_AccountID[ playerid ], mysql_escape( ReturnPlayerName( playerid ) ) ) );

		p_IrresistibleCoins[ playerid ] -= iCoinRequirement;
		SendServerMessage( playerid, "You have changed your name to for %0.0f Irresistible Coins!", iCoinRequirement );

    	// Update houses (furniture also?)
	 	mysql_single_query( sprintf( "UPDATE `HOUSES` SET `OWNER` = '%s' WHERE `OWNER` = '%s'", mysql_escape( newName ), mysql_escape( ReturnPlayerName( playerid ) ) ) );

    	for( new i = 0; i < MAX_HOUSES; i++ ) {
    		if ( strmatch( g_houseData[ i ] [ E_OWNER ], ReturnPlayerName( playerid ) ) ) {
				format( g_houseData[ i ] [ E_OWNER ], 24, "%s", newName );
    			format( szBigString, sizeof( szBigString ), ""COL_GOLD"House:"COL_WHITE" %s(%d)\n"COL_GOLD"Owner:"COL_WHITE" %s\n"COL_GOLD"Price:"COL_WHITE" %s", g_houseData[ i ] [ E_HOUSE_NAME ], i, g_houseData[ i ] [ E_OWNER ], ConvertPrice( g_houseData[ i ] [ E_COST ] ) );
 				UpdateDynamic3DTextLabelText( g_houseData[ i ] [ E_LABEL ] [ 0 ], COLOR_WHITE, szBigString );
    		}
    	}

    	// Update apartments
	 	mysql_single_query( sprintf( "UPDATE `APARTMENTS` SET `OWNER` = '%s' WHERE `OWNER` = '%s'", mysql_escape( newName ), mysql_escape( ReturnPlayerName( playerid ) ) ) );

    	for( new i = 0; i < sizeof( g_apartmentData ); i++ )
    		if ( strmatch( g_apartmentData[ i ] [ E_OWNER ], ReturnPlayerName( playerid ) ) )
				format( g_apartmentData[ i ] [ E_OWNER ], 24, "%s", newName );

    	// Update username
		SetPlayerName( playerid, newName );
    	GetPlayerName( playerid, p_PlayerName[ playerid ], sizeof( p_PlayerName[ ] ) );

    	// Update garages
    	foreach(new g : garages)
    		if ( g_garageData[ g ] [ E_OWNER_ID ] == p_AccountID[ playerid ] )
    			UpdateGarageTitle( g );
	}
	else
	{
		SendError( playerid, "This name is taken already." );
		ShowPlayerDialog( playerid, DIALOG_CHANGENAME, DIALOG_STYLE_INPUT, "Change your name", ""COL_WHITE"What would you like your new name to be? And also, double check!", "Change", "Back" );
	}
	return 1;
}

thread OnListGangMembers( playerid, gangid )
{
	new
	    rows, i;

	cache_get_data( rows, tmpVariable );

	if ( rows )
	{
		static
			userName[ MAX_PLAYER_NAME ];

		for( i = 0, szLargeString[ 0 ] = '\0'; i < rows; i++ )
		{
			cache_get_field_content( i, "NAME", userName );
			format( szLargeString, sizeof( szLargeString ), "%s%s%s\n", szLargeString, cache_get_field_content_int( i, "ONLINE", dbHandle ) ? ( #COL_GREEN ) : ( #COL_WHITE ), userName );
		}

		ShowPlayerDialog( playerid, DIALOG_GANG_LIST_MEMBERS, DIALOG_STYLE_LIST, ""COL_WHITE"Gang Members", szLargeString, "Close", "Back" );
	}
	else
	{
		// Notify user
		SendError( playerid, "This gang no longer has any members." );
	}
	return 1;
}

stock ShowSoundsMenu( playerid )
{
	static
		szSounds[ 11 * sizeof( g_HitmarkerSounds ) ];

	if ( szSounds[ 0 ] == '\0' )
	{
		for( new i = 0; i < sizeof( g_HitmarkerSounds ); i++ )
			format( szSounds, sizeof( szSounds ), "%s%s\n", szSounds, g_HitmarkerSounds[ i ] [ E_NAME ] );
	}
	ShowPlayerDialog( playerid, DIALOG_MODIFY_HITSOUND, DIALOG_STYLE_LIST, ""COL_WHITE"Hitmarker Sound", szSounds, "Select", "Close" );
}

stock ReplaceObjectModel( &objectid, modelid ) {
	static
		Float: X, Float: Y, Float: Z, Float: rX, Float: rY, Float: rZ;

	GetDynamicObjectPos( objectid, X, Y, Z );
	GetDynamicObjectRot( objectid, rX, rY, rZ );

	DestroyDynamicObject( objectid );
	objectid = CreateDynamicObject( modelid, X, Y, Z, rX, rY, rZ );
}

stock GivePlayerLeoWeapons( playerid ) {
	GivePlayerWeapon( playerid, 3, 1 );
	GivePlayerWeapon( playerid, 22, 250 );
	GivePlayerWeapon( playerid, 31, 250 );
	//GivePlayerWeapon( playerid, 41, 0xFFFF );

	if ( p_inFBI{ playerid } == true )
	{
		GivePlayerWeapon( playerid, 29, 250 );
		GivePlayerWeapon( playerid, 34, 100 );
		GivePlayerWeapon( playerid, 27, 250 );
	}

	if ( p_inCIA{ playerid } == true )
		GivePlayerWeapon( playerid, 29, 200 );

	if ( p_inArmy{ playerid } == true )
	{
	    GivePlayerWeapon( playerid, 4, 1 );
	    GivePlayerWeapon( playerid, 24, 200 );
	    GivePlayerWeapon( playerid, 29, 200 );
	    GivePlayerWeapon( playerid, 31, 200 );
		GivePlayerWeapon( playerid, 27, 200 );
	    GivePlayerWeapon( playerid, 16, 5 );
		//GivePlayerWeapon( playerid, 34, 100 );
	}
}

#if ENABLE_COMPONENTS_SYSTEM == true
function OnVehicleComponentsLoad( playerid, vid )
{
	if ( !IsPlayerConnected( playerid ) )
		return 0;

	if ( !g_vehicleData[ playerid ] [ vid ] [ E_CREATED ] )
		return 0;

	new
		rows, fields, i = -1, cid
	;

	cache_get_data( rows, fields );

	if ( rows )
	{
		while( ++i < rows )
		{
			for( cid = 0; cid < MAX_PIMPS; cid++ )
				if ( !g_vehiclePimpData[ playerid ] [ vid ] [ E_CREATED ] [ cid ] ) break;

			if ( cid >= MAX_PIMPS )
				continue;

			if ( g_vehiclePimpData[ playerid ] [ vid ] [ E_CREATED ] [ cid ] )
			    continue;

			g_vehiclePimpData[ playerid ] [ vid ] [ E_CREATED ] [ cid ] = true;
			g_vehiclePimpData[ playerid ] [ vid ] [ E_SQL_ID ] [ cid ] = cache_get_field_content_int( i, "ID", dbHandle );
			g_vehiclePimpData[ playerid ] [ vid ] [ E_MODEL ] [ cid ] = cache_get_field_content_int( i, "MODEL", dbHandle );
			g_vehiclePimpData[ playerid ] [ vid ] [ E_X ] [ cid ] = cache_get_field_content_float( i, "X", dbHandle );
			g_vehiclePimpData[ playerid ] [ vid ] [ E_Y ] [ cid ] = cache_get_field_content_float( i, "Y", dbHandle );
			g_vehiclePimpData[ playerid ] [ vid ] [ E_Z ] [ cid ] = cache_get_field_content_float( i, "Z", dbHandle );
			g_vehiclePimpData[ playerid ] [ vid ] [ E_RX ] [ cid ] = cache_get_field_content_float( i, "RX", dbHandle );
			g_vehiclePimpData[ playerid ] [ vid ] [ E_RY ] [ cid ] = cache_get_field_content_float( i, "RY", dbHandle );
			g_vehiclePimpData[ playerid ] [ vid ] [ E_RZ ] [ cid ] = cache_get_field_content_float( i, "RZ", dbHandle );
			g_vehiclePimpData[ playerid ] [ vid ] [ E_DISABLED ] [ cid ] = !!cache_get_field_content_int( i, "DISABLED", dbHandle );

			DestroyDynamicObject( g_vehiclePimpData[ playerid ] [ vid ] [ E_OBJECT ] [ cid ] );
			g_vehiclePimpData[ playerid ] [ vid ] [ E_OBJECT ] [ cid ] = -1;

			if ( g_vehiclePimpData[ playerid ] [ vid ] [ E_DISABLED ] [ cid ] == false )
			{
				g_vehiclePimpData[ playerid ] [ vid ] [ E_OBJECT ] [ cid ] = CreateDynamicObject( g_vehiclePimpData[ playerid ] [ vid ] [ E_MODEL ] [ cid ], 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, .worldid = GetVehicleVirtualWorld( g_vehicleData[ playerid ] [ vid ] [ E_VEHICLE_ID ] ) );
				AttachDynamicObjectToVehicle( g_vehiclePimpData[ playerid ] [ vid ] [ E_OBJECT ] [ cid ], g_vehicleData[ playerid ] [ vid ] [ E_VEHICLE_ID ],
											g_vehiclePimpData[ playerid ] [ vid ] [ E_X ] [ cid ], g_vehiclePimpData[ playerid ] [ vid ] [ E_Y ] [ cid ], g_vehiclePimpData[ playerid ] [ vid ] [ E_Z ] [ cid ],
											g_vehiclePimpData[ playerid ] [ vid ] [ E_RX ] [ cid ], g_vehiclePimpData[ playerid ] [ vid ] [ E_RY ] [ cid ], g_vehiclePimpData[ playerid ] [ vid ] [ E_RZ ] [ cid ] );
			}
		}
	}
	return 1;
}

stock GetVehicleComponentSlot( playerid, vehicleid ) {

	for( new id = 0; id < MAX_PIMPS; id++ ) {
		if ( g_vehiclePimpData[ playerid ] [ vehicleid ] [ E_CREATED ] [ id ] == false ) {
			return id;
		}
	}
	return -1;
}

stock ShowPlayerVehicleComponents( playerid, categoryid ) {

	erase( szLargeString );

	for( new i = 0; i < sizeof( g_vehicleComponentsData ); i++ ) if ( g_vehicleComponentsData[ i ] [ E_CATEGORY ] == categoryid ) {
		format( szLargeString, sizeof( szLargeString ), "%s%s\t"COL_GOLD"%s\n", szLargeString, g_vehicleComponentsData[ i ] [ E_NAME ], ConvertPrice( g_vehicleComponentsData[ i ] [ E_PRICE ] ) );
	}
	return ShowPlayerDialog( playerid, DIALOG_COMPONENTS, DIALOG_STYLE_TABLIST, sprintf( "Pimp My Ride - %s", g_vehicleComponentsCategories[ categoryid ] ), szLargeString, "Purchase", "Back" );
}

thread OnPlayerCreateVehicleComponent( playerid, vehicleid, slotid )
{
	g_vehiclePimpData[ playerid ] [ vehicleid ] [ E_SQL_ID ] [ slotid ] = cache_insert_id( );
	return 1;
}

stock DestroyVehicleCustomComponents( playerid, vehicleid, bool: destroy_db = false )
{
	for( new slotid = 0; slotid < MAX_PIMPS; slotid++ ) {
		g_vehiclePimpData[ playerid ] [ vehicleid ] [ E_CREATED ] [ slotid ] = false;
		DestroyDynamicObject( g_vehiclePimpData[ playerid ] [ vehicleid ] [ E_OBJECT ] [ slotid ] );
		g_vehiclePimpData[ playerid ] [ vehicleid ] [ E_OBJECT ] [ slotid ] = -1;
	}

	if ( destroy_db ) {
		mysql_single_query( sprintf( "DELETE FROM `COMPONENTS` WHERE `VEHICLE_ID`=%d", g_vehicleData[ playerid ] [ vehicleid ] [ E_SQL_ID ] ) );
	}
}

stock ReplaceVehicleCustomComponents( ownerid, v, bool: recreate_obj = false ) {

	for( new slotid; slotid < MAX_PIMPS; slotid++ ) if ( g_vehiclePimpData[ ownerid ] [ v ] [ E_CREATED ] [ slotid ] && !g_vehiclePimpData[ ownerid ] [ v ] [ E_DISABLED ] ) {
		// Recreate object
		if ( recreate_obj ) {
			DestroyDynamicObject( g_vehiclePimpData[ ownerid ] [ v ] [ E_OBJECT ] [ slotid ] );
			g_vehiclePimpData[ ownerid ] [ v ] [ E_OBJECT ] [ slotid ] = CreateDynamicObject( g_vehiclePimpData[ ownerid ] [ v ] [ E_MODEL ] [ slotid ], 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 );
		}

		// Attach object to vehicle
		AttachDynamicObjectToVehicle( g_vehiclePimpData[ ownerid ] [ v ] [ E_OBJECT ] [ slotid ], g_vehicleData[ ownerid ] [ v ] [ E_VEHICLE_ID ],
							g_vehiclePimpData[ ownerid ] [ v ] [ E_X ] [ slotid ], g_vehiclePimpData[ ownerid ] [ v ] [ E_Y ] [ slotid ], g_vehiclePimpData[ ownerid ] [ v ] [ E_Z ] [ slotid ],
							g_vehiclePimpData[ ownerid ] [ v ] [ E_RX ] [ slotid ], g_vehiclePimpData[ ownerid ] [ v ] [ E_RY ] [ slotid ], g_vehiclePimpData[ ownerid ] [ v ] [ E_RZ ] [ slotid ] );

		// Update virtual world
		Streamer_SetIntData( STREAMER_TYPE_OBJECT, g_vehiclePimpData[ ownerid ] [ v ] [ E_OBJECT ] [ slotid ], E_STREAMER_WORLD_ID, GetVehicleVirtualWorld( g_vehicleData[ ownerid ] [ v ] [ E_VEHICLE_ID ] ) );
	}
}

stock GetVehicleCustomComponents( playerid, vehicleid ) {
	new
		count = 0;

	for( new i = 0; i < MAX_PIMPS; i++ )
		if ( g_vehiclePimpData[ playerid ] [ vehicleid ] [ E_CREATED ] [ i ] )
			count ++;

	return count;
}

stock ShowPlayerVehicleComponentMenu( playerid, ownerid, vehicleid, i )
{
	new
		pimpid;

	for( ; pimpid < sizeof( g_vehicleComponentsData ); pimpid++ )
		if ( g_vehicleComponentsData[ pimpid ] [ E_MODEL_ID ] == g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_MODEL ] [ i ] )
			break;

	if ( !( 0 <= pimpid < sizeof( g_vehicleComponentsData ) ) || g_vehicleComponentsData[ pimpid ] [ E_MODEL_ID ] != g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_MODEL ] [ i ] )
		return SendError( playerid, "You cannot sell this component as it no longer exists." );

	new
		sellPrice = floatround( g_vehicleComponentsData[ pimpid ] [ E_PRICE ] * 0.5 );

	SetPVarInt( playerid, "components_editing", i );
	return ShowPlayerDialog( playerid, DIALOG_COMPONENT_EDIT, DIALOG_STYLE_TABLIST, "Vehicle Components", sprintf( "%s Component\t\nEdit Component\t\nSell Component\t"COL_GOLD"%s", g_vehiclePimpData[ ownerid ] [ vehicleid ] [ E_DISABLED ] [ i ] ? ( "Enable" ) : ( "Disable" ), ConvertPrice( sellPrice ) ), "Select", "Cancel" );
}
#endif

stock incrementPlayerStreak( playerid, streakid ) {

	if ( ++p_streakData[ playerid ] [ streakid ] [ E_STREAK ] > p_streakData[ playerid ] [ streakid ] [ E_BEST_STREAK ] ) {
		p_streakData[ playerid ] [ streakid ] [ E_BEST_STREAK ] = p_streakData[ playerid ] [ streakid ] [ E_STREAK ];

		format( szBigString, 196, "INSERT INTO `STREAKS` (`USER_ID`,`STREAK_ID`,`STREAK`) VALUES(%d,%d,%d) ON DUPLICATE KEY UPDATE `STREAK`=%d;", p_AccountID[ playerid ], streakid, p_streakData[ playerid ] [ streakid ] [ E_BEST_STREAK ], p_streakData[ playerid ] [ streakid ] [ E_BEST_STREAK ] );
		mysql_single_query( szBigString );

		// Notify oneself
		SendServerMessage( playerid, "You are currently on your best "COL_GOLD"%s streak"COL_WHITE" of %d!", g_streaksTypes[ streakid ], p_streakData[ playerid ] [ streakid ] [ E_BEST_STREAK ] );

		// Beep
		Beep( playerid );
	}

	// Notify whole chat
	new
		iModulus = 10;

	if ( p_streakData[ playerid ] [ streakid ] [ E_STREAK ] > 50 )
		iModulus = 1;

	else if ( p_streakData[ playerid ] [ streakid ] [ E_STREAK ] > 20 )
		iModulus = 5;

	if ( p_streakData[ playerid ] [ streakid ] [ E_STREAK ] % iModulus == 0 ) {
		if ( p_streakData[ playerid ] [ streakid ] [ E_STREAK ] == p_streakData[ playerid ] [ streakid ] [ E_BEST_STREAK ] ) {
			SendGlobalMessage( -1, ""COL_GOLD"[STREAK]{FFFFFF} %s(%d) is currently on their best "COL_GOLD"%s streak"COL_WHITE" of %d!", ReturnPlayerName( playerid ), playerid, g_streaksTypes[ streakid ], p_streakData[ playerid ] [ streakid ] [ E_BEST_STREAK ] );
		} else {
			SendGlobalMessage( -1, ""COL_GOLD"[STREAK]{FFFFFF} %s(%d) is currently on a "COL_GOLD"%s streak"COL_WHITE" of %d!", ReturnPlayerName( playerid ), playerid, g_streaksTypes[ streakid ], p_streakData[ playerid ] [ streakid ] [ E_STREAK ] );
		}
	}
}

stock resetPlayerStreaks( playerid ) {

	for( new streakid = 0; streakid < MAX_STREAKS; streakid++ )
		p_streakData[ playerid ] [ streakid ] [ E_STREAK ] = 0;
}

thread OnStreaksLoad( playerid )
{
	if ( !IsPlayerConnected( playerid ) )
		return 0;

	new
		rows, fields, i = -1,
		streakid, streak
	;

	cache_get_data( rows, fields );
	if ( rows ) {
		while( ++i < rows ) {
			// Assign streak
			streakid = cache_get_field_content_int( i, "STREAK_ID", dbHandle );
			streak = cache_get_field_content_int( i, "STREAK", dbHandle );

			// Check if streak is valid and then insert
			if ( streakid < MAX_STREAKS )
				p_streakData[ playerid ] [ streakid ] [ E_BEST_STREAK ] = streak;
		}
	}
	return 1;
}

stock incrementPlayerWeaponKills( playerid, weaponid, increment = 1 )
{
	if ( 0 <= weaponid < MAX_WEAPONS )
	{
		p_WeaponKills[ playerid ] [ weaponid ] += increment;

		format( szBigString, 196, "INSERT INTO `WEAPON_STATS` (`USER_ID`,`WEAPON_ID`,`KILLS`) VALUES(%d,%d,%d) ON DUPLICATE KEY UPDATE `KILLS`=%d;", p_AccountID[ playerid ], weaponid, p_WeaponKills[ playerid ] [ weaponid ], p_WeaponKills[ playerid ] [ weaponid ] );
		mysql_single_query( szBigString );
	}
}

thread OnWeaponStatsLoad( playerid )
{
	if ( !IsPlayerConnected( playerid ) )
		return 0;

	new
		rows, fields, i = -1, weaponid;

	cache_get_data( rows, fields );

	if ( rows ) {
		while( ++i < rows ) {
			// Assign streak
			weaponid = cache_get_field_content_int( i, "WEAPON_ID", dbHandle );

			// Check if streak is valid and then insert
			if ( weaponid < sizeof( p_WeaponKills[ ] ) )
				p_WeaponKills[ playerid ] [ weaponid ] = cache_get_field_content_int( i, "KILLS", dbHandle );
		}
	}
	return 1;
}

stock UpdateGlobalDonated( playerid = INVALID_PLAYER_ID, Float: amount = 0.0, hidden = 0 )
{
	if ( playerid != INVALID_PLAYER_ID && amount > 0.0 ) {
		format( szBigString, sizeof( szBigString ), "INSERT INTO `TOP_DONOR` (`USER_ID`,`AMOUNT`,`LAST_AMOUNT`,`TIME`,`HIDE`) VALUES(%d,%f,%f,%d,%d) ON DUPLICATE KEY UPDATE `AMOUNT`=`AMOUNT`+%f,`LAST_AMOUNT`=%f,`TIME`=%d,`HIDE`=%d;", p_AccountID[ playerid ], amount, amount, g_iTime, hidden, amount, amount, g_iTime, hidden );
		mysql_single_query( szBigString );
	}

	// top donor
	if ( ! hidden ) {
		mysql_function_query( dbHandle, "SELECT `NAME`,`LAST_AMOUNT` FROM `TOP_DONOR` INNER JOIN `USERS` ON `TOP_DONOR`.`USER_ID`=`USERS`.`ID` WHERE `LAST_AMOUNT` > 0 AND `HIDE` < 1 ORDER BY `TIME` DESC LIMIT 1", true, "OnGrabLatestDonor", "" );
	}

	// wall of donors
	mysql_function_query( dbHandle, "SELECT `USERS`.`NAME` FROM `TOP_DONOR` INNER JOIN `USERS` ON `TOP_DONOR`.`USER_ID`=`USERS`.`ID` WHERE `HIDE` < 1 ORDER BY `AMOUNT` DESC, `TIME` DESC", true, "OnUpdateWallOfDonors", "" );
	return 1;
}

thread OnGrabLatestDonor( hidden )
{
	new
		rows;

    cache_get_data( rows, tmpVariable );

	if ( rows )
	{
		static
			szName[ MAX_PLAYER_NAME ],
			Float: fAmount;


		cache_get_field_content( 0, "NAME", szName );
		fAmount = cache_get_field_content_float( 0, "LAST_AMOUNT", dbHandle );

		// Play song!
		GameTextForAll( sprintf( "~y~~h~~h~New Donor!~n~~w~%s", szName ), 6000, 3 );

		// Play sound
		foreach(new p : Player) if ( !IsPlayerUsingRadio( p ) ) {
			PlayAudioStreamForPlayer( p, "http://files.irresistiblegaming.com/game_sounds/donated.mp3" );
		}

		TextDrawSetString( g_TopDonorTD, sprintf( "Le Latest Donor %s - $%0.2f", szName, fAmount ) );
	}
	else
	{
		TextDrawSetString( g_TopDonorTD, "Nobody Donated :(" );
	}
	return 1;
}

thread OnUpdateWallOfDonors( )
{
	new
		rows;

    cache_get_data( rows, tmpVariable );

	if( rows )
	{
		new
			szString[ 600 ],
			iLine = 1,
			iPosition = 0;

		for( new row = 0; row < rows; row++ )
		{
			new
				szName[ MAX_PLAYER_NAME ];

			cache_get_field_content( row, "NAME", szName );

			new
				iOldLength = strlen( szString ) + 4; // 4 is an offset

			if( iOldLength - iPosition > 24 ) {
				iPosition = iOldLength;
				strcat( szString, "\n" ), iLine ++;
			}

			// The wall of donors
			format( szString, sizeof( szString ), "%s%s, ", szString, szName );
		}

		// The wall of donors formatting
		new
			iLength = strlen( szString );

		strdel( szString, iLength - 2, iLength );

		// Develop a size and format
		SetDynamicObjectMaterialText( g_TopDonorWall, 0, szString, 130, "Arial", floatround( 48.0 * floatpower( 0.925, iLine - 1 ), floatround_ceil ), 0, -65536, 0, 1 );
	}
	else
	{
		SetDynamicObjectMaterialText( g_TopDonorWall, 0, "Nobody Donated :(", 130, "Arial", 48, 0, -65536, 0, 1 );
	}
	return 1;
}

stock IsSafeGameText(string[])
{
    new count;
    for(new num, len = strlen(string); num < len; num++)
    {
        if (string[num] == '~')
		{
		    if ((num + 1) < len)
			{
				if (string[(num + 1)] == '~') return false;
			}
			count += 1;
		}
    }
    if ((count % 2) > 0) return false;
    return true;
}

thread OnShowWeaponStats( playerid )
{
	new
		rows;

    cache_get_data( rows, tmpVariable );

	if ( rows )
	{
		szLargeString = ""COL_WHITE"Weapon\t"COL_WHITE"Kills\n";

    	for( new i = 0; i < rows; i++ )
		{
			new
				weaponid = cache_get_field_content_int( i, "WEAPON_ID" ),
				streak = cache_get_field_content_int( i, "KILLS" );

			format( szLargeString, sizeof( szLargeString ), "%s%s\t%d\n", szLargeString, ReturnWeaponName( weaponid ), streak );
		}
		return ShowPlayerDialog( playerid, DIALOG_NULL, DIALOG_STYLE_TABLIST_HEADERS, "{FFFFFF}Weapon Statistics", szLargeString, "Okay", "" );
	}
	else
	{
		return SendError( playerid, "Kill someone with anything to display a statistic!" );
	}
}

thread checkforvipnotes( playerid )
{
	new
	    rows;

    cache_get_data( rows, tmpVariable );

	if ( rows ) {
		SendServerMessage( playerid, "You have currently %d V.I.P note(s) that you can redeem. Use "COL_GREY"/mynotes"COL_WHITE".", rows );
		SendClientMessageToAdmins( -1, ""COL_PINK"[VIP HAS NOTES]"COL_GREY" %s(%d) has logged in with %d pending VIP notes. (/viewnotes)", ReturnPlayerName( playerid ), playerid, rows );
	}
	return 1;
}

stock strreplace(string[], const search[], const replacement[], bool:ignorecase = false, pos = 0, limit = -1, maxlength = sizeof(string)) {
    // No need to do anything if the limit is 0.
    if (limit == 0)
        return 0;

    new
             sublen = strlen(search),
             replen = strlen(replacement),
        bool:packed = ispacked(string),
             maxlen = maxlength,
             len = strlen(string),
             count = 0
    ;


    // "maxlen" holds the max string length (not to be confused with "maxlength", which holds the max. array size).
    // Since packed strings hold 4 characters per array slot, we multiply "maxlen" by 4.
    if (packed)
        maxlen *= 4;

    // If the length of the substring is 0, we have nothing to look for..
    if (!sublen)
        return 0;

    // In this line we both assign the return value from "strfind" to "pos" then check if it's -1.
    while (-1 != (pos = strfind(string, search, ignorecase, pos))) {
        // Delete the string we found
        strdel(string, pos, pos + sublen);

        len -= sublen;

        // If there's anything to put as replacement, insert it. Make sure there's enough room first.
        if (replen && len + replen < maxlen) {
            strins(string, replacement, pos, maxlength);

            pos += replen;
            len += replen;
        }

        // Is there a limit of number of replacements, if so, did we break it?
        if (limit != -1 && ++count >= limit)
            break;
    }

    return count;
}

stock strcpy(dest[], const source[], maxlength=sizeof dest) {
	strcat((dest[0] = EOS, dest), source, maxlength);
}

function ExportVehicle( vehicleid, container )
{
	MoveDynamicObject( g_containerData[ container ] [ E_DOOR ] [ 0 ], g_containerData[ container ] [ E_DOOR1_CORDS ] [ 0 ], g_containerData[ container ] [ E_DOOR1_CORDS ] [ 1 ], g_containerData[ container ] [ E_DOOR1_CORDS ] [ 2 ], ( 0.1 ), 0.0, 0.0, g_containerData[ container ] [ E_OPEN_ANGLE ] [ 0 ] );
	MoveDynamicObject( g_containerData[ container ] [ E_DOOR ] [ 1 ], g_containerData[ container ] [ E_DOOR2_CORDS ] [ 0 ], g_containerData[ container ] [ E_DOOR2_CORDS ] [ 1 ], g_containerData[ container ] [ E_DOOR2_CORDS ] [ 2 ], ( 0.1 ), 0.0, 0.0, g_containerData[ container ] [ E_OPEN_ANGLE ] [ 1 ] );

	g_containerData[ container ] [ E_CLOSED ] = false;

	SetVehicleToRespawn( vehicleid );
}

function ope_Unfreeze( a )
{
	if ( IsPlayerTied( a ) || IsPlayerTazed( a ) )
		return;

	TogglePlayerControllable( a, 1 );
}

stock CreateEntrance( name[ ], Float: X, Float: Y, Float: Z, Float: lX, Float: lY, Float: lZ, interior, world, bool: custom = false, bool: viponly = false, mapicon = -1, savedId = 0 )
{
	new
		ID = Iter_Free(entrances);

	if ( ID != ITER_NONE )
	{
		Iter_Add(entrances, ID);
	    g_entranceData[ ID ] [ E_WORLD ] = world;
	    g_entranceData[ ID ] [ E_INTERIOR ] = interior;
	    g_entranceData[ ID ] [ E_EX ] = X;
	    g_entranceData[ ID ] [ E_EY ] = Y;
	    g_entranceData[ ID ] [ E_EZ ] = Z;
	    g_entranceData[ ID ] [ E_LX ] = lX;
	    g_entranceData[ ID ] [ E_LY ] = lY;
	    g_entranceData[ ID ] [ E_LZ ] = lZ;
	    g_entranceData[ ID ] [ E_SQL_ID ] = savedId;
	    g_entranceData[ ID ] [ E_CUSTOM ] = custom;
	    g_entranceData[ ID ] [ E_VIP ] = viponly;
	    g_entranceData[ ID ] [ E_SAVED ] = savedId != 0;
	    g_entranceData[ ID ] [ E_ENTER ] = CreateDynamicCP( X, Y, Z, 1.5, -1, -1 );
	    g_entranceData[ ID ] [ E_EXIT ] = CreateDynamicCP( lX, lY, lZ, 1.0, world, interior );
		g_entranceData[ ID ] [ E_ENTER_LABEL ] = CreateDynamic3DTextLabel( name, COLOR_GOLD, X, Y, Z, 20.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 1 );
		g_entranceData[ ID ] [ E_EXIT_LABEL ] = CreateDynamic3DTextLabel( "[EXIT]", COLOR_GOLD, lX, lY, lZ, 10.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 1, world, interior );
	   	if ( mapicon != -1 ) CreateDynamicMapIcon( X, Y, Z, mapicon, 0, -1, -1, -1, 750.0 );
	}
	return ID;
}

thread OnEntrancesLoad( )
{
	new
		rows, fields, i = -1, label[ 32 ],
	    loadingTick = GetTickCount( )
	;

	cache_get_data( rows, fields );
	if ( rows )
	{
		while( ++i < rows )
		{
			// Save label
			cache_get_field_content( i, "LABEL", label );

			// Create entrance
			CreateEntrance( label,
				cache_get_field_content_float( i, "X", dbHandle ),
				cache_get_field_content_float( i, "Y", dbHandle ),
				cache_get_field_content_float( i, "Z", dbHandle ),
				cache_get_field_content_float( i, "EX", dbHandle ),
				cache_get_field_content_float( i, "EY", dbHandle ),
				cache_get_field_content_float( i, "EZ", dbHandle ),
				cache_get_field_content_int( i, "INTERIOR", dbHandle ),
				cache_get_field_content_int( i, "WORLD", dbHandle ),
				!!cache_get_field_content_int( i, "CUSTOM", dbHandle ),
				!!cache_get_field_content_int( i, "VIP_ONLY", dbHandle ),
				cache_get_field_content_int( i, "MAP_ICON", dbHandle ),
				.savedId = cache_get_field_content_int( i, "ID", dbHandle )
			);
		}
	}
	printf( "[ENTRANCES]: %d extra entrances have been loaded. (Tick: %dms)", rows, GetTickCount( ) - loadingTick );
	return 1;
}

stock DestroyEntrance( entranceid )
{
	if ( !Iter_Contains( entrances, entranceid ) )
		return;

	Iter_Remove(entrances, entranceid);
	DestroyDynamicCP( g_entranceData[ entranceid ] [ E_ENTER ] );
	DestroyDynamicCP( g_entranceData[ entranceid ] [ E_EXIT ] );
	DestroyDynamic3DTextLabel( g_entranceData[ entranceid ] [ E_ENTER_LABEL ] );
	DestroyDynamic3DTextLabel( g_entranceData[ entranceid ] [ E_EXIT_LABEL ] );
	mysql_single_query( sprintf( "DELETE FROM `ENTRANCES` WHERE `ID`=%d", g_entranceData[ entranceid ] [ E_SQL_ID ] ) );
}

stock GetClosestEntrance( playerid, &Float: distance = FLOAT_INFINITY ) {
    new
    	iCurrent = -1, Float: fTmp;

	foreach(new id : entrances)
	{
        if ( 0.0 < ( fTmp = GetDistanceFromPlayerSquared( playerid, g_entranceData[ id ] [ E_EX ], g_entranceData[ id ] [ E_EY ], g_entranceData[ id ] [ E_EZ ] ) ) < distance ) // Y_Less mentioned there's no need to sqroot
        {
            distance = fTmp;
            iCurrent = id;
        }
    }
    return iCurrent;
}

stock SendClientMessageToAdmins( colour, format[ ], va_args<> ) // Conversion to foreach 14 stuffed the define, not sure how...
{
    static
		out[ 144 ];

    va_format( out, sizeof( out ), format, va_start<2> );

	foreach(new i : Player)
	{
	    if ( p_AdminLevel[ i ] > 0 || IsPlayerUnderCover( i ) )
			SendClientMessage( i, colour, out );
	}
	return 1;
}

stock TextDrawShowForAllSpawned( Text: textdrawid ) {
	foreach(new i : Player) if ( IsPlayerSpawned( i ) ) {
		TextDrawShowForPlayer( i, textdrawid );
	}
}


stock GetClosestRobberyNPC( robberyid, &Float: distance = FLOAT_INFINITY ) {
    new
    	iCurrent = -1, Float: fTmp;

    if ( 0 <= robberyid < MAX_ROBBERIES )
    {
		foreach(new clerkid : RobberyNpc)
		{
	        if ( g_robberyNpcData[ clerkid ] [ E_WORLD ] == g_robberyData[ robberyid ] [ E_WORLD ] )
	        {
	            if ( 0.0 < ( fTmp = GetPlayerDistanceFromPoint( g_robberyNpcData[ clerkid ] [ E_NPC_ID ], g_robberyData[ robberyid ] [ E_DOOR_X ], g_robberyData[ robberyid ] [ E_DOOR_Y ], g_robberyData[ robberyid ] [ E_DOOR_Z ] ) ) < distance )
	            {
	                distance = fTmp;
	                iCurrent = clerkid;
	            }
			}
	    }
    }
    return iCurrent;
}

stock TriggerRobberyForClerks( playerid, robberyid )
{
	new
		clerkid = GetClosestRobberyNPC( robberyid );

	if ( clerkid != -1 )
	{
		new
			npcid = g_robberyNpcData[ clerkid ] [ E_NPC_ID ];

		if ( FCNPC_IsDead( npcid ) || g_robberyNpcData[ clerkid ] [ E_PROVOKED ] || ! g_robberyNpcData[ clerkid ] [ E_LOOT ] )
			return;

		StopPlayerNpcRobbery( playerid );
		FCNPC_ShootAtPlayer( playerid, npcid, .weaponid = 25, .clerkid = clerkid );
		g_robberyNpcData[ clerkid ] [ E_PROVOKED ] = true;
		KillTimer( g_robberyNpcData[ clerkid ] [ E_HOLDUP_TIMER ] ), g_robberyNpcData[ clerkid ] [ E_HOLDUP_TIMER ] = -1;
		TriggerClosestCivilians( playerid, clerkid );
		SendServerMessage( playerid, "You have committed a robbery while the clerk is concious! "COL_ORANGE"The police have been informed." );
	}
}

stock CreateRobberyNPC( name[ ], max_loot, Float: X, Float: Y, Float: Z, Float: rZ, skinid, ... )
{

	static const
		Float: drugDealerPositions[ 5 ] [ 2 ] [ 4 ] =
		{
			// Fiddle
			{
				{ 2182.2810, -1204.4282, 1049.0234, 91.1168 },
				{ 2194.7588, -1201.1827, 1049.0234, 313.135 }
			},

			// Lean
			{
				{ 2194.5054, -1207.9854, 1049.0234, 360.0000 },
				{ 2187.7302, -1206.4150, 1049.0308, 270.0000 }
			},

			// Lay
			{
				{ 2191.0098, -1206.1421, 1049.5361, 41.4342 },
				{ 2195.3901, -1206.0587, 1049.5361, 317.403 }
			},

			// Leaning
			{
				{ 2196.0134, -1218.3213, 1049.0234, 270.0000 },
				{ 2196.0159, -1213.3755, 1049.0234, 270.0000 }
			},

			// Cross arms
			{
				{ 2193.2097, -1219.9078, 1049.0234, 1.4630 },
				{ 2191.6738, -1214.6738, 1049.0234, 270.7185 }
			}
		}
	;

	new
		szBotName[ MAX_PLAYER_NAME ];

	format( szBotName, sizeof( szBotName ), "%s", name );
	strreplacechar( szBotName, ' ', '\0' );
	strreplacechar( szBotName, '/', '\0' );

	for( new i = 7; i < numargs( ); i++ )
    {
		new
			clerkid = Iter_Free(RobberyNpc);

		if ( clerkid != ITER_NONE )
		{
			new
				randomMaxLoot = RandomEx( max_loot - 25, max_loot + 175 ),
				worldid = getarg( i );

			Iter_Add(RobberyNpc, clerkid);

			if ( strlen( worldid != -1 ? sprintf( "[BOT]%s%d", szBotName, clerkid ) : sprintf( "[BOT]%s", szBotName )  ) >= MAX_PLAYER_NAME )
				printf( "Warning: NPC name is too long (%s)", worldid != -1 ? sprintf( "[BOT]%s%d", szBotName, clerkid ) : sprintf( "[BOT]%s", szBotName ) );

			format( g_robberyNpcData[ clerkid ] [ E_NPC_NAME ], MAX_PLAYER_NAME, "%s", name );
			g_robberyNpcData[ clerkid ] [ E_LABEL ] = CreateDynamic3DTextLabel( sprintf( "%s\n"COL_WHITE"Aim To Start Robbery", name ), COLOR_GOLD, X, Y, Z, 25.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, .testlos = 0, .worldid = worldid );
			g_robberyNpcData[ clerkid ] [ E_NPC_ID ] = FCNPC_Create( worldid != -1 ? sprintf( "[BOT]%s%d", szBotName, clerkid ) : sprintf( "[BOT]%s", szBotName ) );
			g_robberyNpcData[ clerkid ] [ E_WORLD ] = worldid == -1 ? 0 : worldid;
			g_robberyNpcData[ clerkid ] [ E_HOLDUP_TIMER ] = -1;
			g_robberyNpcData[ clerkid ] [ E_MAX_LOOT ] = randomMaxLoot;
			g_robberyNpcData[ clerkid ] [ E_LOOT ] = randomMaxLoot;
			g_robberyNpcData[ clerkid ] [ E_SHOOTING_TIMER ] = -1;
			FCNPC_Spawn( g_robberyNpcData[ clerkid ] [ E_NPC_ID ], skinid, X, Y, Z );
			FCNPC_SetAngle( g_robberyNpcData[ clerkid ] [ E_NPC_ID ], ( g_robberyNpcData[ clerkid ] [ E_RZ ] = rZ ) );

			// Create Civilians
			if ( strmatch( name, "Triad Boss" ) )
			{
				CreateCivilianNpc( "Triad", { 117, 118, 121, 122, 123 }, clerkid, "INT_HOUSE", "wash_up", drugDealerPositions[ 0 ], worldid, .interior = 6 );
				CreateCivilianNpc( "Triad", { 117, 118, 121, 122, 123 }, clerkid, "GANGS", "leanIDLE", drugDealerPositions[ 1 ], worldid, .interior = 6 );
				CreateCivilianNpc( "Triad", { 117, 118, 121, 122, 123 }, clerkid, "BEACH", "bather", drugDealerPositions[ 2 ], worldid, .interior = 6 );
				CreateCivilianNpc( "Triad", { 117, 118, 121, 122, 123 }, clerkid, "GANGS", "leanIDLE", drugDealerPositions[ 3 ], worldid, .interior = 6 );
				CreateCivilianNpc( "Triad", { 117, 118, 121, 122, 123 }, clerkid, "COP_AMBIENT", "Coplook_loop", drugDealerPositions[ 4 ], worldid, .interior = 6 );
			}
			else if ( strmatch( name, "Mafia Boss" ) )
			{
				CreateCivilianNpc( "Soldier", { 111, 112, 124, 125, 126, 127 }, clerkid, "INT_HOUSE", "wash_up", drugDealerPositions[ 0 ], worldid, .interior = 6 );
				CreateCivilianNpc( "Soldier", { 111, 112, 124, 125, 126, 127 }, clerkid, "GANGS", "leanIDLE", drugDealerPositions[ 1 ], worldid, .interior = 6 );
				CreateCivilianNpc( "Soldier", { 111, 112, 124, 125, 126, 127 }, clerkid, "BEACH", "bather", drugDealerPositions[ 2 ], worldid, .interior = 6 );
				CreateCivilianNpc( "Soldier", { 111, 112, 124, 125, 126, 127 }, clerkid, "GANGS", "leanIDLE", drugDealerPositions[ 3 ], worldid, .interior = 6 );
				CreateCivilianNpc( "Soldier", { 111, 112, 124, 125, 126, 127 }, clerkid, "COP_AMBIENT", "Coplook_loop", drugDealerPositions[ 4 ], worldid, .interior = 6 );
			}
		}
	}
}

stock ReplenishRobberyNpc( clerkid, bool: fullreplenish = true )
{
	if ( 0 <= clerkid < MAX_ROBBERY_NPCS )
	{
		new
			Float: X, Float: Y, Float: Z,
			npcid = g_robberyNpcData[ clerkid ] [ E_NPC_ID ];

		// Get NPC Pos
		GetPlayerPos( npcid, X, Y, Z );

		// Reset NPC
		if ( FCNPC_IsDead( npcid ) ) {
			FCNPC_Respawn( npcid );
		} else {
			FCNPC_NeutralState( npcid );
			FCNPC_SetAngle( npcid, g_robberyNpcData[ clerkid ] [ E_RZ ] );
		}

		// Make NPC vulernable
		FCNPC_SetInvulnerable( npcid, false );

		// Reset NPC Data
		g_robberyNpcData[ clerkid ] [ E_LOOT ] = 0;
		g_robberyNpcData[ clerkid ] [ E_TIMEOUT ] = 0;
		g_robberyNpcData[ clerkid ] [ E_PROVOKED ] = false;

		KillTimer( g_robberyNpcData[ clerkid ] [ E_HOLDUP_TIMER ] ), g_robberyNpcData[ clerkid ] [ E_HOLDUP_TIMER ] = -1;
		UpdateDynamic3DTextLabelText( g_robberyNpcData[ clerkid ] [ E_LABEL ], COLOR_GOLD, sprintf( "%s\n"COL_WHITE"Aim To Start Robbery", g_robberyNpcData[ clerkid ] [ E_NPC_NAME ] ) );

		// Options
		if ( fullreplenish ) {
			g_robberyNpcData[ clerkid ] [ E_LOOT ] = g_robberyNpcData[ clerkid ] [ E_MAX_LOOT ];
		}
	}
}

stock GetRobberyNpcFromPlayer( playerid )
{
	foreach(new i : RobberyNpc)
		if ( g_robberyNpcData[ i ] [ E_NPC_ID ] == playerid )
			return i;

	return -1;
}

public OnPlayerHoldupStore( playerid, clerkid, step )
{
	if ( !( 0 <= clerkid < MAX_ROBBERY_NPCS )  )
		return 1;

	new
		npcid = g_robberyNpcData[ clerkid ] [ E_NPC_ID ],
		Float: fX, Float: fY, Float: fZ, Float: distance
	;

	GetPlayerPos( npcid, fX, fY, fZ );
	distance = GetDistanceFromPlayerSquared( playerid, fX, fY, fZ );

	if ( ! g_robberyNpcData[ clerkid ] [ E_LOOT ] || !( 0.0 < distance < 625.0 ) || !IsPlayerConnected( playerid ) || ! IsPlayerSpawned( playerid ) || IsPlayerTied( playerid ) || IsPlayerInAnyVehicle( playerid ) || GetPlayerState( playerid ) == PLAYER_STATE_WASTED || IsPlayerAFK( playerid ) || p_Class[ playerid ] == CLASS_POLICE )
		return StopPlayerNpcRobbery( playerid, clerkid );

	// Enough loot? Else finish.
	if ( g_robberyNpcData[ clerkid ] [ E_LOOT ] <= 0 )
		return StopPlayerNpcRobbery( playerid, clerkid );

	if ( step == 0 )
	{
	    new
			szLocation[ MAX_ZONE_NAME ], szCity[ MAX_ZONE_NAME ];

		if ( GetPlayerLocation( playerid, szCity, szLocation ) ) {
			SendClientMessageToCops( -1, ""COL_BLUE"[POLICE RADIO]"COL_WHITE" %s began robbing "COL_GREY"%s"COL_WHITE" near %s in %s.", ReturnPlayerName( playerid ), g_robberyNpcData[ clerkid ] [ E_NPC_NAME ], szLocation, szCity );
		} else {
			SendClientMessageToCops( -1, ""COL_BLUE"[POLICE RADIO]"COL_WHITE" %s began robbing "COL_GREY"%s"COL_WHITE".", ReturnPlayerName( playerid ), g_robberyNpcData[ clerkid ] [ E_NPC_NAME ] );
		}

		CreateCrimeReport( playerid );
		DeletePVar( playerid, "robbedNpc" );
		PlayerTextDrawSetString( playerid, p_RobberyRiskTD[ playerid ], "~g~~h~Clerk is intimidated" );
		UpdateDynamic3DTextLabelText( g_robberyNpcData[ clerkid ] [ E_LABEL ], COLOR_GOLD, sprintf( "%s\n"COL_GREY"Currently Being Robbed", g_robberyNpcData[ clerkid ] [ E_NPC_NAME ] ) );
	}
	else
	{
		new
			targetplayerid = GetPlayerTargetPlayer( playerid );

		// If the player aint aiming at the assistant, whip out a gun
		if ( targetplayerid != npcid || 0 < GetPlayerWeapon( playerid ) < 1 || !( 0.0 < distance < 25.0 ) ) {
			PlayerTextDrawSetString( playerid, p_RobberyRiskTD[ playerid ], "~r~~h~~h~Clerk is getting ideas" );

			// Shoot player
			if ( random( 101 ) < 20 && p_Robberies[ playerid ] > 10 ) {
				g_robberyNpcData[ clerkid ] [ E_PROVOKED ] = true;
				return StopPlayerNpcRobbery( playerid ), FCNPC_ShootAtPlayer( playerid, npcid, .weaponid = 25, .clerkid = clerkid );
			}
		}
		else
		{
			PlayerTextDrawSetString( playerid, p_RobberyRiskTD[ playerid ], "~g~~h~Clerk is intimidated" );
		}

		new
			amount = RandomEx( 7, 10 ) * floatround( floatpower( 2.0, float( step ) - 1.0 ) ),
			robbedNpc = GetPVarInt( playerid, "robbedNpc" ) + amount
		;

		g_robberyNpcData[ clerkid ] [ E_LOOT ] -= amount;

		if ( g_robberyNpcData[ clerkid ] [ E_LOOT ] < 0 )
		{
			new
			    Float: safeDistance = 99999.99,
				robberyid = getClosestRobberySafe( playerid, safeDistance )
			;


			amount += g_robberyNpcData[ clerkid ] [ E_LOOT ];
			robbedNpc = g_robberyNpcData[ clerkid ] [ E_MAX_LOOT ];

			if ( robberyid != INVALID_OBJECT_ID && safeDistance < 100.0 && !g_robberyData[ robberyid ] [ E_STATE ] ) {
				g_robberyData[ robberyid ] [ E_MULTIPLIER ] = 1.1;
				SendServerMessage( playerid, "You have successfully robbed "COL_GOLD"%s"COL_WHITE" from "COL_GREY"%s"COL_WHITE". "COL_GREEN"(+10%s safe loot)", ConvertPrice( robbedNpc ), g_robberyNpcData[ clerkid ] [ E_NPC_NAME ], "%%" );
			} else {
				SendServerMessage( playerid, "You have successfully robbed "COL_GOLD"%s"COL_WHITE" from "COL_GREY"%s"COL_WHITE".", ConvertPrice( robbedNpc ), g_robberyNpcData[ clerkid ] [ E_NPC_NAME ] );
			}
		}

		if ( !( 0 <= amount < 10000 ) )
			return SendError( playerid, "A money exploit occurred. Contact Lorenc ASAP." );

		GivePlayerCash( playerid, amount );
		SetPVarInt( playerid, "robbedNpc", robbedNpc );
		PlayerTextDrawSetString( playerid, p_RobberyAmountTD[ playerid ], sprintf( "Robbed ~g~~h~%s", ConvertPrice( robbedNpc ) ) );
	}

	FCNPC_ApplyAnimation( npcid, "SHOP", "SHP_Rob_GiveCash", 4.1, 0, 1, 1, 1, 0 );
	FCNPC_SetAnimationByName( npcid, "SHOP:SHP_Rob_GiveCash", 4.1, 0, 1, 1, 1, 0 );
	return ( g_robberyNpcData[ clerkid ] [ E_HOLDUP_TIMER ] = SetTimerEx( "OnPlayerHoldupStore", 1000, false, "ddd", playerid, clerkid, step + 1 ) ), 1;
}

stock StopPlayerNpcRobbery( playerid, clerkid = -1, bool: cower = true )
{
	// Reset variables
	DeletePVar( playerid, "robbedNpc" );

	// Hide textdraws
	PlayerTextDrawHide( playerid, p_RobberyRiskTD[ playerid ] );
	PlayerTextDrawHide( playerid, p_RobberyAmountTD[ playerid ] );

	// Reset clerk variables
	if ( clerkid != -1 )
	{
		new
			npcid = g_robberyNpcData[ clerkid ] [ E_NPC_ID ];

		FCNPC_StopAim( npcid );
		FCNPC_SetWeapon( npcid, 0 );
		FCNPC_SetInvulnerable( npcid, true );

		if ( cower ) {
			FCNPC_ApplyAnimation( npcid, "PED", "cower", 3.0, 0, 1, 1, 1, 0 );
			FCNPC_SetAnimationByName( npcid, "PED:cower", 3.0, 0, 1, 1, 1, 0 );
		}

		// Reset loot
		g_robberyNpcData[ clerkid ] [ E_LOOT ] = 0;
		g_robberyNpcData[ clerkid ] [ E_PROVOKED ] = false;
		g_robberyNpcData[ clerkid ] [ E_TIMEOUT ] = g_iTime + 180;
		g_robberyNpcData[ clerkid ] [ E_SHOOTING_TIMER ] = -1;

		// Reset timer
		KillTimer( g_robberyNpcData[ clerkid ] [ E_HOLDUP_TIMER ] ), g_robberyNpcData[ clerkid ] [ E_HOLDUP_TIMER ] = -1;
		UpdateDynamic3DTextLabelText( g_robberyNpcData[ clerkid ] [ E_LABEL ], COLOR_GOLD, sprintf( "%s\n"COL_RED"Unavailable For Robbery", g_robberyNpcData[ clerkid ] [ E_NPC_NAME ] ) );
	}
	return 1;
}

stock FCNPC_ShootAtPlayer( playerid, npcid, weaponid = 25, clerkid = -1 )
{
	// Auto aim on crouch for store clerks
	if ( clerkid != -1 )
	{
		g_robberyNpcData[ clerkid ] [ E_SHOOTING_OFFSET ] = 0.6;
		KillTimer( g_robberyNpcData[ clerkid ] [ E_SHOOTING_TIMER ] );
		g_robberyNpcData[ clerkid ] [ E_SHOOTING_TIMER ] = SetTimerEx( "RobberyNpcShootCheck", 1500, false, "dd", clerkid, playerid );
	}
	else
	{
		// Civilians should have inaccuracy
		FCNPC_SetWeaponAccuracy( npcid, weaponid, 0.5 );
	}

	// Adjust weapon accuracy
	if ( weaponid == 25 )
	{
		FCNPC_SetWeaponReloadTime( npcid, 25, 1800 );
		FCNPC_SetWeaponShootTime( npcid, 25, 1800 );
	}

	FCNPC_ResetAnimation( npcid );
	FCNPC_ClearAnimations( npcid );
	FCNPC_SetWeapon( npcid, weaponid );
	FCNPC_ToggleInfiniteAmmo( npcid, true );
	FCNPC_AimAtPlayer( npcid, playerid, .shoot = true, .shoot_delay = -1, .setangle = true, .offset_x = 0.0, .offset_y = 0.0, .offset_z = 0.6 );
	return 1;
}

function RobberyNpcShootCheck( clerkid, playerid )
{
	new
		npcid = g_robberyNpcData[ clerkid ] [ E_NPC_ID ];

	if ( ! IsPlayerConnected( playerid ) || ! IsPlayerSpawned( playerid ) || FCNPC_IsDead( npcid ) ) {
		return StopPlayerNpcRobbery( playerid, clerkid, .cower = true );
	}

	new
		specialAnimation = GetPlayerSpecialAction( playerid );

	if ( specialAnimation == SPECIAL_ACTION_DUCK && g_robberyNpcData[ clerkid ] [ E_SHOOTING_OFFSET ] != 0.1 ) {
		g_robberyNpcData[ clerkid ] [ E_SHOOTING_OFFSET ] = 0.1;
		FCNPC_AimAtPlayer( npcid, playerid, .shoot = true, .shoot_delay = -1, .setangle = true, .offset_x = 0.0, .offset_y = 0.0, .offset_z = 0.1 );
	} else if ( specialAnimation != SPECIAL_ACTION_DUCK && g_robberyNpcData[ clerkid ] [ E_SHOOTING_OFFSET ] != 0.6 ) {
		g_robberyNpcData[ clerkid ] [ E_SHOOTING_OFFSET ] = 0.6;
		FCNPC_AimAtPlayer( npcid, playerid, .shoot = true, .shoot_delay = -1, .setangle = true, .offset_x = 0.0, .offset_y = 0.0, .offset_z = 0.6 );
	}

	return ( g_robberyNpcData[ clerkid ] [ E_SHOOTING_TIMER ] = SetTimerEx( "RobberyNpcShootCheck", 1500, false, "dd", clerkid, playerid ) ), 1;
}

public FCNPC_OnDeath(npcid, killerid, weaponid)
{
	if ( !IsPlayerConnected( killerid ) )
		return 1;

	new
		clerkid = GetRobberyNpcFromPlayer( npcid )
	;

	if ( 0 <= clerkid < MAX_ROBBERY_NPCS )
	{
		StopPlayerNpcRobbery( killerid, clerkid, .cower = false );

		if ( g_robberyNpcData[ clerkid ] [ E_PROVOKED ] )
			return 1;

	    new
			szLocation[ MAX_ZONE_NAME ], szCity[ MAX_ZONE_NAME ];

		if ( GetPlayerLocation( killerid, szCity, szLocation ) )
			SendClientMessageToCops( -1, ""COL_BLUE"[POLICE RADIO]"COL_WHITE" %s has murdered "COL_GREY"%s"COL_WHITE" near %s in %s.", ReturnPlayerName( killerid ), g_robberyNpcData[ clerkid ] [ E_NPC_NAME ], szLocation, szCity );
		else
			SendClientMessageToCops( -1, ""COL_BLUE"[POLICE RADIO]"COL_WHITE" %s has murdered "COL_GREY"%s"COL_WHITE".", ReturnPlayerName( killerid ), g_robberyNpcData[ clerkid ] [ E_NPC_NAME ] );

		CreateCrimeReport( killerid );
		GivePlayerWantedLevel( killerid, 6 );
		SendServerMessage( killerid, "You have killed the clerk! "COL_RED"The cops have been informed." );
	}
	return 1;
}

public FCNPC_OnSpawn( npcid )
{
	new
		clerkid = GetRobberyNpcFromPlayer( npcid );

	if ( 0 <= clerkid < MAX_ROBBERY_NPCS )
	{
		FCNPC_ApplyAnimation( npcid, "SHOP", "null", 0.0, 0, 0, 0, 0, 0 );
		FCNPC_ApplyAnimation( npcid, "PED", "null", 0.0, 0, 0, 0, 0, 0 );
		FCNPC_SetVirtualWorld( g_robberyNpcData[ clerkid ] [ E_NPC_ID ], g_robberyNpcData[ clerkid ] [ E_WORLD ] );
	}
	else
	{
		new
			civilianid = GetCivilianNpcFromPlayer( npcid );

		if ( 0 <= civilianid < MAX_CIVILIANS )
		{
			FCNPC_SetVirtualWorld( npcid, g_civilianNpcData[ civilianid ] [ E_WORLD ] );
			FCNPC_SetInterior( npcid, g_civilianNpcData[ civilianid ] [ E_INTERIOR ] );

			// animations
			FCNPC_ApplyAnimation( npcid, g_civilianNpcData[ civilianid ] [ E_ANIM_LIB ], "null", 0.0, 0, 0, 0, 0, 0 );
			FCNPC_ApplyAnimation( npcid, g_civilianNpcData[ civilianid ] [ E_ANIM_LIB ], g_civilianNpcData[ civilianid ] [ E_ANIM_NAME ], 3.0, 1, 1, 1, 1, 0 );
			FCNPC_SetAnimationByName( npcid, sprintf( "%s:%s", g_civilianNpcData[ civilianid ] [ E_ANIM_LIB ], g_civilianNpcData[ civilianid ] [ E_ANIM_NAME ] ), 3.0, 1, 1, 1, 1, 0 );
		}
	}
	return 1;
}

public FCNPC_OnTakeDamage(npcid, damagerid, weaponid, bodypart, Float:health_loss)
{
	new
		clerkid = GetRobberyNpcFromPlayer( npcid );

	if ( 0 <= clerkid < MAX_ROBBERY_NPCS && 0 <= damagerid < MAX_PLAYERS && p_Class[ damagerid ] == CLASS_POLICE ) {
		return 0; // Cant damage bots.
	}
	return 1;
}

stock CreateCivilianNpc( name[ ], skinId[ ], clerkId, animlib[ 16 ], animname[ 16 ], const Float: position[ ] [ 4 ], worldid, interior, bool: hostile = true, numSkins = sizeof( skinId ), numPositions = sizeof( position ) )
{
	new
		szBotName[ MAX_PLAYER_NAME ];

	format( szBotName, sizeof( szBotName ), "%s", name );
	strreplacechar( szBotName, ' ', '\0' );
	strreplacechar( szBotName, '/', '\0' );

	new
		civilianid = Iter_Free(CivilianNpc);

	if ( civilianid != ITER_NONE )
	{
		new
			randomSkin = random( numSkins ), randomSpawn = random( numPositions );

		Iter_Add(CivilianNpc, civilianid);

		format( g_civilianNpcData[ civilianid ] [ E_ANIM_LIB ], 16, "%s", animlib );
		format( g_civilianNpcData[ civilianid ] [ E_ANIM_NAME ], 16, "%s", animname );
		format( g_civilianNpcData[ civilianid ] [ E_NPC_NAME ], MAX_PLAYER_NAME, "%s", name );
		CreateDynamic3DTextLabel( sprintf( "%s", name ), 0xFFFFFF25, position[ randomSpawn ] [ 0 ], position[ randomSpawn ] [ 1 ], position[ randomSpawn ] [ 2 ], 25.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, .testlos = 0, .worldid = worldid );
		g_civilianNpcData[ civilianid ] [ E_NPC_ID ] = FCNPC_Create( worldid != -1 ? sprintf( "[BOT]%s%d", szBotName, civilianid ) : sprintf( "[BOT]%s", szBotName ) );
		g_civilianNpcData[ civilianid ] [ E_WORLD ] = worldid == -1 ? 0 : worldid;
		g_civilianNpcData[ civilianid ] [ E_INTERIOR ] = interior == -1 ? 0 : interior;
		g_civilianNpcData[ civilianid ] [ E_CLERK_ID ] = clerkId;
		g_civilianNpcData[ civilianid ] [ E_HOSTILE ] = hostile;
		FCNPC_Spawn( g_civilianNpcData[ civilianid ] [ E_NPC_ID ], skinId[ randomSkin ], position[ randomSpawn ] [ 0 ], position[ randomSpawn ] [ 1 ], position[ randomSpawn ] [ 2 ] );
		FCNPC_SetAngle( g_civilianNpcData[ civilianid ] [ E_NPC_ID ], ( g_civilianNpcData[ civilianid ] [ E_RZ ] = position[ randomSpawn ] [ 3 ] ) );
	}
}

stock GetCivilianNpcFromPlayer( playerid )
{
	foreach(new i : CivilianNpc)
		if ( g_civilianNpcData[ i ] [ E_NPC_ID ] == playerid )
			return i;

	return -1;
}

stock TriggerClosestCivilians( playerid, clerkid = -1, Float: radius = 25.0, &Float: distance = FLOAT_INFINITY )
{
    if ( ! IsPlayerConnected( playerid ) )
    	return;

    new
    	Float: X, Float: Y, Float: Z,
    	worldid = GetPlayerVirtualWorld( playerid )
    ;

    GetPlayerPos( playerid, X, Y, Z );

	foreach(new civilianid : CivilianNpc) if ( ! g_civilianNpcData[ civilianid ] [ E_PROVOKED ] && g_civilianNpcData[ civilianid ] [ E_WORLD ] == worldid )
	{
		if ( GetPlayerDistanceFromPoint( g_civilianNpcData[ civilianid ] [ E_NPC_ID ], X, Y, Z ) < radius )
		{
			if ( g_civilianNpcData[ civilianid ] [ E_HOSTILE ] )
			{
				new
					closestid = GetClosestPlayer( g_civilianNpcData[ civilianid ] [ E_NPC_ID ] );

				g_civilianNpcData[ civilianid ] [ E_PROVOKED ] = true;
				FCNPC_ShootAtPlayer( closestid, g_civilianNpcData[ civilianid ] [ E_NPC_ID ], randarg( 28, 30, 25 ) );
			}
		}
    }

    // Trigger the robbery NPC TOO!
	if ( clerkid != -1 && g_robberyNpcData[ clerkid ] [ E_HOLDUP_TIMER ] == -1 && g_iTime > g_robberyNpcData[ clerkid ] [ E_TIMEOUT ] )
	{
		g_robberyNpcData[ clerkid ] [ E_PROVOKED ] = true;
		FCNPC_ShootAtPlayer( playerid, g_robberyNpcData[ clerkid ] [ E_NPC_ID ], randarg( 28, 30, 25 ), clerkid );
		StopPlayerNpcRobbery( playerid );
	}
}

stock FCNPC_NeutralState( npcid )
{
	FCNPC_StopAim( npcid );
	FCNPC_ResetAnimation( npcid );
	FCNPC_ClearAnimations( npcid );
	FCNPC_SetWeapon( npcid, 0 );
}

///////
stock CreateCrimeReport( playerid )
{
	if ( !( 0 <= playerid < MAX_PLAYERS ) )
		return;

	if ( p_Job{ playerid } == JOB_BURGLAR )
		return;

	new
		iCrimeReport 		= Iter_Free(InformedRobbery);

	if ( iCrimeReport != ITER_NONE )
	{
		new
			Float: X, Float: Y, Float: Z,
			iEntrance 			= p_LastEnteredEntrance[ playerid ],
			iHouse 				= p_InHouse[ playerid ],
			iGarage 			= p_InGarage[ playerid ]
		;

		// Add iterator
	  	Iter_Add( InformedRobbery, iCrimeReport );

	  	// Find user location
		if ( GetPlayerInterior( playerid ) != 0 )
		{
		    if ( iEntrance != -1 )
		  		X = g_entranceData[ iEntrance ] [ E_EX ], Y = g_entranceData[ iEntrance ] [ E_EY ], Z = g_entranceData[ iEntrance ] [ E_EZ ];

		  	else if ( iGarage != -1 )
		  		X = g_garageData[ iGarage ] [ E_X ], Y = g_garageData[ iGarage ] [ E_Y ], Z = g_garageData[ iGarage ] [ E_Z ];

		  	else if ( iHouse != -1 )
		  		X = g_houseData[ iHouse ] [ E_EX ], Y = g_houseData[ iHouse ] [ E_EY ], Z = g_houseData[ iHouse ] [ E_EZ ];

	  		else GetPlayerPos( playerid, X, Y, Z );
		}
	  	else GetPlayerPos( playerid, X, Y, Z );

	  	// Create marker
	  	g_informedRobberies[ iCrimeReport ] [ E_ALPHA ] = 0xFF;
	  	g_informedRobberies[ iCrimeReport ] [ E_MAP_ICON ] = CreateDynamicMapIcon( X, Y, Z, 0, COLOR_RED, -1, -1, 0, 1000.0, MAPICON_GLOBAL );

	  	// Reset Players In Map Icon
	  	Streamer_RemoveArrayData( STREAMER_TYPE_MAP_ICON, g_informedRobberies[ iCrimeReport ] [ E_MAP_ICON ], E_STREAMER_PLAYER_ID, 0 );

	  	// Show For All Cops
	  	foreach (new i : Player) if ( p_Class[ i ] == CLASS_POLICE ) {
	  		Streamer_AppendArrayData( STREAMER_TYPE_MAP_ICON, g_informedRobberies[ iCrimeReport ] [ E_MAP_ICON ], E_STREAMER_PLAYER_ID, i );
	  	}
	}
}

stock CreateAmmunationLocker( Float: X, Float: Y, Float: Z, Float: rX )
{
	new
		lockerid = Iter_Free(WeaponLockers);

	if ( lockerid !=ITER_NONE )
	{
		Iter_Add( WeaponLockers, lockerid );

		new
			Float: nX = X + 1.5 * -floatsin( -rX, degrees ),
			Float: nY = Y + 1.5 * -floatcos( -rX, degrees )
		;

		g_weaponLockerCheckpoint[ lockerid ] = CreateDynamicCP( nX, nY, Z, 2.0 , -1, -1, -1, 100.0 );
		CreateDynamicObject( 14782, X, Y, Z, 0.0, 0.0, rX, -1, -1, -1, 100.0 );
		CreateDynamic3DTextLabel( "[WEAPON LOCKER]", COLOR_GOLD, nX, nY, Z, 20.0 );
	}
	return lockerid;
}

stock SecurityModeToString( modeid )
{
	static
		szMode[ 9 ];

	switch ( modeid )
	{
		case 0: szMode = "Mild";
		case 1: szMode = "Paranoid";
		case 2: szMode = "Disabled";
		default: szMode = "n/a";
	}
	return szMode;
}

stock ShowPlayerAccountGuard( playerid )
{
	if ( p_accountSecurityData[ playerid ] [ E_ID ] != 0 ) {
		if ( p_accountSecurityData[ playerid ] [ E_LAST_DISABLED ] && p_accountSecurityData[ playerid ] [ E_LAST_DISABLED ] < g_iTime ) {
			format( szBigString, sizeof( szBigString ), ""COL_WHITE"Your account email is "COL_GREEN"confirmed\t \nConfirm Email\t"COL_GREEN"%s\nSecurity Mode\t%s\n"COL_RED"Remove Irresistible Guard\t"COL_GREEN"Ready", CensoreString( p_accountSecurityData[ playerid ] [ E_EMAIL ] ), SecurityModeToString( p_accountSecurityData[ playerid ] [ E_MODE ] ) );
		} else if ( p_accountSecurityData[ playerid ] [ E_LAST_DISABLED ] ) {
			format( szBigString, sizeof( szBigString ), ""COL_WHITE"Your account email is "COL_GREEN"confirmed\t \nConfirm Email\t"COL_GREEN"%s\nSecurity Mode\t%s\n"COL_ORANGE"Stop Pending Removal\t"COL_ORANGE"%s", CensoreString( p_accountSecurityData[ playerid ] [ E_EMAIL ] ), SecurityModeToString( p_accountSecurityData[ playerid ] [ E_MODE ] ), secondstotime( p_accountSecurityData[ playerid ] [ E_LAST_DISABLED ] - g_iTime ) );
		} else {
			format( szBigString, sizeof( szBigString ), ""COL_WHITE"Your account email is "COL_GREEN"confirmed\t \nConfirm Email\t"COL_GREEN"%s\nSecurity Mode\t%s\n"COL_RED"Remove Irresistible Guard\t"COL_RED"approx. 24h", CensoreString( p_accountSecurityData[ playerid ] [ E_EMAIL ] ), SecurityModeToString( p_accountSecurityData[ playerid ] [ E_MODE ] ) );
		}
	} else {
		szBigString = ""COL_WHITE"Your account email is "COL_RED"unconfirmed\t \nConfirm Email\t"COL_GREY">>>";
	}
	return ShowPlayerDialog( playerid, DIALOG_ACC_GUARD, DIALOG_STYLE_TABLIST_HEADERS, "{FFFFFF}Irresistible Guard", szBigString, "Select", "Close" );
}

thread OnQueueEmailVerification( playerid, email[ ] )
{
	new
		verification_id = cache_insert_id( );

	// alert
	SendServerMessage( playerid, "An email as been sent to "COL_GREY"%s"COL_WHITE" with instructions to confirm your account.", email );

	// sending an email
	format( szLargeString, sizeof( szLargeString ), "<p>Hello %s, you are receiving this email because you want to add Irresistible Guard to your account.</p><p><a href='http://" # MAILING_URL "/email/verify/%d/%d'>Click here to verify your email</a></p>", ReturnPlayerName( playerid ), p_AccountID[ playerid ], verification_id );
	SendMail( email, ReturnPlayerName( playerid ), sprintf( "Verify your account, %s", ReturnPlayerName( playerid ) ), szLargeString );
	return 1;
}

CMD:verify( playerid, params[ ] )
{
	if ( ! p_accountSecurityData[ playerid ] [ E_ID ] )
		return SendError( playerid, "You do not have an email assigned to your account." );

	if ( p_accountSecurityData[ playerid ] [ E_VERIFIED ] )
		return SendError( playerid, "You are already verified." );

	if ( p_accountSecurityData[ playerid ] [ E_MODE ] == SECURITY_MODE_DISABLED )
		return SendError( playerid, "Your security mode is set to disabled." );

	format( szBigString, 196, "SELECT `CONFIRMED`,UNIX_TIMESTAMP(`DATE`) as `DATE` FROM `USER_CONFIRMED_IPS` WHERE `USER_ID`=%d AND `IP`='%s'", p_AccountID[ playerid ], mysql_escape( ReturnPlayerIP( playerid ) ) );
	mysql_function_query( dbHandle, szBigString, true, "OnAccountEmailVerify", "dd", playerid, 0 );
	return 1;
}

thread OnAccountGuardVerify( playerid )
{
	new
	    rows, fields;

    cache_get_data( rows, fields );

	if ( rows )
	{
		new
			userConfirmedIpId = cache_get_field_content_int( 0, "ID", dbHandle );

		p_accountSecurityData[ playerid ] [ E_VERIFIED ] = true;
		mysql_single_query( sprintf( "UPDATE `USER_CONFIRMED_IPS` SET `CONFIRMED`=1 WHERE `ID`=%d", userConfirmedIpId ) );

		// alert
		SendServerMessage( playerid, "You have confirmed your IP address. Thank you!" );
	}
	else
	{
		SendError( playerid, "Incorrect verification code has been specified. Please try again." );
		ShowPlayerAccountVerification( playerid );
	}
	return 1;
}

thread OnAccountEmailVerify( playerid, login_force )
{
	new
	    rows, fields, timestamp;

    cache_get_data( rows, fields );

	if ( rows )
	{
		new
			confirmed = cache_get_field_content_int( 0, "CONFIRMED", dbHandle );

		if ( confirmed )
		{
			// verify
	    	p_accountSecurityData[ playerid ] [ E_VERIFIED ] = true;

			// alert
			return SendServerMessage( playerid, "This account is protected by Irresistible Guard. "COL_GREEN"The IP you are playing with has been already verified." ), 1;
		}

		// assign last time
		timestamp = cache_get_field_content_int( 0, "DATE", dbHandle );
	}

	// No point forcing a mild mode user to validate
	if ( login_force && p_accountSecurityData[ playerid ] [ E_MODE ] == SECURITY_MODE_MILD )
		return SendError( playerid, "This account is protected by Irresistible Guard. "COL_RED"Please verify your IP through your email to transact in-game." );

	if ( g_iTime - timestamp >= 300 )
	{
		new
			iRandom = RandomEx( 10000000, 99999999 );

		// insert into database
		format( szBigString, sizeof( szBigString ), "INSERT INTO `USER_CONFIRMED_IPS`(`USER_ID`,`IP`,`TOKEN`,`CONFIRMED`) VALUES (%d,'%s','%d',0) ON DUPLICATE KEY UPDATE `TOKEN`='%d',`DATE`=CURRENT_TIMESTAMP", p_AccountID[ playerid ], ReturnPlayerIP( playerid ), iRandom, iRandom );
		mysql_single_query( szBigString );

		// email
		format( szLargeString, sizeof( szLargeString ), "<p>Hey %s, you are receiving this email because an unauthorized IP is accessing your account.</p>"\
														"<p>IP: %s<br>Country: %s (may be inaccurate)</p>"\
														"<p>Your verification token is <strong>%d</strong> - keep this only to yourself!</p>"\
														"<p style='color: red'>If you did not authorize this, change your password in-game or contact an administrator!</p>",
														ReturnPlayerName( playerid ), ReturnPlayerIP( playerid ), GetPlayerCountryName( playerid ), iRandom );

		SendMail( p_accountSecurityData[ playerid ] [ E_EMAIL ], ReturnPlayerName( playerid ), sprintf( "Someones accessing your account, %s", ReturnPlayerName( playerid ) ), szLargeString );
	}
	else
	{
		SendServerMessage( playerid, "Please check your email for another token. A new code can be generated in %s.", secondstotime( 300 - ( g_iTime - timestamp ) ) );
	}

	// force verification
	ShowPlayerAccountVerification( playerid );

	// alert
	if ( p_accountSecurityData[ playerid ] [ E_MODE ] == SECURITY_MODE_PARANOID ) {
		SendError( playerid, "This account is protected by Irresistible Guard. "COL_RED"Please verify your IP through your email to play." );
	} else if ( p_accountSecurityData[ playerid ] [ E_MODE ] == SECURITY_MODE_MILD ) {
		SendError( playerid, "This account is protected by Irresistible Guard. "COL_RED"Please verify your IP through your email to transact in-game." );
	}
	return 1;
}

stock ShowPlayerAccountVerification( playerid )
{
	if ( p_accountSecurityData[ playerid ] [ E_MODE ] == 1 ) {
		return ShowPlayerDialog( playerid, DIALOG_ACC_GUARD_CONFIRM, DIALOG_STYLE_INPUT, "{FFFFFF}Irresistible Guard", ""COL_WHITE"Please type the verification token that has been emailed to you.", "Confirm", "Quit" ), 1;
	} else {
		return ShowPlayerDialog( playerid, DIALOG_ACC_GUARD_CONFIRM, DIALOG_STYLE_INPUT, "{FFFFFF}Irresistible Guard", ""COL_WHITE"Please type the verification token that has been emailed to you.", "Confirm", "Close" ), 1;
	}
}

thread OnEmailLoad( playerid )
{
	new
	    rows, fields;

    cache_get_data( rows, fields );

    if ( rows )
    {
    	p_accountSecurityData[ playerid ] [ E_VERIFIED ] = false;
    	p_accountSecurityData[ playerid ] [ E_ID ] = cache_get_field_content_int( 0, "ID", dbHandle );
    	p_accountSecurityData[ playerid ] [ E_MODE ] = cache_get_field_content_int( 0, "MODE", dbHandle );
    	p_accountSecurityData[ playerid ] [ E_LAST_DISABLED ] = cache_get_field_content_int( 0, "LAST_DISABLED", dbHandle );
    	cache_get_field_content( 0, "EMAIL", p_accountSecurityData[ playerid ] [ E_EMAIL ], dbHandle, 64 );

    	// IP Check
		format( szBigString, 196, "SELECT `CONFIRMED`,UNIX_TIMESTAMP(`DATE`) as `DATE` FROM `USER_CONFIRMED_IPS` WHERE `USER_ID`=%d AND `IP`='%s'", p_AccountID[ playerid ], mysql_escape( ReturnPlayerIP( playerid ) ) );
		mysql_function_query( dbHandle, szBigString, true, "OnAccountEmailVerify", "dd", playerid, 1 );
    }
}

thread OnEmailConfirm( playerid )
{
	new
	    rows, fields;

    cache_get_data( rows, fields );

    if ( rows )
    {
    	// fill data
    	p_accountSecurityData[ playerid ] [ E_VERIFIED ] = true;
    	p_accountSecurityData[ playerid ] [ E_LAST_DISABLED ] = 0;
    	p_accountSecurityData[ playerid ] [ E_ID ] = cache_get_field_content_int( 0, "ID", dbHandle );
    	p_accountSecurityData[ playerid ] [ E_MODE ] = cache_get_field_content_int( 0, "MODE", dbHandle );
    	cache_get_field_content( 0, "EMAIL", p_accountSecurityData[ playerid ] [ E_EMAIL ], dbHandle, 64 );

    	// log ip and alert
    	format( szNormalString, sizeof( szNormalString ), "INSERT INTO `USER_CONFIRMED_IPS`(`USER_ID`,`IP`,`CONFIRMED`) VALUES (%d,'%s',1)", p_AccountID[ playerid ], ReturnPlayerIP( playerid ) );
    	mysql_single_query( szNormalString );

    	// alert
    	SendServerMessage( playerid, "Your email has been confirmed, %s.", ReturnPlayerName( playerid ) );
    }
    else
    {
		format( szNormalString, sizeof( szNormalString ), "SELECT `EMAIL`,UNIX_TIMESTAMP(`DATE`) as `DATE` FROM `EMAIL_VERIFY` WHERE `USER_ID`=%d", p_AccountID[ playerid ] );
		mysql_function_query( dbHandle, szNormalString, true, "OnEmailVerifying", "d", playerid );
    }
	return 1;
}

thread OnEmailVerifying( playerid )
{
	new
		rows, fields, email[ 64 ];

	cache_get_data( rows, fields );

	if ( rows )
	{
		new
			timestamp = cache_get_field_content_int( 0, "DATE", dbHandle );

		if ( g_iTime - timestamp < 300 )
		{
			cache_get_field_content( 0, "EMAIL", email );
			return SendError( playerid, "An email has been sent to "COL_GREY"%s"COL_WHITE", please verify it within %s.", email, secondstotime( 300 - ( g_iTime - timestamp ) ) ), 1;
		}
	}

	return ShowPlayerDialog( playerid, DIALOG_ACC_GUARD_EMAIL, DIALOG_STYLE_INPUT, "{FFFFFF}Irresistible Guard", ""COL_WHITE"Please type your email below. Your email may be used also to promote in-game and/or community associated events.\n\n"COL_ORANGE"This feature can only be used once every 5 minutes.", "Select", "Cancel" ), 1;
}

thread OnAccountGuardDelete( playerid )
{

	new
		rows, fields;

	cache_get_data( rows, fields );

	if ( !rows ) SendError( playerid, "It appears there is no email associated to your account." );
	else
	{
		new
			id = cache_get_field_content_int( 0, "ID", dbHandle ),
			last_disabled = cache_get_field_content_int( 0, "LAST_DISABLED", dbHandle ),
			last_changed = cache_get_field_content_int( 0, "LAST_CHANGED", dbHandle )
		;

		if ( id != p_accountSecurityData[ playerid ] [ E_ID ] )
			return SendError( playerid, "Something is wrong with your email. Talk to Lorenc." ), 1;

		if ( g_iTime - last_changed < 300 ) {
			return SendError( playerid, "You can use this feature in %s.", secondstotime( 300 - ( g_iTime - last_changed ) ) );
		}

		if ( ! last_disabled )
		{
			// first time disabling
			SendServerMessage( playerid, "You are now beginning to remove the email from your account. This will take 24 hours." );
			mysql_single_query( sprintf( "UPDATE `EMAILS` SET `LAST_DISABLED`=%d WHERE `ID`=%d", g_iTime + 86400, id ) );

			// email
			format( szLargeString, sizeof( szLargeString ), "<p>Hey %s, you are receiving this email because you are removing your Irresistible Guard.</p>"\
															"<p>IP: %s<br>Country: %s</p>"\
															"<p style='color: red'>If you did not authorize this, change your password in-game or contact an administrator!</p>",
															ReturnPlayerName( playerid ), ReturnPlayerIP( playerid ), GetPlayerCountryName( playerid ) );

			SendMail( p_accountSecurityData[ playerid ] [ E_EMAIL ], ReturnPlayerName( playerid ), sprintf( "You are removing Irresistible Guard, %s", ReturnPlayerName( playerid ) ), szLargeString );

			// update variables
			p_accountSecurityData[ playerid ] [ E_LAST_DISABLED ] = g_iTime + 86400;
		}
		else if ( g_iTime > last_disabled )
		{
			// under process of disabling
			mysql_single_query( sprintf( "DELETE FROM `EMAILS` WHERE `USER_ID`=%d", p_AccountID[ playerid ] ) );
			mysql_single_query( sprintf( "DELETE FROM `EMAIL_VERIFY` WHERE `USER_ID`=%d", p_AccountID[ playerid ] ) );
			mysql_single_query( sprintf( "DELETE FROM `USER_CONFIRMED_IPS` WHERE `USER_ID`=%d", p_AccountID[ playerid ] ) );

			// email
			format( szLargeString, sizeof( szLargeString ), "<p>Hey %s, you are receiving this email because Irresistible Guard is removed from your account.</p>"\
															"<p>IP: %s<br>Country: %s</p>"\
															"<p style='color: red'>If you did not authorize this, change your password in-game or contact an administrator!</p>",
															ReturnPlayerName( playerid ), ReturnPlayerIP( playerid ), GetPlayerCountryName( playerid ) );

			SendMail( p_accountSecurityData[ playerid ] [ E_EMAIL ], ReturnPlayerName( playerid ), sprintf( "Irresistible Guard is removed, %s", ReturnPlayerName( playerid ) ), szLargeString );

			// reset variables
			p_accountSecurityData[ playerid ] [ E_VERIFIED ] = false;
			p_accountSecurityData[ playerid ] [ E_ID ] = 0;
			p_accountSecurityData[ playerid ] [ E_LAST_DISABLED ] = 0;

			// alert
			SendServerMessage( playerid, "You have successfully removed Irresistible Guard from your account." );
		}
		else
		{
			// update last disabled anyway
			p_accountSecurityData[ playerid ] [ E_LAST_DISABLED ] = last_disabled;

			// show dialog
			format( szNormalString, sizeof( szNormalString ), ""COL_WHITE"You must wait another %s until you can remove your email.\n\nDo you wish to stop this process?", secondstotime( last_disabled - g_iTime ) );
			ShowPlayerDialog( playerid, DIALOG_ACC_GUARD_DEL_CANCEL, DIALOG_STYLE_MSGBOX, "{FFFFFF}Irresistible Guard - Stop Deletion", szNormalString, "Yes", "No" );
		}
	}
	return 1;
}

/**
 * Read all incoming UDP data from discord users that fire commands
 * @return true
 */

#if ENABLE_DISCORD == true
public DCC_OnChannelMessage( DCC_Channel: channel, DCC_User: author, const message[ ] )
{
	// ignore outside of #sfcnr and #admin
	if ( channel != discordGeneralChan && channel != discordAdminChan )
		return 1;

	// process commands
	if ( message[ 0 ] == '!' )
	{
		new
			functiona[ 32 ], posi = 0;

		while ( message[ ++posi ] > ' ' ) {
			functiona[ posi - 1 ] = tolower( message[ posi ] );
		}

		format( functiona, sizeof( functiona ), "discord_%s", functiona );

		while ( message[ posi ] == ' ' ) {
			posi++;
		}

		if ( ! message[ posi ] ) {
			CallLocalFunction( functiona, "dds", _: channel, _: author, "\1" );
		} else {
			CallLocalFunction( functiona, "dds", _: channel, _: author, message[ posi ] );
		}
	}
	return 1;
}

stock ReturnDiscordName( DCC_User: user ) {
	static
		name[ 32 ];

	DCC_GetUserName( user, name, sizeof( name ) );
	return name;
}

/**
 * Sends a message to a channel
 * @return true
*/

stock discordLevelToString( DCC_User: user )
{
	static
		szRank[ 12 ], bool: hasExecutive, bool: hasHead, bool: hasLead, bool: hasVIP;

	DCC_HasGuildMemberRole( discordGuild, user, discordRoleExecutive, hasExecutive );
	DCC_HasGuildMemberRole( discordGuild, user, discordRoleHead, hasHead );
	DCC_HasGuildMemberRole( discordGuild, user, discordRoleLead, hasLead );
	DCC_HasGuildMemberRole( discordGuild, user, discordRoleVIP, hasVIP );

	if ( hasExecutive ) szRank = "Executive";
	else if ( hasHead ) szRank = "Head Admin";
	else if ( hasLead ) szRank = "Lead Admin";
	else if ( hasVIP ) szRank = "VIP";
	else szRank = "Voice";

    return szRank;
}
#endif

stock CreateRouletteTable( Float: X, Float: Y, Float: Z, Float: Angle )
{
	new
		id = Iter_Free(roulettetables);

	if ( id != ITER_NONE )
	{
		g_rouletteTableData[ id ] [ E_X ] = X;
		g_rouletteTableData[ id ] [ E_Y ] = Y;
		g_rouletteTableData[ id ] [ E_Z ] = Z;
		g_rouletteTableData[ id ] [ E_ROTATION ] = Angle;

		g_rouletteTableData[ id ] [ E_SPINNING_TIMER ] = -1;

		g_rouletteTableData[ id ] [ E_OBJECT ] = CreateDynamicObject( 1978, X, Y, Z, 0.00000, 0.00000, Angle );

		X += 1.365 * floatcos( Angle + 98.0, degrees );
		Y += 1.365 * floatsin( Angle + 98.0, degrees );

		CreateDynamic3DTextLabel( "Press ENTER to use\n"COL_WHITE"$1,000 Minimum", COLOR_GREY, X, Y, Z + 0.02, 15.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, .testlos = 0 );

		g_rouletteTableData[ id ] [ E_SPINNER_OBJECT ] = CreateDynamicObject( 1979, X, Y, Z - 0.02, 0.00000, 0.00000, 0.0 );
		Iter_Add( roulettetables, id );
	}
	return 1;
}

stock GenerateRandomRouletteNumber( rouletteid ) {

	new
		iRandom = random( 37 );

	if ( iRandom == 0 )
		TextDrawSetString( g_rouletteNumberBG[ rouletteid ], "ld_roul:roulgre" );

	else if ( ! IsRedRouletteNumber( iRandom ) )
		TextDrawSetString( g_rouletteNumberBG[ rouletteid ], "ld_roul:roulbla" );

	else
		TextDrawSetString( g_rouletteNumberBG[ rouletteid ], "ld_roul:roulred" );

	TextDrawSetString( g_rouletteNumberTD[ rouletteid ], sprintf( "%d", iRandom ) );
	return iRandom;
}

public OnSpinRouletteTable( rouletteid, elapsed, steps )
{
	new
		Float: fElapsed = float( ( elapsed += 25 ) ),
		Float: rotation = -0.0001 * ( fElapsed * fElapsed ) + 0.8162 * fElapsed
	;

	// update it every 50 ms
	if ( elapsed % 50 == 0 && elapsed != 4000 )
		GenerateRandomRouletteNumber( rouletteid );

	SetDynamicObjectRot( g_rouletteTableData[ rouletteid ] [ E_SPINNER_OBJECT ], 0.0, 0.0, rotation );

	if ( elapsed >= 3250 )
		g_rouletteTableData[ rouletteid ] [ E_NO_MORE_BETS ] = true;

	if ( elapsed >= 4000 )
	{
		new
			iWinning = GenerateRandomRouletteNumber( rouletteid );

		// Kill the timer just incase
		KillTimer( g_rouletteTableData[ rouletteid ] [ E_SPINNING_TIMER ] );
		g_rouletteTableData[ rouletteid ] [ E_SPINNING_TIMER ] = -1;
	 	g_rouletteTableData[ rouletteid ] [ E_NO_MORE_BETS ] = false;

		// Call a win
		CallLocalFunction( "OnRouletteWheelStop", "dd", rouletteid, iWinning );
		return 1;
	}

	return ( g_rouletteTableData[ rouletteid ] [ E_SPINNING_TIMER ] = SetTimerEx( "OnSpinRouletteTable", 25, false, "ddd", rouletteid, elapsed, steps ) );
}

stock GetPlayerTotalRouletteBet( playerid ) {
	new
		bet = 0;

	for ( new chipid = 0; chipid < sizeof( g_rouletteChipValue[ ] ); chipid ++ ) if ( g_rouletteChipValue[ playerid ] [ chipid ] >= 100 ) {
		bet += g_rouletteChipValue[ playerid ] [ chipid ];
	}
	return bet;
}

public OnRouletteWheelStop( rouletteid, winner )
{
	new
		globalWaged = 0, globalWon = 0;

	// printf ( "OnRouletteWheelStop( %d, %d )", rouletteid, winner );
	foreach(new playerid : Player) if ( p_RouletteTable[ playerid ] == rouletteid && p_rouletteBetLocked{ playerid } )
	{
		new
			waged = 0, won = 0;

		for( new chipid = 0; chipid < sizeof( g_rouletteOffsets ); chipid ++ ) if ( g_rouletteChipValue[ playerid ] [ chipid ] > 0 )
		{
			// store chip value here
			new
				beforeWin = won,
				winValue = g_rouletteChipValue[ playerid ] [ chipid ];

			// increment the amount waged
			waged += g_rouletteChipValue[ playerid ] [ chipid ];

			// calculate wins
			switch ( g_rouletteOffsets[ chipid ] [ E_VALUE ] )
			{
				// 1st 3to1
				case 3211: {
					if ( winner == 1 || winner == 4 || winner == 7 || winner == 10 || winner == 13 || winner == 16 || winner == 19 || winner == 22 || winner == 25 || winner == 28 || winner == 31 || winner == 34 )
						won += winValue * 3;
				}

				// 2nd 3to1
				case 3212: {
					if ( winner == 2 || winner == 5 || winner == 8 || winner == 11 || winner == 14 || winner == 17 || winner == 20 || winner == 23 || winner == 26 || winner == 29 || winner == 32 || winner == 35 )
						won += winValue * 3;
				}

				// 2nd 3to1
				case 3213: {
					if ( winner == 3 || winner == 6 || winner == 9 || winner == 12 || winner == 15 || winner == 18 || winner == 21 || winner == 24 || winner == 27 || winner == 30 || winner == 33 || winner == 36 )
						won += winValue * 3;
				}

				// 1st 18
				case 118: {
					if ( 1 <= winner <= 18 )
						won += winValue * 2;
				}

				// even
				case 222: {
					if ( winner % 2 == 0 )
						won += winValue * 2;
				}

				// 1st to 12
				case 112: {
					if ( 1 <= winner <= 12 )
						won += winValue * 3;
				}

				// black
				case 44: {
					if ( ! IsRedRouletteNumber( winner ) && winner != 0 )
						won += winValue * 2;
				}

				// red
				case 88: {
					if ( IsRedRouletteNumber( winner ) )
						won += winValue * 2;
				}

				// 2nd 12
				case 212: {
					if ( 13 <= winner <= 24 )
						won += winValue * 3;
				}

				// odd
				case 333: {
					if ( winner % 2 == 1 && winner != 0 )
						won += winValue * 2;
				}

				// 19-36
				case 1936: {
					if ( 19 <= winner <= 36 )
						won += winValue * 2;
				}

				// 3rd 12
				case 312: {
					if ( 25 <= winner <= 36 )
						won += winValue * 3;
				}

				// check if its a single
				default:
				{
					if ( winner == g_rouletteOffsets[ chipid ] [ E_VALUE ] )
						won += winValue * 36;
				}
			}

			if ( beforeWin >= won ) {
				g_rouletteChipValue[ playerid ] [ chipid ] = 0;
				DestroyDynamicObject( g_rouletteChip[ playerid ] [ chipid ] ), g_rouletteChip[ playerid ] [ chipid ] = -1;
				DestroyDynamic3DTextLabel( g_rouletteChipLabel[ playerid ] [ chipid ] ), g_rouletteChipLabel[ playerid ] [ chipid ] = Text3D: -1;
			}

			// track
			globalWaged += waged;
			globalWon += won;
		}

		// bet unlocked and paid
		GivePlayerCash( playerid, won );
		p_rouletteBetLocked{ playerid } = false;

		new
			profit = won - waged;

		// inform users
		if ( profit >= 10000 ) {
			SendGlobalMessage( -1, ""COL_GREY"[CASINO]{FFFFFF} %s(%d) has won "COL_GOLD"%s"COL_WHITE" from roulette!", ReturnPlayerName( playerid ), playerid, ConvertPrice( profit ) );
		}

		// gametext
		if ( profit > 0 )  {
		 	GameTextForPlayer( playerid, sprintf( "~n~~n~~g~%s won!", ConvertPrice( profit ) ), 4000, 3 );
			SendClientMessageFormatted( playerid, -1, ""COL_GREY"[ROULETTE]"COL_WHITE" You have bet a total of %s and profited %s! (winning no %d)", ConvertPrice( waged ), ConvertPrice( profit ), winner );
		} else {
			profit *= -1; // to improve the client message
		 	GameTextForPlayer( playerid, "~n~~n~~r~No win!", 4000, 3 );
			SendClientMessageFormatted( playerid, -1, ""COL_GREY"[ROULETTE]"COL_WHITE" You have bet a total of %s and lost %s! (winning no %d)", ConvertPrice( waged ), ConvertPrice( profit ), winner );
		}
	}

	// log wins/losses
	UpdateServerVariable( "roulette_bets", 0, GetGVarFloat( "roulette_bets" ) + ( float( globalWaged ) / 1000000.0 ), "", GLOBAL_VARTYPE_FLOAT );
	UpdateServerVariable( "roulette_wins", 0, GetGVarFloat( "roulette_wins" ) + ( float( globalWon ) / 1000000.0 ), "", GLOBAL_VARTYPE_FLOAT );
	return 1;
}

public OnRouletteMarkerUpdate( playerid )
{
	new
		rouletteid = p_RouletteTable[ playerid ], column = p_RouletteMarkerColumn{ playerid };

	if ( rouletteid == -1 || ! Iter_Contains( roulettetables, rouletteid ) )
		return RemovePlayerFromRoulette( playerid );

	if ( IsValidDynamicObject( p_RouletteMarker[ playerid ] ) )
	{
	    new ud, lr;
	    GetPlayerKeys( playerid, ud, ud, lr );

	    if ( ud == KEY_UP )
	    {
	    	// up on 0
	    	if ( column == 0 )
	    		column = 38;

	    	// up on 1,2,3
	    	else if ( 1 <= column <= 3 )
	    		column = 0;

	    	// up 1st 12
	    	else if ( column == 42 )
	    		column = 48;

	    	// up 3rd 12
	    	else if ( column == 48 )
	    		column = 45;

	    	// up 2nd 12
	    	else if ( column == 45 )
	    		column = 42;

	    	// up 1-to-18
	    	else if ( column == 40 )
	    		column = 47;

	    	else if ( column == 41 || column == 44 || column == 47 )
	    		column --;

	    	else if ( column == 43 || column == 46 )
	    		column -= 2;

	    	else
	    		column -= 3;
	    }
	    else if ( ud == KEY_DOWN )
	    {
	    	// pressed down on 3to1s
	    	if ( 36 < column < 40 )
	    		column = 0;

	    	// down on 1st 12
	    	else if ( column == 42 )
	    		column = 45;

	    	// down on 2nd 12
	    	else if ( column == 45 )
	    		column = 48;

	    	// down 19-to-36
	    	else if ( column == 47 )
	    		column = 40;

	    	// down on 3rd 12
	    	else if ( column == 48 )
	    		column = 42;

	    	// if pressed down on zero, go to previous
	    	else if ( column == 0 )
	    		column = 2;

	    	else if ( column == 40 || column == 43 || column == 46 )
	    		column ++;

	    	else if ( column == 41 || column == 44 )
	    		column += 2;

	    	else
	    		column += 3;
	    }
	    else if ( lr == KEY_LEFT )
	    {
	    	// right on 0
	    	if ( column == 0 )
	    		column = 0;

	    	else if ( column == 1 || column == 4 || column == 7 || column == 10 )
	    		column = 42;

	    	else if ( column == 13 || column == 16 || column == 19 || column == 22 )
	    		column = 45;

	    	else if ( column == 25 || column == 28 || column == 31 || column == 34 )
	    		column = 48;

	    	// left 1 to 18
	    	else if ( column == 40 )
	    		column = 0;

	    	else
	    		column --;

	    }
	    else if ( lr == KEY_RIGHT )
	    {
	    	// left on 0
	    	if ( column == 0 )
	    		column = 0;

	    	// right 39
	    	if ( column == 39 )
	    		column = 0;

	    	// right red black
	    	else if ( 43 <= column <= 44 )
	    		column = 45;

	    	// right 1-18,even
	    	else if ( 40 <= column <= 41 )
	    		column = 42;

	    	// right odd,19-36
	    	else if ( 46 <= column <= 47 )
	    		column = 48;

	    	// right on 3rd 12
	    	else if ( column == 48 )
	    		column = 25;

	   		// right on 2nd 12
	    	else if ( column == 45 )
	    		column = 13;

	    	// right on 1st 12
	    	else if ( column == 42 )
	    		column = 1;

	    	else
	    		column ++;
	    }

	    // update object pos
		new Float: offsetX = g_rouletteTableData[ rouletteid ] [ E_X ] + g_rouletteOffsets[ column ] [ E_OFFSET ] * floatcos( g_rouletteTableData[ rouletteid ] [ E_ROTATION ] + g_rouletteOffsets[ column ] [ E_ANGLE ], degrees );
		new Float: offsetY = g_rouletteTableData[ rouletteid ] [ E_Y ] + g_rouletteOffsets[ column ] [ E_OFFSET ] * floatsin( g_rouletteTableData[ rouletteid ] [ E_ROTATION ] + g_rouletteOffsets[ column ] [ E_ANGLE ], degrees );
		SetDynamicObjectPos( p_RouletteMarker[ playerid ], offsetX, offsetY, g_rouletteTableData[ rouletteid ] [ E_Z ] - 0.17 );

		// update player column
	    p_RouletteMarkerColumn{ playerid } = column;
	}
	return 1;
}

stock RemovePlayerFromRoulette( playerid )
{
	// remove chips
	for ( new i = 0; i < sizeof( g_rouletteOffsets ); i ++ ) {
		DestroyDynamicObject( g_rouletteChip[ playerid ] [ i ] ), g_rouletteChip[ playerid ] [ i ] = -1;
		DestroyDynamic3DTextLabel( g_rouletteChipLabel[ playerid ] [ i ] ), g_rouletteChipLabel[ playerid ] [ i ] = Text3D: INVALID_3DTEXT_ID;
		g_rouletteChipValue[ playerid ] [ i ] = 0;
	}

	// hide textdraws
	if ( p_RouletteTable[ playerid ] != -1 ) {
		TextDrawHideForPlayer( playerid, g_rouletteNumberBG[ p_RouletteTable[ playerid ] ] );
		TextDrawHideForPlayer( playerid, g_rouletteNumberTD[ p_RouletteTable[ playerid ] ] );
	}

	// reset user variables
	HidePlayerHelpDialog( playerid );
	p_RouletteTable[ playerid ] = -1;
	p_RouletteMarkerColumn{ playerid } = 0;
	p_rouletteBetLocked{ playerid } = false;

	// close timers
	KillTimer( p_RouletteMarkerTimer[ playerid ] ), p_RouletteMarkerTimer[ playerid ] = -1;
	DestroyDynamicObject( p_RouletteMarker[ playerid ] ), p_RouletteMarker[ playerid ] = -1;

	// clear animations if spawned
	if ( IsPlayerSpawned( playerid ) ) {
		SetCameraBehindPlayer( playerid );
		ClearAnimations( playerid );
	}
	return 1;
}

stock TriggerPlayerSlotMachine( playerid, machineid )
{
	if ( p_usingSlotMachine[ playerid ] != machineid )
		return 1;

	if ( GetDistanceFromPlayerSquared( playerid, g_slotmachineData[ machineid ] [ E_X ], g_slotmachineData[ machineid ] [ E_Y ], g_slotmachineData[ machineid ] [ E_Z ] ) > 4.0 ) // Squared
		return StopPlayerUsingSlotMachine( playerid );

	if ( !g_slotmachineData[ machineid ] [ E_ROLLING ] )
	{
		new
			entryFee = g_slotmachineData[ machineid ] [ E_ENTRY_FEE ],
			poolContribute = entryFee == 10000 ? floatround( float( entryFee ) * 0.9 ) : floatround( float( entryFee ) * 0.75 );

		if ( GetPlayerCash( playerid ) < entryFee )
			return SendError( playerid, "You must have at least %s to use this slot machine.", ConvertPrice( entryFee ) ), ( p_AutoSpin{ playerid } = false ), 1;

		// Update casino pool
		UpdateCasinoPoolData( g_slotmachineData[ machineid ] [ E_POOL_ID ], .pool_increment = poolContribute, .total_win = 0, .total_gambled = entryFee );

		// Charge the player
		RollSlotMachine( playerid, machineid );
		PlayerPlaySound( playerid, 4202, 0.0, 0.0, 0.0 );
		ApplyAnimation( playerid, "CASINO", "slot_plyr", 2.0, 0, 1, 1, 0, 0 );
		GivePlayerCash( playerid, -entryFee );
		return 1;
	}
	return 1;
}

stock SendClientMessageToRace( raceid, colour, format[ ], va_args<> )
{
    static
		out[ 144 ];

    va_format( out, sizeof( out ), format, va_start<3> );

	foreach(new i : Player)
	{
	    if ( p_raceLobbyId[ i ] == raceid )
			SendClientMessage( i, colour, out );
	}
	return 1;
}

function OnRaceCountdown( raceid, time )
{
	if ( raceid == -1 || ! Iter_Contains( races, raceid ) )
		return;

	foreach (new playerid : Player) if ( p_raceLobbyId[ playerid ] == raceid ) {
		if ( ! IsPlayerInDynamicRaceCP( playerid, g_raceData[ raceid ] [ E_START_CHECKPOINT ] ) ) {
			SendClientMessageToRace( raceid, -1, ""COL_GREY"[RACE]"COL_WHITE" The race cannot be started as %s(%d) is not in the starting checkpoint.", ReturnPlayerName( playerid ), playerid );
			g_raceData[ raceid ] [ E_CD_TIMER ] = SetTimerEx( "OnRaceCountdown", 960, false, "dd", raceid, time );
			return;
		}
	}

	if ( time <= 0 )
	{
	    foreach (new playerid : Player) if ( p_raceLobbyId[ playerid ] == raceid )
	    {
	    	if ( g_raceData[ raceid ] [ E_MODE ] == RACE_OUTRUN )
	    	{
		    	// create sphere ahead of leader
		    	if ( g_raceData[ raceid ] [ E_LOBBY_HOST ] == playerid )
		    	{
		    		new
		    			vehicleid = GetPlayerVehicleID( playerid ), Float: A;

		    		GetVehicleZAngle( vehicleid, A );

		    		// create sphere obj
		    		g_raceData[ raceid ] [ E_OUTRUN_LEAD ] = playerid;
		    		g_raceData[ raceid ] [ E_OUTRUN_SPHERE ] = CreateDynamicCircle( 0.0, 0.0, 10.0 );
		    		g_raceData[ raceid ] [ E_OUTRUN_OBJECT ] = CreateDynamicObject( 11752, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1, -1, 0 );
		    		g_raceData[ raceid ] [ E_OUTRUN_TIMER ] = SetTimerEx( "OnRaceOutrun", 250, true, "d", raceid );

		    		// attach objects
					Streamer_RemoveArrayData( STREAMER_TYPE_OBJECT, g_raceData[ raceid ] [ E_OUTRUN_OBJECT ], E_STREAMER_PLAYER_ID, 0 );
					AttachDynamicObjectToVehicle( g_raceData[ raceid ] [ E_OUTRUN_OBJECT ], vehicleid, 0.0, OUTRUN_DIST, -15.0, 0.0, 0.0, 0.0 );
		    		AttachDynamicAreaToVehicle( g_raceData[ raceid ] [ E_OUTRUN_SPHERE ], vehicleid, 0.0, -OUTRUN_DIST - 4.0 );
		    	}

		    	// show checkpoint for player
	  			Streamer_AppendArrayData( STREAMER_TYPE_OBJECT, g_raceData[ raceid ] [ E_OUTRUN_OBJECT ], E_STREAMER_PLAYER_ID, playerid );
		    }

	    	// destroy starting checkpoint
	    	DestroyDynamicRaceCP( g_raceData[ raceid ] [ E_START_CHECKPOINT ] );

	    	// show gametext
    		GameTextForPlayer( playerid, "~g~GO!", 2000, 3 );
			PlayerPlaySound( playerid, 1057, 0.0, 0.0, 0.0 );
		}
		g_raceData[ raceid ] [ E_CD_TIMER ] = -1;
	}
	else
	{
	    foreach (new playerid : Player) if ( p_raceLobbyId[ playerid ] == raceid )
	    {
    		GameTextForPlayer( playerid, sprintf( "~y~%d", time ), 2000, 3 );
    		PlayerPlaySound( playerid, 1056, 0.0, 0.0, 0.0 );
	    }
		g_raceData[ raceid ] [ E_CD_TIMER ] = SetTimerEx( "OnRaceCountdown", 960, false, "dd", raceid, time - 1 );
	}
}

stock ShowRaceConfiguration( playerid, raceid )
{

	format( szLargeString, sizeof( szLargeString ), ""COL_WHITE"The current prize pool is %s\t \n"COL_GREY"Race Mode\t%s\n"COL_GREY"Entry Fee\t%s\n"COL_GREY"Prize Distribution\t%0.0f-%0.0f-%0.0f\n",

								ConvertPrice( g_raceData[ raceid ] [ E_POOL ] ), g_raceData[ raceid ] [ E_MODE ] == RACE_STREET_RACE ? ( "Streetrace" ) : ( "Outrun" ), ConvertPrice( g_raceData[ raceid ] [ E_ENTRY_FEE ] ),

								100.0 * g_raceData[ raceid ] [ E_POSITION_PRIZE ] [ 0 ], 100.0 * g_raceData[ raceid ] [ E_POSITION_PRIZE ] [ 1 ], 100.0 * g_raceData[ raceid ] [ E_POSITION_PRIZE ] [ 2 ]
							);

	if ( g_raceData[ raceid ] [ E_MODE ] == RACE_STREET_RACE ) {
		format( szLargeString, sizeof( szLargeString ), "%s"COL_GREY"Finish Destination\t%s\n", szLargeString, g_raceData[ raceid ] [ E_RACE_FINISH_SET ] == 1 ? ( ""COL_GREEN"ACTIVE" ) : ( ""COL_ORANGE"NOT SET" ) );
	} else {
		format( szLargeString, sizeof( szLargeString ), "%s"COL_GREY"Outrun Distance\t%0.1f meters\n", szLargeString, g_raceData[ raceid ] [ E_OUTRUN_DISTANCE ] );
	}

	strcat( szLargeString, ""COL_GREY"View Racers\t " );

	SetPVarInt( playerid, "editing_race", raceid );
	ShowPlayerDialog( playerid, DIALOG_RACE, DIALOG_STYLE_TABLIST_HEADERS, ""COL_GOLD"Race Configuration", szLargeString, "Select", "Close" );
	return 1;
}

function OnRaceOutrun( raceid )
{
	new
		racers = 0, ahead_count = 0, lead = g_raceData[ raceid ] [ E_OUTRUN_LEAD ];

	foreach (new i : Player) if ( p_raceLobbyId[ i ] == raceid && lead != i )
	{
		// increment racers
		racers ++;

		// check if racer is ahead
		if ( GetDistanceBetweenPlayers( lead, i ) > g_raceData[ raceid ] [ E_OUTRUN_DISTANCE ] )
			ahead_count ++;
	}

	// player is ahead of all players
	if ( ahead_count == racers )
	{
		new
			position = ++ g_raceData[ raceid ] [ E_FINISHED_COUNT ];

		// give prize and alert
		if ( 1 <= position <= 3 )
			GivePlayerRaceWin( lead, position, raceid );

		// end race if position over 3 or whatever the race count is or only 1 prize
		printf ("position : %d, Racers : %d", position, racers);
		if ( position >= 3 || position >= racers ||  g_raceData[ raceid ] [ E_POSITION_PRIZE ] [ 0 ] == 1.0 )
		{
			// incase there is a final player and a remaining prize pool
			if ( g_raceData[ raceid ] [ E_POSITION_PRIZE ] [ 0 ] != 1.0 )
			{
				new
					closestRacer = GetClosestRacer( lead, raceid, .exceptid = lead );

				printf( "Yes we have a pool of %d, closest %d", g_raceData[ raceid ] [ E_POOL ], closestRacer );
				if ( IsPlayerConnected( closestRacer ) )
				{
					new
						finalPosition = ++ g_raceData[ raceid ] [ E_FINISHED_COUNT ];

					printf( "position %d", finalPosition );
					if ( 1 <= finalPosition <= 3 )
						GivePlayerRaceWin( closestRacer, finalPosition, raceid );
				}
			}
			else
			{
				SendClientMessageToRace( raceid, -1, ""COL_GREY"[RACE]"COL_WHITE" The race has ended as there can only be one winner." );
			}

			// destroy race
			print ("Shut race");
			return DestroyRace( raceid );
		}

		// transfer leader
		else
		{
			new
				closestRacer = GetClosestRacer( lead, raceid, .exceptid = lead );

		    if ( IsPlayerConnected( closestRacer ) )
		    {
			    new
			    	iVehicle = GetPlayerVehicleID( closestRacer );

				// new leader
				g_raceData[ raceid ] [ E_OUTRUN_LEAD ] = closestRacer;
				SendClientMessageToRace( raceid, -1, ""COL_GREY"[RACE]"COL_WHITE" %s(%d) has taken the lead for the race.", ReturnPlayerName( closestRacer ), closestRacer );

				// see if ahead
				AttachDynamicObjectToVehicle( g_raceData[ raceid ] [ E_OUTRUN_OBJECT ], iVehicle, 0.0, OUTRUN_DIST, -15.0, 0.0, 0.0, 0.0 );
	    		AttachDynamicAreaToVehicle( g_raceData[ raceid ] [ E_OUTRUN_SPHERE ], iVehicle, 0.0, -OUTRUN_DIST - 4.0 );
			}
		}
	}
	return 1;
}

stock GetClosestRacer( playerid, raceid, exceptid = INVALID_PLAYER_ID, &Float: distance = FLOAT_INFINITY ) {
    new
    	iCurrent = INVALID_PLAYER_ID,
        Float: fX, Float: fY,  Float: fZ, Float: fTmp
    ;

    if ( GetPlayerPos( playerid, fX, fY, fZ ) )
    {
		foreach (new i : Player) if ( p_raceLobbyId[ i ] == raceid && exceptid != i && GetPlayerVehicleSeat( playerid ) == 0 )
		{
            if ( 0.0 < ( fTmp = GetPlayerDistanceFromPoint( i, fX, fY, fZ ) ) < distance )
            {
                distance = fTmp;
                iCurrent = i;
            }
	    }
    }
    return iCurrent;
}

stock GivePlayerRaceWin( playerid, position, raceid )
{
	new
		prizeMoney = floatround( float( g_raceData[ raceid ] [ E_POOL ] ) * g_raceData[ raceid ] [ E_POSITION_PRIZE ] [ ( position - 1 ) ] );

	// give cash & reduce prize pool
	GivePlayerCash( playerid, prizeMoney );

	// announcement
	foreach (new i : Player) if ( p_raceLobbyId[ i ] == raceid ) {
		PlayerPlaySound( i, 1149, 0.0, 0.0, 0.0 );
		GameTextForPlayer( i, sprintf( "~y~~h~%d%s~w~ %s", position, positionToString( position ), ReturnPlayerName( playerid ) ), 2000, 3 );
		SendClientMessageFormatted( i, COLOR_GREY, "[RACE]"COL_WHITE" %s(%d) has finished the race in %d%s position (prize %s).", ReturnPlayerName( playerid ), playerid, position, positionToString( position ), ConvertPrice( prizeMoney ) );
	}

	// remove from race
	RemovePlayerFromRace( playerid );
}


stock DestroyRace( raceid )
{
	// remove players from race
	foreach (new playerid : Player) {
		if ( p_raceLobbyId[ playerid ] == raceid ) {
			p_raceLobbyId[ playerid ] = -1;
		}
	}

	// remove race vars
	Iter_Remove( races, raceid );
	g_raceData[ raceid ] [ E_STARTED ] = false;

	// destroy race cps
	DestroyDynamicObject( g_raceData[ raceid ] [ E_OUTRUN_OBJECT ] ), g_raceData[ raceid ] [ E_OUTRUN_OBJECT ] = -1;
	DestroyDynamicArea( g_raceData[ raceid ] [ E_OUTRUN_SPHERE ] ), g_raceData[ raceid ] [ E_OUTRUN_SPHERE ] = -1;
	DestroyDynamicRaceCP( g_raceData[ raceid ] [ E_START_CHECKPOINT ] ), g_raceData[ raceid ] [ E_START_CHECKPOINT ] = -1;
	DestroyDynamicRaceCP( g_raceData[ raceid ] [ E_FINISH_CHECKPOINT ] ), g_raceData[ raceid ] [ E_FINISH_CHECKPOINT ] = -1;
	DestroyDynamicMapIcon( g_raceData[ raceid ] [ E_FINISH_MAP_ICON ] ), g_raceData[ raceid ] [ E_FINISH_MAP_ICON ] = -1;
	KillTimer( g_raceData[ raceid ] [ E_OUTRUN_TIMER ] ), g_raceData[ raceid ] [ E_OUTRUN_TIMER ] = -1;
	return 1;
}

stock RemovePlayerFromRace( playerid )
{
	new
		newLeader = INVALID_PLAYER_ID,
		raceid = p_raceLobbyId[ playerid ]
	;

	if ( ! Iter_Contains( races, raceid ) )
		return 0;

	// hide checkpoints
	Streamer_RemoveArrayData( STREAMER_TYPE_OBJECT, g_raceData[ raceid ] [ E_OUTRUN_OBJECT ], E_STREAMER_PLAYER_ID, playerid );
	Streamer_RemoveArrayData( STREAMER_TYPE_RACE_CP, g_raceData[ raceid ] [ E_START_CHECKPOINT ], E_STREAMER_PLAYER_ID, playerid );
	Streamer_RemoveArrayData( STREAMER_TYPE_RACE_CP, g_raceData[ raceid ] [ E_FINISH_CHECKPOINT ], E_STREAMER_PLAYER_ID, playerid );
	Streamer_RemoveArrayData( STREAMER_TYPE_MAP_ICON, g_raceData[ raceid ] [ E_FINISH_MAP_ICON ], E_STREAMER_PLAYER_ID, playerid );

	// kick player out
	p_raceLobbyId[ playerid ] = -1;

	// assign new leader if possible
	if ( g_raceData[ raceid ] [ E_LOBBY_HOST ] == playerid )
	{
		foreach (new i : Player) if ( p_raceLobbyId[ i ] == raceid ) {
			newLeader = i;
			break;
		}

		if ( IsPlayerConnected( newLeader ) )
		{
			g_raceData[ raceid ] [ E_LOBBY_HOST ] = newLeader;
			// SendClientMessageToRace( raceid, COLOR_GREY, "[RACE]"COL_WHITE" %s(%d) is the new lobby host.", ReturnPlayerName( newLeader ), newLeader );
		}
		else
		{
			printf("Destroyed empty race lobby %d", raceid);
			DestroyRace( raceid );
		}
	}

	// maybe the outrun lead left
	else if ( g_raceData[ raceid ] [ E_MODE ] == RACE_OUTRUN && g_raceData[ raceid ] [ E_OUTRUN_LEAD ] == playerid )
	{
		new
			closestRacer = GetClosestRacer( playerid, raceid, .exceptid = playerid );

	    if ( IsPlayerConnected( closestRacer ) )
	    {
		    new
		    	iVehicle = GetPlayerVehicleID( closestRacer );

			// new leader
			g_raceData[ raceid ] [ E_OUTRUN_LEAD ] = closestRacer;
			SendClientMessageToRace( raceid, -1, ""COL_GREY"[RACE]"COL_WHITE" %s(%d) has taken the lead for the race.", ReturnPlayerName( closestRacer ), closestRacer );

			// see if ahead
			AttachDynamicObjectToVehicle( g_raceData[ raceid ] [ E_OUTRUN_OBJECT ], iVehicle, 0.0, OUTRUN_DIST, -15.0, 0.0, 0.0, 0.0 );
    		AttachDynamicAreaToVehicle( g_raceData[ raceid ] [ E_OUTRUN_SPHERE ], iVehicle, 0.0, -OUTRUN_DIST - 4.0 );
		}
		else
		{
			SendClientMessageToRace( raceid, -1, ""COL_GREY"[RACE]"COL_WHITE" The race has ended as a new leader couldn't be set." );
			DestroyRace( raceid );
		}
	}
	return 1;
}

stock GetRaceMemberCount( raceid ) {
	new
		count = 0;

	foreach (new playerid : Player) if ( p_raceLobbyId[ playerid ] == raceid ) {
		count ++;
	}
	return count;
}

stock SetRaceDestination( raceid, Float: fX, Float: fY, Float: fZ)
{
	// set race position
	g_raceData[ raceid ] [ E_FINISH_POS ] [ 0 ] = fX;
	g_raceData[ raceid ] [ E_FINISH_POS ] [ 1 ] = fY;
	g_raceData[ raceid ] [ E_FINISH_POS ] [ 2 ] = fZ;
	g_raceData[ raceid ] [ E_RACE_FINISH_SET ] = 1;

	// destroy checkpoint/icon again
	DestroyDynamicMapIcon( g_raceData[ raceid ] [ E_FINISH_MAP_ICON ] );
	DestroyDynamicRaceCP( g_raceData[ raceid ] [ E_FINISH_CHECKPOINT ] );

	// place checkpoint
	g_raceData[ raceid ] [ E_FINISH_MAP_ICON ] = CreateDynamicMapIcon( fX, fY, fZ, 53, -1, -1, -1, 0, 6000.0, MAPICON_GLOBAL );
	g_raceData[ raceid ] [ E_FINISH_CHECKPOINT ] = CreateDynamicRaceCP( 1, g_raceData[ raceid ] [ E_FINISH_POS ] [ 0 ], g_raceData[ raceid ] [ E_FINISH_POS ] [ 1 ], g_raceData[ raceid ] [ E_FINISH_POS ] [ 2 ], 0, 0, 0, 5.0, -1, -1, 0 );

  	// reset players in map icon/cp
  	Streamer_RemoveArrayData( STREAMER_TYPE_MAP_ICON, g_raceData[ raceid ] [ E_FINISH_MAP_ICON ], E_STREAMER_PLAYER_ID, 0 );
  	Streamer_RemoveArrayData( STREAMER_TYPE_RACE_CP, g_raceData[ raceid ] [ E_FINISH_CHECKPOINT ], E_STREAMER_PLAYER_ID, 0 );

  	// stream to players
	foreach (new i : Player) if ( p_raceLobbyId[ i ] == raceid ) {
		Streamer_AppendArrayData( STREAMER_TYPE_MAP_ICON, g_raceData[ raceid ] [ E_FINISH_MAP_ICON ], E_STREAMER_PLAYER_ID, i );
		Streamer_AppendArrayData( STREAMER_TYPE_RACE_CP, g_raceData[ raceid ] [ E_FINISH_CHECKPOINT ], E_STREAMER_PLAYER_ID, i );
	}
}

stock IsRaceHost( playerid, raceid ) {
	if ( raceid == -1 || ! Iter_Contains( races, raceid ) )
		return false;

	return g_raceData[ raceid ] [ E_LOBBY_HOST ] == playerid;
}


//biz
thread OnBusinessLoad( )
{
	new
		rows, fields, i = -1,
	    loadingTick = GetTickCount( )
	;

	cache_get_data( rows, fields );
	if ( rows )
	{
		new
			szName[ 32 ], szMembers[ 96 ];

		// TODO: add members
		while( ++i < rows )
		{
			new
				businessid = cache_get_field_content_int( i, "ID", dbHandle );

			// get business name
			cache_get_field_content( i, "NAME", szName, sizeof( szName ) );
			cache_get_field_content( i, "MEMBERS", szMembers, sizeof( szMembers ) );

			// create business
			new b = CreateBusiness(
				cache_get_field_content_int( i, "OWNER_ID", dbHandle ),
				szName,
				cache_get_field_content_int( i, "COST", dbHandle ),
				cache_get_field_content_int( i, "TYPE", dbHandle ),
				cache_get_field_content_float( i, "X", dbHandle ),
				cache_get_field_content_float( i, "Y", dbHandle ),
				cache_get_field_content_float( i, "Z", dbHandle ),
				cache_get_field_content_int( i, "SUPPLIES", dbHandle ),
				cache_get_field_content_int( i, "PRODUCT", dbHandle ),
				cache_get_field_content_int( i, "PROD_TIMESTAMP", dbHandle ),
				cache_get_field_content_int( i, "BANK", dbHandle ),
				businessid
			);

			// check if valid business
			if ( b != -1 )
			{
				// add members
				if ( sscanf( szMembers, sprintf( "a<i>[%d]", MAX_BUSINESS_MEMBERS ), g_businessData[ businessid ] [ E_MEMBERS ] ) ) {
					// must have fucked up, we'll reset members
					for ( new x = 0; x < MAX_BUSINESS_MEMBERS; x ++ )
						g_businessData[ businessid ] [ E_MEMBERS ] [ x ] = 0;
				}

				// apply upgrades
				g_businessData[ businessid ] [ E_CAR_MODEL_ID ] = cache_get_field_content_int( i, "CAR_MODEL", dbHandle );
				g_businessData[ businessid ] [ E_HELI_MODEL_ID ] = cache_get_field_content_int( i, "AIR_MODEL", dbHandle );
				g_businessData[ businessid ] [ E_EXTRA_MEMBERS ] = cache_get_field_content_int( i, "EXTRA_MEMBERS", dbHandle );
				g_businessData[ businessid ] [ E_UPGRADES ] = cache_get_field_content_int( i, "UPGRADES", dbHandle );
				g_businessData[ businessid ] [ E_CAR_NOS ] = !! cache_get_field_content_int( i, "HAS_NOS", dbHandle );
				g_businessData[ businessid ] [ E_CAR_RIMS ] = !! cache_get_field_content_int( i, "HAS_RIMS", dbHandle );

				// add bots inside if neccessary
				if ( g_businessData[ businessid ] [ E_UPGRADES ] ) CreateBusinessActors( businessid );

				// unlock models?
				mysql_function_query( dbHandle, sprintf( "SELECT * FROM `BUSINESS_VEHICLES` WHERE `BUSINESS_ID`=%d", businessid ), true, "OnBusinessVehicleLoad", "d", businessid );
			}
			else printf( "[BUSINESS ERROR]: Unable to create business id %d", b );
		}
	}
	printf( "[BUSINESSES]: %d businesses have been loaded. (Tick: %dms)", i, GetTickCount( ) - loadingTick );
	return 1;
}

thread OnBusinessVehicleLoad( businessid )
{
	new
		rows, fields, i = -1;

	cache_get_data( rows, fields );
	if ( rows ) {
		while( ++i < rows ) {
			new vehicle_index = cache_get_field_content_int( i, "VEHICLE_INDEX", dbHandle );

			if ( vehicle_index < MAX_BIZ_VEH_MODELS ) // Must be something wrong otherwise...
				g_businessVehicleUnlocked[ businessid ] { vehicle_index } = true;
		}
	}
	return 1;
}

CreateBusiness( iAccountID, szBusiness[ 32 ], iPrice, iType, Float: fX, Float: fY, Float: fZ, iSupply = 0, iProduct = 0, iProductionTimestamp = 0, iBank = 0, iExistingID = -1 )
{
	new
		iBusiness = iExistingID != ITER_NONE ? iExistingID : Iter_Free(business);

	if ( Iter_Contains( business, iExistingID ) )
		iBusiness = ITER_NONE; // In the unlikelihood...

	if ( iBusiness != ITER_NONE )
	{
		format( g_businessData[ iBusiness ] [ E_NAME ], 32, "%s", szBusiness );

	    ResetBusiness( iBusiness ); // reset data just incase first

		g_businessData[ iBusiness ] [ E_OWNER_ID ] 		= iAccountID;
		g_businessData[ iBusiness ] [ E_COST ] 			= iPrice;
		g_businessData[ iBusiness ] [ E_INTERIOR_TYPE ] = iType;
		g_businessData[ iBusiness ] [ E_WORLD ] 		= iBusiness + ( MAX_BUSINESSES ); // Random

		g_businessData[ iBusiness ] [ E_X ] = fX;
		g_businessData[ iBusiness ] [ E_Y ] = fY;
		g_businessData[ iBusiness ] [ E_Z ] = fZ;

		g_businessData[ iBusiness ] [ E_BANK ] = iBank;
		g_businessData[ iBusiness ] [ E_PRODUCT ] = iProduct;
		g_businessData[ iBusiness ] [ E_SUPPLIES ] = iSupply;
		g_businessData[ iBusiness ] [ E_PROD_TIMESTAMP ] = iProductionTimestamp;

		// reset actor id (otherwise it defaults as 0)
    	for ( new i = 0; i < sizeof( g_businessActors[ ] ); i ++ )
    		g_businessActors[ iBusiness ] [ i ] = -1;

		// production label
		g_businessData[ iBusiness ] [ E_PROD_LABEL ] = CreateDynamic3DTextLabel( "... Loading ...", COLOR_GOLD, g_businessInteriorData[ iType ] [ E_PROD_X ], g_businessInteriorData[ iType ] [ E_PROD_Y ], g_businessInteriorData[ iType ] [ E_PROD_Z ], 20.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, g_businessData[ iBusiness ] [ E_WORLD ], g_businessData[ iBusiness ] [ E_INTERIOR_TYPE ] + 20 );
		UpdateBusinessProductionLabel( iBusiness );

		// add a private vehicle!
		if ( iType == BUSINESS_WEAPON ) {
			new baggage = CreateVehicle( 485, -4301.9580, 209.8583, 1303.1013, 90.0, -1, -1, 360 );
			SetVehicleVirtualWorld( baggage, g_businessData[ iBusiness ] [ E_WORLD ] );
			LinkVehicleToInterior( baggage, 20 + iType );
		}

		// checkpoints
		g_businessData[ iBusiness ] [ E_ENTER_CP ] = CreateDynamicCP( fX, fY, fZ, 1.0, -1, 0, -1, 100.0 );
		g_businessData[ iBusiness ] [ E_EXIT_CP ] = CreateDynamicCP( g_businessInteriorData[ iType ] [ E_X ], g_businessInteriorData[ iType ] [ E_Y ], g_businessInteriorData[ iType ] [ E_Z ], 1.0, g_businessData[ iBusiness ] [ E_WORLD ], g_businessData[ iBusiness ] [ E_INTERIOR_TYPE ] + 20, -1, 100.0 );

		format( szBigString, sizeof( szBigString ), ""COL_GOLD"Business:"COL_WHITE" %s(%d)\n"COL_GOLD"Owner:"COL_WHITE" No-one\n"COL_GOLD"Price:"COL_WHITE" %s\n"COL_GOLD"Members:"COL_WHITE" 0", szBusiness, iBusiness, ConvertPrice( g_businessData[ iBusiness ] [ E_COST ] ) );
	    g_businessData[ iBusiness ] [ E_ENTER_LABEL ] = CreateDynamic3DTextLabel( szBigString, COLOR_GOLD, fX, fY, fZ, 20.0 );
		g_businessData[ iBusiness ] [ E_EXIT_LABEL ] = CreateDynamic3DTextLabel( "[EXIT]", COLOR_GOLD, g_businessInteriorData[ iType ] [ E_X ], g_businessInteriorData[ iType ] [ E_Y ], g_businessInteriorData[ iType ] [ E_Z ], 20.0 );

	    // just incase, reset variables
	    StopBusinessExportMission( iBusiness );

	    // insert or readjust name
		if ( iExistingID != -1 && iAccountID != 0 ) UpdateBusinessTitle( iBusiness );
		else if ( iExistingID == -1 )
		{
			format( szBigString, sizeof( szBigString ), "INSERT INTO `BUSINESSES`(`ID`, `OWNER_ID`, `NAME`, `COST`, `TYPE`, `X`, `Y`, `Z`) VALUES (%d,%d,'%s',%d,%d,%f,%f,%f)", iBusiness, iAccountID, szBusiness, iPrice, iType, fX, fY, fZ );
			mysql_single_query( szBigString );
		}

		Iter_Add(business, iBusiness);
	}
	return iBusiness;
}

stock ResetBusiness( iBusiness )
{
	// data
	g_businessData[ iBusiness ] [ E_PRODUCT ] = 0;
	g_businessData[ iBusiness ] [ E_SUPPLIES ] = 0;

	// upgrades
	g_businessData[ iBusiness ] [ E_CAR_MODEL_ID ] = 554;
	g_businessData[ iBusiness ] [ E_HELI_MODEL_ID ] = 417;
	g_businessData[ iBusiness ] [ E_EXTRA_MEMBERS ] = 0;
	g_businessData[ iBusiness ] [ E_UPGRADES ] = 0;
	g_businessData[ iBusiness ] [ E_CAR_NOS ] = false;
	g_businessData[ iBusiness ] [ E_CAR_RIMS ] = false;

    // reset members
    for ( new i = 0; i < MAX_BUSINESS_MEMBERS; i ++ )
    	g_businessData[ iBusiness ] [ E_MEMBERS ] [ i ] = 0;

    // reset vehicle models
    for ( new i = 0; i < MAX_BIZ_VEH_MODELS; i ++ )
    	g_businessVehicleUnlocked[ iBusiness ] { i } = false;

    // reset actors
    for ( new i = 0; i < sizeof( g_businessActors[ ] ); i ++ )
    	DestroyActor( g_businessActors[ iBusiness ] [ i ] ), g_businessActors[ iBusiness ] [ i ] = -1;

    // queries
	mysql_single_query( sprintf( "DELETE FROM `BUSINESS_VEHICLES` WHERE `BUSINESS_ID`=%d", iBusiness ) );
	mysql_single_query( sprintf( "UPDATE `USERS` SET `BUSINESS_ID`=-1 WHERE `BUSINESS_ID`=%d", iBusiness ) );
}

stock GetBusinessAssociates( businessid ) {
	new
		members = 0;

    for ( new i = 0; i < MAX_BUSINESS_MEMBERS; i ++ )
    	if ( g_businessData[ businessid ] [ E_MEMBERS ] [ i ] != 0 )
    		members ++;

    if ( g_businessData[ businessid ] [ E_OWNER_ID ] != 0 )
    	members ++;

    return members;
}

thread OnUpdateBusinessTitle( businessid )
{
	new
		rows, szOwner[ MAX_PLAYER_NAME ] = "No-one", associates = GetBusinessAssociates( businessid );

	cache_get_data( rows, tmpVariable );

	if ( rows )
		cache_get_field_content( 0, "NAME", szOwner );

	format( szBigString, sizeof( szBigString ), ""COL_GOLD"Business:"COL_WHITE" %s(%d)\n"COL_GOLD"Owner:"COL_WHITE" %s\n"COL_GOLD"Price:"COL_WHITE" %s\n"COL_GOLD"Members:"COL_WHITE" %d", g_businessData[ businessid ] [ E_NAME ], businessid, szOwner, ConvertPrice( g_businessData[ businessid ] [ E_COST ] ), associates );
	UpdateDynamic3DTextLabelText( g_businessData[ businessid ] [ E_ENTER_LABEL ], COLOR_GOLD, szBigString );
	return 1;
}

stock UpdateBusinessProductionLabel( businessid )
{
	new
		prod_price = g_businessData[ businessid ] [ E_PRODUCT ] * GetProductPrice( g_businessData[ businessid ] [ E_INTERIOR_TYPE ] ), supply_price = g_businessData[ businessid ] [ E_SUPPLIES ] * GetResupplyPrice( g_businessData[ businessid ] [ E_INTERIOR_TYPE ] );

	// check if its processing
	if ( g_businessData[ businessid ] [ E_PROD_TIMESTAMP ] != 0 && g_businessData[ businessid ] [ E_PROD_TIMESTAMP ] > g_iTime ) {
		format( szBigString, sizeof( szBigString ), ""COL_GREEN"Bank:"COL_WHITE" %s\n"COL_GREEN"Product:"COL_WHITE" %d (%s)\n"COL_GREEN"Supplies:"COL_WHITE" %d (%s)\n"COL_ORANGE"%s until production finishes", ConvertPrice( g_businessData[ businessid ] [ E_BANK ] ), g_businessData[ businessid ] [ E_PRODUCT ], ConvertPrice( prod_price ), g_businessData[ businessid ] [ E_SUPPLIES ], ConvertPrice( supply_price ), secondstotime( g_businessData[ businessid ] [ E_PROD_TIMESTAMP ] - g_iTime, ", ", 5, 0 ) );
	} else {
		format( szBigString, sizeof( szBigString ), ""COL_GREEN"Bank:"COL_WHITE" %s\n"COL_GREEN"Product:"COL_WHITE" %d (%s)\n"COL_GREEN"Supplies:"COL_WHITE" %d (%s)\n"COL_GREEN"Production finished", ConvertPrice( g_businessData[ businessid ] [ E_BANK ] ), g_businessData[ businessid ] [ E_PRODUCT ], ConvertPrice( prod_price ), g_businessData[ businessid ] [ E_SUPPLIES ], ConvertPrice( supply_price ) );
	}

	// update label
	UpdateDynamic3DTextLabelText( g_businessData[ businessid ] [ E_PROD_LABEL ], -1, szBigString );
}

stock UpdateBusinessData( businessid )
{
	new
		members[ 96 ];

    for ( new i = 0; i < MAX_BUSINESS_MEMBERS; i ++ )
    	format( members, sizeof( members ), "%s%d ", members, g_businessData[ businessid ] [ E_MEMBERS ] [ i ] );

	format( szLargeString, sizeof( szLargeString ), "UPDATE `BUSINESSES` SET `OWNER_ID`=%d,`NAME`='%s',`SUPPLIES`=%d,`PRODUCT`=%d,`MEMBERS`='%s',`PROD_TIMESTAMP`=%d,`BANK`=%d WHERE `ID`=%d",
		g_businessData[ businessid ] [ E_OWNER_ID ], mysql_escape( g_businessData[ businessid ] [ E_NAME ] ), g_businessData[ businessid ] [ E_SUPPLIES ], g_businessData[ businessid ] [ E_PRODUCT ],
		members, g_businessData[ businessid ] [ E_PROD_TIMESTAMP ], g_businessData[ businessid ] [ E_BANK ], businessid );

	mysql_single_query( szLargeString );
	return 1;
}

stock DestroyBusiness( businessid )
{
	if ( businessid < 0 || businessid >= MAX_GARAGES )
		return 0;

	if ( !Iter_Contains( business, businessid ) )
	    return 0;

	new
		playerid = GetPlayerIDFromAccountID( g_businessData[ businessid ] [ E_OWNER_ID ] );

	if ( IsPlayerConnected( playerid ) ) {
		p_OwnedBusinesses[ playerid ] --;
	    SendClientMessage( playerid, -1, ""COL_PINK"[BUSINESS]"COL_WHITE" One of your businesses has been destroyed.");
	}

	mysql_single_query( sprintf( "DELETE FROM `BUSINESSES` WHERE `ID`=%d", businessid ) );

	Iter_Remove(business, businessid);
	g_businessData[ businessid ] [ E_OWNER_ID ] = 0;
	DestroyDynamicCP( g_businessData[ businessid ] [ E_ENTER_CP ] );
	DestroyDynamicCP( g_businessData[ businessid ] [ E_EXIT_CP ] );
	DestroyDynamic3DTextLabel( g_businessData[ businessid ] [ E_PROD_LABEL ] );
	DestroyDynamic3DTextLabel( g_businessData[ businessid ] [ E_ENTER_LABEL ] );
	DestroyDynamic3DTextLabel( g_businessData[ businessid ] [ E_EXIT_LABEL ] );
	StopBusinessExportMission( businessid );
	ResetBusiness( businessid );
	return 1;
}

stock GetProductPrice( business_type, bool: hardened = false )
{
	new
		Float: price, player_count = Iter_Count(Player);

	// based on formula : https://i.gyazo.com/af5796ce25aee7c871adcddc5eb0a0ac.png
	// calculate here : https://www.geogebra.org/m/eBHzJyKt
	switch ( business_type )
	{
		// (10,125), (100,350)
		case BUSINESS_WEAPON: price = 111487.4 * floatpower( 1.0115, player_count ); // 111.4874 * 1.0115^x for x in [25, 50, 75, 100, 125, 150]

		// (10,50), (100,140)
		case BUSINESS_COKE: price = 44595.0 * floatpower( 1.0115, player_count ); // 43.2117 * 1.0147^x for x in [25, 50, 75, 100, 125, 150]

		// (10,18), (100,50)
		case BUSINESS_METH: price = 16068.4 * floatpower( 1.0115, player_count ); // 15757.0 * 1.0134^x for x in [25, 50, 75, 100, 125, 150]

		// (10,10), (100,28)
		case BUSINESS_WEED: price = 8919.0 * floatpower( 1.0115, player_count );  // 8.909 * 1.0116^x for x in [25, 50, 75, 100, 125, 150]
	}

	// hardened with chopper, 25% more profit
	if ( hardened )
		price *= 1.25;

	return floatround( price );
}

stock GetResupplyPrice( business_type )
{
	return g_businessInteriorData[ business_type ] [ E_COST_PRICE ];
}

stock ShowBusinessTerminal( playerid )
{
	new
		businessid = p_InBusiness[ playerid ];

	if ( ! Iter_Contains( business, businessid ) )
		return SendError( playerid, "The server can't detect what business you're in. Re-enter the facility." );

	if ( ! IsBusinessAssociate( playerid, businessid ) )
		return SendError( playerid, "You're not an associate of this business." );

	new
		members = GetBusinessAssociates( businessid );

	format( szBigString, sizeof( szBigString ), "Rename Business\t"COL_GREY"%s\nWithdraw Bank Money\t"COL_GREY"%s\nManage Members\t"COL_GREY"%d %s\nSell Inventory\t"COL_GREY"%d product\nResupply Business\t"COL_GREY"%d %s\nBusiness Upgrades\t ",
			g_businessData[ businessid ] [ E_NAME ],
			ConvertPrice( g_businessData[ businessid ] [ E_BANK ] ),
			members, members == 1 ? ( "member" ) : ( "members" ),
			g_businessData[ businessid ] [ E_PRODUCT ],
			g_businessData[ businessid ] [ E_SUPPLIES ], g_businessData[ businessid ] [ E_SUPPLIES ] == 1 ? ( "supply" ) : ( "supplies" )
	);
	return ShowPlayerDialog( playerid, DIALOG_BUSINESS_TERMINAL, DIALOG_STYLE_TABLIST, ""COL_GREY"Business System", szBigString, "Select", "Cancel" );
}

stock ShowBusinessUpgrades( playerid, businessid )
{
	new
		business_type = g_businessData[ businessid ] [ E_INTERIOR_TYPE ];

	format( szBigString, sizeof( szBigString ), "Upgrade Car\t"COL_GREY"%s\nUpgrade Air Vehicle\t"COL_GREY"%s\n",
		GetVehicleName( g_businessData[ businessid ] [ E_CAR_MODEL_ID ] ), GetVehicleName( g_businessData[ businessid ] [ E_HELI_MODEL_ID ] ) );

	format( szBigString, sizeof( szBigString ), "%sUpgrade Production\t"COL_GREEN"%s\nAdd Member Slot\t"COL_GREEN"%s\n", szBigString,
		g_businessData[ businessid ] [ E_UPGRADES ] >= 1 ? ( "MAXED" ) : ( ConvertPrice( g_businessInteriorData[ business_type ] [ E_UPGRADE_COST ] ) ), g_businessData[ businessid ] [ E_EXTRA_MEMBERS ] >= 4 ? ( "MAXED" ) : ( "$500,000" ) );

	format( szBigString, sizeof( szBigString ), "%sAdd Nitrous To Car\t"COL_GREEN"%s\nAdd Gold Rims\t"COL_GREEN"%s\n", szBigString,
		g_businessData[ businessid ] [ E_CAR_NOS ] ? ( "ADDED" ) : ( "$250,000" ), g_businessData[ businessid ] [ E_CAR_RIMS ] ? ( "ADDED" ) : ( "$250,000" ) );

	return ShowPlayerDialog( playerid, DIALOG_BUSINESS_UPGRADES, DIALOG_STYLE_TABLIST, ""COL_GREY"Business System", szBigString, "Select", "Back" );
}

stock IsBusinessAssociate( playerid, businessid )
{
	if ( ! IsPlayerConnected( playerid ) )
		return 0;

	new
		accountid = p_AccountID[ playerid ];

	if ( accountid == 0 )
		return 0;

    for ( new i = 0; i < MAX_BUSINESS_MEMBERS; i ++ )
    	if ( g_businessData[ businessid ] [ E_MEMBERS ] [ i ] == accountid )
    		return 1;

    return g_businessData[ businessid ] [ E_OWNER_ID ] == accountid;
}

stock SetRandomDropoffLocation( playerid, businessid, bool: heli = false )
{
	static const
		Float: g_helicopterSpawns[ 3 ] [ 3 ] [ 4 ] =
		{
			// san fierro
			{ { -1279.6904, -8.909900, 14.4117, 113.0514 }, { -1475.6725, -172.7831, 14.3233, 107.4014 }, { -1480.9645, -561.67210, 14.3281, 224.6014 } },

			// las ventuas
			{ { 1570.4276, 1473.7267, 11.07640, 94.42440 }, { 1551.9801, 1428.9448, 11.03680, 87.83020 }, { 1310.77920, 1400.50050, 11.3766, 214.995 } },

			// los santos
			{ { 1914.0532, -2339.2131, 13.8111, 162.1368 }, { 2023.2230, -2436.9309, 13.7232, 73.29400 }, { 1828.49350, -2420.6563, 13.9001, 121.6646 } }
		}
	;

	static
		szLocation[ MAX_ZONE_NAME ], city_id;

	// figure the city of the business
	Get2DCity( szLocation, g_businessData[ businessid ] [ E_X ], g_businessData[ businessid ] [ E_Y ], g_businessData[ businessid ] [ E_Z ] );

	// assign index
	if ( strmatch( szLocation, "Las Venturas" ) )
		city_id = 1;

	else if ( strmatch( szLocation, "Los Santos" ) )
		city_id = 2;

	else
		city_id = 0;

	// create checkpoints etc
	if ( ! heli )
	{
		new
			Float: nodeX, Float: nodeY, Float: nodeZ, Float: nextX, Float: nextY,
			nodeid = NearestNodeFromPoint( g_businessData[ businessid ] [ E_X ], g_businessData[ businessid ] [ E_Y ], g_businessData[ businessid ] [ E_Z ] ),
			nextNodeid = NearestNodeFromPoint( g_businessData[ businessid ] [ E_X ], g_businessData[ businessid ] [ E_Y ], g_businessData[ businessid ] [ E_Z ], 9999.9, nodeid )
		;

		GetNodePos( nextNodeid, nextX, nextY, nodeZ );
		GetNodePos( nodeid, nodeX, nodeY, nodeZ );

		new
			business_car = GetBusinessCarModelIndex( g_businessData[ businessid ] [ E_CAR_MODEL_ID ] ),
			Float: rotation = atan2( nextY - nodeY, nextX - nodeX ) - 90.0
		;

	   	g_businessVehicle[ businessid ] = CreateVehicle( g_businessCarModelData[ business_car ] [ E_MODEL ], nodeX, nodeY, nodeZ, rotation, 3, 3, -1 );

	   	if ( g_businessCarModelData[ business_car ] [ E_OBJECT_MODEL ] != 0 ) {
			g_businessData[ businessid ] [ E_VEHICLE_DECOR ] = CreateDynamicObject( g_businessCarModelData[ business_car ] [ E_OBJECT_MODEL ], 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 );
			AttachDynamicObjectToVehicle( g_businessData[ businessid ] [ E_VEHICLE_DECOR ], g_businessVehicle[ businessid ], g_businessCarModelData[ business_car ] [ E_O_X ], g_businessCarModelData[ business_car ] [ E_O_Y ], g_businessCarModelData[ business_car ] [ E_O_Z ], g_businessCarModelData[ business_car ] [ E_O_RX ], g_businessCarModelData[ business_car ] [ E_O_RY ], g_businessCarModelData[ business_car ] [ E_O_RZ ] );
	   	}
	   	else g_businessData[ businessid ] [ E_VEHICLE_DECOR ] = INVALID_OBJECT_ID;

	   	// just incase of index bug
	   	if ( g_businessVehicle[ businessid ] )
	   	{
	   		g_isBusinessVehicle[ g_businessVehicle[ businessid ] ] = businessid;

		   	// add nos
		   	if ( g_businessData[ businessid ] [ E_CAR_NOS ] ) {
		   		AddVehicleComponent( g_businessVehicle[ businessid ], 1010 );
		   	}

		   	// gold rim
		   	if ( g_businessData[ businessid ] [ E_CAR_RIMS ] ) {
		   		AddVehicleComponent( g_businessVehicle[ businessid ], 1080 );
		   	}

		   	if ( g_businessCarModelData[ business_car ] [ E_BOOT_OPEN ] ) {
				GetVehicleParamsEx( g_businessVehicle[ businessid ], engine, lights, alarm, doors, bonnet, boot, objective );
				SetVehicleParamsEx( g_businessVehicle[ businessid ], engine, lights, alarm, doors, bonnet, VEHICLE_PARAMS_ON, objective );
		   	}
	   	}

	   	// create new drop locations
		new
			ignore_drop_ids[ sizeof( g_roadBusinessExportData[ ] ) ] = { -1, ... };

		for ( new x = 0; x < MAX_DROPS; x ++ )
		{
			new
				drop_off_index = randomExcept( sizeof( g_roadBusinessExportData[ ] ), ignore_drop_ids, sizeof( ignore_drop_ids ) );

			// so we get random drops always
			ignore_drop_ids[ drop_off_index ] = drop_off_index;

			// clear them incase
			g_businessData[ businessid ] [ E_EXPORTED ] [ x ] = false;
			DestroyDynamicMapIcon( g_businessData[ businessid ] [ E_EXPORT_ICON ] [ x ] );
			DestroyDynamicRaceCP( g_businessData[ businessid ] [ E_EXPORT_CP ] [ x ] );
			DestroyDynamicArea( g_businessData[ businessid ] [ E_EXPORT_CIRCLE ] [ x ] );

			// assign indexes (used for dropping the shit off)
			g_businessData[ businessid ] [ E_EXPORT_CITY ] = city_id;
			g_businessData[ businessid ] [ E_EXPORT_INDEX ] [ x ] = drop_off_index;

			// map icons, cp, areas
			g_businessData[ businessid ] [ E_EXPORT_ICON ] [ x ] = CreateDynamicMapIcon( g_roadBusinessExportData[ city_id ] [ drop_off_index ] [ 0 ], g_roadBusinessExportData[ city_id ] [ drop_off_index ] [ 1 ], g_roadBusinessExportData[ city_id ] [ drop_off_index ] [ 2 ], 19, -1, -1, -1, 0, 6000.0, MAPICON_GLOBAL );
			g_businessData[ businessid ] [ E_EXPORT_CP ] [ x ] = CreateDynamicRaceCP( 1, g_roadBusinessExportData[ city_id ] [ drop_off_index ] [ 0 ], g_roadBusinessExportData[ city_id ] [ drop_off_index ] [ 1 ], g_roadBusinessExportData[ city_id ] [ drop_off_index ] [ 2 ], 0, 0, 0, 5.0, -1, -1, 0 );

		  	// reset players in map icon/cp
		  	Streamer_RemoveArrayData( STREAMER_TYPE_MAP_ICON, g_businessData[ businessid ] [ E_EXPORT_ICON ] [ x ], E_STREAMER_PLAYER_ID, 0 );
		  	Streamer_RemoveArrayData( STREAMER_TYPE_RACE_CP, g_businessData[ businessid ] [ E_EXPORT_CP ] [ x ], E_STREAMER_PLAYER_ID, 0 );

		  	// stream to players
			foreach (new i : Player) if ( IsBusinessAssociate( i, businessid ) ) {
				Streamer_AppendArrayData( STREAMER_TYPE_MAP_ICON, g_businessData[ businessid ] [ E_EXPORT_ICON ] [ x ], E_STREAMER_PLAYER_ID, i );
				Streamer_AppendArrayData( STREAMER_TYPE_RACE_CP, g_businessData[ businessid ] [ E_EXPORT_CP ] [ x ], E_STREAMER_PLAYER_ID, i );
			}
		}

		// alert player
		ShowPlayerHelpDialog( playerid, 5000, "Exit the facility and enter the business vehicle marked outside." );
		SendGlobalMessage( COLOR_GREY, "[BUSINESS]"COL_WHITE" %s(%d) has begun transporting "COL_GOLD"%s"COL_WHITE" of business product!", ReturnPlayerName( playerid ), playerid, ConvertPrice( g_businessData[ businessid ] [ E_EXPORT_VALUE ] * ( MAX_DROPS - g_businessData[ businessid ] [ E_EXPORTED_AMOUNT ] ) ) );
	}
	else
	{
		// create the heli
		new
			business_heli = GetBusinessAirModelIndex( g_businessData[ businessid ] [ E_HELI_MODEL_ID ] ),
			random_index = random( sizeof( g_helicopterSpawns[ ] ) )
		;

	   	g_businessVehicle[ businessid ] = CreateVehicle( g_businessAirModelData[ business_heli ] [ E_MODEL ], g_helicopterSpawns[ city_id ] [ random_index ] [ 0 ], g_helicopterSpawns[ city_id ] [ random_index ] [ 1 ], g_helicopterSpawns[ city_id ] [ random_index ] [ 2 ],  g_helicopterSpawns[ city_id ] [ random_index ] [ 3 ], -1, -1, -1 );

	   	if ( g_businessVehicle[ businessid ] ) 	{
	   		g_isBusinessVehicle[ g_businessVehicle[ businessid ] ] = businessid;
	   	}

		// map icon to heli
		g_businessData[ businessid ] [ E_EXPORT_ICON ] [ 0 ] = CreateDynamicMapIcon( g_helicopterSpawns[ city_id ] [ random_index ] [ 0 ], g_helicopterSpawns[ city_id ] [ random_index ] [ 1 ], g_helicopterSpawns[ city_id ] [ random_index ] [ 2 ], 5, -1, -1, -1, 0, 6000.0, MAPICON_GLOBAL );

		// reset players in map icon/cp
	  	Streamer_RemoveArrayData( STREAMER_TYPE_MAP_ICON, g_businessData[ businessid ] [ E_EXPORT_ICON ] [ 0 ], E_STREAMER_PLAYER_ID, 0 );

	  	// stream to players
		foreach (new i : Player) if ( IsBusinessAssociate( i, businessid ) ) {
			Streamer_AppendArrayData( STREAMER_TYPE_MAP_ICON, g_businessData[ businessid ] [ E_EXPORT_ICON ] [ 0 ], E_STREAMER_PLAYER_ID, i );
		}

		// destroy cp, unnused
		DestroyDynamicRaceCP( g_businessData[ businessid ] [ E_EXPORT_CP ] [ 0 ] ), g_businessData[ businessid ] [ E_EXPORT_CP ] [ 0 ] = -1;

		// alert
		ShowPlayerHelpDialog( playerid, 5000, "Exit the facility and go to your local airport." );
	}
	return 1;
}

stock StopBusinessExportMission( businessid )
{
	new
		vehicleid = g_businessVehicle[ businessid ], modelid = GetVehicleModel( vehicleid );

	// reset variables
	for ( new i = 0; i < MAX_DROPS; i ++ ) {
		g_businessData[ businessid ] [ E_EXPORTED ] [ i ] = false;
		DestroyDynamicMapIcon( g_businessData[ businessid ] [ E_EXPORT_ICON ] [ i ] ), g_businessData[ businessid ] [ E_EXPORT_ICON ] [ i ] = -1;
		DestroyDynamicRaceCP( g_businessData[ businessid ] [ E_EXPORT_CP ] [ i ] ), g_businessData[ businessid ] [ E_EXPORT_CP ] [ i ] = -1;
		DestroyDynamicArea( g_businessData[ businessid ] [ E_EXPORT_CIRCLE ] [ i ] ), g_businessData[ businessid ] [ E_EXPORT_CIRCLE ] [ i ] = -1;
	}

	// export stop
	g_businessData[ businessid ] [ E_EXPORT_STARTED ] = 0;
	g_businessData[ businessid ] [ E_EXPORTED_AMOUNT ] = 0;

	// destroy vehicle
	DestroyVehicle( g_businessVehicle[ businessid ] ), g_businessVehicle[ businessid ] = INVALID_VEHICLE_ID;
	DestroyDynamicObject( g_businessData[ businessid ] [ E_VEHICLE_DECOR ] ), g_businessData[ businessid ] [ E_VEHICLE_DECOR ] = INVALID_OBJECT_ID;

	// reset vehicle variable if needed
	if ( vehicleid != INVALID_VEHICLE_ID )
		g_isBusinessVehicle[ vehicleid ] = -1;

	// slap the player in the heli high and stop the mission
	foreach (new playerid : Player) if ( IsPlayerInVehicle( playerid, vehicleid ) && IsBusinessAerialVehicle( businessid, modelid ) ) {
		SyncObject( playerid, 0.0, 0.0, 250.0 );
		GivePlayerWeapon( playerid, 46, 1 );
	}
}

public OnVehicleStreamIn(vehicleid, forplayerid)
{
	if ( g_isBusinessVehicle[ vehicleid ] != -1 && Iter_Contains( business, g_isBusinessVehicle[ vehicleid ] ) )
	{
		// new businessid = g_isBusinessVehicle[ vehicleid ];
		// if ( IsBusinessAssociate( forplayerid, businessid ) )
		SetVehicleParamsForPlayer( vehicleid, forplayerid, 1, 0 );
	}
    return 1;
}

public OnVehicleStreamOut(vehicleid, forplayerid)
{
	return 1;
}

stock randomExcept( end, except[ ], len = sizeof( except ) ) {

    new
        random_number = random( end );

    for ( new x = 0; x < len; x ++ ) {
        if ( random_number == except[ x ] ) {
            return randomExcept( end, except, len );
        }
    }
    return random_number;
}

function DestroyDrugObject( objectid )
	return DestroyDynamicObject( objectid ), 1;

stock SellBusinessProduct( playerid, businessid, locationid )
{
	// destroy checkpoint
	g_businessData[ businessid ] [ E_EXPORTED ] [ locationid ] = true;
	DestroyDynamicMapIcon( g_businessData[ businessid ] [ E_EXPORT_ICON ] [ locationid ] ), g_businessData[ businessid ] [ E_EXPORT_ICON ] [ locationid ] = -1;
	DestroyDynamicRaceCP( g_businessData[ businessid ] [ E_EXPORT_CP ] [ locationid ] ), g_businessData[ businessid ] [ E_EXPORT_CP ] [ locationid ] = -1;
	DestroyDynamicArea( g_businessData[ businessid ] [ E_EXPORT_CIRCLE ] [ locationid ] ), g_businessData[ businessid ] [ E_EXPORT_CIRCLE ] [ locationid ] = -1;

	// count drugs exported
	new
		drugsSold = ++ g_businessData[ businessid ] [ E_EXPORTED_AMOUNT ];

	// award business
	new
		product_amount = g_businessData[ businessid ] [ E_EXPORT_VALUE ];

	g_businessData[ businessid ] [ E_BANK ] += product_amount;
	UpdateBusinessData( businessid );
	UpdateBusinessProductionLabel( businessid );

	GivePlayerScore( playerid, 2 );
	GivePlayerWantedLevel( playerid, 6 );
	SendServerMessage( playerid, "You have successfully exported "COL_GOLD"%s"COL_WHITE" worth of product. "COL_ORANGE"(%d/%d)", ConvertPrice( product_amount ), drugsSold, MAX_DROPS );

	// calculate if it was the last batch
	if ( drugsSold == MAX_DROPS )
	{
		new
			business_type = g_businessData[ businessid ] [ E_INTERIOR_TYPE ],
			profit = ( product_amount - g_businessInteriorData[ business_type ] [ E_COST_PRICE ] ) * MAX_DROPS
		;

		// P&L
		SendServerMessage( playerid, "You have completed selling all business product. Total profit %s%s"COL_WHITE".", profit > 0 ? ( COL_GREEN ) : ( COL_RED ), ConvertPrice( profit ) );

		// Destroy checkpoint and vehicle
		StopBusinessExportMission( businessid );
	}

	// just send alerts fuck it
	SendGlobalMessage( COLOR_GREY, "[BUSINESS]"COL_WHITE" %s(%d) has dropped off their %d%s batch of drugs for "COL_GOLD"%s"COL_WHITE"!", ReturnPlayerName( playerid ), playerid, drugsSold, positionToString( drugsSold ), ConvertPrice( product_amount ) );
}

stock ShowBusinessMembers( playerid, businessid )
{
	new
		szMembers[ 96 ] = "0";

	for ( new i = 0; i < MAX_BUSINESS_MEMBERS; i ++ ) if ( g_businessData[ businessid ] [ E_MEMBERS ] [ i ] != 0 ) {
		format( szMembers, sizeof( szMembers ), "%s,%d", szMembers, g_businessData[ businessid ] [ E_MEMBERS ] [ i ] );
	}

	format( szBigString, sizeof( szBigString ), "SELECT `NAME` FROM `USERS` WHERE `ID` IN (%s)", szMembers );
	mysql_function_query( dbHandle, szBigString, true, "OnShowBusinessMembers", "dd", playerid, businessid );
	return 1;
}

function OnShowBusinessMembers( playerid, businessid )
{
	new
		rows, fields, member[ MAX_PLAYER_NAME ];

	cache_get_data( rows, fields );

	if ( rows )
	{
		szBigString = ""COL_GREY"Add a new member...\n";

    	for( new i = 0; i < rows; i++ )
		{
			// get member name
			cache_get_field_content( i, "NAME", member, sizeof( member ) );
			format( szBigString, sizeof( szBigString ), "%s%s\n", szBigString, member );
		}

		ShowPlayerDialog( playerid, DIALOG_BUSINESS_MEMBERS, DIALOG_STYLE_LIST, ""COL_GREY"Business System", szBigString, "Kick", "Back" );
	}
	else
	{
		SendServerMessage( playerid, "Couldn't find any members for the business, add one if you desire." );
		ShowPlayerDialog( playerid, DIALOG_BUSINESS_ADD_MEMBER, DIALOG_STYLE_INPUT, ""COL_GREY"Business System", ""COL_WHITE"Type the name of the player you wish to add as a member.", "Add", "Back" );
	}
}

stock CheckPendingBusiness( playerid )
{
	foreach (new businessid : business) if ( g_businessData[ businessid ] [ E_EXPORT_STARTED ] && IsBusinessAssociate( playerid, businessid ) ) {

		new
			members = 0;

		foreach (new i : Player) if ( playerid != i && IsBusinessAssociate( i, businessid ) ) {
			members ++;
		}

		printf ("%d online players for business %d, stopping mission?", members, businessid );
		if ( members <= 0 ) {
			print( "stopped" );
			StopBusinessExportMission( businessid );
		}
	}
}

#if ENABLE_DISCORD == false
stock DCC_SendChannelMessage( DCC_Channel: channel, const message[ ] ) {
	#pragma unused channel
	#pragma unused message
	return 1;
}
stock DCC_SendUserMessage( DCC_User: user, const message[ ] )
{
	#pragma unused user
	#pragma unused message
	return 1;
}
#else
stock DCC_SendUserMessage( DCC_User: user, const message[ ] )
{
	static
		user_id[ 64 ];

	DCC_GetUserId( user, user_id, sizeof( user_id ) );
	format( szBigString, sizeof( szBigString ), "<@%s> ... %s", user_id, message );
	return DCC_SendChannelMessage( discordSpamChan, szBigString );
}
#endif

stock GetBusinessCarModelIndex( modelid ) {
	new
		index = 0;

	for( new i = 0; i < sizeof( g_businessCarModelData ); i ++ ) if ( g_businessCarModelData[ i ] [ E_MODEL ] == modelid ) {
		index = i;
		break;
	}
	return index;
}

stock GetBusinessAirModelIndex( modelid ) {
	new
		index = 0;

	for( new i = 0; i < sizeof( g_businessAirModelData ); i ++ ) if ( g_businessAirModelData[ i ] [ E_MODEL ] == modelid ) {
		index = i;
		break;
	}
	return index;
}

stock CreateBlackjackTable( payout, Float: X, Float: Y, Float: Z, Float: Angle, world = 0 )
{
    new
        id = Iter_Free(blackjacktables);

    if ( id != ITER_NONE )
    {
        g_blackjackData[ id ] [ E_X ] = X;
        g_blackjackData[ id ] [ E_Y ] = Y;
        g_blackjackData[ id ] [ E_Z ] = Z;
        g_blackjackData[ id ] [ E_ROTATION ] = Angle;

        g_blackjackData[ id ] [ E_GAME_TIMER ] = -1;
        g_blackjackData[ id ] [ E_PAYOUT ] = payout;
        g_blackjackData[ id ] [ E_OBJECT ] = CreateDynamicObject( 2188, X, Y, Z, 0.00000, 0.00000, Angle );
        g_blackjackData[ id ] [ E_ACTOR ] = CreateActor( 171, X - 0.4 * floatcos( Angle - 90.0, degrees ), Y - 0.4 * floatsin( Angle - 90.0, degrees ), Z, Angle + 180.0 );
        CreateDynamic3DTextLabel( sprintf( "Press ENTER to use\n"COL_WHITE"%s Minimum", ConvertPrice( payout ) ), COLOR_GREY, X, Y, Z + 0.25, 15.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, .testlos = 0 );

		SetActorInvulnerable( g_blackjackData[ id ] [ E_ACTOR ], true );
		SetActorVirtualWorld( g_blackjackData[ id ] [ E_ACTOR ], world );

        ResetBlackjackTable( id );
        Iter_Add( blackjacktables, id );
    }
    return 1;
}

function DrawPlayerBlackjackCard( tableid, player_index )
{
    new
        randomCard = random( sizeof( g_blackjackDealerCards ) );

    for ( new cardid = 0; cardid < MAX_BLACKJACK_CARDS; cardid ++ ) if ( g_blackjackPlayerCardIndex[ tableid ] [ cardid ] [ player_index ] == -1 ) {
        TextDrawSetString( g_blackjackPlayerCards[ tableid ] [ cardid ] [ player_index ], g_cardTextdrawData[ randomCard ] );
        foreach (new gamerid : Player) if ( p_blackjackTable[ gamerid ] == tableid ) {
        	TextDrawShowForPlayer( gamerid, g_blackjackPlayerCards[ tableid ] [ cardid ] [ player_index ] );
    		PlayerPlaySound( gamerid, 1145, 0.0, 0.0, 0.0 );
        }
        g_blackjackPlayerCardIndex[ tableid ] [ cardid ] [ player_index ] = randomCard;
        break;
    }
    return randomCard;
}

function BeginBlackJackTurn( tableid )
{
    new
        cardid = g_blackjackData[ tableid ] [ E_CARDS_DRAWN ] ++;

    if ( cardid >= MAX_BLACKJACK_CARDS ) {
        ResetBlackjackTable( tableid );
        return;
    }

    new
        randomCard = random( sizeof( g_blackjackDealerCards ) );

    // dealer cards
    ApplyActorAnimation( g_blackjackData[ tableid ] [ E_ACTOR ], "CASINO", "dealone", 4.1, 0, 0, 0, 0, 0 );
    ApplyActorAnimation( g_blackjackData[ tableid ] [ E_ACTOR ], "CASINO", "dealone", 4.1, 0, 0, 0, 0, 0 );
    TextDrawSetString( g_blackjackDealerCards[ tableid ] [ cardid ], g_cardTextdrawData[ randomCard ] );
    g_blackjackDealerCardIndex[ tableid ] [ cardid ] = randomCard;

    // noise
    foreach (new gamerid : Player) if ( p_blackjackTable[ gamerid ] != -1 ) {
    	PlayerPlaySound( gamerid, 1145, 0.0, 0.0, 0.0 );
    }

    // deal player first card
    if ( cardid == 0 )
    {
    	new
    		bet_amount = 0;

        for ( new player_index = 0; player_index < MAX_BLACKJACK_PLAYERS; player_index ++ ) if ( g_blackjackSlotData[ tableid ] [ player_index ] != -1 )
        {
            new
                gamerid = g_blackjackSlotData[ tableid ] [ player_index ];

            if ( GetPlayerCash( gamerid ) < g_blackjackData[ tableid ] [ E_PAYOUT ] ) {
                SendError( gamerid, "You don't have any money to wager." );
                RemovePlayerFromBlackjack( gamerid, .reset_cam = 1 );
                continue;
            }

            bet_amount += g_blackjackData[ tableid ] [ E_PAYOUT ];
            GivePlayerCash( gamerid, -g_blackjackData[ tableid ] [ E_PAYOUT ] );
            DrawPlayerBlackjackCard( tableid, player_index );
            if ( cardid < 1 ) { // distribute first two cards to players
               SetTimerEx( "DrawPlayerBlackjackCard", BLACKJACK_DEALER_WAIT, false, "dd", tableid, player_index );
            }
        }

		UpdateServerVariable( "blackjack_bets", 0, GetGVarFloat( "blackjack_bets" ) + ( float( bet_amount ) / 1000000.0 ), "", GLOBAL_VARTYPE_FLOAT );

        // begin turns
        new
            first_player = GetNextAvailableBlackjackPlayer( tableid ),
            first_player_index = GetBlackjackPlayerIndex( tableid, first_player )
        ;

        if ( first_player_index != -1 )
        	g_blackjackPlayerState[ tableid ] [ first_player_index ] = BLACKJACK_STATE_TURN;

        g_blackjackData[ tableid ] [ E_GAME_TIMER ] = SetTimerEx( "BlackjackPlayerTurn", BLACKJACK_DEALER_WAIT + 500, false, "ddd", tableid, first_player, BLACKJACK_PLAYER_WAIT );
    }

    // check for blackjack on players & bot
    new
        dealer_score = CheckForBlackjack( tableid );

    // pull more cards
    if ( cardid >= 1 && dealer_score < 17 )
        g_blackjackData[ tableid ] [ E_GAME_TIMER ] = SetTimerEx( "BeginBlackJackTurn", BLACKJACK_DEALER_WAIT, false, "d", tableid );

    if ( dealer_score >= 17 ) {
        SendClientMessageToBlackjack( tableid, COLOR_GREY, "[BLACKJACK]"COL_WHITE" Table will reset in 5 seconds as all hands have been dealt." );
        SetTimerEx( "ResetBlackjackTable", 5000, false, "d", tableid );
    }
}

stock GetNextAvailableBlackjackPlayer( tableid, exclude = INVALID_PLAYER_ID )
{
    new
        playerid = INVALID_PLAYER_ID;

    for ( new player_index = 0; player_index < MAX_BLACKJACK_PLAYERS; player_index ++ ) if ( g_blackjackSlotData[ tableid ] [ player_index ] != -1 && g_blackjackPlayerState[ tableid ] [ player_index ] == BLACKJACK_STATE_NONE && exclude != g_blackjackSlotData[ tableid ] [ player_index ] && g_blackjackPlayerCardIndex[ tableid ] [ 0 ] [ player_index ] != -1 ) {
        playerid = g_blackjackSlotData[ tableid ] [ player_index ];
        break;
    }
    return playerid;
}

function BlackjackPlayerTurn( tableid, playerid, seconds_left )
{
    new
        player_index = GetBlackjackPlayerIndex( tableid, playerid );

    if ( IsPlayerConnected( playerid ) && player_index != -1 && seconds_left >= 0 && g_blackjackPlayerState[ tableid ] [ player_index ] == BLACKJACK_STATE_TURN )
    {
        foreach (new gamerid : Player) if ( p_blackjackTable[ gamerid ] == tableid ) {
            TextDrawSetString( g_blackjackTurnTD[ tableid ], sprintf( "%s has %d seconds left", ReturnPlayerName( playerid ), seconds_left ) );
            TextDrawShowForPlayer( gamerid, g_blackjackTurnTD[ tableid ] );
        }
        g_blackjackData[ tableid ] [ E_GAME_TIMER ] = SetTimerEx( "BlackjackPlayerTurn", 960, false, "ddd", tableid, playerid, seconds_left - 1 );
    }
    else
    {
        new
            next_player = GetNextAvailableBlackjackPlayer( tableid, playerid );

        if ( next_player == INVALID_PLAYER_ID )
        {
            TextDrawHideForAll( g_blackjackTurnTD[ tableid ] );
            g_blackjackData[ tableid ] [ E_GAME_TIMER ] = SetTimerEx( "BeginBlackJackTurn", BLACKJACK_DEALER_WAIT, false, "d", tableid );
        }
        else
        {
            new
                next_player_index  = GetBlackjackPlayerIndex( tableid, next_player );

           	// otherwise winning hands will get reissued prizes
            if ( player_index != -1 && g_blackjackPlayerState[ tableid ] [ player_index ] != BLACKJACK_STATE_WIN && g_blackjackPlayerState[ tableid ] [ player_index ] != BLACKJACK_STATE_BUST )
            	g_blackjackPlayerState[ tableid ] [ player_index ] = BLACKJACK_STATE_STAND;

            g_blackjackPlayerState[ tableid ] [ next_player_index ] = BLACKJACK_STATE_TURN;
            g_blackjackData[ tableid ] [ E_GAME_TIMER ] = SetTimerEx( "BlackjackPlayerTurn", 960, false, "ddd", tableid, next_player, BLACKJACK_PLAYER_WAIT );
        }
    }
}

function ResetBlackjackTable( tableid )
{
	if ( tableid == -1 )
		return;

    // variables
    KillTimer( g_blackjackData[ tableid ] [ E_GAME_TIMER ] ), g_blackjackData[ tableid ] [ E_GAME_TIMER ] = -1;
    g_blackjackData[ tableid ] [ E_CARDS_DRAWN ] = 0;

    // card data
    for ( new c = 0; c < MAX_BLACKJACK_CARDS; c ++ ) {
        g_blackjackDealerCardIndex[ tableid ] [ c ] = -1;
        TextDrawSetString( g_blackjackDealerCards[ tableid ] [ c ], "ld_card:cdback" );

        for ( new p = 0; p < MAX_BLACKJACK_PLAYERS; p ++ ) {
            g_blackjackPlayerState[ tableid ] [ p ] = BLACKJACK_STATE_NONE;
            g_blackjackPlayerCardIndex[ tableid ] [ c ] [ p ] = -1;
            TextDrawSetString( g_blackjackPlayerCards[ tableid ] [ c ] [ p ], "ld_card:cdback" );
            if ( c > 1 ) TextDrawHideForAll( g_blackjackPlayerCards[ tableid ] [ c ] [ p ] );
        }
    }

    // reshow textdraws to players
    for ( new player_index = 0; player_index < MAX_BLACKJACK_PLAYERS; player_index ++ ) if ( g_blackjackSlotData[ tableid ] [ player_index ] != -1 )
    {
        new
            gamerid = g_blackjackSlotData[ tableid ] [ player_index ];

        // deal only first two cards
        for ( new c = 0; c < MAX_BLACKJACK_CARDS; c ++ )
        {
            TextDrawShowForPlayer( gamerid, g_blackjackDealerCards[ tableid ] [ c ] );

            // show two player cards only
            if ( c >= 2 )
                continue;

            for ( new p = 0; p < GetBlackjackPlayers( tableid ); p ++ ) {
                TextDrawShowForPlayer( gamerid, g_blackjackPlayerCards[ tableid ] [ c ] [ p ] );
            }
        }
    }
}

stock CheckForBlackjack( tableid )
{
    new
        dealer_score = 0;

    //if ( g_blackjackData[ tableid ] [ E_CARDS_DRAWN ] <= 1 )
    //    return dealer_score;

    // calculate dealer score
    for ( new c = 0; c < MAX_BLACKJACK_CARDS; c ++ ) if ( g_blackjackDealerCardIndex[ tableid ] [ c ] != -1 )
    {
        new
            card_value = GetBlackjackCardValue( g_blackjackDealerCardIndex[ tableid ] [ c ] );

        // printf("%d Card = %d", c, card_value);

        if ( card_value == 1 ) {
            if ( dealer_score >= 11 ) dealer_score += 1;
            else dealer_score += 11;
        }
        else dealer_score += card_value;
    }
    //printf("The Dealer score is %d", dealer_score );

    // calculate player score
    for ( new player_index = 0; player_index < MAX_BLACKJACK_PLAYERS; player_index ++ ) if ( g_blackjackSlotData[ tableid ] [ player_index ] != -1 && g_blackjackPlayerCardIndex[ tableid ] [ 0 ] [ player_index ] != -1 )
    {
        new
            playerid = g_blackjackSlotData[ tableid ] [ player_index ], player_score = 0;

		for ( new c = 0; c < MAX_BLACKJACK_CARDS; c ++ ) if ( g_blackjackPlayerCardIndex[ tableid ] [ c ] [ player_index ] != -1 )
	    {
	        new
	            card_value = GetBlackjackCardValue( g_blackjackPlayerCardIndex[ tableid ] [ c ] [ player_index ] );

	        if ( card_value == 1 ) {
	            if ( player_score >= 11 ) player_score += 1;
	            else player_score += 11;
	        }
	        else player_score += card_value;
	    }

        if ( g_blackjackPlayerState[ tableid ] [ player_index ] != BLACKJACK_STATE_BUST && g_blackjackPlayerState[ tableid ] [ player_index ] != BLACKJACK_STATE_WIN  )
        {
            new
                payout = floatround( float( g_blackjackData[ tableid ] [ E_PAYOUT ] ) * 2.0 );

            // check for win
       		if ( dealer_score == player_score && dealer_score >= 17 ) {
       			payout = g_blackjackData[ tableid ] [ E_PAYOUT ];
                g_blackjackPlayerState[ tableid ] [ player_index ] = BLACKJACK_STATE_WIN;
                SendClientMessageToBlackjack( tableid, COLOR_GREY, "[BLACKJACK]"COL_WHITE" %s(%d) has been returned %s due to a push.", ReturnPlayerName( playerid ), playerid, ConvertPrice( payout ) );
		 		GameTextForPlayer( playerid, sprintf( "~n~~n~~g~%s won!", ConvertPrice( payout ) ), 4000, 3 );
                GivePlayerCash( playerid, payout );
            }
            else if ( player_score == 21 ) {
                g_blackjackPlayerState[ tableid ] [ player_index ] = BLACKJACK_STATE_WIN;
                if ( IsPlayerHandBlackjack( tableid, player_index, player_score ) ) {
	                payout = floatround( float( g_blackjackData[ tableid ] [ E_PAYOUT ] ) * 2.5 );
	                SendClientMessageToBlackjack( tableid, COLOR_GREY, "[BLACKJACK]"COL_WHITE" Blackjack! %s(%d) has won %s!", ReturnPlayerName( playerid ), playerid, ConvertPrice( payout ) );
                } else {
	                SendClientMessageToBlackjack( tableid, COLOR_GREY, "[BLACKJACK]"COL_WHITE" %s(%d) has won %s due to a card count of 21!", ReturnPlayerName( playerid ), playerid, ConvertPrice( payout ) );
                }
		 		GameTextForPlayer( playerid, sprintf( "~n~~n~~g~%s won!", ConvertPrice( payout ) ), 4000, 3 );
                GivePlayerCash( playerid, payout );
            }
            else if ( dealer_score == 21 ) {
                g_blackjackPlayerState[ tableid ] [ player_index ] = BLACKJACK_STATE_BUST;
                SendClientMessageToBlackjack( tableid, COLOR_GREY, "[BLACKJACK]"COL_WHITE" %s(%d) has lost %s due to a dealer %s.", ReturnPlayerName( playerid ), playerid, ConvertPrice( g_blackjackData[ tableid ] [ E_PAYOUT ] ), IsDealerHandBlackjack( tableid, dealer_score ) ? ( "blackjack" ) : ( "21" ) );
		 		GameTextForPlayer( playerid, "~n~~n~~r~No win!", 4000, 3 );
            }
            else if ( player_score > 21 ) {
                g_blackjackPlayerState[ tableid ] [ player_index ] = BLACKJACK_STATE_BUST;
                SendClientMessageToBlackjack( tableid, COLOR_GREY, "[BLACKJACK]"COL_WHITE" %s(%d) has lost %s due to a bust.", ReturnPlayerName( playerid ), playerid, ConvertPrice( g_blackjackData[ tableid ] [ E_PAYOUT ] ) );
		 		GameTextForPlayer( playerid, "~n~~n~~r~No win!", 4000, 3 );
            }
            else if ( dealer_score > 21 ) {
                g_blackjackPlayerState[ tableid ] [ player_index ] = BLACKJACK_STATE_WIN;
                SendClientMessageToBlackjack( tableid, COLOR_GREY, "[BLACKJACK]"COL_WHITE" %s(%d) has won %s due to a dealer bust.", ReturnPlayerName( playerid ), playerid, ConvertPrice( payout ) );
		 		GameTextForPlayer( playerid, sprintf( "~n~~n~~g~%s won!", ConvertPrice( payout ) ), 4000, 3 );
                GivePlayerCash( playerid, payout );
            }
            else if ( player_score < dealer_score && dealer_score >= 17 ) {
                g_blackjackPlayerState[ tableid ] [ player_index ] = BLACKJACK_STATE_BUST;
                SendClientMessageToBlackjack( tableid, COLOR_GREY, "[BLACKJACK]"COL_WHITE" %s(%d) has lost %s due to a bust.", ReturnPlayerName( playerid ), playerid, ConvertPrice( g_blackjackData[ tableid ] [ E_PAYOUT ] ) );
		 		GameTextForPlayer( playerid, "~n~~n~~r~No win!", 4000, 3 );
            }
            else if ( player_score > dealer_score && dealer_score >= 17 ) {
                g_blackjackPlayerState[ tableid ] [ player_index ] = BLACKJACK_STATE_WIN;
                SendClientMessageToBlackjack( tableid, COLOR_GREY, "[BLACKJACK]"COL_WHITE" %s(%d) has won %s due to a dealer bust.", ReturnPlayerName( playerid ), playerid, ConvertPrice( g_blackjackData[ tableid ] [ E_PAYOUT ] ) );
		 		GameTextForPlayer( playerid, sprintf( "~n~~n~~g~%s won!", ConvertPrice( payout ) ), 4000, 3 );
                GivePlayerCash( playerid, payout );
            }

            // alert world
			if ( g_blackjackPlayerState[ tableid ] [ player_index ] == BLACKJACK_STATE_WIN && payout > g_blackjackData[ tableid ] [ E_PAYOUT ] && payout >= 10000 ) {
				UpdateServerVariable( "blackjack_wins", 0, GetGVarFloat( "blackjack_wins" ) + ( float( payout ) / 1000000.0 ), "", GLOBAL_VARTYPE_FLOAT );
				SendGlobalMessage( -1, ""COL_GREY"[CASINO]{FFFFFF} %s(%d) has won "COL_GOLD"%s"COL_WHITE" from blackjack!", ReturnPlayerName( playerid ), playerid, ConvertPrice( payout ) );
			}
        }
    }
    return dealer_score;
}

stock RemovePlayerFromBlackjack( playerid, reset_cam = 0 )
{
    new
        blackjack_table = p_blackjackTable[ playerid ];

    if ( blackjack_table == -1 )
        return 0;

    // hide textdraws & reset
    for ( new c = 0; c < MAX_BLACKJACK_CARDS; c ++ ) {
        TextDrawHideForPlayer( playerid, g_blackjackDealerCards[ blackjack_table ] [ c ] );

        for ( new p = 0; p < MAX_BLACKJACK_PLAYERS; p ++ ) {
            TextDrawHideForPlayer( playerid, g_blackjackPlayerCards[ blackjack_table ] [ c ] [ p ] );
        }
    }
  	TextDrawHideForPlayer( playerid, g_blackjackTurnTD[ blackjack_table ] );

    // check if it is a player
    new
        player_index = GetBlackjackPlayerIndex( blackjack_table, playerid );

    if ( player_index != -1 )
    {
        foreach (new i : Player) if ( p_blackjackTable[ i ] == blackjack_table ) {
            for ( new c = 0; c < MAX_BLACKJACK_CARDS; c ++ ) {
                g_blackjackPlayerCardIndex[ blackjack_table ] [ c ] [ player_index ] = -1;
                g_blackjackPlayerState[ blackjack_table ] [ player_index ] = BLACKJACK_STATE_NONE;
                TextDrawSetString( g_blackjackPlayerCards[ blackjack_table ] [ c ] [ player_index ], "ld_card:cdback" );
                TextDrawHideForPlayer( i, g_blackjackPlayerCards[ blackjack_table ] [ c ] [ player_index ] );
            }
        }
        g_blackjackSlotData[ blackjack_table ] [ player_index ] = -1;
    }

    // reset camera?
    if ( reset_cam ) {
        TogglePlayerControllable( playerid, 1 );
        ClearAnimations( playerid );
        SetCameraBehindPlayer( playerid );
        HidePlayerHelpDialog( playerid );
    }

    // reset variables
    p_blackjackTable[ playerid ] = -1;

    // reset table just incase empty
    if ( GetBlackjackPlayers( blackjack_table ) <= 0 )
		ResetBlackjackTable( blackjack_table );

    return 1;
}

stock SendClientMessageToBlackjack( tableid, colour, format[ ], va_args<> )
{
    static
        out[ 144 ];

    va_format( out, sizeof( out ), format, va_start<3> );

    for(new i = 0; i < 10; i++) if ( p_blackjackTable[ i ] == tableid ) {
        SendClientMessage( i, colour, out );
    }
    return 1;
}

stock initializeBlackjackTextdraws( id )
{
    g_blackjackTurnTD[ id ] = TextDrawCreate(330.000000, 204.000000, "Lorenc has 5 seconds");
    TextDrawAlignment(g_blackjackTurnTD[ id ], 2);
    TextDrawBackgroundColor(g_blackjackTurnTD[ id ], 255);
    TextDrawFont(g_blackjackTurnTD[ id ], 1);
    TextDrawLetterSize(g_blackjackTurnTD[ id ], 0.260000, 1.200000);
    TextDrawColor(g_blackjackTurnTD[ id ], 16711935);
    TextDrawSetOutline(g_blackjackTurnTD[ id ], 1);
    TextDrawSetProportional(g_blackjackTurnTD[ id ], 1);

    for ( new c = 0; c < MAX_BLACKJACK_CARDS; c ++ )
    {
        g_blackjackDealerCards[ id ] [ c ] = TextDrawCreate(243.000000 + 35.0 * float( c ), 138.000000, "ld_card:cdback");
        TextDrawBackgroundColor( g_blackjackDealerCards[ id ] [ c ], 255);
        TextDrawFont( g_blackjackDealerCards[ id ] [ c ], 4);
        TextDrawLetterSize( g_blackjackDealerCards[ id ] [ c ], 0.500000, 1.000000);
        TextDrawUseBox( g_blackjackDealerCards[ id ] [ c ], 1);
        TextDrawBoxColor( g_blackjackDealerCards[ id ] [ c ], 255);
        TextDrawTextSize( g_blackjackDealerCards[ id ] [ c ], 30.000000, 51.000000);
    }

    new
        Float: g_blackjackPlayerPosition[ MAX_BLACKJACK_PLAYERS ] [ 2 ] = { { 295.0, 334.0 }, { 205.0, 319.0 }, { 390.0, 329.0 } };

    for ( new c = 0; c < MAX_BLACKJACK_CARDS; c ++ )
    {
        for ( new p = 0; p < MAX_BLACKJACK_PLAYERS; p ++ )
        {
            g_blackjackPlayerCards[ id ] [ c ] [ p ] = TextDrawCreate( g_blackjackPlayerPosition[ p ] [ 0 ] + 10.0 * float( c ), g_blackjackPlayerPosition[ p ] [ 1 ] - 16.0 * float( c ), "ld_card:cdback" );
            TextDrawBackgroundColor( g_blackjackPlayerCards[ id ] [ c ] [ p ], 255 );
            TextDrawFont( g_blackjackPlayerCards[ id ] [ c ] [ p ], 4 );
            TextDrawLetterSize( g_blackjackPlayerCards[ id ] [ c ] [ p ], 0.5, 0.7 );
            TextDrawUseBox( g_blackjackPlayerCards[ id ] [ c ] [ p ], 1 );
            TextDrawBoxColor( g_blackjackPlayerCards[ id ] [ c ] [ p ], 255 );
            TextDrawTextSize( g_blackjackPlayerCards[ id ] [ c ] [ p ], 22.000000, 37.000000 );
        }
    }
}

stock IsPlayerHandBlackjack( tableid, player_index, card_count )
{
	if ( card_count == 21 && ( g_blackjackPlayerCardIndex[ tableid ] [ 0 ] [ player_index ] == 0 || g_blackjackPlayerCardIndex[ tableid ] [ 0 ] [ player_index ] == 13 || g_blackjackPlayerCardIndex[ tableid ] [ 0 ] [ player_index ] == 26 || g_blackjackPlayerCardIndex[ tableid ] [ 0 ] [ player_index ] == 39 ) )
		return true;

	if ( card_count == 21 && ( g_blackjackPlayerCardIndex[ tableid ] [ 1 ] [ player_index ] == 0 || g_blackjackPlayerCardIndex[ tableid ] [ 1 ] [ player_index ] == 13 || g_blackjackPlayerCardIndex[ tableid ] [ 1 ] [ player_index ] == 26 || g_blackjackPlayerCardIndex[ tableid ] [ 1 ] [ player_index ] == 39 ) )
		return true;

	return false;
}

stock IsDealerHandBlackjack( tableid, card_count )
{
	if ( card_count == 21 && ( g_blackjackDealerCardIndex[ tableid ] [ 0 ] == 0 || g_blackjackDealerCardIndex[ tableid ] [ 0 ] == 13 || g_blackjackDealerCardIndex[ tableid ] [ 0 ] == 26 || g_blackjackDealerCardIndex[ tableid ] [ 0 ] == 39 ) )
		return true;

	if ( card_count == 21 && ( g_blackjackDealerCardIndex[ tableid ] [ 1 ] == 0 || g_blackjackDealerCardIndex[ tableid ] [ 1 ] == 13 || g_blackjackDealerCardIndex[ tableid ] [ 1 ] == 26 || g_blackjackDealerCardIndex[ tableid ] [ 1 ] == 39 ) )
		return true;

	return false;
}

stock GetBlackjackCardValue( card_index )
{
    new
        card_value = 0;

    switch ( card_index )
    {
        case 0, 13, 26, 39: card_value = 1;
        case 1, 14, 27, 40: card_value = 2;
        case 2, 15, 28, 41: card_value = 3;
        case 3, 16, 29, 42: card_value = 4;
        case 4, 17, 30, 43: card_value = 5;
        case 5, 18, 31, 44: card_value = 6;
        case 6, 19, 32, 45: card_value = 7;
        case 7, 20, 33, 46: card_value = 8;
        case 8, 21, 34, 47: card_value = 9;
        case 9, 22, 35, 48, 10, 23, 36, 49, 11, 24, 37, 50, 12, 25, 38, 51: card_value = 10;
    }
    return card_value;
}

stock GetBlackjackPlayerIndex( tableid, playerid )
{
    for ( new player_index = 0; player_index < MAX_BLACKJACK_PLAYERS; player_index ++ ) if ( playerid == g_blackjackSlotData[ tableid ] [ player_index ] ) {
        return player_index;
    }
    return -1;
}

stock GetBlackjackPlayers( tableid ) {
    new
        count = 0;

    for ( new p = 0; p < MAX_BLACKJACK_PLAYERS; p ++ ) if ( g_blackjackSlotData[ tableid ] [ p ] != -1 )
        count ++;

    return count;
}
